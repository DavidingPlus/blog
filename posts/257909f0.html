<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><script>window.MSInputMethodContext&&document.documentMode&&(window.location.href="https://support.dmeng.net/upgrade-your-browser.html")</script><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/favicon-16x16.webp?v=2.8.6" type="image/png" sizes="16x16"><link rel="icon" href="/assets/favicon-32x32.webp?v=2.8.6" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/assets/apple-touch-icon.webp?v=2.8.6" sizes="180x180"><meta name="description" content="为什么需要 F2FS？        传统的文件系统（如 FAT32, EXT4）是为“旋转的磁碟（HDD）”设计的，而 F2FS 是为“闪存（NAND Flash）”设计的。 在存储领域，传统的文件系统如 FAT32 或 EXT4 最初都是为机械硬盘这种“旋转磁碟”设计的。这类设备拥有物理磁头，在磁道上移动时可以直接覆盖旧数据。然而，F2FS 则是专门"><meta property="og:type" content="article"><meta property="og:title" content="F2FS 文件系统"><meta property="og:url" content="https://blog.davidingplus.cn/posts/257909f0.html"><meta property="og:site_name" content="DavidingPlus&#39;s Blog"><meta property="og:description" content="为什么需要 F2FS？        传统的文件系统（如 FAT32, EXT4）是为“旋转的磁碟（HDD）”设计的，而 F2FS 是为“闪存（NAND Flash）”设计的。 在存储领域，传统的文件系统如 FAT32 或 EXT4 最初都是为机械硬盘这种“旋转磁碟”设计的。这类设备拥有物理磁头，在磁道上移动时可以直接覆盖旧数据。然而，F2FS 则是专门"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251224164153966.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251224165214273.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251224170347186.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225152548700.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225153846231.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225153933456.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225154609242.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225155522809.png"><meta property="article:published_time" content="2025-12-24T17:30:00.000Z"><meta property="article:modified_time" content="2025-12-29T17:30:00.000Z"><meta property="article:author" content="DavidingPlus"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.davidingplus.cn/images/2025/12/29/image-20251224164153966.png"><title>F2FS 文件系统 | DavidingPlus's Blog</title><link ref="canonical" href="https://blog.davidingplus.cn/posts/257909f0.html"><link rel="dns-prefetch" href="https://cdn.davidingplus.cn"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fontawesome.css" type="text/css"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fancybox.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.6"><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,assistSearch:["bing","baidu"],fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"55px",tocMaxDepth:6},header:{enable:!0,showOnPost:!0,scrollDownIcon:!0},postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},back2bottom:{enable:!0},codeblock:{style:"default",highlight:"light",wordWrap:!0},reward:!0,fancybox:!0,zoomImage:{gapAside:"20px"},galleryWaterfall:{colWidth:"255px",gapX:"65px"},lazyload:!0,pjax:{avoidBanner:!0},externalLink:{icon:{enable:!0,name:"fas fa-external-link-alt"}},shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"恭喜亲亲，复制成功咧",copyError:"哎呀，复制失败了"},sourcePath:{js:"js",css:"css",images:"images"},utterancesTheme:{light:"github-light",dark:"photon-dark"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-bars"></i></span><span class="header-nav-menu-item__text">其他</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/friends/"><span class="header-nav-submenu-item__icon"><i class="fas fa-users"></i></span><span class="header-nav-submenu-item__text">友链</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/gallery/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" target="_blank" rel="noopener" href="https://davidingplus.cn/"><span class="header-nav-menu-item__icon"><i class="fas fa-pager"></i></span><span class="header-nav-menu-item__text">站点主页</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">DavidingPlus's Blog</div><div class="header-banner-info__subtitle">🕊️ world peace</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">F2FS 文件系统</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2025-12-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-12-29</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">31.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">250分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><meta name="referrer" content="no-referrer"><h1 id="为什么需要-f2fs"><a href="#为什么需要-f2fs" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#为什么需要-f2fs"></a> 为什么需要 F2FS？</h1><p>传统的文件系统（如 FAT32, EXT4）是为“旋转的磁碟（HDD）”设计的，而 F2FS 是为“闪存（NAND Flash）”设计的。</p><p>在存储领域，传统的文件系统如 FAT32 或 EXT4 最初都是为机械硬盘这种“旋转磁碟”设计的。这类设备拥有物理磁头，在磁道上移动时可以直接覆盖旧数据。然而，F2FS 则是专门为 NAND 闪存设计的，它深刻理解闪存与磁盘在物理特性上的巨大差异。闪存最核心的限制在于它无法像磁碟那样进行原地“覆盖写”。一旦一个存储位置写入了数据，必须先执行擦除操作才能再次写入。更棘手的是，闪存写入的最小单位通常很小，只有几 KB 左右的“页”，但擦除的最小单位却非常大，往往达到数 MB 级别的“块”。如果文件系统像处理磁盘那样频繁地在同一个逻辑地址修改数据，底层的闪存就不得不不断执行繁重的“读-改-写”循环，这会导致整体写入性能随时间推移而急剧下降。</p><span id="more"></span><p>为了掩盖闪存这些古怪的物理特性，所有的闪存设备，无论是你手中的 SD 卡还是高性能的 SSD，内部都内置了一个微控制器来运行闪存转换层，也就是 FTL。FTL 的本质是一个欺骗机制，它让操作系统觉得这块闪存依然是一个可以随意覆盖写的普通磁盘。然而，当传统文件系统进行大量的随机写入时，FTL 必须在后台疯狂地进行“垃圾回收”和“磨损均衡”，试图在不断变化的物理空间中寻找空白区域来安置这些新数据。由于 FTL 并不了解文件系统的上层布局，它的这种盲目搬运效率极低。这就是为什么很多嵌入式设备或智能手机在使用一段时间后会变得卡顿，其深层原因往往是文件系统的随机写入行为让底层的 FTL 陷入了几乎崩溃的处理链条中。</p><p>F2FS 解决这一难题的核心武器是采用了<strong>日志结构文件系统</strong>，即 LFS 架构。我们可以做一个形象的比喻：传统文件系统就像一块黑板，哪里写错了就擦掉哪里，然后再原地重写；而 F2FS 则像是一个永远不使用橡皮擦的笔记本，无论你是新增文件还是修改旧文件，它永远不会去动之前写过的内容，而是不断在笔记本最后一页的空白处按顺序往后写。这种“追加式写入”的做法将所有的逻辑修改转换成了物理上的顺序写。对于底层闪存来说，顺序写入是最完美的运行模式，它极大地减轻了 FTL 的管理压力，让后台垃圾回收变得非常简单高效，同时也因为数据分布更加均匀而天然地实现了磨损均衡，从而显著延长了昂贵闪存硬件的寿命。</p><p>虽然 LFS 架构的概念很早就有，但早期的实现一直被“漫游树（wandering tree）”这一难题所困扰，导致无法大规模商用。在传统的 LFS 中，如果你修改了一个数据块，由于它必须写到新位置，物理地址就变了。这意味着指向这个块的上一级索引节点也必须修改地址来指向它，而索引节点的地址改变又会触发上上级节点的修改，最终这种递归更新会一直蔓延到文件系统的根节点，造成巨大的额外开销。**F2FS 的绝活在于它引入了节点地址表，也就是 NAT。**NAT 像一个稳固的中转站，它给每个索引节点分配一个固定的 ID，并记录这个 ID 目前对应的物理地址。当一个数据块移动时，F2FS 只需要更新 NAT 表里对应的一个条目即可，彻底切断了向上递归的“漫游”效应。正是这个核心发明，让 F2FS 能够保持 LFS 的高性能，又避开了复杂的连锁更新，成为了现代闪存存储的基石。</p><h1 id="总体结构"><a href="#总体结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#总体结构"></a> 总体结构</h1><p>相对于传统的日志结构型文件系统，F2FS 在 wandering tree 和 gc 的高时间开销等问题，有一定的改进和优化。</p><ol><li>wandering tree 问题: 在传统的 LFS 中，由于采用异地更新（Out-of-place Update），当一个数据块被修改并写到新地址时，其父节点的指针也必须随之更新以指向新地址。这种更新会沿着文件系统的索引树一路向上递归，直到根节点。这种现象会导致极高的元数据（Metadata）写入开销，原本只改一个字节，最后可能导致整个树路径上的所有块都要重写。F2FS 通过引入 **NAT（Node Address Table）**层，成功切断了这种递归关联，实现了“不动声色”的地址转换。</li><li>高 gc 开销问题: LFS 随着时间推移会产生大量无效数据（旧版本的块）。当磁盘空间不足时，必须启动垃圾回收。传统的 LFS 往往在 GC 时面临不可预知的长延迟，严重影响实时性能。F2FS 通过 **Multi-head Logging（多头日志写入）**和多种 GC 策略（贪婪算法与成本收益算法），根据数据的冷热程度进行分类存储，极大地降低了 GC 时的有效数据搬迁量，减少了系统的波动性。</li></ol><h2 id="系统特性"><a href="#系统特性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#系统特性"></a> 系统特性</h2><h3 id="基本数据单位"><a href="#基本数据单位" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基本数据单位"></a> 基本数据单位</h3><p>分为四类：</p><ol><li>**Block（块）：**F2FS 读写操作的最小原子单位，大小固定为 <strong>4KB</strong>。这一设计与 Linux 的 Page Cache 以及大多数闪存设备的 Page 大小高度契合。所有的元数据结构和用户数据均以 Block 为单位组织。</li><li>**Segment（段）：**管理 Block 的基本容器，大小为 <strong>2MB</strong>（包含 512 个 Block）。Segment 是 F2FS 进行空间管理和分配的基石。之所以选择 2MB，是为了适配主流闪存芯片的物理擦除块（Erase Block）大小，从而减少擦除时的干扰。</li><li>**Section（节）：**由连续的若干个 Segment 组成，默认情况下 <strong>1 Section = 1 Segment</strong>。Section 是垃圾回收（GC）的物理操作单位。F2FS 会根据数据的冷热属性，将数据分配到不同的 Section 中，以便在 GC 时能以更高的效率释放整块空间。</li><li>**Zone（区）：**由多个 Section 组成。在某些高级配置或特定硬件（如具有隔离特性的闪存阵列）上，Zone 用于进一步的物理隔离，以防止不同类型的数据在物理层面上产生写干扰。</li></ol><h3 id="lfs-异地更新特性"><a href="#lfs-异地更新特性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#lfs-异地更新特性"></a> LFS 异地更新特性</h3><p>F2FS 遵循“永远不要覆盖旧数据”的原则。这种**异地更新（Out-of-place Update）**策略是 F2FS 性能和可靠性的根源：</p><ul><li>**传统就地更新（In-place）：**如 FAT/EXT4。当修改文件 A 的第 1 块时，直接在原物理位置重写。对于闪存，这会触发底层昂贵的“读取-擦除-修改-写回”过程。</li><li>**F2FS 异地更新：**当修改发生时，F2FS 直接在当前的 Log 尾部找一个干净的物理块写入新数据。旧块被标记为“Invalid（无效）”，留待未来的 GC 处理。</li></ul><p><strong>优点：</strong></p><ol><li>**写聚合：**将碎片化的随机写转换为大吞吐量的顺序写，极大提升 IOPS。</li><li>**磨损均衡：**数据自动在全盘范围内散布，避免了因频繁更新特定元数据（如文件表）导致的局部闪存颗粒提前损坏。</li></ol><p>这样做的问题是：这种设计依赖 **Checkpoint（检查点）**机制来保证一致性。F2FS 不会像 JFS（日志文件系统）那样在每次操作时写日志，而是定期创建快照。这意味着如果突发断电且此时还没到 Checkpoint 时刻，可能会丢失极短时间内的数据。</p><h3 id="multi-head-logging多头日志写入特性"><a href="#multi-head-logging多头日志写入特性" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#multi-head-logging多头日志写入特性"></a> Multi-head Logging（多头日志写入）特性</h3><p>F2FS 的核心精髓在于它能感知数据的“温度”。Log 区域指的是文件系统中用于分配 free block(空闲的且没有写入数据的 block)的区域，例如 F2FS 的一个文件需要写入新数据，它就要去 Log 区域请求 free block，然后再将数据写入这个 free block 中。传统的 LFS 往往会维护一个大的日志区域，一切数据的分配都从这个大的日志区域中进行处理。它同时维护了 6 个活动的 Log 区域（活跃段），将数据精准分类：</p><ul><li><strong>节点类（Node）：存储文件的索引结构</strong><ul><li><strong>HOT NODE</strong>：目录文件的直接索引块（Direct Node）。由于目录操作极其频繁且对用户感知影响大，将其单独存放以加快访问速度。</li><li><strong>WARM NODE</strong>：普通文件的直接索引块。</li><li><strong>COLD NODE</strong>：间接索引块（Indirect Node）。这些块通常属于超大文件，修改频率相对较低。</li></ul></li><li><strong>数据类（Data）：存储用户实际内容</strong><ul><li><strong>HOT DATA</strong>：目录项数据（Dentry）。目录下的文件名、inode 号等信息经常变动。</li><li><strong>WARM DATA</strong>：普通文件的内容。这是系统中最主要的数据流。</li><li><strong>COLD DATA</strong>：多媒体文件、只读文件或 GC 搬迁产生的数据。这类数据一旦写入，很难再次被修改。</li></ul></li></ul><h2 id="闪存设备物理布局"><a href="#闪存设备物理布局" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#闪存设备物理布局"></a> 闪存设备物理布局</h2><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251224164153966.png" alt="image-20251224164153966"></p><p>通过 mkfs.f2fs 格式化后，整个存储空间被划分为六大功能区。除了主数据区外，前五个区域统称为元数据区。</p><ol><li>Superblock（超级块，SB）</li></ol><p>位于分区的最开始，存储了文件系统的关键几何参数（块大小、段数量、区域边界）。为了保证安全性，F2FS 会保存两个 SB 备份。在挂载（Mount）时，驱动首先读取 SB 并初始化内存中的 f2fs_sb_info 结构。</p><ol start="2"><li>Checkpoint（检查点，CP）</li></ol><p>这是系统的“大脑”。CP 记录了当前文件系统的最新一致状态。它包含了两份备份（A/B 切换写入），以防在写 CP 过程中突然断电。CP 存储了 NAT 和 SIT 的位图快照、当前活跃段的列表以及 Orphan Inode（孤儿节点）等信息。在 RTEMS 重启后，挂载过程会根据 CP 来快速恢复整个文件系统的逻辑拓扑。</p><ol start="3"><li>Segment Information Table（段信息表，SIT）</li></ol><p>SIT 负责监控 <strong>Main Area</strong> 中每个 Segment 的使用情况。它包含一个位图，指示该段内 512 个块中哪些是有效的（Valid）。主要作用是 SIT 是 GC 决策的关键依据。系统通过查询 SIT 找到那些无效块最多的段进行回收。</p><ol start="4"><li>Node Address Table（节点地址表，NAT）</li></ol><p>建立了一张表保存了每一个 node 的物理地址信息。这是 F2FS 解决漫游树问题的秘密武器。</p><ul><li>**机制：**每个 Node（索引节点）都有一个唯一的逻辑 ID（NID）。NAT 就像一个巨大的映射表，记录了 NID -&gt; 物理地址 的转换。</li><li>**优势：**当文件数据更新导致 Node 本身位置发生移动时，只有 NAT 表中的物理地址需要更新，而指向该 NID 的父节点无需改动。这大大减少了元数据连锁更新的负担。</li></ul><ol start="5"><li>Segment Summary Area（段摘要区，SSA）</li></ol><p>这个区域主要保存了 jounal(SIT/NAT 临时的修改信息)以及 summary(记录了逻辑地址和物理地址关系的结构，主要用于 GC)。SSA 区域在内存中没有专门的数据结构。SSA 存储了块的“身份证明”。</p><ul><li>**反向查找：**SSA 记录了主数据区每个物理块对应的父 Node ID 及其在文件内部的偏移。</li><li>**主要用途：**在 GC 搬迁数据时，系统必须确定这个物理块到底是哪个文件的，SSA 提供了这种反向检索能力，确保搬迁后能正确更新对应的索引指针。</li></ul><ol start="6"><li>Main Area（主数据区）</li></ol><p>这是文件系统最广阔的腹地，所有的用户数据、目录项、以及各种 Node 块（Inode 块、索引块）都存储在这里。所有的块分配都遵循前面提到的 6 个 Log 区域的冷热分类策略。</p><h1 id="superblock-区域"><a href="#superblock-区域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#superblock-区域"></a> SuperBlock 区域</h1><p>SuperBlock 区域的结构如下：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251224165214273.png" alt="image-20251224165214273"></p><p>Superblock区域是由两个 <code>struct f2fs_super_block</code> 结构组成，互为备份。</p><h2 id="f2fs_super_block-结构"><a href="#f2fs_super_block-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_super_block-结构"></a> f2fs_super_block 结构</h2><p><code>struct f2fs_super_block</code> 定义了文件系统的几何参数和各功能区的物理偏移。我们可以观察到，F2FS 的许多设计都采用了 log2 的指数形式，例如 log_blocksize 和 log_blocks_per_seg。这种设计允许内核在计算物理地址时使用位移操作（Shift）代替昂贵的除法运算，这对于 CPU 资源有限的嵌入式设备（如运行 RTEMS 的环境）非常友好。此外，该结构体包含了一系列以 _blkaddr 结尾的字段，它们精确指向了 Checkpoint、SIT、NAT、SSA 以及 Main Area 的起始块地址。magic 字段（魔数）则用于标识这确实是一个 F2FS 卷，是驱动程序进行合法性检查的第一道关卡。定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> &#123;</span></span><br><span class="line">	__le32 magic;			<span class="comment">/* Magic Number */</span></span><br><span class="line">	__le16 major_ver;		<span class="comment">/* Major Version */</span></span><br><span class="line">	__le16 minor_ver;		<span class="comment">/* Minor Version */</span></span><br><span class="line">	__le32 log_sectorsize;		<span class="comment">/* log2 sector size in bytes */</span></span><br><span class="line">	__le32 log_sectors_per_block;	<span class="comment">/* log2 # of sectors per block */</span></span><br><span class="line">	__le32 log_blocksize;		<span class="comment">/* log2 block size in bytes */</span></span><br><span class="line">	__le32 log_blocks_per_seg;	<span class="comment">/* log2 # of blocks per segment */</span></span><br><span class="line">	__le32 segs_per_sec;		<span class="comment">/* # of segments per section */</span></span><br><span class="line">	__le32 secs_per_zone;		<span class="comment">/* # of sections per zone */</span></span><br><span class="line">	__le32 checksum_offset;		<span class="comment">/* checksum offset inside super block */</span></span><br><span class="line">	__le64 block_count;		<span class="comment">/* total # of user blocks */</span></span><br><span class="line">	__le32 section_count;		<span class="comment">/* total # of sections */</span></span><br><span class="line">	__le32 segment_count;		<span class="comment">/* total # of segments */</span></span><br><span class="line">	__le32 segment_count_ckpt;	<span class="comment">/* # of segments for checkpoint */</span></span><br><span class="line">	__le32 segment_count_sit;	<span class="comment">/* # of segments for SIT */</span></span><br><span class="line">	__le32 segment_count_nat;	<span class="comment">/* # of segments for NAT */</span></span><br><span class="line">	__le32 segment_count_ssa;	<span class="comment">/* # of segments for SSA */</span></span><br><span class="line">	__le32 segment_count_main;	<span class="comment">/* # of segments for main area */</span></span><br><span class="line">	__le32 segment0_blkaddr;	<span class="comment">/* start block address of segment 0 */</span></span><br><span class="line">	__le32 cp_blkaddr;		<span class="comment">/* start block address of checkpoint */</span></span><br><span class="line">	__le32 sit_blkaddr;		<span class="comment">/* start block address of SIT */</span></span><br><span class="line">	__le32 nat_blkaddr;		<span class="comment">/* start block address of NAT */</span></span><br><span class="line">	__le32 ssa_blkaddr;		<span class="comment">/* start block address of SSA */</span></span><br><span class="line">	__le32 main_blkaddr;		<span class="comment">/* start block address of main area */</span></span><br><span class="line">	__le32 root_ino;		<span class="comment">/* root inode number */</span></span><br><span class="line">	__le32 node_ino;		<span class="comment">/* node inode number */</span></span><br><span class="line">	__le32 meta_ino;		<span class="comment">/* meta inode number */</span></span><br><span class="line">	__u8 uuid[<span class="number">16</span>];			<span class="comment">/* 128-bit uuid for volume */</span></span><br><span class="line">	__le16 volume_name[MAX_VOLUME_NAME];	<span class="comment">/* volume name */</span></span><br><span class="line">	__le32 extension_count;		<span class="comment">/* # of extensions below */</span></span><br><span class="line">	__u8 extension_list[F2FS_MAX_EXTENSION][F2FS_EXTENSION_LEN];<span class="comment">/* extension array */</span></span><br><span class="line">	__le32 cp_payload;</span><br><span class="line">	__u8 version[VERSION_LEN];	<span class="comment">/* the kernel version */</span></span><br><span class="line">	__u8 init_version[VERSION_LEN];	<span class="comment">/* the initial kernel version */</span></span><br><span class="line">	__le32 feature;			<span class="comment">/* defined features */</span></span><br><span class="line">	__u8 encryption_level;		<span class="comment">/* versioning level for encryption */</span></span><br><span class="line">	__u8 encrypt_pw_salt[<span class="number">16</span>];	<span class="comment">/* Salt used for string2key algorithm */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_device</span> <span class="title">devs</span>[<span class="title">MAX_DEVICES</span>];</span>	<span class="comment">/* device list */</span></span><br><span class="line">	__le32 qf_ino[F2FS_MAX_QUOTAS];	<span class="comment">/* quota inode numbers */</span></span><br><span class="line">	__u8 hot_ext_count;		<span class="comment">/* # of hot file extension */</span></span><br><span class="line">	__le16  s_encoding;		<span class="comment">/* Filename charset encoding */</span></span><br><span class="line">	__le16  s_encoding_flags;	<span class="comment">/* Filename charset encoding flags */</span></span><br><span class="line">	__u8 s_stop_reason[MAX_STOP_REASON];	<span class="comment">/* stop checkpoint reason */</span></span><br><span class="line">	__u8 s_errors[MAX_F2FS_ERRORS];		<span class="comment">/* reason of image corrupts */</span></span><br><span class="line">	__u8 reserved[<span class="number">258</span>];		<span class="comment">/* valid reserved region */</span></span><br><span class="line">	__le32 crc;			<span class="comment">/* checksum of superblock */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><h2 id="f2fs_sb_info-结构"><a href="#f2fs_sb_info-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_sb_info-结构"></a> f2fs_sb_info 结构</h2><p>当 RTEMS 成功从磁盘读取了原始的超级块数据后，它并不会直接频繁操作磁盘上的那段字节流，而是会初始化一个内存管理结构体 <code>struct f2fs_sb_info</code>（简称 SBI）。SBI 是 F2FS 在运行时的“指挥部”，它不仅包含了原始超级块的指针 raw_super，还整合了节点管理器（NM）、段管理器（SM）以及用于保证线程安全的各类锁机制（如 sb_lock、gc_mutex）。对于移植工作而言，SBI 是最频繁被打交道的数据结构，它将静态的磁盘布局转换成了动态的内存对象，负责维护文件系统的实时挂载状态。<code>struct f2fs_super_block</code> 在内存中对应的结构是 <code>struct f2fs_sb_info</code>，它除了包含了<code>struct f2fs_super_block</code>的信息以外，还包含了一些额外的功能，如锁、SIT、NAT 对应的内存管理结构等。定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>;</span>			<span class="comment">/* pointer to VFS super block */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">s_proc</span>;</span>		<span class="comment">/* proc entry */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">raw_super</span>;</span>	<span class="comment">/* raw super block pointer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">sb_lock</span>;</span>		<span class="comment">/* lock for raw super block */</span></span><br><span class="line">	<span class="type">int</span> valid_super_block;			<span class="comment">/* valid super block no */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> s_flag;				<span class="comment">/* flags for sbi */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">writepages</span>;</span>		<span class="comment">/* mutex for writepages() */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_BLK_DEV_ZONED</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> blocks_per_blkz;		<span class="comment">/* F2FS blocks per zone */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_open_zones;		<span class="comment">/* max open zone resources of the zoned device */</span></span><br><span class="line">	<span class="comment">/* For adjust the priority writing position of data in zone UFS */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> blkzone_alloc_policy;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for node-related operations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> *<span class="title">nm_info</span>;</span>		<span class="comment">/* node manager */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node_inode</span>;</span>		<span class="comment">/* cache node blocks */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for segment-related operations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sm_info</span> *<span class="title">sm_info</span>;</span>		<span class="comment">/* segment manager */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for bio operations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_bio_info</span> *<span class="title">write_io</span>[<span class="title">NR_PAGE_TYPE</span>];</span>	<span class="comment">/* for write bios */</span></span><br><span class="line">	<span class="comment">/* keep migration IO order for LFS mode */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">io_order_lock</span>;</span></span><br><span class="line">	<span class="type">pgoff_t</span> page_eio_ofs[NR_PAGE_TYPE];	<span class="comment">/* EIO page offset */</span></span><br><span class="line">	<span class="type">int</span> page_eio_cnt[NR_PAGE_TYPE];		<span class="comment">/* EIO count */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for checkpoint */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span>;</span>		<span class="comment">/* raw checkpoint pointer */</span></span><br><span class="line">	<span class="type">int</span> cur_cp_pack;			<span class="comment">/* remain current cp pack */</span></span><br><span class="line">	<span class="type">spinlock_t</span> cp_lock;			<span class="comment">/* for flag in ckpt */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">meta_inode</span>;</span>		<span class="comment">/* cache meta blocks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">cp_global_sem</span>;</span>	<span class="comment">/* checkpoint procedure lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">cp_rwsem</span>;</span>		<span class="comment">/* blocking FS operations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">node_write</span>;</span>		<span class="comment">/* locking node writes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">node_change</span>;</span>	<span class="comment">/* locking node change */</span></span><br><span class="line">	<span class="type">wait_queue_head_t</span> cp_wait;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> last_time[MAX_TIME];	<span class="comment">/* to store time in jiffies */</span></span><br><span class="line">	<span class="type">long</span> interval_time[MAX_TIME];		<span class="comment">/* to store thresholds */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ckpt_req_control</span> <span class="title">cprc_info</span>;</span>	<span class="comment">/* for checkpoint request control */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">cp_stats</span> <span class="title">cp_stats</span>;</span>		<span class="comment">/* for time stat of checkpoint */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode_management</span> <span class="title">im</span>[<span class="title">MAX_INO_ENTRY</span>];</span>	<span class="comment">/* manage inode cache */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">spinlock_t</span> fsync_node_lock;		<span class="comment">/* for node entry lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">fsync_node_list</span>;</span>	<span class="comment">/* node list head */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fsync_seg_id;		<span class="comment">/* sequence id */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> fsync_node_num;		<span class="comment">/* number of node entries */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for orphan inode, use 0&#x27;th array */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_orphans;		<span class="comment">/* max orphan inodes */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for inode management */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">inode_list</span>[<span class="title">NR_INODE_TYPE</span>];</span>	<span class="comment">/* dirty inode list */</span></span><br><span class="line">	<span class="type">spinlock_t</span> inode_lock[NR_INODE_TYPE];	<span class="comment">/* for dirty inode list lock */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">flush_lock</span>;</span>		<span class="comment">/* for flush exclusion */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for extent tree cache */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">extent_tree_info</span> <span class="title">extent_tree</span>[<span class="title">NR_EXTENT_CACHES</span>];</span></span><br><span class="line">	<span class="type">atomic64_t</span> allocated_data_blocks;	<span class="comment">/* for block age extent_cache */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_read_extent_count;	<span class="comment">/* max read extent count per inode */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* The threshold used for hot and warm data seperation*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hot_data_age_threshold;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> warm_data_age_threshold;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> last_age_weight;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* control donate caches */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> donate_files;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* basic filesystem units */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> log_sectors_per_block;	<span class="comment">/* log2 sectors per block */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> log_blocksize;		<span class="comment">/* log2 block size */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> blocksize;			<span class="comment">/* block size */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> root_ino_num;		<span class="comment">/* root inode number*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> node_ino_num;		<span class="comment">/* node inode number*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> meta_ino_num;		<span class="comment">/* meta inode number*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> log_blocks_per_seg;	<span class="comment">/* log2 blocks per segment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> blocks_per_seg;		<span class="comment">/* blocks per segment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> unusable_blocks_per_sec;	<span class="comment">/* unusable blocks per section */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> segs_per_sec;		<span class="comment">/* segments per section */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> secs_per_zone;		<span class="comment">/* sections per zone */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> total_sections;		<span class="comment">/* total section count */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> total_node_count;		<span class="comment">/* total node block count */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> total_valid_node_count;	<span class="comment">/* valid node block count */</span></span><br><span class="line">	<span class="type">int</span> dir_level;				<span class="comment">/* directory level */</span></span><br><span class="line">	<span class="type">bool</span> readdir_ra;			<span class="comment">/* readahead inode in readdir */</span></span><br><span class="line">	u64 max_io_bytes;			<span class="comment">/* max io bytes to merge IOs */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">block_t</span> user_block_count;		<span class="comment">/* # of user blocks */</span></span><br><span class="line">	<span class="type">block_t</span> total_valid_block_count;	<span class="comment">/* # of valid blocks */</span></span><br><span class="line">	<span class="type">block_t</span> discard_blks;			<span class="comment">/* discard command candidats */</span></span><br><span class="line">	<span class="type">block_t</span> last_valid_block_count;		<span class="comment">/* for recovery */</span></span><br><span class="line">	<span class="type">block_t</span> reserved_blocks;		<span class="comment">/* configurable reserved blocks */</span></span><br><span class="line">	<span class="type">block_t</span> current_reserved_blocks;	<span class="comment">/* current reserved blocks */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Additional tracking for no checkpoint mode */</span></span><br><span class="line">	<span class="type">block_t</span> unusable_block_count;		<span class="comment">/* # of blocks saved by last cp */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nquota_files;		<span class="comment">/* # of quota sysfile */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">quota_sem</span>;</span>		<span class="comment">/* blocking cp for flags */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">umount_lock_holder</span>;</span>	<span class="comment">/* s_umount lock holder */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* # of pages, see count_type */</span></span><br><span class="line">	<span class="type">atomic_t</span> nr_pages[NR_COUNT_TYPE];</span><br><span class="line">	<span class="comment">/* # of allocated blocks */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">percpu_counter</span> <span class="title">alloc_valid_block_count</span>;</span></span><br><span class="line">	<span class="comment">/* # of node block writes as roll forward recovery */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">percpu_counter</span> <span class="title">rf_node_block_count</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* writeback control */</span></span><br><span class="line">	<span class="type">atomic_t</span> wb_sync_req[META];	<span class="comment">/* count # of WB_SYNC threads */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* valid inode count */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">percpu_counter</span> <span class="title">total_valid_inode_count</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_mount_info</span> <span class="title">mount_opt</span>;</span>	<span class="comment">/* mount options */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for cleaning operations */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">gc_lock</span>;</span>		<span class="comment">/*</span></span><br><span class="line"><span class="comment">						 * semaphore for GC, avoid</span></span><br><span class="line"><span class="comment">						 * race between GC and GC or CP</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_gc_kthread</span>	*<span class="title">gc_thread</span>;</span>	<span class="comment">/* GC thread */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">atgc_management</span> <span class="title">am</span>;</span>		<span class="comment">/* atgc management */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> cur_victim_sec;		<span class="comment">/* current victim section num */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gc_mode;			<span class="comment">/* current GC state */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> next_victim_seg[<span class="number">2</span>];	<span class="comment">/* next segment in victim section */</span></span><br><span class="line">	<span class="type">spinlock_t</span> gc_remaining_trials_lock;</span><br><span class="line">	<span class="comment">/* remaining trial count for GC_URGENT_* and GC_IDLE_* */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gc_remaining_trials;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for skip statistic */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> skipped_gc_rwsem;		<span class="comment">/* FG_GC only */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free sections reserved for pinned file */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> reserved_pin_section;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* threshold for gc trials on pinned files */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> gc_pin_file_threshold;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">pin_sem</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* maximum # of trials to find a victim segment for SSR and GC */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> max_victim_search;</span><br><span class="line">	<span class="comment">/* migration granularity of garbage collection, unit: segment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> migration_granularity;</span><br><span class="line">	<span class="comment">/* migration window granularity of garbage collection, unit: segment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> migration_window_granularity;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * for stat information.</span></span><br><span class="line"><span class="comment">	 * one is for the LFS mode, and the other is for the SSR mode.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_STAT_FS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_stat_info</span> *<span class="title">stat_info</span>;</span>	<span class="comment">/* FS status information */</span></span><br><span class="line">	<span class="type">atomic_t</span> meta_count[META_MAX];		<span class="comment">/* # of meta blocks */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> segment_count[<span class="number">2</span>];		<span class="comment">/* # of allocated segments */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> block_count[<span class="number">2</span>];		<span class="comment">/* # of allocated blocks */</span></span><br><span class="line">	<span class="type">atomic_t</span> inplace_count;		<span class="comment">/* # of inplace update */</span></span><br><span class="line">	<span class="comment">/* # of lookup extent cache */</span></span><br><span class="line">	<span class="type">atomic64_t</span> total_hit_ext[NR_EXTENT_CACHES];</span><br><span class="line">	<span class="comment">/* # of hit rbtree extent node */</span></span><br><span class="line">	<span class="type">atomic64_t</span> read_hit_rbtree[NR_EXTENT_CACHES];</span><br><span class="line">	<span class="comment">/* # of hit cached extent node */</span></span><br><span class="line">	<span class="type">atomic64_t</span> read_hit_cached[NR_EXTENT_CACHES];</span><br><span class="line">	<span class="comment">/* # of hit largest extent node in read extent cache */</span></span><br><span class="line">	<span class="type">atomic64_t</span> read_hit_largest;</span><br><span class="line">	<span class="type">atomic_t</span> inline_xattr;			<span class="comment">/* # of inline_xattr inodes */</span></span><br><span class="line">	<span class="type">atomic_t</span> inline_inode;			<span class="comment">/* # of inline_data inodes */</span></span><br><span class="line">	<span class="type">atomic_t</span> inline_dir;			<span class="comment">/* # of inline_dentry inodes */</span></span><br><span class="line">	<span class="type">atomic_t</span> compr_inode;			<span class="comment">/* # of compressed inodes */</span></span><br><span class="line">	<span class="type">atomic64_t</span> compr_blocks;		<span class="comment">/* # of compressed blocks */</span></span><br><span class="line">	<span class="type">atomic_t</span> swapfile_inode;		<span class="comment">/* # of swapfile inodes */</span></span><br><span class="line">	<span class="type">atomic_t</span> <span class="type">atomic_files</span>;			<span class="comment">/* # of opened atomic file */</span></span><br><span class="line">	<span class="type">atomic_t</span> max_aw_cnt;			<span class="comment">/* max # of atomic writes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> io_skip_bggc;		<span class="comment">/* skip background gc for in-flight IO */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> other_skip_bggc;		<span class="comment">/* skip background gc for other reasons */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ndirty_inode[NR_INODE_TYPE];	<span class="comment">/* # of dirty inodes */</span></span><br><span class="line">	<span class="type">atomic_t</span> cp_call_count[MAX_CALL_TYPE];	<span class="comment">/* # of cp call */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">spinlock_t</span> stat_lock;			<span class="comment">/* lock for stat operations */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* to attach REQ_META|REQ_FUA flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> data_io_flag;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> node_io_flag;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For sysfs support */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">s_kobj</span>;</span>			<span class="comment">/* /sys/fs/f2fs/&lt;devname&gt; */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">s_kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">s_stat_kobj</span>;</span>		<span class="comment">/* /sys/fs/f2fs/&lt;devname&gt;/stat */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">s_stat_kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kobject</span> <span class="title">s_feature_list_kobj</span>;</span>		<span class="comment">/* /sys/fs/f2fs/&lt;devname&gt;/feature_list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span> <span class="title">s_feature_list_kobj_unregister</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For shrinker support */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">s_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">umount_mutex</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> shrinker_run_no;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For multi devices */</span></span><br><span class="line">	<span class="type">int</span> s_ndevs;				<span class="comment">/* number of devices */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dev_info</span> *<span class="title">devs</span>;</span>		<span class="comment">/* for device list */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dirty_device;		<span class="comment">/* for checkpoint data flush */</span></span><br><span class="line">	<span class="type">spinlock_t</span> dev_lock;			<span class="comment">/* protect dirty_device */</span></span><br><span class="line">	<span class="type">bool</span> aligned_blksize;			<span class="comment">/* all devices has the same logical blksize */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> first_seq_zone_segno;	<span class="comment">/* first segno in sequential zone */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bggc_io_aware;		<span class="comment">/* For adjust the BG_GC priority when pending IO */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> allocate_section_hint;	<span class="comment">/* the boundary position between devices */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> allocate_section_policy;	<span class="comment">/* determine the section writing priority */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For write statistics */</span></span><br><span class="line">	u64 sectors_written_start;</span><br><span class="line">	u64 kbytes_written;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Precomputed FS UUID checksum for seeding other checksums */</span></span><br><span class="line">	__u32 s_chksum_seed;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">post_read_wq</span>;</span>	<span class="comment">/* post read workqueue */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we are in irq context, let&#x27;s update error information into</span></span><br><span class="line"><span class="comment">	 * on-disk superblock in the work.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">s_error_work</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> errors[MAX_F2FS_ERRORS];		<span class="comment">/* error flags */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> stop_reason[MAX_STOP_REASON];	<span class="comment">/* stop reason */</span></span><br><span class="line">	<span class="type">spinlock_t</span> error_lock;			<span class="comment">/* protect errors/stop_reason array */</span></span><br><span class="line">	<span class="type">bool</span> error_dirty;			<span class="comment">/* errors of sb is dirty */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">inline_xattr_slab</span>;</span>	<span class="comment">/* inline xattr entry */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> inline_xattr_slab_size;	<span class="comment">/* default inline xattr slab size */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For reclaimed segs statistics per each GC mode */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gc_segment_mode;		<span class="comment">/* GC state for reclaimed segments */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> gc_reclaimed_segs[MAX_GC_MODE];	<span class="comment">/* Reclaimed segs for each mode */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> seq_file_ra_mul;		<span class="comment">/* multiplier for ra_pages of seq. files in fadvise */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> max_fragment_chunk;			<span class="comment">/* max chunk size for block fragmentation mode */</span></span><br><span class="line">	<span class="type">int</span> max_fragment_hole;			<span class="comment">/* max hole size for block fragmentation mode */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For atomic write statistics */</span></span><br><span class="line">	<span class="type">atomic64_t</span> current_atomic_write;</span><br><span class="line">	s64 peak_atomic_write;</span><br><span class="line">	u64 committed_atomic_block;</span><br><span class="line">	u64 revoked_atomic_block;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* carve out reserved_blocks from total blocks */</span></span><br><span class="line">	<span class="type">bool</span> carve_out;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_FS_COMPRESSION</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">page_array_slab</span>;</span>	<span class="comment">/* page array entry */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> page_array_slab_size;	<span class="comment">/* default page array slab size */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For runtime compression statistics */</span></span><br><span class="line">	u64 compr_written_block;</span><br><span class="line">	u64 compr_saved_block;</span><br><span class="line">	u32 compr_new_inode;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For compressed block cache */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">compress_inode</span>;</span>		<span class="comment">/* cache compressed blocks */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> compress_percent;		<span class="comment">/* cache page percentage */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> compress_watermark;	<span class="comment">/* cache page watermark */</span></span><br><span class="line">	<span class="type">atomic_t</span> compress_page_hit;		<span class="comment">/* cache hit count */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_IOSTAT</span></span><br><span class="line">	<span class="comment">/* For app/fs IO statistics */</span></span><br><span class="line">	<span class="type">spinlock_t</span> iostat_lock;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> iostat_count[NR_IO_TYPE];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> iostat_bytes[NR_IO_TYPE];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> prev_iostat_bytes[NR_IO_TYPE];</span><br><span class="line">	<span class="type">bool</span> iostat_enable;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> iostat_next_period;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> iostat_period_ms;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* For io latency related statistics info in one iostat period */</span></span><br><span class="line">	<span class="type">spinlock_t</span> iostat_lat_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iostat_lat_info</span> *<span class="title">iostat_io_lat</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h2 id="init_sb_info"><a href="#init_sb_info" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#init_sb_info"></a> init_sb_info()</h2><p>init_sb_info() 函数承担了从“原始字节”到“逻辑对象”的转换任务。首先，它会执行大量的字节序转换（如 le32_to_cpu），确保无论磁盘是在大端还是小端机器上格式化的，在当前 CPU 内存中都能正确解析。接着，它会计算出一些关键的导出参数，如总节点数量、根目录索引号（root_ino）等。除此之外，该函数还会初始化文件系统的同步原语，包括各种读写信号量、互斥锁和自旋锁。在 RTEMS 移植过程中，你需要将这些 Linux 特有的锁接口（如 mutex_init 或 init_rwsem）映射到 RTEMS 的信号量或互斥量 API 上。只有正确完成了这一步，F2FS 才能在多线程任务环境下安全地操作元数据。定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_sb_info</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">raw_super</span> =</span> sbi-&gt;raw_super;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	sbi-&gt;log_sectors_per_block =</span><br><span class="line">		le32_to_cpu(raw_super-&gt;log_sectors_per_block);</span><br><span class="line">	sbi-&gt;log_blocksize = le32_to_cpu(raw_super-&gt;log_blocksize);</span><br><span class="line">	sbi-&gt;blocksize = BIT(sbi-&gt;log_blocksize);</span><br><span class="line">	sbi-&gt;log_blocks_per_seg = le32_to_cpu(raw_super-&gt;log_blocks_per_seg);</span><br><span class="line">	sbi-&gt;blocks_per_seg = BIT(sbi-&gt;log_blocks_per_seg);</span><br><span class="line">	sbi-&gt;segs_per_sec = le32_to_cpu(raw_super-&gt;segs_per_sec);</span><br><span class="line">	sbi-&gt;secs_per_zone = le32_to_cpu(raw_super-&gt;secs_per_zone);</span><br><span class="line">	sbi-&gt;total_sections = le32_to_cpu(raw_super-&gt;section_count);</span><br><span class="line">	sbi-&gt;total_node_count = SEGS_TO_BLKS(sbi,</span><br><span class="line">			((le32_to_cpu(raw_super-&gt;segment_count_nat) / <span class="number">2</span>) *</span><br><span class="line">			NAT_ENTRY_PER_BLOCK));</span><br><span class="line">	sbi-&gt;allocate_section_hint = le32_to_cpu(raw_super-&gt;section_count);</span><br><span class="line">	sbi-&gt;allocate_section_policy = ALLOCATE_FORWARD_NOHINT;</span><br><span class="line">	F2FS_ROOT_INO(sbi) = le32_to_cpu(raw_super-&gt;root_ino);</span><br><span class="line">	F2FS_NODE_INO(sbi) = le32_to_cpu(raw_super-&gt;node_ino);</span><br><span class="line">	F2FS_META_INO(sbi) = le32_to_cpu(raw_super-&gt;meta_ino);</span><br><span class="line">	sbi-&gt;cur_victim_sec = NULL_SECNO;</span><br><span class="line">	sbi-&gt;gc_mode = GC_NORMAL;</span><br><span class="line">	sbi-&gt;next_victim_seg[BG_GC] = NULL_SEGNO;</span><br><span class="line">	sbi-&gt;next_victim_seg[FG_GC] = NULL_SEGNO;</span><br><span class="line">	sbi-&gt;max_victim_search = DEF_MAX_VICTIM_SEARCH;</span><br><span class="line">	sbi-&gt;migration_granularity = SEGS_PER_SEC(sbi);</span><br><span class="line">	sbi-&gt;migration_window_granularity = f2fs_sb_has_blkzoned(sbi) ?</span><br><span class="line">		DEF_MIGRATION_WINDOW_GRANULARITY_ZONED : SEGS_PER_SEC(sbi);</span><br><span class="line">	sbi-&gt;seq_file_ra_mul = MIN_RA_MUL;</span><br><span class="line">	sbi-&gt;max_fragment_chunk = DEF_FRAGMENT_SIZE;</span><br><span class="line">	sbi-&gt;max_fragment_hole = DEF_FRAGMENT_SIZE;</span><br><span class="line">	spin_lock_init(&amp;sbi-&gt;gc_remaining_trials_lock);</span><br><span class="line">	atomic64_set(&amp;sbi-&gt;current_atomic_write, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	sbi-&gt;dir_level = DEF_DIR_LEVEL;</span><br><span class="line">	sbi-&gt;interval_time[CP_TIME] = DEF_CP_INTERVAL;</span><br><span class="line">	sbi-&gt;interval_time[REQ_TIME] = DEF_IDLE_INTERVAL;</span><br><span class="line">	sbi-&gt;interval_time[DISCARD_TIME] = DEF_IDLE_INTERVAL;</span><br><span class="line">	sbi-&gt;interval_time[GC_TIME] = DEF_IDLE_INTERVAL;</span><br><span class="line">	sbi-&gt;interval_time[DISABLE_TIME] = DEF_DISABLE_INTERVAL;</span><br><span class="line">	sbi-&gt;interval_time[ENABLE_TIME] = DEF_ENABLE_INTERVAL;</span><br><span class="line">	sbi-&gt;interval_time[UMOUNT_DISCARD_TIMEOUT] =</span><br><span class="line">				DEF_UMOUNT_DISCARD_TIMEOUT;</span><br><span class="line">	clear_sbi_flag(sbi, SBI_NEED_FSCK);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_COUNT_TYPE; i++)</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;sbi-&gt;nr_pages[i], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; META; i++)</span><br><span class="line">		<span class="type">atomic_set</span>(&amp;sbi-&gt;wb_sync_req[i], <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	INIT_LIST_HEAD(&amp;sbi-&gt;s_list);</span><br><span class="line">	mutex_init(&amp;sbi-&gt;umount_mutex);</span><br><span class="line">	init_f2fs_rwsem(&amp;sbi-&gt;io_order_lock);</span><br><span class="line">	spin_lock_init(&amp;sbi-&gt;cp_lock);</span><br><span class="line"></span><br><span class="line">	sbi-&gt;dirty_device = <span class="number">0</span>;</span><br><span class="line">	spin_lock_init(&amp;sbi-&gt;dev_lock);</span><br><span class="line"></span><br><span class="line">	init_f2fs_rwsem(&amp;sbi-&gt;sb_lock);</span><br><span class="line">	init_f2fs_rwsem(&amp;sbi-&gt;pin_sem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="checkpoint-区域"><a href="#checkpoint-区域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#checkpoint-区域"></a> CheckPoint 区域</h1><p>Checkpoint（检查点，简称 CP）是 F2FS 维护数据一致性的灵魂结构，它记录了文件系统在某一时刻的完整“快照”状态。由于 F2FS 采用日志结构（LFS）不断进行异地更新，系统的元数据（如 NAT、SIT）和数据位置总是在动态变化。为了保证在系统突然断电或崩溃后能够恢复，F2FS 会定期或在特定条件下（如 Umount、Sync）将当前活跃的段信息、节点分配情况以及位图快照写入 Checkpoint 区域。为了极致的可靠性，F2FS 维护了两份互为备份的 CP 结构（通常称为 CP #0 和 CP #1）。**系统始终保持一个为“稳定版本”，另一个为“正在写入版本”。**如果在更新 CP 时发生故障，系统可以安全地回退到上一个稳定的 CP，确保文件系统不会因为元数据损坏而无法挂载。</p><p>CheckPoint 区域的结构如下。从图中看出分别是 checkpoint 元数据区域(f2fs_checkpoint)、orphan node 区域、active segments 区域。同时 active segments 区域在不同的情况下，会有不同的形式，目的是减少 IO 的写入。</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251224170347186.png" alt="image-20251224170347186"></p><h2 id="f2fs_checkpoint-结构"><a href="#f2fs_checkpoint-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_checkpoint-结构"></a> f2fs_checkpoint 结构</h2><p><code>struct f2fs_checkpoint</code> 定义了恢复系统所需的最少信息量。其中最重要的字段是 checkpoint_ver（版本号），系统通过比较两个 CP 备份的版本号来确定哪一个是最新的。此外，cur_node_segno 和 cur_node_blkoff（以及对应的 Data 字段）记录了上次 CP 时系统 6 个写入头的精确坐标。如果没有这些坐标，挂载后文件系统将不知道该从哪个物理块开始继续追加数据。同时，结构体末尾的 sit_nat_version_bitmap 记录了 SIT 和 NAT 区域的版本位图，帮助系统快速定位元数据表的最前沿更新。F2FS 必须定时执行 Checkpoint 去记录当前系统的 log 分配到哪个位置，否则在系统宕机的时候，会出现数据丢失等一致性问题，因此 cur_xxx_segno 以及 cur_xxx_blkoff 记录了上次 Checkpoint 时，系统正在使用的 log 的 segment number，以及分配到这个 segment 的哪个位置。定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> &#123;</span></span><br><span class="line">	__le64 checkpoint_ver;		<span class="comment">/* checkpoint block version number */</span></span><br><span class="line">	__le64 user_block_count;	<span class="comment">/* # of user blocks */</span></span><br><span class="line">	__le64 valid_block_count;	<span class="comment">/* # of valid blocks in main area */</span></span><br><span class="line">	__le32 rsvd_segment_count;	<span class="comment">/* # of reserved segments for gc */</span></span><br><span class="line">	__le32 overprov_segment_count;	<span class="comment">/* # of overprovision segments */</span></span><br><span class="line">	__le32 free_segment_count;	<span class="comment">/* # of free segments in main area */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* information of current node segments */</span></span><br><span class="line">	__le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];</span><br><span class="line">	__le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];</span><br><span class="line">	<span class="comment">/* information of current data segments */</span></span><br><span class="line">	__le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];</span><br><span class="line">	__le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];</span><br><span class="line">	__le32 ckpt_flags;		<span class="comment">/* Flags : umount and journal_present */</span></span><br><span class="line">	__le32 cp_pack_total_block_count;	<span class="comment">/* total # of one cp pack */</span></span><br><span class="line">	__le32 cp_pack_start_sum;	<span class="comment">/* start block number of data summary */</span></span><br><span class="line">	__le32 valid_node_count;	<span class="comment">/* Total number of valid nodes */</span></span><br><span class="line">	__le32 valid_inode_count;	<span class="comment">/* Total number of valid inodes */</span></span><br><span class="line">	__le32 next_free_nid;		<span class="comment">/* Next free node number */</span></span><br><span class="line">	__le32 sit_ver_bitmap_bytesize;	<span class="comment">/* Default value 64 */</span></span><br><span class="line">	__le32 nat_ver_bitmap_bytesize; <span class="comment">/* Default value 256 */</span></span><br><span class="line">	__le32 checksum_offset;		<span class="comment">/* checksum offset inside cp block */</span></span><br><span class="line">	__le64 elapsed_time;		<span class="comment">/* mounted time */</span></span><br><span class="line">	<span class="comment">/* allocation type of current segment */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> alloc_type[MAX_ACTIVE_LOGS];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* SIT and NAT version bitmap */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sit_nat_version_bitmap[];</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><h2 id="orphan-node"><a href="#orphan-node" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#orphan-node"></a> Orphan Node</h2><p>这是一个动态的区域，如果没有 orphan node list 则不会占用空间。</p><h2 id="active-segments"><a href="#active-segments" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#active-segments"></a> Active Segments</h2><p>Active Segments 又被称为 <strong>CURSEG</strong>，是 F2FS 实施 Multi-head Logging 策略的直接体现。为了提高效率，F2FS 并非每次分配一个块就去更新一次磁盘上的 SIT（段信息表）或 NAT（节点地址表），因为这样会带来巨大的写压力。相反，它利用 CP 区域中的 **Journal（日志）**和 **Summary（摘要）**结构作为临时缓存。Journal 记录了活跃段中元数据的频繁修改，而 Summary 记录了逻辑地址与物理地址的映射。只有当触发 Checkpoint 操作时，这些暂存在内存和 CP 区域的信息才会被批量持久化。这种设计极大地平衡了闪存的寿命与系统的实时性能。</p><p>CP 的主要任务是维护数据一致性，因此 CP 的 active segment 区域的主要任务是维护 Active Segment 的分配状态，使系统宕机时候可以恢复正常。维护 active segment 需要维护三种信息，分别是 f2fs_checkpoint 的信息，以及该 segment 对应的 journal 和 summary 的信息。</p><ul><li><strong>f2fs_checkpoint 中 Active Segment 信息</strong>：从上面给出的 f2fs_checkpoint 定义，cur_node_segno[MAX_ACTIVE_NODE_LOGS] 和 cur_data_segno[MAX_ACTIVE_DATA_LOGS] 表示 node 和 data 当前的 Active Segment 的编号(segment number, segno)，系统可以通过这个编号找到对应的 segment。MAX_ACTIVE_NODE_LOGS 以及 MAX_ACTIVE_NODE_LOGS 分别表示 data 和 node 有多少种类型，F2FS 默认情况下都等于 3，表示 HOT、WARM、COLD 类型数据。cur_node_blkoff[MAX_ACTIVE_NODE_LOGS] 以及 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS] 则分别表示当前 active segment 分配到哪一个 block(一个 segment 包含了 512 个 block)。</li><li><strong>Segment 对应的 Journal 信息</strong>：Journal 在两处地方都有出现，分别是 CP 区域以及 SSA 区域。CP 区域的 journal 主要用来保存 <strong>active segment</strong> 的修改信息，而 SSA 区域的则是持久化保存的<strong>所有的 segment</strong> 的 journal 信息。如系统分配出一个 block 给用户，那么就要将这个 block 所在的 segment 的 bitmap 中标记为已分配，防止其他写请求使用。分两个区域存放 journal 是为了减轻频繁更新导致的系统性能下降。例如，当系统写压力很大的时候，bitmap 就会频繁被更新，如果这个时候频繁将 bitmap 写入 SSA，就会加重写压力。因此 CP 区域的 Journal 的作用就是维护这些经常修改的数据，等待 CP 被触发的时候才回写到闪存设备，从而减少写压力，提高闪存寿命。</li><li><strong>Segment 对应的 Summary 信息</strong>：summary 同样在 CP 区域和 SSA 区域有出现，它表示的是逻辑地址和物理地址的映射关系，这个映射关系会使用到 GC 流程中。summary 与 segment 是一对一的关系，一个 summary 保存了一个 segment 所有的 block 的物理地址和逻辑地址的映射关系。summary 保存在 CP 区域中同样是出于减少 IO 的写入。</li></ul><h2 id="内存管理结构"><a href="#内存管理结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存管理结构"></a> 内存管理结构</h2><p>Checkpoint 的内存管理结构是 <code>struct f2fs_checkpoint</code> 本身，因为 Checkpoint 一般只在 F2FS 启动的时候被读取数据，用于数据恢复，而在运行过程中大部分情况都是被写，用于记录恢复信息。因此，Checkpoint 不需要过于复杂的内存管理结构，因此使用 <code>struct f2fs_checkpoint</code> 本身即可以满足需求。</p><p>F2FS 的 log，即 active segments，主要用于系统 free block 的分配，因此需要特定的管理结构 <code>struct curseg_info</code> 进行管理。定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* for active log information */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">curseg_mutex</span>;</span>		<span class="comment">/* lock for consistency */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> *<span class="title">sum_blk</span>;</span>	<span class="comment">/* cached summary block */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">journal_rwsem</span>;</span>	<span class="comment">/* protect journal area */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> *<span class="title">journal</span>;</span>		<span class="comment">/* cached journal info */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> alloc_type;		<span class="comment">/* current allocation type */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> seg_type;		<span class="comment">/* segment type like CURSEG_XXX_TYPE */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> segno;			<span class="comment">/* current segment number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> next_blkoff;		<span class="comment">/* next block offset to write */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> zone;			<span class="comment">/* current zone number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> next_segno;		<span class="comment">/* preallocated segment */</span></span><br><span class="line">	<span class="type">int</span> fragment_remained_chunk;		<span class="comment">/* remained block size in a chunk for block fragmentation mode */</span></span><br><span class="line">	<span class="type">bool</span> inited;				<span class="comment">/* indicate inmem log is inited */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>从结构分析可以直到，<code>curseg_info</code> 记录当前的 segment 的分配信息，当系统出现宕机的时候，可以从 CP 记录的 <code>curseg_info</code> 恢复当上一次 CP 点的状态。每一种类型的 active segment 就对应一个 <code>struct curseg_info</code> 结构。在 F2FS 中，使用一个数组来表示:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sm_info</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg_array</span>;</span> <span class="comment">// 默认是分配6个curseg_info，分别对应不同类型</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>struct f2fs_sm_info</code>是 SIT 的管理结构，它也管理了 CP 最终的 active segment 的信息，是一个跨区域的管理结构。</p><p><code>struct f2fs_checkpoint</code> 通过 get_checkpoint_version() 函数从磁盘读取出来：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">get_checkpoint_version</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">block_t</span> cp_addr,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> f2fs_checkpoint **cp_block, <span class="keyword">struct</span> page **cp_page,</span></span><br><span class="line"><span class="params">		<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> *version)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> blk_size = sbi-&gt;blocksize;</span><br><span class="line">	<span class="type">size_t</span> crc_offset = <span class="number">0</span>;</span><br><span class="line">	__u32 crc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	*cp_page = f2fs_get_meta_page(sbi, cp_addr); <span class="comment">// 根据CP所在的地址cp_addr从磁盘读取一个block</span></span><br><span class="line">	*cp_block = (<span class="keyword">struct</span> f2fs_checkpoint *)page_address(*cp_page); <span class="comment">// 直接转换为数据结构</span></span><br><span class="line"></span><br><span class="line">	crc_offset = le32_to_cpu((*cp_block)-&gt;checksum_offset);</span><br><span class="line">	<span class="keyword">if</span> (crc_offset &gt; (blk_size - <span class="keyword">sizeof</span>(__le32))) &#123;</span><br><span class="line">		f2fs_msg(sbi-&gt;sb, KERN_WARNING,</span><br><span class="line">			<span class="string">&quot;invalid crc_offset: %zu&quot;</span>, crc_offset);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	crc = cur_cp_crc(*cp_block);</span><br><span class="line">	<span class="keyword">if</span> (!f2fs_crc_valid(sbi, crc, *cp_block, crc_offset)) &#123; <span class="comment">// 比较CRC的值，进而知道是否成功读取出来</span></span><br><span class="line">		f2fs_msg(sbi-&gt;sb, KERN_WARNING, <span class="string">&quot;invalid crc value&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*version = cur_cp_version(*cp_block);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>struct curseg_info</code> 则是通过 build_curseg() 函数进行初始化:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_curseg</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">array</span>;</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">array</span> = f2fs_kzalloc(sbi, array_size(NR_CURSEG_TYPE, <span class="keyword">sizeof</span>(*<span class="built_in">array</span>)),</span><br><span class="line">			     GFP_KERNEL); <span class="comment">// 根据active segment类型的数目分配空间</span></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">array</span>)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	SM_I(sbi)-&gt;curseg_array = <span class="built_in">array</span>; <span class="comment">// 赋值到f2fs_sm_info-&gt;curseg_array</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_CURSEG_TYPE; i++) &#123; <span class="comment">// 为curseg的其他信息分配空间</span></span><br><span class="line">		mutex_init(&amp;<span class="built_in">array</span>[i].curseg_mutex);</span><br><span class="line">		<span class="built_in">array</span>[i].sum_blk = f2fs_kzalloc(sbi, PAGE_SIZE, GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">array</span>[i].sum_blk)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		init_rwsem(&amp;<span class="built_in">array</span>[i].journal_rwsem);</span><br><span class="line">		<span class="built_in">array</span>[i].journal = f2fs_kzalloc(sbi,</span><br><span class="line">				<span class="keyword">sizeof</span>(<span class="keyword">struct</span> f2fs_journal), GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">array</span>[i].journal)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">		<span class="built_in">array</span>[i].segno = NULL_SEGNO;</span><br><span class="line">		<span class="built_in">array</span>[i].next_blkoff = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> restore_curseg_summaries(sbi); <span class="comment">// 从f2fs_checkpoint恢复上一个CP点CURSEG的状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">restore_curseg_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> *<span class="title">sit_j</span> =</span> CURSEG_I(sbi, CURSEG_COLD_DATA)-&gt;journal;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> *<span class="title">nat_j</span> =</span> CURSEG_I(sbi, CURSEG_HOT_DATA)-&gt;journal;</span><br><span class="line">	<span class="type">int</span> type = CURSEG_HOT_DATA;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (; type &lt;= CURSEG_COLD_NODE; type++) &#123; <span class="comment">// 按类型逐个恢复active segment的信息</span></span><br><span class="line">		err = read_normal_summaries(sbi, type);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_normal_summaries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> *<span class="title">sum</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">new</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> blk_off;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> segno = <span class="number">0</span>;</span><br><span class="line">	<span class="type">block_t</span> blk_addr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	segno = le32_to_cpu(ckpt-&gt;cur_data_segno[type]); <span class="comment">// 从CP读取segno</span></span><br><span class="line">	blk_off = le16_to_cpu(ckpt-&gt;cur_data_blkoff[type - CURSEG_HOT_DATA]); <span class="comment">// 从CP读取blk_off</span></span><br><span class="line">	blk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type); <span class="comment">// 获取summary block地址	</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 读取&amp;转换结构</span></span><br><span class="line">	new = f2fs_get_meta_page(sbi, blk_addr);</span><br><span class="line">	sum = (<span class="keyword">struct</span> f2fs_summary_block *)page_address(new);</span><br><span class="line"></span><br><span class="line">	curseg = CURSEG_I(sbi, type); <span class="comment">// 根据type找到对应的curseg</span></span><br><span class="line">	mutex_lock(&amp;curseg-&gt;curseg_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 复制&amp;恢复数据 */</span></span><br><span class="line">	down_write(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line">	<span class="built_in">memcpy</span>(curseg-&gt;journal, &amp;sum-&gt;journal, SUM_JOURNAL_SIZE);</span><br><span class="line">	up_write(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(curseg-&gt;sum_blk-&gt;entries, sum-&gt;entries, SUM_ENTRY_SIZE);</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;curseg-&gt;sum_blk-&gt;footer, &amp;sum-&gt;footer, SUM_FOOTER_SIZE);</span><br><span class="line">	curseg-&gt;next_segno = segno;</span><br><span class="line">	reset_curseg(sbi, type, <span class="number">0</span>);</span><br><span class="line">	curseg-&gt;alloc_type = ckpt-&gt;alloc_type[type];</span><br><span class="line">	curseg-&gt;next_blkoff = blk_off; <span class="comment">// 恢复上次的分配状态</span></span><br><span class="line">	mutex_unlock(&amp;curseg-&gt;curseg_mutex);</span><br><span class="line">	f2fs_put_page(new, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="segment-infomation-table-区域"><a href="#segment-infomation-table-区域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#segment-infomation-table-区域"></a> Segment Infomation Table 区域</h1><p>Segment Infomation Table，简称 SIT，是 F2FS 用于集中管理 segment 状态的结构。它的主要作用是维护的 segment 的分配信息，它的作用可以使用两个常见例子进行描述:</p><ul><li>用户进行写操作，那么 segment 会根据用户写入的数据量分配特定数目的 block 给用户进行数据写入，SIT 会将这些已经被分配的 block 标记为&quot;已经使用(valid 状态)&quot;，那么之后的写操作就不会再使用这些 block。</li><li>用户进行了<strong>覆盖写</strong>操作以后，由于 F2FS <strong>异地更新</strong>的特性，F2FS 会分配新 block 给用户写入，同时会将旧 block 置为&quot;无效状态(invalid 状态)&quot;，这样 gc 的时候可以根据 segment 无效的 block 的数目，采取某种策略进行回收。</li></ul><p>综上所述，SIT 的作用是维护每一个 segment 的 block 的使用状态以及有效无效状态。</p><h2 id="元数据的物理结构"><a href="#元数据的物理结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#元数据的物理结构"></a> 元数据的物理结构</h2><p>SIT 区域的结构如下。SIT 区域由 N 个 <code>struct f2fs_sit_block</code> 组成，每一个 <code>struct f2fs_sit_block</code> 包含了 55 个 <code>struct f2fs_sit_entry</code>，每一个 entry 对应了一个 segment 的管理状态。每一个 entry 包含了三个变量: vblocks(记录这个 segment 有多少个 block 已经被使用了)，valid_map(记录这个 segment 里面的哪一些 block 是无效的)，mtime(表示修改时间)。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225152548700.png" alt="image-20251225152548700" style="zoom:67%"><p>SIT 的基本存放单元是 <code>struct f2fs_sit_block</code>，定义如下:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_block</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> <span class="title">entries</span>[<span class="title">SIT_ENTRY_PER_BLOCK</span>];</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p>由于一个 block 的尺寸是 4 KB，因此跟根据 <code>sizeof(struct f2fs_sit_entry entries)</code> 的值，得到 <code>SIT_ENTRY_PER_BLOCK</code> 的值为 55。<code>struct f2fs_sit_entry entries</code>用来表示每一个 segment 的状态信息，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> &#123;</span></span><br><span class="line">	__le16 vblocks;				<span class="comment">/* reference above */</span></span><br><span class="line">	__u8 valid_map[SIT_VBLOCK_MAP_SIZE];	<span class="comment">/* bitmap for valid blocks */</span></span><br><span class="line">	__le64 mtime;				<span class="comment">/* segment age for cleaning */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p>第一个参数 <code>vblocks</code> 表示当前 segment 有多少个 block 已经被使用，第二个参数 <code>valid_map</code> 表示 segment 内的每一个 block 的有效无效信息; 由于一个 segment 包含了 512 个 block，因此需要用 512 个 bit 去表示每一个 block 的有效无效状态，因此 <code>SIT_VBLOCK_MAP_SIZE</code> 的值是 64(8*64=512)。最后一个参数 <code>mtime</code> 表示这个 entry 被修改的时间，用于挑选 GC 时需要使用的 segment。</p><h2 id="内存管理结构-2"><a href="#内存管理结构-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存管理结构-2"></a> 内存管理结构</h2><p>SIT 在内存中对应的管理结构是 <code>struct f2fs_sm_info</code>，它在 build_segment_manager() 函数进行初始化：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sm_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_info</span>;</span>		<span class="comment">/* whole segment information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_segmap_info</span> *<span class="title">free_info</span>;</span>	<span class="comment">/* free segment information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_info</span>;</span>	<span class="comment">/* dirty segment information */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg_array</span>;</span>	<span class="comment">/* active segment information */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">curseg_lock</span>;</span>	<span class="comment">/* for preventing curseg change */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">block_t</span> seg0_blkaddr;		<span class="comment">/* block address of 0&#x27;th segment */</span></span><br><span class="line">	<span class="type">block_t</span> main_blkaddr;		<span class="comment">/* start block address of main area */</span></span><br><span class="line">	<span class="type">block_t</span> ssa_blkaddr;		<span class="comment">/* start block address of SSA area */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> segment_count;	<span class="comment">/* total # of segments */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> main_segments;	<span class="comment">/* # of segments in main area */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> reserved_segments;	<span class="comment">/* # of reserved segments */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ovp_segments;	<span class="comment">/* # of overprovision segments */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a threshold to reclaim prefree segments */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> rec_prefree_segments;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">sit_entry_set</span>;</span>	<span class="comment">/* sit entry set list */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ipu_policy;	<span class="comment">/* in-place-update policy */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_ipu_util;	<span class="comment">/* in-place-update threshold */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_fsync_blocks;	<span class="comment">/* threshold for fsync */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_seq_blocks;	<span class="comment">/* threshold for sequential blocks */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_hot_blocks;	<span class="comment">/* threshold for hot block allocation */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> min_ssr_sections;	<span class="comment">/* threshold to trigger SSR allocation */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for flush command control */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">flush_cmd_control</span> *<span class="title">fcc_info</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for discard command control */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">discard_cmd_control</span> *<span class="title">dcc_info</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">build_segment_manager</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">raw_super</span> =</span> F2FS_RAW_SUPER(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_checkpoint</span> *<span class="title">ckpt</span> =</span> F2FS_CKPT(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sm_info</span> *<span class="title">sm_info</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配空间 */</span></span><br><span class="line">	sm_info = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> f2fs_sm_info), GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 初始化一些地址信息，基础信息 */</span></span><br><span class="line">	sbi-&gt;sm_info = sm_info;</span><br><span class="line">	INIT_LIST_HEAD(&amp;sm_info-&gt;wblist_head);</span><br><span class="line">	spin_lock_init(&amp;sm_info-&gt;wblist_lock);</span><br><span class="line">	sm_info-&gt;seg0_blkaddr = le32_to_cpu(raw_super-&gt;segment0_blkaddr);</span><br><span class="line">	sm_info-&gt;main_blkaddr = le32_to_cpu(raw_super-&gt;main_blkaddr);</span><br><span class="line">	sm_info-&gt;segment_count = le32_to_cpu(raw_super-&gt;segment_count);</span><br><span class="line">	sm_info-&gt;reserved_segments = le32_to_cpu(ckpt-&gt;rsvd_segment_count);</span><br><span class="line">	sm_info-&gt;ovp_segments = le32_to_cpu(ckpt-&gt;overprov_segment_count);</span><br><span class="line">	sm_info-&gt;main_segments = le32_to_cpu(raw_super-&gt;segment_count_main);</span><br><span class="line">	sm_info-&gt;ssa_blkaddr = le32_to_cpu(raw_super-&gt;ssa_blkaddr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化内存中的entry数据结构 */</span></span><br><span class="line">	err = build_sit_info(sbi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 初始化可用segment的数据结构 */</span></span><br><span class="line">	err = build_free_segmap(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复checkpoint active segment区域的信息，参考checkpoint结构那一节 */</span></span><br><span class="line">	err = build_curseg(sbi);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 从磁盘中将SIT物理区域记录的 物理区域sit_entry与只存在于内存的sit_entry建立联系 */</span></span><br><span class="line">	build_sit_entries(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 根据checkpoint记录的恢复信息，恢复可用segment的映射关系 */</span></span><br><span class="line">	init_free_segmap(sbi);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 恢复脏segment的映射关系 */</span></span><br><span class="line">	err = build_dirty_segmap(sbi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化最大最小的修改时间 */</span></span><br><span class="line">	init_min_max_mtime(sbi);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>build_sit_info() 用于初始化内存区域的 entry，这里需要注意的是注意区分内存 entry 以及物理区域的 entry：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_sit_info</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">raw_super</span> =</span> F2FS_RAW_SUPER(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> sit_segs, start;</span><br><span class="line">	<span class="type">char</span> *src_bitmap, *bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bitmap_size, main_bitmap_size, sit_bitmap_size;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> discard_map = f2fs_block_unit_discard(sbi) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate memory for SIT information */</span></span><br><span class="line">	sit_i = f2fs_kzalloc(sbi, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> sit_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	SM_I(sbi)-&gt;sit_info = sit_i;</span><br><span class="line"></span><br><span class="line">	sit_i-&gt;sentries =</span><br><span class="line">		f2fs_kvzalloc(sbi, array_size(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> seg_entry),</span><br><span class="line">					      MAIN_SEGS(sbi)),</span><br><span class="line">			      GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i-&gt;sentries)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	main_bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));</span><br><span class="line">	sit_i-&gt;dirty_sentries_bitmap = f2fs_kvzalloc(sbi, main_bitmap_size,</span><br><span class="line">								GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i-&gt;dirty_sentries_bitmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_CHECK_FS</span></span><br><span class="line">	bitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * (<span class="number">3</span> + discard_map);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	bitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * (<span class="number">2</span> + discard_map);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	sit_i-&gt;bitmap = f2fs_kvzalloc(sbi, bitmap_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i-&gt;bitmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	bitmap = sit_i-&gt;bitmap;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; MAIN_SEGS(sbi); start++) &#123;</span><br><span class="line">		sit_i-&gt;sentries[start].cur_valid_map = bitmap;</span><br><span class="line">		bitmap += SIT_VBLOCK_MAP_SIZE;</span><br><span class="line"></span><br><span class="line">		sit_i-&gt;sentries[start].ckpt_valid_map = bitmap;</span><br><span class="line">		bitmap += SIT_VBLOCK_MAP_SIZE;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_CHECK_FS</span></span><br><span class="line">		sit_i-&gt;sentries[start].cur_valid_map_mir = bitmap;</span><br><span class="line">		bitmap += SIT_VBLOCK_MAP_SIZE;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (discard_map) &#123;</span><br><span class="line">			sit_i-&gt;sentries[start].discard_map = bitmap;</span><br><span class="line">			bitmap += SIT_VBLOCK_MAP_SIZE;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	sit_i-&gt;tmp_map = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i-&gt;tmp_map)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__is_large_section(sbi)) &#123;</span><br><span class="line">		sit_i-&gt;sec_entries =</span><br><span class="line">			f2fs_kvzalloc(sbi, array_size(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> sec_entry),</span><br><span class="line">						      MAIN_SECS(sbi)),</span><br><span class="line">				      GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!sit_i-&gt;sec_entries)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* get information related with SIT */</span></span><br><span class="line">	sit_segs = le32_to_cpu(raw_super-&gt;segment_count_sit) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* setup SIT bitmap from ckeckpoint pack */</span></span><br><span class="line">	sit_bitmap_size = __bitmap_size(sbi, SIT_BITMAP);</span><br><span class="line">	src_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);</span><br><span class="line"></span><br><span class="line">	sit_i-&gt;sit_bitmap = kmemdup(src_bitmap, sit_bitmap_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i-&gt;sit_bitmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_CHECK_FS</span></span><br><span class="line">	sit_i-&gt;sit_bitmap_mir = kmemdup(src_bitmap,</span><br><span class="line">					sit_bitmap_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i-&gt;sit_bitmap_mir)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	sit_i-&gt;invalid_segmap = f2fs_kvzalloc(sbi,</span><br><span class="line">					main_bitmap_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sit_i-&gt;invalid_segmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	sit_i-&gt;sit_base_addr = le32_to_cpu(raw_super-&gt;sit_blkaddr);</span><br><span class="line">	sit_i-&gt;sit_blocks = SEGS_TO_BLKS(sbi, sit_segs);</span><br><span class="line">	sit_i-&gt;written_valid_blocks = <span class="number">0</span>;</span><br><span class="line">	sit_i-&gt;bitmap_size = sit_bitmap_size;</span><br><span class="line">	sit_i-&gt;dirty_sentries = <span class="number">0</span>;</span><br><span class="line">	sit_i-&gt;sents_per_block = SIT_ENTRY_PER_BLOCK;</span><br><span class="line">	sit_i-&gt;elapsed_time = le64_to_cpu(sbi-&gt;ckpt-&gt;elapsed_time);</span><br><span class="line">	sit_i-&gt;mounted_time = ktime_get_boottime_seconds();</span><br><span class="line">	init_rwsem(&amp;sit_i-&gt;sentry_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>build_free_segmap() 用于初始化 segment 的分配状态：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_free_segmap</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_segmap_info</span> *<span class="title">free_i</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> bitmap_size, sec_bitmap_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* allocate memory for free segmap information */</span></span><br><span class="line">	free_i = f2fs_kzalloc(sbi, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> free_segmap_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!free_i)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	SM_I(sbi)-&gt;free_info = free_i;</span><br><span class="line"></span><br><span class="line">	bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));</span><br><span class="line">	free_i-&gt;free_segmap = f2fs_kvmalloc(sbi, bitmap_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!free_i-&gt;free_segmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	sec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));</span><br><span class="line">	free_i-&gt;free_secmap = f2fs_kvmalloc(sbi, sec_bitmap_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!free_i-&gt;free_secmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set all segments as dirty temporarily */</span></span><br><span class="line">	<span class="built_in">memset</span>(free_i-&gt;free_segmap, <span class="number">0xff</span>, bitmap_size);</span><br><span class="line">	<span class="built_in">memset</span>(free_i-&gt;free_secmap, <span class="number">0xff</span>, sec_bitmap_size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init free segmap information */</span></span><br><span class="line">	free_i-&gt;start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));</span><br><span class="line">	free_i-&gt;free_segments = <span class="number">0</span>;</span><br><span class="line">	free_i-&gt;free_sections = <span class="number">0</span>;</span><br><span class="line">	spin_lock_init(&amp;free_i-&gt;segmap_lock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>build_sit_entries() 的作用是从 SIT 的物理区域存放的物理 entry 与内存的 entry 建立联系，首先看看物理 entry 和内存 entry 的差异在哪里。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">build_sit_entries</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span> =</span> CURSEG_I(sbi, CURSEG_COLD_DATA);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> *<span class="title">journal</span> =</span> curseg-&gt;journal;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seg_entry</span> *<span class="title">se</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> <span class="title">sit</span>;</span></span><br><span class="line">	<span class="type">int</span> sit_blk_cnt = SIT_BLK_CNT(sbi);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> i, start, end;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> readed, start_blk = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">	<span class="type">block_t</span> sit_valid_blocks[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		readed = f2fs_ra_meta_pages(sbi, start_blk, BIO_MAX_VECS,</span><br><span class="line">							META_SIT, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		start = start_blk * sit_i-&gt;sents_per_block;</span><br><span class="line">		end = (start_blk + readed) * sit_i-&gt;sents_per_block;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (; start &lt; end &amp;&amp; start &lt; MAIN_SEGS(sbi); start++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_block</span> *<span class="title">sit_blk</span>;</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">folio</span> *<span class="title">folio</span>;</span></span><br><span class="line"></span><br><span class="line">			se = &amp;sit_i-&gt;sentries[start];</span><br><span class="line">			folio = get_current_sit_folio(sbi, start);</span><br><span class="line">			<span class="keyword">if</span> (IS_ERR(folio))</span><br><span class="line">				<span class="keyword">return</span> PTR_ERR(folio);</span><br><span class="line">			sit_blk = folio_address(folio);</span><br><span class="line">			sit = sit_blk-&gt;entries[SIT_ENTRY_OFFSET(sit_i, start)];</span><br><span class="line">			f2fs_folio_put(folio, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">			err = check_block_count(sbi, start, &amp;sit);</span><br><span class="line">			<span class="keyword">if</span> (err)</span><br><span class="line">				<span class="keyword">return</span> err;</span><br><span class="line">			seg_info_from_raw_sit(se, &amp;sit);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (se-&gt;type &gt;= NR_PERSISTENT_LOG) &#123;</span><br><span class="line">				f2fs_err(sbi, <span class="string">&quot;Invalid segment type: %u, segno: %u&quot;</span>,</span><br><span class="line">							se-&gt;type, start);</span><br><span class="line">				f2fs_handle_error(sbi,</span><br><span class="line">						ERROR_INCONSISTENT_SUM_TYPE);</span><br><span class="line">				<span class="keyword">return</span> -EFSCORRUPTED;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			sit_valid_blocks[SE_PAGETYPE(se)] += se-&gt;valid_blocks;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!f2fs_block_unit_discard(sbi))</span><br><span class="line">				<span class="keyword">goto</span> init_discard_map_done;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* build discard map only one time */</span></span><br><span class="line">			<span class="keyword">if</span> (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(se-&gt;discard_map, <span class="number">0xff</span>,</span><br><span class="line">						SIT_VBLOCK_MAP_SIZE);</span><br><span class="line">				<span class="keyword">goto</span> init_discard_map_done;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">memcpy</span>(se-&gt;discard_map, se-&gt;cur_valid_map,</span><br><span class="line">						SIT_VBLOCK_MAP_SIZE);</span><br><span class="line">			sbi-&gt;discard_blks += BLKS_PER_SEG(sbi) -</span><br><span class="line">						se-&gt;valid_blocks;</span><br><span class="line">init_discard_map_done:</span><br><span class="line">			<span class="keyword">if</span> (__is_large_section(sbi))</span><br><span class="line">				get_sec_entry(sbi, start)-&gt;valid_blocks +=</span><br><span class="line">							se-&gt;valid_blocks;</span><br><span class="line">		&#125;</span><br><span class="line">		start_blk += readed;</span><br><span class="line">	&#125; <span class="keyword">while</span> (start_blk &lt; sit_blk_cnt);</span><br><span class="line"></span><br><span class="line">	down_read(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; sits_in_cursum(journal); i++) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> old_valid_blocks;</span><br><span class="line"></span><br><span class="line">		start = le32_to_cpu(segno_in_journal(journal, i));</span><br><span class="line">		<span class="keyword">if</span> (start &gt;= MAIN_SEGS(sbi)) &#123;</span><br><span class="line">			f2fs_err(sbi, <span class="string">&quot;Wrong journal entry on segno %u&quot;</span>,</span><br><span class="line">				 start);</span><br><span class="line">			err = -EFSCORRUPTED;</span><br><span class="line">			f2fs_handle_error(sbi, ERROR_CORRUPTED_JOURNAL);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		se = &amp;sit_i-&gt;sentries[start];</span><br><span class="line">		sit = sit_in_journal(journal, i);</span><br><span class="line"></span><br><span class="line">		old_valid_blocks = se-&gt;valid_blocks;</span><br><span class="line"></span><br><span class="line">		sit_valid_blocks[SE_PAGETYPE(se)] -= old_valid_blocks;</span><br><span class="line"></span><br><span class="line">		err = check_block_count(sbi, start, &amp;sit);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		seg_info_from_raw_sit(se, &amp;sit);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (se-&gt;type &gt;= NR_PERSISTENT_LOG) &#123;</span><br><span class="line">			f2fs_err(sbi, <span class="string">&quot;Invalid segment type: %u, segno: %u&quot;</span>,</span><br><span class="line">							se-&gt;type, start);</span><br><span class="line">			err = -EFSCORRUPTED;</span><br><span class="line">			f2fs_handle_error(sbi, ERROR_INCONSISTENT_SUM_TYPE);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		sit_valid_blocks[SE_PAGETYPE(se)] += se-&gt;valid_blocks;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (f2fs_block_unit_discard(sbi)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(se-&gt;discard_map, <span class="number">0xff</span>, SIT_VBLOCK_MAP_SIZE);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">memcpy</span>(se-&gt;discard_map, se-&gt;cur_valid_map,</span><br><span class="line">							SIT_VBLOCK_MAP_SIZE);</span><br><span class="line">				sbi-&gt;discard_blks += old_valid_blocks;</span><br><span class="line">				sbi-&gt;discard_blks -= se-&gt;valid_blocks;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (__is_large_section(sbi)) &#123;</span><br><span class="line">			get_sec_entry(sbi, start)-&gt;valid_blocks +=</span><br><span class="line">							se-&gt;valid_blocks;</span><br><span class="line">			get_sec_entry(sbi, start)-&gt;valid_blocks -=</span><br><span class="line">							old_valid_blocks;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* update ckpt_valid_block */</span></span><br><span class="line">	<span class="keyword">if</span> (__is_large_section(sbi)) &#123;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">int</span> segno;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (segno = <span class="number">0</span>; segno &lt; MAIN_SEGS(sbi); segno += SEGS_PER_SEC(sbi)) &#123;</span><br><span class="line">			set_ckpt_valid_blocks(sbi, segno);</span><br><span class="line">			sanity_check_valid_blocks(sbi, segno);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sit_valid_blocks[NODE] != valid_node_count(sbi)) &#123;</span><br><span class="line">		f2fs_err(sbi, <span class="string">&quot;SIT is corrupted node# %u vs %u&quot;</span>,</span><br><span class="line">			 sit_valid_blocks[NODE], valid_node_count(sbi));</span><br><span class="line">		f2fs_handle_error(sbi, ERROR_INCONSISTENT_NODE_COUNT);</span><br><span class="line">		<span class="keyword">return</span> -EFSCORRUPTED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (sit_valid_blocks[DATA] + sit_valid_blocks[NODE] &gt;</span><br><span class="line">				valid_user_blocks(sbi)) &#123;</span><br><span class="line">		f2fs_err(sbi, <span class="string">&quot;SIT is corrupted data# %u %u vs %u&quot;</span>,</span><br><span class="line">			 sit_valid_blocks[DATA], sit_valid_blocks[NODE],</span><br><span class="line">			 valid_user_blocks(sbi));</span><br><span class="line">		f2fs_handle_error(sbi, ERROR_INCONSISTENT_BLOCK_COUNT);</span><br><span class="line">		<span class="keyword">return</span> -EFSCORRUPTED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 物理entry</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> &#123;</span></span><br><span class="line">	__le16 vblocks;				<span class="comment">/* reference above */</span></span><br><span class="line">	__u8 valid_map[SIT_VBLOCK_MAP_SIZE];	<span class="comment">/* bitmap for valid blocks */</span></span><br><span class="line">	__le64 mtime;				<span class="comment">/* segment age for cleaning */</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存entry</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> valid_blocks;	<span class="comment">/* # of valid blocks */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *cur_valid_map;	<span class="comment">/* validity bitmap of blocks */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> ckpt_valid_blocks;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *ckpt_valid_map;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> type;		<span class="comment">/* segment type like CURSEG_XXX_TYPE */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mtime;	<span class="comment">/* modification time of the segment */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>两者之间的差异主要是多了表示 segment 类型的 type 变量，以及多了两个与 checkpoint 相关的内容。</p><p>其实物理 entry 也包含了 segment type 的信息，但是为了节省空间，将 segment type 于 vblocks 存放在了一起，及 vblocks 的前 10 位表示数目，后 6 位表示 segment type，关系如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SIT_VBLOCKS_SHIFT	10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIT_VBLOCKS_MASK	((1 &lt;&lt; SIT_VBLOCKS_SHIFT) - 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIT_VBLOCKS(raw_sit)				\</span></span><br><span class="line"><span class="meta">	(le16_to_cpu((raw_sit)-&gt;vblocks) &amp; SIT_VBLOCKS_MASK)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIT_TYPE(raw_sit)					\</span></span><br><span class="line"><span class="meta">	((le16_to_cpu((raw_sit)-&gt;vblocks) &amp; ~SIT_VBLOCKS_MASK)	\</span></span><br><span class="line"><span class="meta">	 &gt;&gt; SIT_VBLOCKS_SHIFT)</span></span><br></pre></td></tr></table></div></figure><p>因此，内存 entry 实际上仅仅多了 2 个与 checkpoint 相关的信息，即 <code>ckpt_valid_blocks</code> 与 <code>ckpt_valid_map</code> 。在系统执行 checkpoint 的时候，会将 <code>valid_blocks</code> 以及 <code>cur_valid_map</code> 的值分别写入 <code>ckpt_valid_blocks</code> 与 <code>ckpt_valid_map</code>，当系统出现宕机的时候根据这个值恢复映射信息。</p><p>init_free_segmap() 从内存 entry 以及 checkpoint 中恢复 free segment 的信息。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_free_segmap</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> start;</span><br><span class="line">	<span class="type">int</span> type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seg_entry</span> *<span class="title">sentry</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (start = <span class="number">0</span>; start &lt; MAIN_SEGS(sbi); start++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (f2fs_usable_blks_in_seg(sbi, start) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		sentry = get_seg_entry(sbi, start);</span><br><span class="line">		<span class="keyword">if</span> (!sentry-&gt;valid_blocks)</span><br><span class="line">			__set_free(sbi, start);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			SIT_I(sbi)-&gt;written_valid_blocks +=</span><br><span class="line">						sentry-&gt;valid_blocks;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* set use the current segments */</span></span><br><span class="line">	<span class="keyword">for</span> (type = CURSEG_HOT_DATA; type &lt;= CURSEG_COLD_NODE; type++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg_t</span> =</span> CURSEG_I(sbi, type);</span><br><span class="line"></span><br><span class="line">		__set_test_and_inuse(sbi, <span class="type">curseg_t</span>-&gt;segno);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>init_dirty_segmap() 函数恢复脏 segment 的信息。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">init_dirty_segmap</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dirty_seglist_info</span> *<span class="title">dirty_i</span> =</span> DIRTY_I(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">free_segmap_info</span> *<span class="title">free_i</span> =</span> FREE_I(sbi);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> segno = <span class="number">0</span>, offset = <span class="number">0</span>, secno;</span><br><span class="line">	<span class="type">block_t</span> valid_blocks, usable_blks_in_seg;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="comment">/* find dirty segment based on free segmap */</span></span><br><span class="line">		segno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);</span><br><span class="line">		<span class="keyword">if</span> (segno &gt;= MAIN_SEGS(sbi))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		offset = segno + <span class="number">1</span>;</span><br><span class="line">		valid_blocks = get_valid_blocks(sbi, segno, <span class="literal">false</span>);</span><br><span class="line">		usable_blks_in_seg = f2fs_usable_blks_in_seg(sbi, segno);</span><br><span class="line">		<span class="keyword">if</span> (valid_blocks == usable_blks_in_seg || !valid_blocks)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (valid_blocks &gt; usable_blks_in_seg) &#123;</span><br><span class="line">			f2fs_bug_on(sbi, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mutex_lock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line">		__locate_dirty_segment(sbi, segno, DIRTY);</span><br><span class="line">		mutex_unlock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!__is_large_section(sbi))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	mutex_lock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line">	<span class="keyword">for</span> (segno = <span class="number">0</span>; segno &lt; MAIN_SEGS(sbi); segno += SEGS_PER_SEC(sbi)) &#123;</span><br><span class="line">		valid_blocks = get_valid_blocks(sbi, segno, <span class="literal">true</span>);</span><br><span class="line">		secno = GET_SEC_FROM_SEG(sbi, segno);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!valid_blocks || valid_blocks == CAP_BLKS_PER_SEC(sbi))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span> (is_cursec(sbi, secno))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		set_bit(secno, dirty_i-&gt;dirty_secmap);</span><br><span class="line">	&#125;</span><br><span class="line">	mutex_unlock(&amp;dirty_i-&gt;seglist_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="node-address-table-区域"><a href="#node-address-table-区域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#node-address-table-区域"></a> Node Address Table 区域</h1><p>Node Address Table，简称 NAT，是 F2FS 用于集中管理 node 的结构。**它的主要维护了一张表(如下图)，记录了每一个 node 在 flash 设备的物理地址。**F2FS 给每一个 node 分配了一个 node ID(nid)，系统可以根据 nid 从 NAT 查找到该 node 在 flash 设备上的物理地址，然后从 flash 设备读取出来。表的结构如下：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225153846231.png" alt="image-20251225153846231"></p><h2 id="元数据的物理结构-2"><a href="#元数据的物理结构-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#元数据的物理结构-2"></a> 元数据的物理结构</h2><p>NAT 区域由 N 个 <code>struct f2fs_nat_block</code> 组成，每一个 <code>struct f2fs_nat_block</code> 包含了 455 个 <code>struct f2fs_nat_entry</code>。每一个 nid 对应了一个 entry，每一个 entry 记录了这个 node 的在 flash 设备上的物理地址 block_addr。同时 entry 也记录了一个 ino 的值，这个值用于找到这个 node 的 parent node，如果 nid == ino 则表示这个 node 是 inode，如果 nid != ino，则表示这是一个 direct_node 或者 indrect_node。version 变量用于系统恢复。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225153933456.png" alt="image-20251225153933456" style="zoom:65%"><h2 id="内存管理结构-3"><a href="#内存管理结构-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内存管理结构-3"></a> 内存管理结构</h2><p>NAT 在内存中对应的管理结构是 <code>struct f2fs_nm_info</code>，它在 build_node_manager() 函数进行初始化。<code>struct f2fs_nm_info</code> 不会将所有的 NAT 的数据都读取出来，而是读取 NAT 的一部分，然后构建 free nid 表，用于给新的 node 分配 nid。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> &#123;</span></span><br><span class="line">	<span class="type">block_t</span> nat_blkaddr;		<span class="comment">/* base disk address of NAT */</span></span><br><span class="line">	<span class="type">nid_t</span> max_nid;			<span class="comment">/* maximum possible node ids */</span></span><br><span class="line">	<span class="type">nid_t</span> available_nids;		<span class="comment">/* # of available node ids */</span></span><br><span class="line">	<span class="type">nid_t</span> next_scan_nid;		<span class="comment">/* the next nid to be scanned */</span></span><br><span class="line">	<span class="type">nid_t</span> max_rf_node_blocks;	<span class="comment">/* max # of nodes for recovery */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ram_thresh;	<span class="comment">/* control the memory footprint */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ra_nid_pages;	<span class="comment">/* # of nid pages to be readaheaded */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> dirty_nats_ratio;	<span class="comment">/* control dirty nats ratio threshold */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* NAT cache management */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">nat_root</span>;</span><span class="comment">/* root of the nat entry cache */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">nat_set_root</span>;</span><span class="comment">/* root of the nat set cache */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_rwsem</span> <span class="title">nat_tree_lock</span>;</span>	<span class="comment">/* protect nat entry tree */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">nat_entries</span>;</span>	<span class="comment">/* cached nat entry list (clean) */</span></span><br><span class="line">	<span class="type">spinlock_t</span> nat_list_lock;	<span class="comment">/* protect clean nat entry list */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nat_cnt[MAX_NAT_STATE]; <span class="comment">/* the # of cached nat entries */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nat_blocks;	<span class="comment">/* # of nat blocks */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* free node ids management */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">radix_tree_root</span> <span class="title">free_nid_root</span>;</span><span class="comment">/* root of the free_nid cache */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">free_nid_list</span>;</span>		<span class="comment">/* list for free nids excluding preallocated nids */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nid_cnt[MAX_NID_STATE];	<span class="comment">/* the number of free node id */</span></span><br><span class="line">	<span class="type">spinlock_t</span> nid_list_lock;	<span class="comment">/* protect nid lists ops */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">build_lock</span>;</span>	<span class="comment">/* lock for build free nids */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> **free_nid_bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *nat_block_bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> *free_nid_count;	<span class="comment">/* free nid count of NAT block */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* for checkpoint */</span></span><br><span class="line">	<span class="type">char</span> *nat_bitmap;		<span class="comment">/* NAT bitmap pointer */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nat_bits_blocks;	<span class="comment">/* # of nat bits blocks */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *nat_bits;	<span class="comment">/* NAT bits blocks */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *full_nat_bits;	<span class="comment">/* full NAT pages */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *empty_nat_bits;	<span class="comment">/* empty NAT pages */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_CHECK_FS</span></span><br><span class="line">	<span class="type">char</span> *nat_bitmap_mir;		<span class="comment">/* NAT bitmap mirror */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> bitmap_size;		<span class="comment">/* bitmap size */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">build_node_manager</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 分配空间 */</span></span><br><span class="line">	sbi-&gt;nm_info = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> f2fs_nm_info), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!sbi-&gt;nm_info)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化sbi-&gt;nm_info的信息 */</span></span><br><span class="line">	err = init_node_manager(sbi);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 构建free nids表，用于给新的node分配nid */</span></span><br><span class="line">	build_free_nids(sbi);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>init_node_manager() 函数主要用于初始化 <code>sbi-&gt;nm_info</code> 内的变量信息。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">init_node_manager</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_super_block</span> *<span class="title">sb_raw</span> =</span> F2FS_RAW_SUPER(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> *<span class="title">nm_i</span> =</span> NM_I(sbi);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *version_bitmap;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nat_segs;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	nm_i-&gt;nat_blkaddr = le32_to_cpu(sb_raw-&gt;nat_blkaddr);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* segment_count_nat includes pair segment so divide to 2. */</span></span><br><span class="line">	nat_segs = le32_to_cpu(sb_raw-&gt;segment_count_nat) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	nm_i-&gt;nat_blocks = nat_segs &lt;&lt; le32_to_cpu(sb_raw-&gt;log_blocks_per_seg);</span><br><span class="line">	nm_i-&gt;max_nid = NAT_ENTRY_PER_BLOCK * nm_i-&gt;nat_blocks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* not used nids: 0, node, meta, (and root counted as valid node) */</span></span><br><span class="line">	nm_i-&gt;available_nids = nm_i-&gt;max_nid - sbi-&gt;total_valid_node_count -</span><br><span class="line">						F2FS_RESERVED_NODE_NUM;</span><br><span class="line">	nm_i-&gt;nid_cnt[FREE_NID] = <span class="number">0</span>;</span><br><span class="line">	nm_i-&gt;nid_cnt[PREALLOC_NID] = <span class="number">0</span>;</span><br><span class="line">	nm_i-&gt;ram_thresh = DEF_RAM_THRESHOLD;</span><br><span class="line">	nm_i-&gt;ra_nid_pages = DEF_RA_NID_PAGES;</span><br><span class="line">	nm_i-&gt;dirty_nats_ratio = DEF_DIRTY_NAT_RATIO_THRESHOLD;</span><br><span class="line">	nm_i-&gt;max_rf_node_blocks = DEF_RF_NODE_BLOCKS;</span><br><span class="line"></span><br><span class="line">	INIT_RADIX_TREE(&amp;nm_i-&gt;free_nid_root, GFP_ATOMIC);</span><br><span class="line">	INIT_LIST_HEAD(&amp;nm_i-&gt;free_nid_list);</span><br><span class="line">	INIT_RADIX_TREE(&amp;nm_i-&gt;nat_root, GFP_NOIO);</span><br><span class="line">	INIT_RADIX_TREE(&amp;nm_i-&gt;nat_set_root, GFP_NOIO);</span><br><span class="line">	INIT_LIST_HEAD(&amp;nm_i-&gt;nat_entries);</span><br><span class="line">	spin_lock_init(&amp;nm_i-&gt;nat_list_lock);</span><br><span class="line"></span><br><span class="line">	mutex_init(&amp;nm_i-&gt;build_lock);</span><br><span class="line">	spin_lock_init(&amp;nm_i-&gt;nid_list_lock);</span><br><span class="line">	init_f2fs_rwsem(&amp;nm_i-&gt;nat_tree_lock);</span><br><span class="line"></span><br><span class="line">	nm_i-&gt;next_scan_nid = le32_to_cpu(sbi-&gt;ckpt-&gt;next_free_nid);</span><br><span class="line">	nm_i-&gt;bitmap_size = __bitmap_size(sbi, NAT_BITMAP);</span><br><span class="line">	version_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);</span><br><span class="line">	nm_i-&gt;nat_bitmap = kmemdup(version_bitmap, nm_i-&gt;bitmap_size,</span><br><span class="line">					GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!nm_i-&gt;nat_bitmap)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!test_opt(sbi, NAT_BITS))</span><br><span class="line">		disable_nat_bits(sbi, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	err = __get_nat_bitmaps(sbi);</span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_CHECK_FS</span></span><br><span class="line">	nm_i-&gt;nat_bitmap_mir = kmemdup(version_bitmap, nm_i-&gt;bitmap_size,</span><br><span class="line">					GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!nm_i-&gt;nat_bitmap_mir)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>build_free_nids() 主要用于构建 free nid 表，用于给新的 node 分配 nid。 为了节省内存，F2FS 不会将 NAT 中所有的 free nid 读取出来，只会读取一部分，因此使用 <code>nm_i-&gt;fcnt</code> 表示缓存了多少个 free nid。然后会读取一定的数目的 <code>f2fs_nat_block</code> 出来，并遍历其中的每一个 <code>f2fs_nat_entry</code>，加入到 free nid 的管理结构中。最后还会搜索一下 log 区域的 free nid 信息，也加入到 free nid 管理结构中。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">build_free_nids</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> *<span class="title">nm_i</span> =</span> NM_I(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span> =</span> CURSEG_I(sbi, CURSEG_HOT_DATA);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> *<span class="title">journal</span> =</span> curseg-&gt;journal;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">nid_t</span> nid = nm_i-&gt;next_scan_nid; <span class="comment">// next_scan_nid的含义上面有介绍，从这里开始搜索free nid</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* *</span></span><br><span class="line"><span class="comment">	 * 为了节省内存，F2FS不会将NAT中所有的free nid读取出来，只会读取一部分</span></span><br><span class="line"><span class="comment">	 * fcnt表示目前缓存了多少个free nid，如果大于NAT_ENTRY_PER_BLOCK，则不再缓存了</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (nm_i-&gt;fcnt &gt;= NAT_ENTRY_PER_BLOCK)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 因为准备开始读取NAT的page(block)，因此根据nid(next_scan_nid)的所在的block开始，</span></span><br><span class="line"><span class="comment">	 * 读取FREE_NID_PAGES(=8)个page进入内存 </span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES,</span><br><span class="line">							META_NAT, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">	down_read(&amp;nm_i-&gt;nat_tree_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> get_current_nat_page(sbi, nid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* </span></span><br><span class="line"><span class="comment">         * 读取当前nid所在的f2fs_nat_block(page)，</span></span><br><span class="line"><span class="comment">         * 然后将free nid加入到nm_i-&gt;free_nid_list/root中 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">		scan_nat_page(sbi, page, nid);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 释放当前的f2fs_nat_block对应的page */</span></span><br><span class="line">		f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 已经读取了一个f2fs_nat_block，自然要跳到下一个f2fs_nat_block的第一个nid */</span></span><br><span class="line">		nid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));</span><br><span class="line">		<span class="keyword">if</span> (unlikely(nid &gt;= nm_i-&gt;max_nid))</span><br><span class="line">			nid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 所有block读完之后就跳出循环 */</span></span><br><span class="line">		<span class="keyword">if</span> (++i &gt;= FREE_NID_PAGES)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 更新next_scan_nid，前面的已经扫描过了，下一次从这个nid开始扫描 */</span></span><br><span class="line">	nm_i-&gt;next_scan_nid = nid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 遍历log的nat_journal记录的nat_entry信息，从中寻找free nid */</span></span><br><span class="line">	down_read(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nats_in_cursum(journal); i++) &#123;</span><br><span class="line">		<span class="type">block_t</span> addr;</span><br><span class="line">		<span class="comment">/* 从journal中获取nid信息 */</span></span><br><span class="line">        nid = le32_to_cpu(nid_in_journal(journal, i));</span><br><span class="line">        <span class="comment">/* 从journal中获取该nid对应的物理地址 */</span></span><br><span class="line">		addr = le32_to_cpu(nat_in_journal(journal, i).block_addr);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* addr==NULL_ADDR 表示这个nid没有被文件使用，因此加入free nid，否则去除free nid */</span></span><br><span class="line">		<span class="keyword">if</span> (addr == NULL_ADDR) </span><br><span class="line">			add_free_nid(sbi, nid, <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			remove_free_nid(nm_i, nid);</span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line">	up_read(&amp;nm_i-&gt;nat_tree_lock);</span><br><span class="line"></span><br><span class="line">	ra_meta_pages(sbi, NAT_BLOCK_OFFSET(nm_i-&gt;next_scan_nid),</span><br><span class="line">					nm_i-&gt;ra_nid_pages, META_NAT, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>scan_nat_page() 函数的作用是扫描当前的 <code>f2fs_nat_block</code> 的每一个 entry，并找到其中的 free nid，加入到 <code>nm_i</code> 的 free nid 管理结构中。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">scan_nat_page</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> f2fs_nat_block *nat_blk, <span class="type">nid_t</span> start_nid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> *<span class="title">nm_i</span> =</span> NM_I(sbi);</span><br><span class="line">	<span class="type">block_t</span> blk_addr;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nat_ofs = NAT_BLOCK_OFFSET(start_nid);</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	__set_bit_le(nat_ofs, nm_i-&gt;nat_block_bitmap);</span><br><span class="line"></span><br><span class="line">	i = start_nid % NAT_ENTRY_PER_BLOCK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; i &lt; NAT_ENTRY_PER_BLOCK; i++, start_nid++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(start_nid &gt;= nm_i-&gt;max_nid))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		blk_addr = le32_to_cpu(nat_blk-&gt;entries[i].block_addr);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (blk_addr == NEW_ADDR)</span><br><span class="line">			<span class="keyword">return</span> -EFSCORRUPTED;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (blk_addr == NULL_ADDR) &#123;</span><br><span class="line">			add_free_nid(sbi, start_nid, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			spin_lock(&amp;NM_I(sbi)-&gt;nid_list_lock);</span><br><span class="line">			update_free_nid_bitmap(sbi, start_nid, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">			spin_unlock(&amp;NM_I(sbi)-&gt;nid_list_lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="segment-summary-area-区域"><a href="#segment-summary-area-区域" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#segment-summary-area-区域"></a> Segment Summary Area 区域</h1><p>Segment Summary Area，简称 SSA，是 F2FS 用于集中管理物理地址到逻辑地址的映射关系的结构，同时它也具有通过 journal 缓存 sit 或者 nat 的操作用于数据恢复的作用。映射关系的主要作用是当给出一个物理地址的时候，可以通过 SSA 索引得到对应的逻辑地址，主要应用在 GC 流程中; SSA 所包含的 journal 可以缓存一些 sit 或者 nat 的操作，用于避免频繁的元数据更新，以及宕机时候的数据恢复。</p><h2 id="元数据的物理结构-3"><a href="#元数据的物理结构-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#元数据的物理结构-3"></a> 元数据的物理结构</h2><p>从结构图可以知道，SSA 区域由 N 个 <code>struct f2fs_summary_block</code> 组成，每一个 <code>struct f2fs_summary_block</code> 包含了 512 个 <code>struct f2fs_summary_entry</code>，刚好对应一个 segment。segment 里面的每一个 block(物理地址)对应一个的 <code>struct f2fs_summary_entry</code>，它记录了物理地址到逻辑地址的映射信息。它包含了三个变量: nid(该物理地址是属于哪一个 node 的)，version(用于数据恢复)，ofs_in_node(该物理地址属于该 nid 对应的 node 的第 ofs_in_node 个 block)。</p><p><code>f2fs_journal</code> 属于 journal 的信息，它的作用是减少频繁地对 NAT 区域以及 SIT 区域的更新。例如，当系统写压力很大的时候，segment bitmap 更新就会很频繁，就会对 <code>struct f2fs_sit_entry</code> 结构进行频繁地改动。如果这个时候频繁将新的映射关系写入 SIT，就会加重写压力。此时可以将数据先写入到 journal 中，因此 <strong>journal 的作用就是维护这些经常修改的数据，等待 CP 被触发的时候才写入磁盘，从而减少写压力</strong>。也许这里会有疑问，为什么将 journal 放在 SSA 区域而不是 NAT 区域以及 SIT 区域呢？这是因为这种存放方式可以减少元数据区域空间的占用。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225154609242.png" alt="image-20251225154609242" style="zoom:67%"><p>SSA 的基本存放单元是 <code>struct f2fs_summary_block</code>，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Block-sized summary block structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> <span class="title">entries</span>[<span class="title">ENTRIES_IN_SUM</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> <span class="title">journal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">summary_footer</span> <span class="title">footer</span>;</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p>与 summary 直接相关的是 <code>struct f2fs_summary</code> 以及 <code>struct summary_footer</code>。<code>ENTRIES_IN_SUM</code> 的值 512，因此每一个 entry 对应一个 block，记录了从物理地址到逻辑地址的映射关系，entry 的结构如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a summary entry for a block in a segment */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> &#123;</span></span><br><span class="line">	__le32 nid;		<span class="comment">/* parent node id */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u8 reserved[<span class="number">3</span>];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u8 version;		<span class="comment">/* node version number */</span></span><br><span class="line">			__le16 ofs_in_node;	<span class="comment">/* block index in parent node */</span></span><br><span class="line">		&#125; __packed;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">summary_footer</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> entry_type;	<span class="comment">/* SUM_TYPE_XXX */</span></span><br><span class="line">	__le32 check_sum;		<span class="comment">/* summary checksum */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p><code>struct f2fs_summary</code> 用了一个 union 结构进行表示，但是核心信息是 <code>nid</code>、<code>version</code> 以及 <code>ofs_in_node</code>。数据的索引是通过 node 来进行。文件访问某一个页的数据时，需要首先根据页的索引，找到对应的 nid 以及 offset(两者构成逻辑地址)，从而根据 nid 得到 node page，再根据 offset 得到了该页的物理地址，然后从磁盘中读取出来。<code>f2fs_summary</code> 则是<strong>记录物理地址到逻辑地址的映射</strong>，即根据物理地址找到对应的 nid 以及 offset。例如，现在需要根据物理地址为 624 的 block，找到对应的 nid 以及 offset。那么物理地址为 624，可以得到该地址位于第二个 segment，然后属于第二个 segment 的第 113 个 block(block 的编址从 0 开始)。因此根据属于第二个 segment 的信息，找到第二个 <code>struct f2fs_summary_block</code>，然后根据偏移量为 113 的信息，找到对应的 <code>struct f2fs_summary</code> 结构，从而得到 <code>nid</code> 以及 <code>ofs_in_node</code>。</p><p><code>struct summary_footer</code> 结构记录了校验信息，以及这个 summary 对应的 segment 是属于保存 data 数据的 segment 还是 node 数据的segment。</p><p>SSA 在内存没有单独的管理结构，summary 以及 journal 在内存中主要存在于 CURSEG 中。</p><h1 id="文件数据组织方式"><a href="#文件数据组织方式" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件数据组织方式"></a> 文件数据组织方式</h1><p>文件数据的组织方式一般时被设计为 inode-data 模式，即每一个文件都具有一个 inode，这个 inode 记录 data 的组织关系，这个关系称为<strong>文件结构</strong>。例如用户需要访问 A 文件的第 1000 个字节，系统就会先根据 A 文件的路径找到的 A 的 inode，然后从 inode 找到第 1000 个字节所在的物理地址，然后从磁盘读取出来。那么 F2FS 的文件结构是怎么样的呢？</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/12/29/image-20251225155522809.png" alt="image-20251225155522809" style="zoom:80%"><p>F2FS 中的一个 inode，包含两个主要部分: metadata 部分，和数据块寻址部分。我们重点观察数据块寻址部分，分析 inode 时如何将数据块索引出来。在图中，数据块寻址部分包含 direct pointers，single-indirect，double-indirect，以及 triple-indirect。它们的含义分别是：</p><ul><li><strong>direct pointer:</strong> inode 内直接指向数据块(图右上角 Data)的地址数组，即 <strong>inode-&gt;data模式</strong>。</li><li><strong>single-indirect pointer:</strong> inode 记录了两个 single-indirect pointer(图右上角 Direct node)，每一个 single-indirect pointer 存储了多个数据块的地址，即 <strong>inode-&gt;direct_node-&gt;data 模式</strong>。</li><li><strong>double-indirect:</strong> inode 记录了两个 double-indirect pointer(图右上角 indirect node)，每一个 double-indirect pointer 记录了许多 single-indirect pointer，每一个 single-indirect pointer 指向了数据块，即 <strong>inode-&gt;indirect_node-&gt;direct_node-&gt;data 模式</strong>。</li><li><strong>triple-indirect:</strong> inode 记录了一个 triple-indirect pointer(图右上角 indirect node)，每一个 triple-indirect pointer 记录了许多 double-indirect pointer，每一个 double-indirect pointer 记录了许多 single-indirect pointer，最后每一个 single-indirect pointer 指向了数据块。即 <strong>inode-&gt;indirect_node-&gt;indirect_node-&gt;direct_node-&gt;data 模式</strong>。</li></ul><p>可以发现，F2FS 的 inode 结构采取 indirect_node，首先在 inode 内部寻找物理地址，如果找不到再去 direct_node 找，层层深入。</p><h2 id="f2fs_node-结构及其作用"><a href="#f2fs_node-结构及其作用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_node-结构及其作用"></a> f2fs_node 结构及其作用</h2><p>对于一个较大的文件，它可能包含 inode 以外的 node，去保存一些间接寻址的信息。single-indirect pointer 记录的是数据块的地址，而 double-indirect pointer 记录的是 single-indirect pointer 的地址，triple-indirect pointer 记录的 double-indirect pointer 地址。在F2FS中：</p><ul><li>inode 对应的是 <code>f2fs_inode</code> 结构，包含了多个 direct pointer 指向数据块物理地址；</li><li>single-indirect pointer 对应的是 <code>direct_node</code> 结构，包含了多个 direct pointer 指向物理地址；</li><li>double-indirect pointer 对应的是 <code>indirect_node</code> 结构，包含了多个指向 <code>direct_node</code> 的地址；</li><li>triple-indirect pointer 对应的也是 <code>indirect_node</code> 结构，包含了多个指向 <code>indirect_node</code> 的地址。</li></ul><h3 id="基本-node-结构"><a href="#基本-node-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#基本-node-结构"></a> 基本 node 结构</h3><p>为了方便 F2FS 的对 node 的区分和管理，<code>f2fs_inode</code> 和 <code>direct_node</code> 以及 <code>indirect_node</code> 都使用了同一个数据结构 <code>f2fs_node</code> 进行描述，并通过 union 的方式，将 <code>f2fs_node</code> 初始化成不同的 node 形式。定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_node</span> &#123;</span></span><br><span class="line">	<span class="comment">/* can be one of three types: inode, direct, and indirect types */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode</span> <span class="title">i</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">direct_node</span> <span class="title">dn</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">indirect_node</span> <span class="title">in</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node_footer</span> <span class="title">footer</span>;</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_footer</span> &#123;</span></span><br><span class="line">	__le32 nid;		<span class="comment">/* node id */</span></span><br><span class="line">	__le32 ino;		<span class="comment">/* inode number */</span></span><br><span class="line">	__le32 flag;		<span class="comment">/* include cold/fsync/dentry marks and offset */</span></span><br><span class="line">	__le64 cp_ver;		<span class="comment">/* checkpoint version */</span></span><br><span class="line">	__le32 next_blkaddr;	<span class="comment">/* next node page block address */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p>其中起到区分是哪一种 node 的关键数据结构是 <code>node_footer</code>。如果 <code>node_footer</code> 的 <code>nid</code> 和 <code>ino</code> 相等，则表示这是一个 <code>f2fs_inode</code> 结构，如果不相等，则表示这是一个 <code>direct_node</code> 或者 <code>indirect_node</code>。</p><h3 id="f2fs_inode-结构"><a href="#f2fs_inode-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_inode-结构"></a> f2fs_inode 结构</h3><p>考虑 <code>f2fs_inode</code> 的结构，省略其他元数据的信息，重点关注文件如何索引的，结构如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode</span> &#123;</span></span><br><span class="line">	...</span><br><span class="line">	__le32 i_addr[DEF_ADDRS_PER_INODE]; <span class="comment">// DEF_ADDRS_PER_INODE=923</span></span><br><span class="line">	__le32 i_nid[DEF_NIDS_PER_INODE];	<span class="comment">// DEF_NIDS_PER_INODE=5</span></span><br><span class="line">	...</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p><code>i_addr</code> 数组就是前面提及的 direct pointer，数组的下标是文件的逻辑位置，数组的值就是 flash 设备的物理地址。例如文件的第一个页就对应 <code>i_addr[0]</code>，第二个页就对应 <code>i_addr[1]</code>，而 <code>i_addr[0]</code> 和 <code>i_addr[1]</code> 所记录的物理地址，就是文件第一个页(page)和第二个页的数据的物理地址，系统可以将两个物理地址提交到 flash 设备，将数据读取出来。</p><p>我们可以发现 <code>i_addr</code> 的数组长度只有 923，即一个 <code>f2fs_inode</code> 只能直接索引到 923 个页/块的地址(约 3.6 MB)，对于大于 3.6 MB的文件，就需要使用<strong>间接寻址</strong>。<code>f2fs_inode</code> 的 <code>i_nid</code> 数组就是为了间接寻址而设计，<code>i_nid</code> 数组是一个长度为 5 的数组，可以记录 5 个 node 的地址。其中：</p><ul><li><code>i_nid[0]</code> 和 <code>i_nid[1]</code> 记录的是 <code>direct_node</code> 的地址，即对应前述的 single-indirect pointer。</li><li><code>i_nid[2]</code> 和 <code>i_nid[3]</code> 记录的是 <code>indirect_node</code> 的地址，这两个 <code>indirect_node</code> 记录的是 <code>direct_node</code> 的地址，即对应前述的 double-indirect pointer。</li><li><code>i_nid[4]</code> 记录的是 <code>indirect_node</code> 的地址，但是这个 <code>indirect_node</code> 记录的是 <code>indirect_node</code> 的地址，即前述的 triple-indirect pointer。</li></ul><h3 id="direct_node-和-indirect_node-结构"><a href="#direct_node-和-indirect_node-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#direct_node-和-indirect_node-结构"></a> direct_node 和 indirect_node 结构</h3><p><code>direct_node</code> 记录的是数据块的地址，<code>indirect_inode</code> 记录的是 node 的 id，系统可以通过 nid 找到对应的 node 的地址。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">direct_node</span> &#123;</span></span><br><span class="line">	__le32 addr[ADDRS_PER_BLOCK]; <span class="comment">// ADDRS_PER_BLOCK=1018</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">indirect_node</span> &#123;</span></span><br><span class="line">	__le32 nid[NIDS_PER_BLOCK]; <span class="comment">// NIDS_PER_BLOCK=1018</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><h3 id="wandering-tree-问题"><a href="#wandering-tree-问题" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#wandering-tree-问题"></a> Wandering Tree 问题</h3><p>F2FS 的设计是为了解决 wandering tree 的问题，那么现在的设计是如何解决这个问题的呢。假设一个文件发生更改，修改了 <code>direct_node</code> 里面的某一个 block 的数据，根据 LFS 的异地更新特性，我们需要给更改后的数据一个新的 block。传统的 LFS 需要将这个新的 block 的地址一层层网上传递，直到 inode 结构。<strong>而 F2FS 的设计是只需要将 <code>direct_node</code> 对应位置的 <code>addr</code> 的值更新为新 block 的地址，从而没必要往上传递，因此解决了 wandering tree 的问题。</strong></p><h2 id="普通文件数据的保存"><a href="#普通文件数据的保存" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#普通文件数据的保存"></a> 普通文件数据的保存</h2><p>一个文件由一个 <code>f2fs_inode</code> 和多个 <code>direct_inode</code> 或者 <code>indirect_inode</code> 所组成。当系统创建一个文件的时候，它会首先创建一个 <code>f2fs_inode</code> 写入到 flash 设备，然后用户往该文件写入第一个 page 的时候，会将数据写入到 main area 的一个 block 中，然后将该 block 的物理地址赋值到 <code>f2fs_inode-&gt;i_addr[0]</code> 中，这样就完成了 Node-Data 的管理关系。随着对同一文件写入的数据的增多，会逐渐使用到其他类型的 node 去保存文件的数据。</p><h2 id="内联数据文件的保存"><a href="#内联数据文件的保存" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#内联数据文件的保存"></a> 内联数据文件的保存</h2><p>文件的实际数据是保存在 <code>f2fs_inode-&gt;i_addr</code> 对应的物理块当中，因此即使一个很小的文件，如 1 个字节的小文件，也需要一个 node 和 data block 才能实现正常的保存和读写，也就是需要 8 KB 的磁盘空间去保存一个尺寸为 1 字节的小文件。而且 <code>f2fs_inode-&gt;i_addr[923]</code> 里面除了 <code>f2fs_inode-&gt;i_addr[0]</code> 保存了一个物理地址，其余的 922 个 i_addr 都被闲置，造成了空间的浪费。</p><p>F2FS 为了减少空间的使用量，使用内联(inline)文件减少这些空间的浪费。它的核心思想是当文件足够小的时候，使用 <code>f2fs_inode-&gt;i_addr</code> 数组直接保存数据本身，而不单独写入一个 block 中，再进行寻址。因此，如上面的例子，只有 1 个字节大小的文件，只需要一个 <code>f2fs_inode</code> 结构，即 4 KB，就可以同时将 node 信息和 data 信息同时保存，减少了一半的空间使用量。</p><p>根据上述定义，可以计算得到多大的文件可以使用内联的方式进行保存，<code>f2fs_inode</code> 有尺寸为 923 的用于保存数据物理地址的数组 i_addr，它的数据类型是 __le32，即 4 个字节。保留一个数组成员另做它用，因此内联文件最大尺寸为: 922 * 4 = 3688 字节。</p><h2 id="文件访问的实际例子"><a href="#文件访问的实际例子" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件访问的实际例子"></a> 文件访问的实际例子</h2><p>Linux 的文件是通过 page 进行组织起来的，默认 page 的 size 是 4 KB，使用 index 作为编号。</p><p>一个小文件访问例子：例如一个 size = 10 KB 的文件，需要 3 个 page 去保存数据，这 3 个 page 的编号是 0，1，2。当用户访问这个文件的第 2~6kb 的数据的时候，系统就会计算出数据保存在 page index = 0 和 1 的 page 中，然后根据文件的路径找到对应的 <code>f2fs_inode</code> 结构，page index = 0 和 1 即对应 <code>f2fs_inode</code> 的 <code>i_addr[0]</code> 和 <code>i_addr[1]</code>。系统进而从这两个 <code>i_addr</code> 读取物理地址，提交到 flash 设备将数据读取出来。</p><p>一个大文件访问例子：假设用户需要读取文件第 4000 个页(page index = 3999)的数据，第一步: 那么首先系统会根据文件路径找到对应的 f2fs_inode 结构。第二步：由于 4000 &gt;（923 + 1018 + 1018），<code>f2fs_inode-&gt;i_addr</code>和 <code>f2fs_inode-&gt;nid[0]和nid[1]</code> 都无法满足需求，因此系统根据 <code>f2fs_inode-&gt;nid[2]</code> 找到对应的 <code>indirect_node</code> 的地址。第三步：<code>indirect_node</code> 保存的是 <code>direct_node</code> 的nid数组，由于 4000 - 923 - 1018 - 1018 = 1041，而一个 <code>direct_node</code> 只能保存 1018 个 block，因此可以知道数据位于 <code>indirect_node-&gt;nid[1]</code> 对应的 <code>direct_node</code> 中。第四步：计算剩下的的偏移(4000-923-1018-1018-1018=23)找到数据的物理地址位于该 <code>direct_node</code> 的 <code>direct_node-&gt;addr[23]</code> 中。</p><h1 id="读流程"><a href="#读流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#读流程"></a> 读流程</h1><p>F2FS 的读流程包含了以下几个子流程:</p><ol><li>vfs_read 函数。</li><li>generic_file_read_iter 函数: 根据访问类型执行不同的处理。</li><li>generic_file_buffered_read 函数: 根据用户传入的文件偏移，读取尺寸等信息，计算起始位置和页数，然后遍历每一个 page，通过预读或者单个读取的方式从磁盘中读取出来。</li><li>f2fs_read_data_page&amp;f2fs_read_data_pages 函数: 从磁盘读取 1 个 page 或者多个 page。</li><li>f2fs_mpage_readpages 函数: f2fs 读取数据的主流程。</li></ol><p>第一步的 vfs_read 函数是 VFS 层面的流程，下面仅针对涉及 F2FS 的读流程，且经过简化的主要流程进行分析。</p><h2 id="generic_file_read_iter-函数"><a href="#generic_file_read_iter-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#generic_file_read_iter-函数"></a> generic_file_read_iter 函数</h2><p>这个函数的作用是处理普通方式访问以及 direct 方式访问的读行为，这里仅针对普通方式的读访问进行分析:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_file_read_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *iter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">size_t</span> count = iov_iter_count(iter); <span class="comment">// 获取需要读取的字节数</span></span><br><span class="line">	<span class="type">ssize_t</span> retval = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!count)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (iocb-&gt;ki_flags &amp; IOCB_DIRECT) &#123; <span class="comment">// 处理direct方式的访问，这里不做介绍</span></span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	retval = generic_file_buffered_read(iocb, iter, retval); <span class="comment">// 进行普通的读访问</span></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="generic_file_buffered_read-函数"><a href="#generic_file_buffered_read-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#generic_file_buffered_read-函数"></a> generic_file_buffered_read 函数</h2><p>在介绍这两个之前，需要先介绍一种 VFS 提高读取速度的机制: 预读(readahead)机制。它的核心原理是，当用户访问 page 1，系统就会将 page 1 后续的 page 2，page 3，page 4 一起读取到 page cache(减少与磁盘这种速度慢设备的交互次数，提高读性能)。之后用户再连续读取 page 2，page 3，page 4 时，由于已经读取到内存中，因此可以快速地返回给用户。</p><p>generic_file_buffered_read() 函数的主要作用是循环地从磁盘或者内存读取用户需要的 page，同时也会在某些情况调用 page_cache_sync_readahead() 函数进行预读，由于函数比较复杂，且很多 goto 语句，简化后的步骤如下：</p><p><strong>情况 1：预读(readahead)机制成功预读到用户需要接下来访问的 page</strong></p><ol><li>ind_get_page: 系统无法在 cache 中找到用户需要的 page。</li><li>page_cache_sync_readahead: 系统执行该函数进行预读，一次性读取多个 page。</li><li>find_get_page: 再重新在 cache 获取一次 page，获取成功后跳转到 page ok 区域。</li><li>page_ok: 复制 page 的数据去用户传入的 buffer 中，然后判读是否为最后一个 page，如果是则退出读流程。</li></ol><p><strong>情况 2：预读(readahead)机制错误预读到用户需要接下来访问的 page</strong></p><ol><li>find_get_page: 系统无法在 cache 中找到用户需要的 page。</li><li>page_cache_sync_readahead: 系统执行该函数进行预读，一次性读取多个 page。</li><li>find_get_page: 再重新在 cache 获取一次 page，获取失败，跳转到 no_cached_page 区域。</li><li>no_cached_page: 创建一个 page cache 结构，加入到 LRU 后，跳转到 readpage 区域。</li><li>readpage: 执行 <code>mapping-&gt;a_ops-&gt;readpage</code> 函数从磁盘读取数据，成功后跳转到 page ok 区域。</li><li>page_ok: 复制 page 的数据去用户传入的 buffer 中，然后判读是否为最后一个 page，如果是则退出读流程。</li></ol><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">generic_file_buffered_read</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> iov_iter *iter, <span class="type">ssize_t</span> written)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	index = *ppos &gt;&gt; PAGE_SHIFT; <span class="comment">// 文件指针偏移*ppos除以page的大小就是页偏移index</span></span><br><span class="line">	prev_index = ra-&gt;prev_pos &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	prev_offset = ra-&gt;prev_pos &amp; (PAGE_SIZE<span class="number">-1</span>);</span><br><span class="line">	last_index = (*ppos + iter-&gt;count + PAGE_SIZE<span class="number">-1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	offset = *ppos &amp; ~PAGE_MASK;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">find_page:</span><br><span class="line">		page = find_get_page(mapping, index); <span class="comment">// 根据页偏移index从cache获取page</span></span><br><span class="line">		<span class="keyword">if</span> (!page) &#123; <span class="comment">// 获取失败进行一次预读</span></span><br><span class="line">			page_cache_sync_readahead(mapping, ra, filp,</span><br><span class="line">					index, last_index - index);</span><br><span class="line">			page = find_get_page(mapping, index); <span class="comment">// 预读后再从cache获取page</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(page == <span class="literal">NULL</span>)) <span class="comment">// 如果仍然失败则跳转到no_cached_page，成功则直接去page ok区域</span></span><br><span class="line">				<span class="keyword">goto</span> no_cached_page;</span><br><span class="line">		&#125;</span><br><span class="line">page_ok: </span><br><span class="line">		<span class="comment">// page数据读取成功后都进入这个区域，用于将数据复制到用户传入的buffer中</span></span><br><span class="line">		isize = i_size_read(inode);</span><br><span class="line">		end_index = (isize - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">		nr = PAGE_SIZE;</span><br><span class="line">		<span class="keyword">if</span> (index == end_index) &#123; <span class="comment">// 如果到了最后一个index就退出循环</span></span><br><span class="line">			nr = ((isize - <span class="number">1</span>) &amp; ~PAGE_MASK) + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> (nr &lt;= offset) &#123;</span><br><span class="line">				put_page(page);</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		nr = nr - offset;</span><br><span class="line">		ret = copy_page_to_iter(page, offset, nr, iter); <span class="comment">// 复制用户数据到buffer中</span></span><br><span class="line">		offset += ret;</span><br><span class="line">		index += offset &gt;&gt; PAGE_SHIFT;</span><br><span class="line">		offset &amp;= ~PAGE_MASK;</span><br><span class="line">		prev_offset = offset;</span><br><span class="line"></span><br><span class="line">		put_page(page);</span><br><span class="line">		written += ret;</span><br><span class="line">		<span class="keyword">if</span> (!iov_iter_count(iter))  <span class="comment">// 如果将所有数据读取完毕后退出循环</span></span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; nr) &#123;</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">readpage:</span><br><span class="line">		ClearPageError(page);</span><br><span class="line">		error = mapping-&gt;a_ops-&gt;readpage(filp, page); <span class="comment">// 去磁盘进行读取</span></span><br><span class="line">		<span class="keyword">goto</span> page_ok;</span><br><span class="line">no_cached_page:</span><br><span class="line">		page = page_cache_alloc(mapping); <span class="comment">// 创建page cache</span></span><br><span class="line">		error = add_to_page_cache_lru(page, mapping, index,</span><br><span class="line">				mapping_gfp_constraint(mapping, GFP_KERNEL)); <span class="comment">// 加入lru</span></span><br><span class="line">		<span class="keyword">goto</span> readpage;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	ra-&gt;prev_pos = prev_index;</span><br><span class="line">	ra-&gt;prev_pos &lt;&lt;= PAGE_SHIFT;</span><br><span class="line">	ra-&gt;prev_pos |= prev_offset;</span><br><span class="line"></span><br><span class="line">	*ppos = ((<span class="type">loff_t</span>)index &lt;&lt; PAGE_SHIFT) + offset;</span><br><span class="line">	file_accessed(filp);</span><br><span class="line">	<span class="keyword">return</span> written ? written : error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>预读函数 page_cache_sync_readahead() 的分析由于篇幅有限无法全部展示，这里仅分析它的核心调用函数 __do_page_cache_readahead():</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> __do_page_cache_readahead(<span class="keyword">struct</span> address_space *mapping,</span><br><span class="line">		<span class="keyword">struct</span> file *filp, <span class="type">pgoff_t</span> offset, <span class="type">unsigned</span> <span class="type">long</span> nr_to_read,</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> lookahead_size)</span><br><span class="line">&#123;</span><br><span class="line">	end_index = ((isize - <span class="number">1</span>) &gt;&gt; PAGE_SHIFT); <span class="comment">// 得到文件的最后一个页的页偏移index</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (page_idx = <span class="number">0</span>; page_idx &lt; nr_to_read; page_idx++) &#123; <span class="comment">// nr_to_read是需要预读的page的数目</span></span><br><span class="line">		<span class="type">pgoff_t</span> page_offset = offset + page_idx; <span class="comment">// offset表示从第几个page开始预读</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (page_offset &gt; end_index) <span class="comment">// 预读超过了文件大小就退出</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			</span><br><span class="line">		page = __page_cache_alloc(gfp_mask); <span class="comment">// 创建page cache</span></span><br><span class="line">		page-&gt;index = page_offset; <span class="comment">// 设置page index</span></span><br><span class="line">		list_add(&amp;page-&gt;lru, &amp;page_pool); <span class="comment">// 将所有预读的page加入到一个list中</span></span><br><span class="line">		nr_pages++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nr_pages)</span><br><span class="line">		read_pages(mapping, filp, &amp;page_pool, nr_pages, gfp_mask); <span class="comment">// 执行预读</span></span><br><span class="line">	BUG_ON(!list_empty(&amp;page_pool));</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> nr_pages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">read_pages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> list_head *pages, <span class="type">unsigned</span> <span class="type">int</span> nr_pages, <span class="type">gfp_t</span> gfp)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_plug</span> <span class="title">plug</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> page_idx;</span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">	blk_start_plug(&amp;plug);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mapping-&gt;a_ops-&gt;readpages) &#123;</span><br><span class="line">		ret = mapping-&gt;a_ops-&gt;readpages(filp, mapping, pages, nr_pages); <span class="comment">// 执行readpages函数进行预读</span></span><br><span class="line">		put_pages_list(pages);</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	blk_finish_plug(&amp;plug);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="f2fs_read_data_page-f2fs_read_data_pages-函数"><a href="#f2fs_read_data_page-f2fs_read_data_pages-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_read_data_page-f2fs_read_data_pages-函数"></a> f2fs_read_data_page &amp; f2fs_read_data_pages 函数</h2><p>当预读机制会调用 <code>mapping-&gt;a_ops-&gt;readpages</code> 函数一次性读取多个 page。而当预读失败时，也会调用 <code>mapping-&gt;a_ops-&gt;readpage</code> 读取单个 page。这两个函数在 f2fs 中对应的就是 <code>f2fs_read_page</code> 和 <code>f2fs_read_pages</code>，如下所示:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_read_data_page</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">	<span class="type">int</span> ret = -EAGAIN;</span><br><span class="line"></span><br><span class="line">	trace_f2fs_readpage(page, DATA);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (f2fs_has_inline_data(inode)) <span class="comment">// inline文件使用特定的读取方法，这里暂不分析</span></span><br><span class="line">		ret = f2fs_read_inline_data(inode, page);</span><br><span class="line">	ret = f2fs_mpage_readpages(page-&gt;mapping, <span class="literal">NULL</span>, page, <span class="number">1</span>); <span class="comment">// 读取1个page</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_read_data_pages</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> list_head *pages, <span class="type">unsigned</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> list_last_entry(pages, <span class="keyword">struct</span> page, lru);</span><br><span class="line"></span><br><span class="line">	trace_f2fs_readpages(inode, page, nr_pages);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (f2fs_has_inline_data(inode)) <span class="comment">// inline文件是size小于1个page的文件，因此不需要进行预读，直接return 0</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f2fs_mpage_readpages(mapping, pages, <span class="literal">NULL</span>, nr_pages); <span class="comment">// 读取nr_pages个page</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="f2fs_mpage_readpages函数"><a href="#f2fs_mpage_readpages函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_mpage_readpages函数"></a> f2fs_mpage_readpages函数</h2><p>无论是 <code>f2fs_read_page</code> 函数还是 <code>f2fs_read_pages</code> 函数，都是调用 <code>f2fs_mpage_readpages</code> 函数进行读取，区别仅在于传入参数。<code>f2fs_mpage_readpages</code> 的定义为:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_mpage_readpages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> list_head *pages, <span class="keyword">struct</span> page *page, <span class="type">unsigned</span> nr_pages)</span>;</span><br></pre></td></tr></table></div></figure><ol><li>第二个参数表示一个链表头，这个链表保存了多个 page，因此需要写入多个 page 的时候，就要传入一个 List。</li><li>第三个参数表示单个 page，在写入单个 page 的时候，通过这个函数写入。</li><li>第四个参数表示需要写入 page 的数目。</li></ol><p>因此：</p><ol><li>在写入多个 page 的时候，需要设定第二个参数，和第四个参数，然后设定第三个参数为 NULL。</li><li>在写入单个 page 的时候，需要设定第三个参数，和第四个参数，然后设定第二个参数为 NULL。</li></ol><p>然后分析这个函数的执行流程:</p><ol><li>遍历传入的 page，得到每一个 page 的 index 以及 inode。</li><li>将 page 的 inode 以及 index 传入 f2fs_map_blocks() 函数获取到该 page 的物理地址。</li><li>将物理地址通过 submit_bio() 读取该 page 在磁盘中的数据。</li></ol><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_mpage_readpages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> list_head *pages, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> nr_pages)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 主流程第一步 初始化map结构，这个步骤非常重要，用于获取page在磁盘的物理地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_map_blocks</span> <span class="title">map</span>;</span></span><br><span class="line">	<span class="built_in">map</span>.m_pblk = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">map</span>.m_lblk = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">map</span>.m_len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">map</span>.m_flags = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">map</span>.m_next_pgofs = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 主流程第二步 开始进行遍历，结束条件为 nr_pages 不为空</span></span><br><span class="line">	<span class="keyword">for</span> (page_idx = <span class="number">0</span>; nr_pages; page_idx++, nr_pages--) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 循环第一步，如果是读取多个page，则pages不为空，从list里面读取每一次的page结构</span></span><br><span class="line">		<span class="keyword">if</span> (pages) &#123;</span><br><span class="line">			page = list_entry(pages-&gt;prev, <span class="keyword">struct</span> page, lru);</span><br><span class="line">			list_del(&amp;page-&gt;lru);</span><br><span class="line">			<span class="keyword">if</span> (add_to_page_cache_lru(page, mapping,</span><br><span class="line">						  page-&gt;index, GFP_KERNEL))</span><br><span class="line">				<span class="keyword">goto</span> next_page;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment"> 		 * map.m_lblk是上一个block_in_file</span></span><br><span class="line"><span class="comment"> 		 * map.m_lblk + map.m_len是需要读取长度的最后一个blokaddr</span></span><br><span class="line"><span class="comment"> 		 * 因此这里的意思是，如果是在这个 map.m_lblk &lt; block_in_file &lt; map.m_lblk + map.m_len </span></span><br><span class="line"><span class="comment"> 		 * 这个范围里面，不需要map，直接将上次的blkaddr+1就是需要的地址</span></span><br><span class="line"><span class="comment"> 		 * </span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">// 循环第二步，如果上一次找到了page，则跳到 got_it 通过bio获取page的具体数据</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">map</span>.m_flags &amp; F2FS_MAP_MAPPED) &amp;&amp; block_in_file &gt; <span class="built_in">map</span>.m_lblk &amp;&amp;</span><br><span class="line">			block_in_file &lt; (<span class="built_in">map</span>.m_lblk + <span class="built_in">map</span>.m_len))</span><br><span class="line">			<span class="keyword">goto</span> got_it;</span><br><span class="line">	</span><br><span class="line">		<span class="comment">// 循环第三步，使用page offset和length，通过f2fs_map_blocks获得物理地址</span></span><br><span class="line">		<span class="built_in">map</span>.m_flags = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (block_in_file &lt; last_block) &#123;</span><br><span class="line">			<span class="built_in">map</span>.m_lblk = block_in_file; <span class="comment">// 文件的第几个block</span></span><br><span class="line">			<span class="built_in">map</span>.m_len = last_block - block_in_file; <span class="comment">// 读取的block的长度</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (f2fs_map_blocks(inode, &amp;<span class="built_in">map</span>, <span class="number">0</span>,</span><br><span class="line">						F2FS_GET_BLOCK_READ))</span><br><span class="line">				<span class="keyword">goto</span> set_error_page;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">got_it:</span><br><span class="line">		<span class="comment">// 循环第四步，通过map的结果执行不一样的处理方式</span></span><br><span class="line">		<span class="keyword">if</span> ((<span class="built_in">map</span>.m_flags &amp; F2FS_MAP_MAPPED)) &#123; <span class="comment">// 如果找到了地址，则计算block_nr得到磁盘的地址</span></span><br><span class="line">			block_nr = <span class="built_in">map</span>.m_pblk + block_in_file - <span class="built_in">map</span>.m_lblk;</span><br><span class="line">			SetPageMappedToDisk(page);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!PageUptodate(page) &amp;&amp; !cleancache_get_page(page)) &#123;</span><br><span class="line">				SetPageUptodate(page);</span><br><span class="line">				<span class="keyword">goto</span> confused;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">// 获取失败了，则跳过这个page</span></span><br><span class="line">			zero_user_segment(page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">			SetPageUptodate(page);</span><br><span class="line">			unlock_page(page);</span><br><span class="line">			<span class="keyword">goto</span> next_page;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这部分开始用于将物理地址通过submit_bio提交到磁盘读取数据</span></span><br><span class="line"><span class="comment">		 * 由于从磁盘读取数据是一个相对耗时的操作，</span></span><br><span class="line"><span class="comment">		 * 因此显然每读取一个页就访问一次磁盘一次的方式是低效的且影响读性能的，</span></span><br><span class="line"><span class="comment">		 * 所以F2FS会尽量一次性提交多个页到磁盘读取数据，以提高性能。</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 这部分开始就是具体实现:</span></span><br><span class="line"><span class="comment">		 * 1. 创建一个bio(最大一次性提交256个页)</span></span><br><span class="line"><span class="comment">		 * 2. 将需要读取的页添加到这个bio中，</span></span><br><span class="line"><span class="comment">		 *     ------如果bio未满则将page添加到bio中</span></span><br><span class="line"><span class="comment">		 *     ------如果bio满了立即访问磁盘读取</span></span><br><span class="line"><span class="comment">		 *     ------如果循环结束以后，bio还是未满，则通过本函数末尾的操作提交未满的bio。</span></span><br><span class="line"><span class="comment">		 *     </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 循环第五步，判断bio装的page是否到了设定的最大数量，如果到了最大值则先发送到磁盘</span></span><br><span class="line">		<span class="keyword">if</span> (bio &amp;&amp; (last_block_in_bio != block_nr - <span class="number">1</span>)) &#123;</span><br><span class="line">submit_and_realloc:</span><br><span class="line">			submit_bio(READ, bio);</span><br><span class="line">			bio = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 循环第六步，如果bio是空，则创建一个bio，然后指定的f2fs_read_end_io进行读取</span></span><br><span class="line">		<span class="keyword">if</span> (bio == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_ctx</span> *<span class="title">ctx</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (f2fs_encrypted_inode(inode) &amp;&amp;</span><br><span class="line">					S_ISREG(inode-&gt;i_mode)) &#123;</span><br><span class="line"></span><br><span class="line">				ctx = fscrypt_get_ctx(inode, GFP_NOFS);</span><br><span class="line">				<span class="keyword">if</span> (IS_ERR(ctx))</span><br><span class="line">					<span class="keyword">goto</span> set_error_page;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* wait the page to be moved by cleaning */</span></span><br><span class="line">				f2fs_wait_on_encrypted_page_writeback(</span><br><span class="line">						F2FS_I_SB(inode), block_nr);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			bio = bio_alloc(GFP_KERNEL,</span><br><span class="line">				<span class="type">min_t</span>(<span class="type">int</span>, nr_pages, BIO_MAX_PAGES)); <span class="comment">// 创建bio</span></span><br><span class="line">			<span class="keyword">if</span> (!bio) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ctx)</span><br><span class="line">					fscrypt_release_ctx(ctx);</span><br><span class="line">				<span class="keyword">goto</span> set_error_page;</span><br><span class="line">			&#125;</span><br><span class="line">			bio-&gt;bi_bdev = bdev;</span><br><span class="line">			bio-&gt;bi_iter.bi_sector = SECTOR_FROM_BLOCK(block_nr); <span class="comment">// 设定bio的sector地址</span></span><br><span class="line">			bio-&gt;bi_end_io = f2fs_read_end_io;</span><br><span class="line">			bio-&gt;bi_private = ctx;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 循环第七步，将page加入到bio中，等待第五步满了之后发送到磁盘</span></span><br><span class="line">		<span class="keyword">if</span> (bio_add_page(bio, page, blocksize, <span class="number">0</span>) &lt; blocksize)</span><br><span class="line">			<span class="keyword">goto</span> submit_and_realloc;</span><br><span class="line"></span><br><span class="line">set_error_page:</span><br><span class="line">		SetPageError(page);</span><br><span class="line">		zero_user_segment(page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">		unlock_page(page);</span><br><span class="line">		<span class="keyword">goto</span> next_page;</span><br><span class="line">confused: <span class="comment">// 特殊情况进行submit bio</span></span><br><span class="line">		<span class="keyword">if</span> (bio) &#123;</span><br><span class="line">			submit_bio(READ, bio);</span><br><span class="line">			bio = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		unlock_page(page);</span><br><span class="line">next_page:</span><br><span class="line">		<span class="keyword">if</span> (pages)</span><br><span class="line">			put_page(page);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	BUG_ON(pages &amp;&amp; !list_empty(pages));</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果还有bio没有处理，例如读取的页遍历完以后，还没有达到第五步要求的bio的最大保存页数，就会在这里提交bio到磁盘读取</span></span><br><span class="line">	<span class="keyword">if</span> (bio)</span><br><span class="line">		submit_bio(READ, bio);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="写流程"><a href="#写流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#写流程"></a> 写流程</h1><p>F2FS 的写流程主要包含了以下几个子流程:</p><ol><li>调用 vfs_write 函数。</li><li>调用 f2fs_file_write_iter 函数: 初始化 f2fs_node 的信息。</li><li>调用 f2fs_write_begin 函数: 创建 page cache，并填充数据。</li><li>写入到 page cache: 等待系统触发 writeback 回写到磁盘。</li><li>调用 f2fs_write_end 函数: 将 page 设置为最新状态。</li><li>调用 f2fs_write_data_pages 函数: 系统 writeback 或者 fsync 触发的时候执行这个函数写入到磁盘。</li></ol><p>第一步的 vfs_write 函数是 VFS 层面的流程，下面仅针对涉及 F2FS 的写流程，且经过简化的主要流程进行分析。</p><h2 id="f2fs_file_write_iter函数"><a href="#f2fs_file_write_iter函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_file_write_iter函数"></a> f2fs_file_write_iter函数</h2><p>这个函数的主要作用是在数据写入文件之前进行预处理，核心流程就是将该文件对应 <code>f2fs_inode</code> 或者 <code>direct_node</code> 对应写入位置的 <code>i_addr</code> 或者 <code>addr</code>的值进行初始化。例如用户需要在第 4 个 page 的位置写入数据，那么 <code>f2fs_file_write_iter</code> 函数会首先找到该文件对应的 <code>f2fs_inode</code>，然后找到第 4 个 page 对应的数据块地址记录，即 <code>f2fs_inode-&gt;i_addr[3]</code>。如果该位置的值是 <code>NULL_ADDR</code> 则表示当前是<strong>添加写(Append Write)</strong>，因此将值初始化为 <code>NEW_ADDR</code>。如果是该位置的值是一个具体的 block 号，那么表示为<strong>覆盖写(Overwrite)</strong>，不需要做处理。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">f2fs_file_write_iter</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span> =</span> iocb-&gt;ki_filp;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(file);</span><br><span class="line">	<span class="type">ssize_t</span> ret;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	err = f2fs_preallocate_blocks(iocb, from); <span class="comment">// 进行预处理</span></span><br><span class="line">	...</span><br><span class="line">	ret = __generic_file_write_iter(iocb, from); <span class="comment">// 预处理完成后继续执行下一步写流程</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>下面继续分析 f2fs_preallocate_blocks()。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_preallocate_blocks</span><span class="params">(<span class="keyword">struct</span> kiocb *iocb, <span class="keyword">struct</span> iov_iter *from)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> file_inode(iocb-&gt;ki_filp); <span class="comment">// 获取inode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_map_blocks</span> <span class="title">map</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>.m_lblk = F2FS_BLK_ALIGN(iocb-&gt;ki_pos); <span class="comment">// 根据文件指针偏移计算需要从第几个block开始写入</span></span><br><span class="line">	<span class="built_in">map</span>.m_len = F2FS_BYTES_TO_BLK(iocb-&gt;ki_pos + iov_iter_count(from)); <span class="comment">// 计算要写入block的个数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化一些信息</span></span><br><span class="line">	<span class="built_in">map</span>.m_next_pgofs = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">map</span>.m_next_extent = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="built_in">map</span>.m_seg_type = NO_CHECK_TYPE;</span><br><span class="line"></span><br><span class="line">	flag = F2FS_GET_BLOCK_PRE_AIO;</span><br><span class="line"></span><br><span class="line">map_blocks:</span><br><span class="line">	err = f2fs_map_blocks(inode, &amp;<span class="built_in">map</span>, <span class="number">1</span>, flag); <span class="comment">// 进行初始化</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>f2fs_map_blocks() 函数的作用非常广泛，主要作用是通过逻辑地址(文件偏移指针)找到对应的物理地址(block 号)。因此在读写流程中都有作用。在写流程中，该函数的主要作用是初始化地址信息。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_map_blocks</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> f2fs_map_blocks *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> create, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> maxblocks = <span class="built_in">map</span>-&gt;m_len;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(inode);</span><br><span class="line">	<span class="type">int</span> mode = create ? ALLOC_NODE : LOOKUP_NODE;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">map</span>-&gt;m_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pgofs =	(<span class="type">pgoff_t</span>)<span class="built_in">map</span>-&gt;m_lblk; <span class="comment">// 获得文件访问偏移量</span></span><br><span class="line">	end = pgofs + maxblocks; <span class="comment">// 获得需要读取的block的长度</span></span><br><span class="line"></span><br><span class="line">next_dnode:</span><br><span class="line"></span><br><span class="line">	set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 初始化dnode，dnode的作用是根据逻辑地址找到物理地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据inode找到对应的f2fs_inode或者direct_node结构，然后通过pgofs(文件页偏移)获得物理地址，记录在dn中</span></span><br><span class="line">	err = f2fs_get_dnode_of_data(&amp;dn, pgofs, mode); </span><br><span class="line"></span><br><span class="line">	start_pgofs = pgofs;</span><br><span class="line">	prealloc = <span class="number">0</span>;</span><br><span class="line">	last_ofs_in_node = ofs_in_node = dn.ofs_in_node;</span><br><span class="line">	end_offset = ADDRS_PER_PAGE(dn.node_page, inode);</span><br><span class="line"></span><br><span class="line">next_block:</span><br><span class="line">	<span class="comment">// 根据dn获得物理地址，ofs_in_node表示这个物理地址位于当前node的第几个数据块</span></span><br><span class="line">	<span class="comment">// 如 f2fs_inode-&gt;i_addr[3]，那么dn.ofs_in_node=3</span></span><br><span class="line">	blkaddr = datablock_addr(dn.inode, dn.node_page, dn.ofs_in_node); </span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (!is_valid_blkaddr(blkaddr)) &#123; <span class="comment">// is_valid_blkaddr函数用于判断是否存在旧数据</span></span><br><span class="line">		<span class="comment">// 如果不存在旧数据</span></span><br><span class="line">		<span class="keyword">if</span> (create) &#123;</span><br><span class="line">			<span class="keyword">if</span> (flag == F2FS_GET_BLOCK_PRE_AIO) &#123;</span><br><span class="line">				<span class="keyword">if</span> (blkaddr == NULL_ADDR) &#123;</span><br><span class="line">					prealloc++; <span class="comment">// 记录有多少个添加写的block</span></span><br><span class="line">					last_ofs_in_node = dn.ofs_in_node;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">map</span>-&gt;m_flags |= F2FS_MAP_NEW; <span class="comment">// F2FS_MAP_NEW表示正在处理一个从未使用的数据</span></span><br><span class="line">			blkaddr = dn.data_blkaddr; <span class="comment">// 记录当前的物理地址</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 记录处理了多少个block</span></span><br><span class="line">	dn.ofs_in_node++; </span><br><span class="line">	pgofs++;</span><br><span class="line">	...</span><br><span class="line">	<span class="comment">// 这里表示已经处理到最后一个block了</span></span><br><span class="line">	<span class="keyword">if</span> (flag == F2FS_GET_BLOCK_PRE_AIO &amp;&amp;</span><br><span class="line">			(pgofs == end || dn.ofs_in_node == end_offset)) &#123;</span><br><span class="line"></span><br><span class="line">		dn.ofs_in_node = ofs_in_node; <span class="comment">// 回到第一个block</span></span><br><span class="line">		err = f2fs_reserve_new_blocks(&amp;dn, prealloc); <span class="comment">// 通过这个函数将其地址设置为NEW_ADDR</span></span><br><span class="line">		<span class="built_in">map</span>-&gt;m_len += dn.ofs_in_node - ofs_in_node;</span><br><span class="line">		dn.ofs_in_node = end_offset;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">if</span> (pgofs &gt;= end)</span><br><span class="line">		<span class="keyword">goto</span> sync_out; <span class="comment">// 表示已经全部处理完，可以退出这个函数了</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dn.ofs_in_node &lt; end_offset)</span><br><span class="line">		<span class="keyword">goto</span> next_block; <span class="comment">// 每执行上面的流程就处理一个block，如果没有处理所有用户写入的block，那么回去继续处理</span></span><br><span class="line">	...</span><br><span class="line">sync_out:</span><br><span class="line">	...</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>然后分析 f2fs_reserve_new_blocks()。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_reserve_new_blocks</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="type">blkcnt_t</span> count)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(dn-&gt;inode);</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">for</span> (; count &gt; <span class="number">0</span>; dn-&gt;ofs_in_node++) &#123;</span><br><span class="line">		<span class="type">block_t</span> blkaddr = datablock_addr(dn-&gt;inode,</span><br><span class="line">					dn-&gt;node_page, dn-&gt;ofs_in_node);</span><br><span class="line">		<span class="keyword">if</span> (blkaddr == NULL_ADDR) &#123; <span class="comment">// 首先判断是不是NULL_ADDR，如果是则初始化为NEW_ADDR</span></span><br><span class="line">			dn-&gt;data_blkaddr = NEW_ADDR;</span><br><span class="line">			__set_data_blkaddr(dn);</span><br><span class="line">			count--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="f2fs_write_begin-和-f2fs_write_end-函数"><a href="#f2fs_write_begin-和-f2fs_write_end-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_write_begin-和-f2fs_write_end-函数"></a> f2fs_write_begin 和 f2fs_write_end 函数</h2><p>VFS 中 <code>write_begin</code> 和 <code>write_end</code> 函数分别是数据写入 page cache 前以及写入后的处理。写入 page cache 后，系统会维护一段时间，直到满足一定条件后(如 fsync 和 writeback 会写)，VFS 会调用 writepages 函数，将这些缓存在内存中的 page 一次性写入到磁盘中。<code>write_begin</code> 和 <code>write_end</code> 函数的调用可以参考 VFS 的 <code>generic_perform_write</code> 函数。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">generic_perform_write</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> iov_iter *i, <span class="type">loff_t</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span> =</span> file-&gt;f_mapping;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span> =</span> mapping-&gt;a_ops;</span><br><span class="line">	<span class="type">long</span> status = <span class="number">0</span>;</span><br><span class="line">	<span class="type">ssize_t</span> written = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> offset;</span><br><span class="line">		<span class="type">unsigned</span> <span class="type">long</span> bytes;</span><br><span class="line">		<span class="type">size_t</span> copied;</span><br><span class="line">		<span class="type">void</span> *fsdata;</span><br><span class="line"></span><br><span class="line">		offset = (pos &amp; (PAGE_SIZE - <span class="number">1</span>)); <span class="comment">// 计算文件偏移，按page计算</span></span><br><span class="line">		bytes = <span class="type">min_t</span>(<span class="type">unsigned</span> <span class="type">long</span>, PAGE_SIZE - offset, iov_iter_count(i)); <span class="comment">// 计算需要写多少个字节</span></span><br><span class="line">again:</span><br><span class="line">		status = a_ops-&gt;write_begin(file, mapping, pos, bytes, flags, &amp;page, &amp;fsdata); <span class="comment">// 调用write_begin，对page进行初始化</span></span><br><span class="line"></span><br><span class="line">		copied = iov_iter_copy_from_user_atomic(page, i, offset, bytes); <span class="comment">//  将处理后的数据拷贝到page当中</span></span><br><span class="line">		flush_dcache_page(page); <span class="comment">// 将包含用户数据的page加入到page cache中，等待系统触发writeback的时候回写</span></span><br><span class="line"></span><br><span class="line">		status = a_ops-&gt;write_end(file, mapping, pos, bytes, copied, page, fsdata); <span class="comment">// 调用write_end函数进行后续处理</span></span><br><span class="line">		</span><br><span class="line">		copied = status;</span><br><span class="line"></span><br><span class="line">		iov_iter_advance(i, copied);</span><br><span class="line"></span><br><span class="line">		pos += copied;</span><br><span class="line">		written += copied;</span><br><span class="line"></span><br><span class="line">		balance_dirty_pages_ratelimited(mapping);</span><br><span class="line">	&#125; <span class="keyword">while</span> (iov_iter_count(i)); <span class="comment">// 直到处理完所有的数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> written ? written : status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>然后分析 VFS 的 <code>write_begin</code> 和 <code>write_end</code> 对应的功能，<code>write_begin</code> 在 F2FS 中对应的是 <code>f2fs_write_begin</code>，它的作用是将根据用户需要写入的数据类型，对 page 进行初始化，如下所示：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_begin</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">		<span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> page **pagep, <span class="type">void</span> **fsdata)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">pgoff_t</span> index = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) pos) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="type">bool</span> need_balance = <span class="literal">false</span>, drop_atomic = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">block_t</span> blkaddr = NULL_ADDR;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	page = f2fs_pagecache_get_page(mapping, index,</span><br><span class="line">				FGP_LOCK | FGP_WRITE | FGP_CREAT, GFP_NOFS); <span class="comment">// 第一步创建或者获取page cache</span></span><br><span class="line"></span><br><span class="line">	*pagep = page;</span><br><span class="line"></span><br><span class="line">	err = prepare_write_begin(sbi, page, pos, len,</span><br><span class="line">					&amp;blkaddr, &amp;need_balance); <span class="comment">// 第二步根据页偏移信息获取到对应的物理地址blkaddr</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三步，根据写类型对新创建的page进行初始化处理</span></span><br><span class="line">	<span class="keyword">if</span> (blkaddr == NEW_ADDR) &#123; <span class="comment">//如果是添加写，则将该page直接使用0填充</span></span><br><span class="line">		zero_user_segment(page, <span class="number">0</span>, PAGE_SIZE);</span><br><span class="line">		SetPageUptodate(page);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果是覆盖写，则将该page直接使用0填充</span></span><br><span class="line">		err = f2fs_submit_page_read(inode, page, blkaddr); <span class="comment">// 从磁盘中将旧数据读取出来</span></span><br><span class="line"></span><br><span class="line">		lock_page(page);</span><br><span class="line">		<span class="keyword">if</span> (unlikely(page-&gt;mapping != mapping)) &#123;</span><br><span class="line">			f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">goto</span> repeat;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(!PageUptodate(page))) &#123;</span><br><span class="line">			err = -EIO;</span><br><span class="line">			<span class="keyword">goto</span> fail;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>通过 flush_dcache_page() 函数将用户数据写入到 page cache 之后，进行 <code>write_end</code> 处理，在 F2FS 中它对应的是 f2fs_write_end() 函数，它的作用是，如下所述:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_end</span><span class="params">(<span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">			<span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> copied,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> page *page, <span class="type">void</span> *fsdata)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!PageUptodate(page)) &#123; <span class="comment">// 判断是否已经将page cache在写入是否到达了最新的状态</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(copied != len))</span><br><span class="line">			copied = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			SetPageUptodate(page); <span class="comment">// 如果不是就处理后设置为最新</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!copied)</span><br><span class="line">		<span class="keyword">goto</span> unlock_out;</span><br><span class="line"></span><br><span class="line">	set_page_dirty(page); <span class="comment">// 将page设置为dirty，就会加入到inode-&gt;mapping的radix tree中，等待系统回写</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pos + copied &gt; i_size_read(inode))</span><br><span class="line">		f2fs_i_size_write(inode, pos + copied); <span class="comment">// 更新文件尺寸</span></span><br><span class="line">unlock_out:</span><br><span class="line">	f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">	f2fs_update_time(F2FS_I_SB(inode), REQ_TIME); <span class="comment">// 更新文件修改日期</span></span><br><span class="line">	<span class="keyword">return</span> copied;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="f2fs_write_data_pages-函数"><a href="#f2fs_write_data_pages-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_write_data_pages-函数"></a> f2fs_write_data_pages 函数</h2><p>系统会将用户写入的数据先写入到 page cache，然后等待时机回写到磁盘中。page cache 的回写是通过 f2fs_write_data_pages() 函数进行。系统会将 page cache 中 dirty 的 pages 加入到一个 list 当中，然后传入到 f2fs_write_data_pages() 进行处理。它包含如下步骤:</p><ol><li>f2fs_write_data_pages &amp; __f2fs_write_data_pages 函数: 做一些不那么重要的预处理。</li><li>f2fs_write_cache_pages 函数: 从 inode-&gt;mapping 的 radix tree 中取出 page。</li><li>__write_data_page 函数: 判断文件类型(内联文件，目录文件，普通文件)进行不同的写入。</li><li>f2fs_do_write_data_page: 根据 F2FS 的状态选择进行就地回写(在原物理地址更新)还是异地回写(在其他物理地址更新)。</li><li>f2fs_outplace_write_data: 执行回写，更新 f2fs_inode 的状态。</li><li>do_write_page: 从 CURSEG 分配物理地址，然后写入到磁盘。</li></ol><h3 id="f2fs_write_data_pages-__f2fs_write_data_pages-函数"><a href="#f2fs_write_data_pages-__f2fs_write_data_pages-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_write_data_pages-__f2fs_write_data_pages-函数"></a> f2fs_write_data_pages &amp; __f2fs_write_data_pages 函数</h3><p>这两个函数只是包含了一些不太重要的预处理。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_data_pages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">			    <span class="keyword">struct</span> writeback_control *wbc)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> __f2fs_write_data_pages(mapping, wbc,</span><br><span class="line">			F2FS_I(inode)-&gt;cp_task == current ?</span><br><span class="line">			FS_CP_DATA_IO : FS_DATA_IO); <span class="comment">// 这个函数可以知道当前是普通的写入，还是Checkpoint数据的写入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __f2fs_write_data_pages(<span class="keyword">struct</span> address_space *mapping,</span><br><span class="line">						<span class="keyword">struct</span> writeback_control *wbc,</span><br><span class="line">						<span class="keyword">enum</span> iostat_type io_type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">blk_plug</span> <span class="title">plug</span>;</span></span><br><span class="line">	<span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	blk_start_plug(&amp;plug);</span><br><span class="line"></span><br><span class="line">	ret = f2fs_write_cache_pages(mapping, wbc, io_type); <span class="comment">// 取出需要回写的page，然后写入</span></span><br><span class="line"></span><br><span class="line">	blk_finish_plug(&amp;plug);</span><br><span class="line"></span><br><span class="line">	f2fs_remove_dirty_inode(inode); <span class="comment">// 写入后将inode从dirty标志清除，即不需要再回写</span></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">skip_write:</span><br><span class="line">	wbc-&gt;pages_skipped += get_dirty_pages(inode);</span><br><span class="line">	trace_f2fs_writepages(mapping-&gt;host, wbc, DATA);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="f2fs_write_cache_pages-函数"><a href="#f2fs_write_cache_pages-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_write_cache_pages-函数"></a> f2fs_write_cache_pages 函数</h3><p>这个函数的主要作用是从 inode 对应的 mapping(radix tree 的 root)中，取出所有需要回写的 page，然后通过一个循环，逐个写入到磁盘。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_write_cache_pages</span><span class="params">(<span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> writeback_control *wbc,</span></span><br><span class="line"><span class="params">					<span class="keyword">enum</span> iostat_type io_type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pagevec</span> <span class="title">pvec</span>;</span></span><br><span class="line">	</span><br><span class="line">	pagevec_init(&amp;pvec); <span class="comment">// 这是一个用于装载page的数组，数组大小是15个page</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wbc-&gt;sync_mode == WB_SYNC_ALL || wbc-&gt;tagged_writepages)</span><br><span class="line">		tag = PAGECACHE_TAG_TOWRITE; <span class="comment">// tag是mapping给每一个pae的标志，用于标志这些page的属性</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		tag = PAGECACHE_TAG_DIRTY;</span><br><span class="line">		</span><br><span class="line">retry:</span><br><span class="line">	<span class="keyword">if</span> (wbc-&gt;sync_mode == WB_SYNC_ALL || wbc-&gt;tagged_writepages)</span><br><span class="line">		tag_pages_for_writeback(mapping, index, end); <span class="comment">// SYNC模式下，将所有的tag=PAGECACHE_TAG_DIRTY的page重新标志为PAGECACHE_TAG_TOWRITE，作用是SYNC模式下必须全部回写到磁盘</span></span><br><span class="line">	done_index = index;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (!done &amp;&amp; (index &lt;= end)) &#123;</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 从mapping中取出tag类型的15个page，装载到pvec中</span></span><br><span class="line">		nr_pages = pagevec_lookup_range_tag(&amp;pvec, mapping, &amp;index, end, tag); </span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 循环将pvec中的page取出，回写到磁盘</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nr_pages; i++) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> pvec.pages[i];</span><br><span class="line">			<span class="type">bool</span> submitted = <span class="literal">false</span>;</span><br><span class="line">			</span><br><span class="line">			ret = __write_data_page(page, &amp;submitted, wbc, io_type); <span class="comment">// 写入磁盘的核心函数</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (--wbc-&gt;nr_to_write &lt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">					wbc-&gt;sync_mode == WB_SYNC_NONE) &#123;</span><br><span class="line">				done = <span class="number">1</span>; <span class="comment">// 如果本次writeback的所有page写完就退出</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		pagevec_release(&amp;pvec); <span class="comment">// 释放掉pvec</span></span><br><span class="line">		cond_resched();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (wbc-&gt;range_cyclic || (range_whole &amp;&amp; wbc-&gt;nr_to_write &gt; <span class="number">0</span>))</span><br><span class="line">		mapping-&gt;writeback_index = done_index;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (last_idx != ULONG_MAX)</span><br><span class="line">		<span class="comment">// page通过一些函数后，会放入到bio中，然后提交到磁盘。</span></span><br><span class="line">		<span class="comment">// f2fs的机制是不会马上提交bio，需要等到bio包含了一定数目的page之后才会提交</span></span><br><span class="line">		<span class="comment">// 因此这个函数作用是，即使数目不够，但是仍要强制提交bio，需要与磁盘同步</span></span><br><span class="line">		f2fs_submit_merged_write_cond(F2FS_M_SB(mapping), mapping-&gt;host,</span><br><span class="line">						<span class="number">0</span>, last_idx, DATA);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="__write_data_page-函数"><a href="#__write_data_page-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#__write_data_page-函数"></a> __write_data_page 函数</h3><p>这个函数的作用是判断文件类型(目录文件，内联文件，普通文件)进行不同的写入。F2FS 针对普通文件，有两种保存方式，分别是内联方式(inline)和普通方式。这里主要介绍普通文件的写流程。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __write_data_page(<span class="keyword">struct</span> page *page, <span class="type">bool</span> *submitted,</span><br><span class="line">				<span class="keyword">struct</span> writeback_control *wbc,</span><br><span class="line">				<span class="keyword">enum</span> iostat_type io_type)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(inode);</span><br><span class="line">	<span class="type">loff_t</span> i_size = i_size_read(inode);</span><br><span class="line">	<span class="type">const</span> <span class="type">pgoff_t</span> end_index = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) i_size) &gt;&gt; PAGE_SHIFT;</span><br><span class="line">	<span class="comment">// 这个数据结构在整个写流程非常重要，记录了写入的信息</span></span><br><span class="line">	<span class="comment">// 关键变量是 fio-&gt;old_blkaddr 以及 fio-&gt;new_blkaddr记录旧地址和新地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_io_info</span> <span class="title">fio</span> =</span> &#123; </span><br><span class="line">		.sbi = sbi,</span><br><span class="line">		.ino = inode-&gt;i_ino,</span><br><span class="line">		.type = DATA,</span><br><span class="line">		.op = REQ_OP_WRITE,</span><br><span class="line">		.op_flags = wbc_to_write_flags(wbc),</span><br><span class="line">		.old_blkaddr = NULL_ADDR,</span><br><span class="line">		.page = page, <span class="comment">// 即将写入的page</span></span><br><span class="line">		.encrypted_page = <span class="literal">NULL</span>,</span><br><span class="line">		.submitted = <span class="literal">false</span>,</span><br><span class="line">		.need_lock = LOCK_RETRY,</span><br><span class="line">		.io_type = io_type,</span><br><span class="line">		.io_wbc = wbc,</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (page-&gt;index &lt; end_index)</span><br><span class="line">		<span class="keyword">goto</span> write;</span><br><span class="line">		</span><br><span class="line">write:</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode)) &#123; <span class="comment">// 如果是目录文件，直接写入不需要修改</span></span><br><span class="line">		err = f2fs_do_write_data_page(&amp;fio);</span><br><span class="line">		<span class="keyword">goto</span> done;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = -EAGAIN;</span><br><span class="line">	<span class="keyword">if</span> (f2fs_has_inline_data(inode)) &#123; <span class="comment">// 内联文件使用内联的写入方式</span></span><br><span class="line">		err = f2fs_write_inline_data(inode, page);</span><br><span class="line">		<span class="keyword">if</span> (!err)</span><br><span class="line">			<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (err == -EAGAIN) &#123; <span class="comment">// 普通文件则使用普通的方式</span></span><br><span class="line">		err = f2fs_do_write_data_page(&amp;fio);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">done:</span><br><span class="line">	<span class="keyword">if</span> (err &amp;&amp; err != -ENOENT)</span><br><span class="line">		<span class="keyword">goto</span> redirty_out;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	inode_dec_dirty_pages(inode); <span class="comment">// 每写入一个page，就清除了inode一个dirty pages，因此数目减去1</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		ClearPageUptodate(page);</span><br><span class="line"></span><br><span class="line">	unlock_page(page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (submitted)</span><br><span class="line">		*submitted = fio.submitted;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">redirty_out:</span><br><span class="line">	redirty_page_for_writepage(wbc, page);</span><br><span class="line">	<span class="keyword">if</span> (!err || wbc-&gt;for_reclaim)</span><br><span class="line">		<span class="keyword">return</span> AOP_WRITEPAGE_ACTIVATE;</span><br><span class="line">	unlock_page(page);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="f2fs_do_write_data_page-函数"><a href="#f2fs_do_write_data_page-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_do_write_data_page-函数"></a> f2fs_do_write_data_page 函数</h3><p>这个函数的作用是根据系统的状态选择就地更新数据(inplace update)还是异地更新数据(outplace update)。一般情况下，系统只会在磁盘空间比较满的时候选择就地更新策略，避免触发过多的 gc 影响性能。因此，这里主要介绍异地更新的写流程:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_do_write_data_page</span><span class="params">(<span class="keyword">struct</span> f2fs_io_info *fio)</span> <span class="comment">// 前面提到fio是写流程最重要的数据结构</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> fio-&gt;page;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> page-&gt;mapping-&gt;host;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> <span class="title">dn</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">extent_info</span> <span class="title">ei</span> =</span> &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">bool</span> ipu_force = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 初始化dnode</span></span><br><span class="line">	err = f2fs_get_dnode_of_data(&amp;dn, page-&gt;index, LOOKUP_NODE); <span class="comment">// 根据文件偏移page-&gt;index获取物理地址</span></span><br><span class="line"></span><br><span class="line">	fio-&gt;old_blkaddr = dn.data_blkaddr; <span class="comment">// 将旧的物理地址赋值给fio-&gt;old_blkaddr</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fio-&gt;old_blkaddr == NULL_ADDR) &#123; <span class="comment">// 前面提及到f2fs_file_write_iter已经将物理地址设置为NEW_ADDR或者具体的block号，因此这里表示在写入磁盘之前，用户又将这部分数据删除了，所以没必要写入了</span></span><br><span class="line">		ClearPageUptodate(page);</span><br><span class="line">		<span class="keyword">goto</span> out_writepage;</span><br><span class="line">	&#125;</span><br><span class="line">got_it:</span><br><span class="line">	<span class="keyword">if</span> (ipu_force || (is_valid_blkaddr(fio-&gt;old_blkaddr) &amp;&amp;</span><br><span class="line">					need_inplace_update(fio))) &#123; <span class="comment">// 判断是否需要就地更新</span></span><br><span class="line">		err = encrypt_one_page(fio);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> out_writepage;</span><br><span class="line"></span><br><span class="line">		set_page_writeback(page);</span><br><span class="line">		ClearPageError(page);</span><br><span class="line">		f2fs_put_dnode(&amp;dn);</span><br><span class="line">		<span class="keyword">if</span> (fio-&gt;need_lock == LOCK_REQ)</span><br><span class="line">			f2fs_unlock_op(fio-&gt;sbi);</span><br><span class="line">		err = f2fs_inplace_write_data(fio); <span class="comment">// 使用就地更新的方式写入</span></span><br><span class="line">		trace_f2fs_do_write_data_page(fio-&gt;page, IPU);</span><br><span class="line">		set_inode_flag(inode, FI_UPDATE_WRITE);</span><br><span class="line">		<span class="keyword">return</span> err;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err = encrypt_one_page(fio); <span class="comment">// 如果开启系统加密，会将这个fio-&gt;page先加密</span></span><br><span class="line"></span><br><span class="line">	set_page_writeback(page);</span><br><span class="line">	ClearPageError(page);</span><br><span class="line"></span><br><span class="line">	f2fs_outplace_write_data(&amp;dn, fio); <span class="comment">// 执行异地更新函数</span></span><br><span class="line"></span><br><span class="line">	set_inode_flag(inode, FI_APPEND_WRITE);</span><br><span class="line">	<span class="keyword">if</span> (page-&gt;index == <span class="number">0</span>)</span><br><span class="line">		set_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);</span><br><span class="line">out_writepage:</span><br><span class="line">	f2fs_put_dnode(&amp;dn);</span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (fio-&gt;need_lock == LOCK_REQ)</span><br><span class="line">		f2fs_unlock_op(fio-&gt;sbi);</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="f2fs_outplace_write_data-函数"><a href="#f2fs_outplace_write_data-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_outplace_write_data-函数"></a> f2fs_outplace_write_data 函数</h3><p>这个函数主要用作异地更新，所谓异地更新即不在原先的物理地址更新数据，因此包含了如下四个步骤:</p><ol><li>分配一个新的物理地址。</li><li>将数据写入新的物理地址。</li><li>将旧的物理地址无效掉，然后等 GC 回收。</li><li>更新逻辑地址和物理地址的映射关系。</li></ol><p>本函数即完成以上四个步骤:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f2fs_outplace_write_data</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn,</span></span><br><span class="line"><span class="params">					<span class="keyword">struct</span> f2fs_io_info *fio)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> fio-&gt;sbi;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> <span class="title">sum</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node_info</span> <span class="title">ni</span>;</span></span><br><span class="line"></span><br><span class="line">	f2fs_get_node_info(sbi, dn-&gt;nid, &amp;ni);</span><br><span class="line">	set_summary(&amp;sum, dn-&gt;nid, dn-&gt;ofs_in_node, ni.version);</span><br><span class="line">	</span><br><span class="line">	do_write_page(&amp;sum, fio); <span class="comment">// 这里完成第1,2,3步骤</span></span><br><span class="line">	f2fs_update_data_blkaddr(dn, fio-&gt;new_blkaddr); <span class="comment">// 这里完成第四个步骤，重新建立映射</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>struct dnode_of_data dn</code> 的作用是根据文件 inode，找到 <code>f2fs_inode</code> 或者 <code>direct_node</code>，然后再通过文件偏移得到物理地址，因此 f2fs_update_data_blkaddr() 也是通过 <code>dnode_of_data</code> 将新的物理地址更新到 <code>f2fs_inode</code> 或者 <code>direct_node</code> 对应的位置中。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f2fs_update_data_blkaddr</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="type">block_t</span> blkaddr)</span></span><br><span class="line">&#123;</span><br><span class="line">	dn-&gt;data_blkaddr = blkaddr; <span class="comment">// 获得新的物理地址</span></span><br><span class="line">	f2fs_set_data_blkaddr(dn); <span class="comment">// 更新地址到f2fs_inode或者direct_node</span></span><br><span class="line">	f2fs_update_extent_cache(dn); <span class="comment">// 更新cache</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">f2fs_set_data_blkaddr</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn)</span></span><br><span class="line">&#123;</span><br><span class="line">	f2fs_wait_on_page_writeback(dn-&gt;node_page, NODE, <span class="literal">true</span>); <span class="comment">// 因为要更新node，所以要保证当前的node是最新状态</span></span><br><span class="line">	__set_data_blkaddr(dn);</span><br><span class="line">	<span class="keyword">if</span> (set_page_dirty(dn-&gt;node_page)) <span class="comment">// 设置dirty，因为更新后的地址要回写到磁盘记录</span></span><br><span class="line">		dn-&gt;node_changed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __set_data_blkaddr(<span class="keyword">struct</span> dnode_of_data *dn)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_node</span> *<span class="title">rn</span> =</span> F2FS_NODE(dn-&gt;node_page); <span class="comment">// 根据node page转换到对应的f2fs_node</span></span><br><span class="line">	__le32 *addr_array;</span><br><span class="line">	<span class="type">int</span> base = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	addr_array = blkaddr_in_node(rn); <span class="comment">// 这个用于获得f2fs_inode-&gt;i_addr地址或者direct_node-&gt;addr地址</span></span><br><span class="line">	addr_array[base + dn-&gt;ofs_in_node] = cpu_to_le32(dn-&gt;data_blkaddr); <span class="comment">// 根据偏移赋值更新</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> __le32 *<span class="title function_">blkaddr_in_node</span><span class="params">(<span class="keyword">struct</span> f2fs_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// RAW_IS_INODE判断当前node是属于f2fs_inode还是f2fs_node，然后返回物理地址数组指针</span></span><br><span class="line">	<span class="keyword">return</span> RAW_IS_INODE(node) ? node-&gt;i.i_addr : node-&gt;dn.addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="do_write_page-函数"><a href="#do_write_page-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#do_write_page-函数"></a> do_write_page 函数</h3><p>上一节提及到异地更新的 1,2,3 步骤都是在这里完成，分别是 f2fs_allocate_data_block() 函数完成新物理地址的分配，以及旧物理地址的回收; f2fs_submit_page_write() 函数完成最后一步，将数据提交到磁盘。下面进行分析:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">do_write_page</span><span class="params">(<span class="keyword">struct</span> f2fs_summary *sum, <span class="keyword">struct</span> f2fs_io_info *fio)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> type = __get_segment_type(fio); <span class="comment">// 获取数据类型，这个类型指HOT/WARM/COLD X NODE/DATA的六种类型</span></span><br><span class="line"></span><br><span class="line">	f2fs_allocate_data_block(fio-&gt;sbi, fio-&gt;page, fio-&gt;old_blkaddr,</span><br><span class="line">			&amp;fio-&gt;new_blkaddr, sum, type, fio, <span class="literal">true</span>); <span class="comment">// 完成异地更新的1,2步</span></span><br><span class="line"></span><br><span class="line">	f2fs_submit_page_write(fio); <span class="comment">//完成异地更新的第3步</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>f2fs_allocate_data_block() 函数首先会根据 type 获得 CURSEG。然后在 CURSEG 分配一个新的物理块，然后将旧的物理块无效掉。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f2fs_allocate_data_block</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">		<span class="type">block_t</span> old_blkaddr, <span class="type">block_t</span> *new_blkaddr,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> f2fs_summary *sum, <span class="type">int</span> type,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> f2fs_io_info *fio, <span class="type">bool</span> add_list)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sit_info</span> *<span class="title">sit_i</span> =</span> SIT_I(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span> =</span> CURSEG_I(sbi, type);</span><br><span class="line"></span><br><span class="line">	*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg); <span class="comment">// 获取新的物理地址</span></span><br><span class="line"></span><br><span class="line">	__add_sum_entry(sbi, type, sum); <span class="comment">// 将当前summary更新到CURSEG中</span></span><br><span class="line"></span><br><span class="line">	__refresh_next_blkoff(sbi, curseg); <span class="comment">// 更新下一次可以用的物理地址</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 下面更新主要是更新SIT区域的segment信息</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据new_blkaddr找到对应的sit_entry，然后更新状态为valid(值为1)，表示被用户使用，不可被其他人所使用</span></span><br><span class="line">	update_sit_entry(sbi, *new_blkaddr, <span class="number">1</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 根据old_blkaddr找到对应的sit_entry，然后更新状态为invalid(值为-1)，表示被覆盖了，等待GC回收后重新投入使用</span></span><br><span class="line">	<span class="keyword">if</span> (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)</span><br><span class="line">		update_sit_entry(sbi, old_blkaddr, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果当前segment没有空间进行下一次分配了，就分配一个新的segment给CURSEG</span></span><br><span class="line">	<span class="keyword">if</span> (!__has_curseg_space(sbi, type))</span><br><span class="line">		sit_i-&gt;s_ops-&gt;allocate_segment(sbi, type, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将segment设置为脏，等CP写回磁盘</span></span><br><span class="line">	locate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));</span><br><span class="line">	locate_dirty_segment(sbi, GET_SEGNO(sbi, *new_blkaddr));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>f2fs_submit_page_write() 完成最后的提交到磁盘的任务，先创建一个 bio，然后将 page 加入到 bio 中，如果 bio 满了就提交到磁盘。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f2fs_submit_page_write</span><span class="params">(<span class="keyword">struct</span> f2fs_io_info *fio)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> fio-&gt;sbi;</span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">page_type</span> <span class="title">btype</span> =</span> PAGE_TYPE_OF_BIO(fio-&gt;type);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_bio_info</span> *<span class="title">io</span> =</span> sbi-&gt;write_io[btype] + fio-&gt;temp; <span class="comment">// 这个是F2FS用于临时存放bio的变量</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">bio_page</span>;</span></span><br><span class="line"></span><br><span class="line">	down_write(&amp;io-&gt;io_rwsem);</span><br><span class="line">next:</span><br><span class="line">	<span class="comment">// 第一步根据是否有加密，将bio_page设置为对应的page</span></span><br><span class="line">	<span class="keyword">if</span> (fio-&gt;encrypted_page)</span><br><span class="line">		bio_page = fio-&gt;encrypted_page;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		bio_page = fio-&gt;page;</span><br><span class="line"></span><br><span class="line">	fio-&gt;submitted = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">alloc_new:</span><br><span class="line">	<span class="comment">// 如果bio是null，就创建一个新的bio</span></span><br><span class="line">	<span class="keyword">if</span> (io-&gt;bio == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		io-&gt;bio = __bio_alloc(sbi, fio-&gt;new_blkaddr, fio-&gt;io_wbc,</span><br><span class="line">						BIO_MAX_PAGES, <span class="literal">false</span>,</span><br><span class="line">						fio-&gt;type, fio-&gt;temp); <span class="comment">// BIO_MAX_PAGES一般等于256</span></span><br><span class="line">		io-&gt;fio = *fio;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将page加入到bio中，如果  &lt; PAGE_SIZE 表示bio已经满了，因此就先将这个bio提交，然后重新分配一个新的bio</span></span><br><span class="line">	<span class="keyword">if</span> (bio_add_page(io-&gt;bio, bio_page, PAGE_SIZE, <span class="number">0</span>) &lt; PAGE_SIZE) &#123;</span><br><span class="line">		__submit_merged_bio(io); <span class="comment">// 提交bio，最终会执行submit_bio函数</span></span><br><span class="line">		<span class="keyword">goto</span> alloc_new;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	up_write(&amp;io-&gt;io_rwsem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>需要注意的是，在这个函数，当 bio 还没有填满 page 的时候是不会被提交到磁盘的，这是因为 F2FS 通过增大 bio 的 size 提高了写性能。因此，在用户 fsync 或者系统 writeback 的时候，为了保证这些 page 都可以刷写到磁盘，会如 f2fs_write_cache_pages() 函数所介绍一样，通过 f2fs_submit_merged_write_cond() 函数或者其他函数强行提交这个 page 未满的 bio。</p><h1 id="文件创建流程"><a href="#文件创建流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#文件创建流程"></a> 文件创建流程</h1><p>linux 的文件的创建可以抽象为两个流程。</p><ol><li>创建一个 inode，使得包含文件的元数据信息;</li><li>将这个新创建的 inode 加入父目录的管理当中，可以理解建立父目录与这个新 inode 的关系。</li></ol><p>到具体代码，上述两个抽象流程在 F2FS 中主要包含了以下几个子流程：</p><ol><li>调用 vfs_open 函数。</li><li>调用 f2fs_create 函数: 创建文件 inode，并链接到父目录。<ul><li>f2fs_new_inode 函数创建 inode。</li><li>f2fs_add_link 函数链接到父目录。</li></ul></li></ol><p>第一步的 vfs_open 函数是 VFS 层面的流程，下面仅针对涉及 F2FS 的文件创建流程，且经过简化的主要流程进行分析。</p><h2 id="inode-和-f2fs_inode_info"><a href="#inode-和-f2fs_inode_info" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#inode-和-f2fs_inode_info"></a> inode 和 f2fs_inode_info</h2><p><code>inode</code> 结构是 linux 的 vfs 层最核心的结构之一，反应了文件的应该具有的基础信息，但是对于一些文件系统，原生的 <code>inode</code> 结构的信息并不够，还需要增加一些额外的变量去支持文件系统的某些功能，同时为了保证 vfs 层对所有文件系统的兼容性，我们直接修改 <code>inode</code> 结构不是一个明智的方法。针对这种场景，f2fs 使用了一种叫 <code>f2fs_inode_info</code> 的结构去扩展原有的 <code>inode</code> 的功能。</p><h3 id="相互转换"><a href="#相互转换" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#相互转换"></a> 相互转换</h3><p>从 <code>inode</code> 到 <code>f2fs_inode_info</code>:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> f2fs_inode_info *<span class="title function_">F2FS_I</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> container_of(inode, <span class="keyword">struct</span> f2fs_inode_info, vfs_inode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>从 <code>f2fs_inode_info</code> 到 <code>inode</code>:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vfs的inode其实是f2fs_inode_info结构体的一个内部变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> <span class="title">vfs_inode</span>;</span>		<span class="comment">/* serve a vfs inode */</span></span><br><span class="line">	...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此访问可以直接指向</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode_info</span> *<span class="title">fi</span> =</span> F2FS_I(inode);</span><br><span class="line">fi-&gt;vfs_inode <span class="comment">// 这里 fi-&gt;vfs_inode == inode</span></span><br></pre></td></tr></table></div></figure><p>从上面代码我们可以看出，f2fs 中的 <code>inode</code> 是 <code>f2fs_inode_info</code> 当中的一个内部变量，因此可以用 container_of 这个函数直接获得，也可以通过指针获得。</p><h3 id="vfs-inode-的创建和销毁"><a href="#vfs-inode-的创建和销毁" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#vfs-inode-的创建和销毁"></a> VFS inode 的创建和销毁</h3><p>我们一般使用 VFS 提供的 <code>new_inode</code> 函数创建一个新 inode。这个 <code>new_inode</code> 函数内部会调用 new_inode_pseudo 函数，然后再调用 alloc_inode 函数，最后调用 <code>f2fs_alloc_inode</code> 函数，我们从这里开始分析:</p><p>如下代码，显然就是通过内存分配函数先创建一个 <code>f2fs_inode_info</code> 然后返回给上层：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">f2fs_alloc_inode</span><span class="params">(<span class="keyword">struct</span> super_block *sb)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode_info</span> *<span class="title">fi</span>;</span></span><br><span class="line"></span><br><span class="line">	fi = kmem_cache_alloc(f2fs_inode_cachep, GFP_F2FS_ZERO); <span class="comment">//简单直接创建f2fs_inode_info</span></span><br><span class="line">	<span class="keyword">if</span> (!fi)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	init_once((<span class="type">void</span> *) fi); <span class="comment">// 这个函数初始化vfs inode部分的原始信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面开始初始化f2fs_inode_info部分的原始信息</span></span><br><span class="line">	<span class="type">atomic_set</span>(&amp;fi-&gt;dirty_pages, <span class="number">0</span>);</span><br><span class="line">	init_rwsem(&amp;fi-&gt;i_sem);</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> &amp;fi-&gt;vfs_inode; <span class="comment">// 返回的vfs_inode给上层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>当 vfs inode 的 link 是 0 的时候，它应当被销毁。由于 vfs inode 是 f2fs_inode_info 的内部变量：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用户传入一个inode销毁</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f2fs_destroy_inode</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">	call_rcu(&amp;inode-&gt;i_rcu, f2fs_i_callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>同样简单直接，free 掉这块内存就行。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">f2fs_i_callback</span><span class="params">(<span class="keyword">struct</span> rcu_head *head)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> container_of(head, <span class="keyword">struct</span> inode, i_rcu);</span><br><span class="line">	kmem_cache_free(f2fs_inode_cachep, F2FS_I(inode));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="f2fs_create-函数"><a href="#f2fs_create-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_create-函数"></a> f2fs_create 函数</h2><p>这个函数的主要作用是创建 vfs_inode，并链接到对应的目录下，核心流程就是先创建该文件的基于 f2fs 的 inode 结构，以及对应的 f2fs 的 inode page，即 <code>f2fs_inode</code>。然后设置函数指针，最后将 f2fs 的 inode page 链接到对应的目录下。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_create</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> dentry *dentry, <span class="type">umode_t</span> mode,</span></span><br><span class="line"><span class="params">						<span class="type">bool</span> excl)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(dir);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">nid_t</span> ino = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	inode = f2fs_new_inode(dir, mode); <span class="comment">// 创建f2fs特定的inode结构</span></span><br><span class="line"></span><br><span class="line">	inode-&gt;i_op = &amp;f2fs_file_inode_operations; <span class="comment">// 然后赋值对应的函数指针</span></span><br><span class="line">	inode-&gt;i_fop = &amp;f2fs_file_operations;</span><br><span class="line">	inode-&gt;i_mapping-&gt;a_ops = &amp;f2fs_dblock_aops;</span><br><span class="line">	ino = inode-&gt;i_ino; <span class="comment">// 记录该inode的ino</span></span><br><span class="line"></span><br><span class="line">	err = f2fs_add_link(dentry, inode); <span class="comment">// 将该inode链接到用户传入的父目录dir中</span></span><br><span class="line">	<span class="keyword">if</span> (err)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">	f2fs_alloc_nid_done(sbi, ino); <span class="comment">// 在f2fs_new_inode函数内分配了ino，在这里完成最后一步</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><h3 id="f2fs_new_inode-函数"><a href="#f2fs_new_inode-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_new_inode-函数"></a> f2fs_new_inode 函数</h3><p>下面继续分析 <code>f2fs_new_inode</code> 函数(只显示主干部分)，这个函数创建 inode 结构，<strong>还没</strong>创建对应的 f2fs inode page。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">f2fs_new_inode</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(dir);</span><br><span class="line">	<span class="type">nid_t</span> ino;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">	<span class="type">bool</span> nid_free = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> xattr_size = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">	inode = new_inode(dir-&gt;i_sb); <span class="comment">// 先创建出来一个没有ino的inode结构，参考前面提及的创建流程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!f2fs_alloc_nid(sbi, &amp;ino)) &#123; <span class="comment">// 然后给这个inode分配一个nid，即ino</span></span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	nid_free = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	inode_init_owner(inode, dir, mode); <span class="comment">// 初始化从属信息: 访问模式、父目录等</span></span><br><span class="line"></span><br><span class="line">	inode-&gt;i_ino = ino; <span class="comment">// 初始化一些元数据信息，例如ino</span></span><br><span class="line">	inode-&gt;i_blocks = <span class="number">0</span>;</span><br><span class="line">	inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = current_time(inode);</span><br><span class="line">	F2FS_I(inode)-&gt;i_crtime = inode-&gt;i_mtime;</span><br><span class="line">	inode-&gt;i_generation = sbi-&gt;s_next_generation++;</span><br><span class="line"></span><br><span class="line">	err = insert_inode_locked(inode); <span class="comment">// 将这个inode插入到全局的inode table(VFS行为)</span></span><br><span class="line"></span><br><span class="line">    set_inode_flag(inode, FI_NEW_INODE); <span class="comment">// 注意这个标志位后面会用到</span></span><br><span class="line">    </span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 上面省略代码都在设置法f2fs_inode_info的flag，并在这个函数将部分flag设置到vfs inode中</span></span><br><span class="line">	f2fs_set_inode_flags(inode); </span><br><span class="line">	<span class="keyword">return</span> inode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="f2fs_add_link-函数"><a href="#f2fs_add_link-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_add_link-函数"></a> f2fs_add_link 函数</h3><p>经过上面的函数，我们已经创建了一个 f2fs 使用的 vfs inode，接下来我们要将这个 inode 链接到父目录的 inode 当中，建立联系，<code>f2fs_add_link</code> 函数直接会调用 <code>f2fs_do_add_link</code> 函数，因此我们直接分析这个函数。其中 <code>f2fs_dir_entry</code> 代表是目录项，可以理解为<strong>父目录包含了多个子文件/目录项，每一个目录项对应一个子文件/子目录的关联信息。我们将新创建的 inode 加入到父目录的管理，也就是在父目录中为这个新 inode 下创建一个目录项。</strong></p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">f2fs_add_link</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这里的dentry就是新inode的dentry</span></span><br><span class="line">	<span class="keyword">return</span> f2fs_do_add_link(d_inode(dentry-&gt;d_parent), &amp;dentry-&gt;d_name,</span><br><span class="line">				inode, inode-&gt;i_ino, inode-&gt;i_mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dir是父目录</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">f2fs_do_add_link</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="type">const</span> <span class="keyword">struct</span> qstr *name,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> inode *inode, <span class="type">nid_t</span> ino, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dir_entry</span> *<span class="title">de</span> =</span> <span class="literal">NULL</span>; <span class="comment">// 父目录dir的目录项，初始化为NULL</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">    <span class="comment">// 如果文件已经加密，则获得解密后的名字fname</span></span><br><span class="line">	err = fscrypt_setup_filename(dir, name, <span class="number">0</span>, &amp;fname); </span><br><span class="line">	<span class="keyword">if</span> (de) &#123; <span class="comment">// 如果找到目录项</span></span><br><span class="line">		f2fs_put_page(page, <span class="number">0</span>);</span><br><span class="line">		err = -EEXIST;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (IS_ERR(page)) &#123;</span><br><span class="line">		err = PTR_ERR(page);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// 对于一个新inode，它对应的父目录的目录项f2fs_dir_entry应该是不存在的</span></span><br><span class="line">		err = f2fs_add_dentry(dir, &amp;fname, inode, ino, mode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><code>f2fs_add_dentry</code> 函数提取了文件名字的字符串以及字符串长度：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_add_dentry</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="keyword">struct</span> fscrypt_name *fname,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> inode *inode, <span class="type">nid_t</span> ino, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">new_name</span>;</span></span><br><span class="line">	<span class="type">int</span> err = -EAGAIN;</span><br><span class="line"></span><br><span class="line">	new_name.name = fname_name(fname); <span class="comment">// 将文件名的字符串格式保存在这里</span></span><br><span class="line">	new_name.len = fname_len(fname);   <span class="comment">// 将文件名的长度保存在这里</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在这个函数实现新inode和父inode的链接</span></span><br><span class="line">	err = f2fs_add_regular_entry(dir, &amp;new_name, fname-&gt;usr_fname,</span><br><span class="line">						inode, ino, mode);</span><br><span class="line"></span><br><span class="line">	f2fs_update_time(F2FS_I_SB(dir), REQ_TIME); <span class="comment">// 更新修改时间</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>新 inode 的 <code>f2fs_dir_entry</code> 应该是不存在的，注意 <code>FI_NEW_INODE</code> 的 flag。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_add_regular_entry</span><span class="params">(<span class="keyword">struct</span> inode *dir, <span class="type">const</span> <span class="keyword">struct</span> qstr *new_name,</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="keyword">struct</span> qstr *orig_name,</span></span><br><span class="line"><span class="params">				<span class="keyword">struct</span> inode *inode, <span class="type">nid_t</span> ino, <span class="type">umode_t</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 上面的机制比较复杂，在这里不提，在目录项的作用相关章节再提</span></span><br><span class="line">    <span class="comment">// 上面做了一大堆事情可以理解为，根据[文件名的长度]创建一个新的f2fs_dir_entry，然后加入到父目录当中</span></span><br><span class="line">    <span class="comment">// 需要注意的是这个f2fs_dir_entry还没有包含新inode的信息</span></span><br><span class="line">       </span><br><span class="line">    <span class="comment">//  接下来就是要做的就是</span></span><br><span class="line">    <span class="comment">// 	1. 为新的vfs inode创建inode page，初始化与父目录有关的信息</span></span><br><span class="line">    <span class="comment">// 	2. 基于新inode的信息(名字，ino等)更新f2fs_dir_entry</span></span><br><span class="line">        </span><br><span class="line">	<span class="keyword">if</span> (inode) &#123;</span><br><span class="line">        <span class="comment">// 这个函数就是创建inode page，初始化与父目录有关的信息</span></span><br><span class="line">		page = f2fs_init_inode_metadata(inode, dir, new_name,</span><br><span class="line">						orig_name, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于新inode的信息(名字，ino等)更新f2fs_dir_entry</span></span><br><span class="line">	f2fs_update_dentry(ino, mode, &amp;d, new_name, dentry_hash, bit_pos);</span><br><span class="line"></span><br><span class="line">	set_page_dirty(dentry_page);</span><br><span class="line">	f2fs_update_parent_metadata(dir, inode, current_depth); <span class="comment">// 清除FI_NEW_INODE的flag</span></span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>由于新 inode 设置了 <code>FI_NEW_INODE</code>，因此 <code>f2fs_init_inode_metadata</code> 函数就是完成了两个功能:</p><ol><li>创建一个新的 inode page，然后初始化 acl、security 等信息。</li><li>然后初始化新创建的 inode page 的名字。</li><li>再增加 inode 的引入链接。</li></ol><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">f2fs_init_inode_metadata</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> inode *dir,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="keyword">struct</span> qstr *new_name, <span class="type">const</span> <span class="keyword">struct</span> qstr *orig_name,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> page *dpage)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于新inode设置了FI_NEW_INODE</span></span><br><span class="line">	<span class="keyword">if</span> (is_inode_flag_set(inode, FI_NEW_INODE)) &#123;</span><br><span class="line">        <span class="comment">// 创建一个新的inode page，然后初始化acl、security等信息。</span></span><br><span class="line">		page = f2fs_new_inode_page(inode);</span><br><span class="line"></span><br><span class="line">		err = f2fs_init_acl(inode, dir, page, dpage);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> put_error;</span><br><span class="line"></span><br><span class="line">		err = f2fs_init_security(inode, dir, orig_name, page);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> put_error;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		page = f2fs_get_node_page(F2FS_I_SB(dir), inode-&gt;i_ino);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(page))</span><br><span class="line">			<span class="keyword">return</span> page;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_name) &#123; <span class="comment">// 然后初始化新创建的inode page的名字</span></span><br><span class="line">		init_dent_inode(new_name, page);</span><br><span class="line">		<span class="keyword">if</span> (f2fs_encrypted_inode(dir))</span><br><span class="line">			file_set_enc_name(inode);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 再增加inode的引入链接。</span></span><br><span class="line">	<span class="keyword">if</span> (is_inode_flag_set(inode, FI_INC_LINK))</span><br><span class="line">		f2fs_i_links_write(inode, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>将新的 inode 链接到父目录后，后续用户访问时，可以通过父目录找到新创建的文件的 inode，即完成了整个文件的创建流程。</p><h1 id="重要数据结构和函数分析"><a href="#重要数据结构和函数分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#重要数据结构和函数分析"></a> 重要数据结构和函数分析</h1><h2 id="f2fs_summary-和-f2fs_summary_block"><a href="#f2fs_summary-和-f2fs_summary_block" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_summary-和-f2fs_summary_block"></a> f2fs_summary 和 f2fs_summary_block</h2><h3 id="介绍"><a href="#介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h3><p>因为每一个 segment 需要管理 512 个 Block 的地址，而且很多场合需要通过 block 地址找到这个 block 是属于哪一个 node，以及属于这个 node 的第几个 block。<code>f2fs_summary</code> 主要保存了 block-&gt;node 的映射信息：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> &#123;</span></span><br><span class="line">	__le32 nid;		<span class="comment">/* parent node id */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u8 reserved[<span class="number">3</span>];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u8 version;		<span class="comment">/* node version number */</span></span><br><span class="line">			__le16 ofs_in_node;	<span class="comment">/* block index in parent node */</span></span><br><span class="line">		&#125; __packed;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p>一个 segment 对应的 512 个 <code>f2fs_summary</code> 是通过一个 4 KB 的 block 保存，<code>f2fs_summary_block</code> 保存在元数据区域的 <strong>SSA</strong> 区域:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> <span class="title">entries</span>[<span class="title">ENTRIES_IN_SUM</span>];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> <span class="title">journal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">summary_footer</span> <span class="title">footer</span>;</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">summary_footer</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> entry_type;	<span class="comment">/* SUM_TYPE_XXX */</span></span><br><span class="line">	__le32 check_sum;		<span class="comment">/* summary checksum */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p>其中 <code>summary_footer</code> 记录了这个 <code>f2fs_summary_block</code> 的一些属性，如校验信息，以及这个 <code>f2fs_summary_block</code> 对应的 segment 所管理的 block 是属于 node 还是 data。</p><h3 id="应用场景"><a href="#应用场景" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3><ol><li><strong>GC 基本流程:</strong> 选一个无效 block 最多的当选择出需要 gc 的 victim segment，然后将这个 victim segment 的 block 迁移插入到其他 segment 中，这样就可以制造出一个全部 block 都可以用的 segment。</li><li><strong>f2fs_summary 在 GC 的作用:</strong> 当选择出需要 gc 的 victim segment 之后，可以通过这个 victim segment 的 segno，在 SSA 区域找到 <code>f2fs_summary_block</code>。对 victim segment 的每一个 block 进行迁移的时候，会根据 block 的地址在 <code>f2fs_summary_block</code> 找到 它所对应的 <code>f2fs_summary</code> 然后根据它所记录的 <code>f2fs_summary-&gt;nid</code> 以及 <code>f2fs_summary-&gt;ofs_in_node</code> 找到对应的具体的 block 的数据，然后将这些数据设置为 dirty，然后等待 vfs 的 writeback 机制完成页迁移。</li></ol><h2 id="seg_entry-和-sit_info"><a href="#seg_entry-和-sit_info" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#seg_entry-和-sit_info"></a> seg_entry 和 sit_info</h2><h3 id="seg_entry-结构"><a href="#seg_entry-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#seg_entry-结构"></a> seg_entry 结构</h3><h4 id="介绍-2"><a href="#介绍-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#介绍-2"></a> 介绍</h4><p>因为每一个 segment 需要管理 512 个 Block 的地址，因此需要通过某种方式去标记一个 segment 下的 block，哪些是已经使用的，哪些 block 是处于无效状态等待回收。在 F2FS 中，通过结构体 <code>seg_entry</code> 去管理一个 segment 下的所有 block 的使用信息:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seg_entry</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> type:<span class="number">6</span>;		<span class="comment">/* 这个segment的类型 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> valid_blocks:<span class="number">10</span>;	<span class="comment">/* 已经使用的块的数目 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ckpt_valid_blocks:<span class="number">10</span>;	<span class="comment">/* 上一次执行CP时，使用的块的数目 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> padding:<span class="number">6</span>;		<span class="comment">/* padding */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *cur_valid_map;	<span class="comment">/* 通过bitmap(512位)表示这个segment哪些被使用，哪些没使用 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_F2FS_CHECK_FS</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *cur_valid_map_mir;	<span class="comment">/* mirror of current valid bitmap */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * # of valid blocks and the validity bitmap stored in the the last</span></span><br><span class="line"><span class="comment">	 * checkpoint pack. This information is used by the SSR mode.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *ckpt_valid_map;	<span class="comment">/* 上次CP时的bitmap状态 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *discard_map; <span class="comment">/* 标记哪些block需要discard的bitmap */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> mtime;	<span class="comment">/* 修改时间 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><code>seg_entry</code> 由于跟磁盘空间大小有关，因此初始化时以动态分配的方式，保存在元数据区域的 <strong>SIT</strong> 区域当中，代码的具体实现为 <code>sbi-&gt;sit_info-&gt;sentries</code> 中。</p><h4 id="应用场景-2"><a href="#应用场景-2" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#应用场景-2"></a> 应用场景</h4><p><strong>写流程:</strong> 当文件的修改某一个 block 的数据时，需要经过的流程是：</p><ol><li>分配一个新的 block;</li><li>将数据写入到新分配的 block 中;</li><li>将旧 block 置为无效，等待回收;</li><li>将新 block 写入到磁盘中。</li></ol><p>这一个流程需要更新的 segment 的管理信息，因为新 block 和旧 block 可能来自不同的 segment，因此需要更新 segment 的统计信息，具体流程是: 根据新 block 的地址，找到对应 segment number 和 seg_entry，然后在 <code>seg_entry</code> 的根据新 block 在 segment 的 bitmap 对应位置设为 1，然后给 <code>seg_entry-&gt;valid_blocks</code> 加一，表示这个 segment 新增加了一个被使用 block；对于旧 block，一样是根据 block 地址找到 segment number 和 seg_entry，然后执行相反操作对 bitmap 设为 0，然后 <code>seg_entry-&gt;valid_blocks</code> 减一。</p><h3 id="curseg_info-结构"><a href="#curseg_info-结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#curseg_info-结构"></a> curseg_info 结构</h3><h4 id="介绍-3"><a href="#介绍-3" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#介绍-3"></a> 介绍</h4><p><code>curseg_info</code> 在 F2FS 中表示的是当前使用的 segment 的信息。一般情况下，F2FS 同时运行着 6 个 <code>curseg_info</code> ，分别表示 <strong>(NODE,DATA) X (HOT,WARM,COLD)</strong> 这些不同类型的 segment。它的基本结构和关联数据结构是：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">curseg_mutex</span>;</span>		<span class="comment">/* lock for consistency */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> *<span class="title">sum_blk</span>;</span>	<span class="comment">/* cached summary block */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">journal_rwsem</span>;</span>	<span class="comment">/* protect journal area */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> *<span class="title">journal</span>;</span>		<span class="comment">/* cached journal info */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> alloc_type;		<span class="comment">/* current allocation type */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> segno;			<span class="comment">/* current segment number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> next_blkoff;		<span class="comment">/* next block offset to write */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> zone;			<span class="comment">/* current zone number */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> next_segno;		<span class="comment">/* preallocated segment */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>f2fs_summary_block:</strong> <code>curseg_info</code> 表示一个 segment，因此通过 <code>f2fs_summary_block</code> 管理这个 segment 下的所有 block。 <code>f2fs_summary_block</code> 包含 512 个 <code>f2fs_summary</code>，每个 summary 代表一个这个 segment 里面的一个 block，它的结构是:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary_block</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> <span class="title">entries</span>[<span class="title">ENTRIES_IN_SUM</span>];</span> <span class="comment">/* ENTRIES_IN_SUM = 512 表示被管理的512个块 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> <span class="title">journal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">summary_footer</span> <span class="title">footer</span>;</span> <span class="comment">/* 指示这个segment的类型 */</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_summary</span> &#123;</span></span><br><span class="line">	__le32 nid;		<span class="comment">/* 属主node id */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__u8 reserved[<span class="number">3</span>];</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			__u8 version;		<span class="comment">/* node version number */</span></span><br><span class="line">			__le16 ofs_in_node;	<span class="comment">/* 属主node里面的第几个block */</span></span><br><span class="line">		&#125; __packed;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>可以看到每一个 <code>f2fs_summary</code> 用来描述这个 segment 里面的 block 是属于哪一个 node，而且是这个 node 里面的第几个 block。</p><p><strong>f2fs_journal:</strong> <code>curseg_info</code> 管理着 512 个 block，需要一种机制去记录每一个它所管理的 block 是否已经被分配出去。因此 <code>f2fs_journal</code> 的作用就是记录每一个 block 是否是有效。它的结构如下:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__le16 n_nats;</span><br><span class="line">		__le16 n_sits; <span class="comment">/* 这个journal里面包含多少个sit_journal对象 */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/* spare area is used by NAT or SIT journals or extra info */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nat_journal</span> <span class="title">nat_j</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sit_journal</span> <span class="title">sit_j</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_extra_info</span> <span class="title">info</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sit_journal</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sit_journal_entry</span> <span class="title">entries</span>[<span class="title">SIT_JOURNAL_ENTRIES</span>];</span></span><br><span class="line">	__u8 reserved[SIT_JOURNAL_RESERVED];</span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sit_journal_entry</span> &#123;</span></span><br><span class="line">	__le32 segno;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> <span class="title">se</span>;</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> &#123;</span></span><br><span class="line">	__le16 vblocks;				<span class="comment">/* reference above */</span></span><br><span class="line">	__u8 valid_map[SIT_VBLOCK_MAP_SIZE];	<span class="comment">/* SIT_VBLOCK_MAP_SIZE = 64，64 * 8 = 512 可以表示每一个块的valid状态 */</span></span><br><span class="line">	__le64 mtime;				<span class="comment">/* segment age for cleaning */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p><code>f2fs_journal</code> 可以记录 NAT 和 SIT 的 journal。通过 <code>f2fs_sit_entry</code> 可以发现，<code>f2fs_journal</code> 保存的是有效 block 的数目 <code>vblocks</code> 以及它的 bitmap <code>valid_map</code>。</p><h4 id="curseg_info-的作用"><a href="#curseg_info-的作用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#curseg_info-的作用"></a> curseg_info 的作用</h4><p><code>curseg_info</code> 的作用主要是当一个 Node 或者 Data 需要分配一个新的 block 的时候，就会根据这个 block 的类型，在 <code>curseg_info</code> 取出一个 segment，然后在这个 segment 分配出一个新的 block，然后将新的 block 的映射信息，写入 <code>curseg_info</code> 的 <code>f2fs_summary_block</code> 和 <code>f2fs_journal</code> 中。这样设计的原因是，将大部分更新元数据的操作都放在 <code>curseg_info</code> 完成，避免了频繁读写磁盘。</p><h2 id="f2fs-journal-机制"><a href="#f2fs-journal-机制" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs-journal-机制"></a> F2FS Journal 机制</h2><h3 id="介绍-4"><a href="#介绍-4" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#介绍-4"></a> 介绍</h3><p>当 F2FS 进行文件读写的时候，根据 <code>f2fs_node</code> 的设计以及闪存设备异地更新的特性，每修改一个数据块，都需要改动 <code>f2fs_node</code> 的地址映射，以及 NAT，SIT 等信息。但是如果仅仅因为一个小改动，例如修改一个块，就需要改动这么多数据，然后再写入磁盘，这样既会导致性能下降，也会导致 SSD 寿命的下降。故 F2FS 设计了 journal 机制，用于将这些对数据的修改会暂存在 <code>f2fs_journal</code>，等系统进行 checkpoint 的时候，再写入磁盘当中。</p><p>部分内容参考: <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/sunwukong54/article/details/45669017">https://blog.csdn.net/sunwukong54/article/details/45669017</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><h3 id="涉及到的数据结构"><a href="#涉及到的数据结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#涉及到的数据结构"></a> 涉及到的数据结构</h3><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		__le16 n_nats; <span class="comment">/* 这个journal里面包含多少个nat_journal对象 */</span></span><br><span class="line">		__le16 n_sits; <span class="comment">/* 这个journal里面包含多少个sit_journal对象 */</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">/* spare area is used by NAT or SIT journals or extra info */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">nat_journal</span> <span class="title">nat_j</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sit_journal</span> <span class="title">sit_j</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_extra_info</span> <span class="title">info</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p><code>f2fs_journal</code> 可以保存 NAT 的 journal 也可以保存 SIT 的 journal，以下分别分析:</p><p><strong>NAT Journal</strong><br>NAT 类型的 journal 主要保存的每一个 node 是属于哪一个 inode，以及它的地址是什么，这样设计的原始访问某一个 node 的时候，只要根据 nid 找到对应的 <code>nat_journal_entry</code>，然后就可以找到 <code>f2fs_nat_entry</code>，最后找到 blkaddr。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nat_journal</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nat_journal_entry</span> <span class="title">entries</span>[<span class="title">NAT_JOURNAL_ENTRIES</span>];</span></span><br><span class="line">	__u8 reserved[NAT_JOURNAL_RESERVED];</span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nat_journal_entry</span> &#123;</span></span><br><span class="line">	__le32 nid;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nat_entry</span> <span class="title">ne</span>;</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nat_entry</span> &#123;</span></span><br><span class="line">	__u8 version;		<span class="comment">/* latest version of cached nat entry */</span></span><br><span class="line">	__le32 ino;		<span class="comment">/* inode number */</span></span><br><span class="line">	__le32 block_addr;	<span class="comment">/* block address */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p><strong>SIT Journal</strong><br>SIT 类型的 Journal 和 segment 一一对应。segment 管理着 512 个 block，需要一种机制去记录每一个它所管理的 block 是否已经被分配出去。通过 <code>f2fs_sit_entry</code> 可以发现，<code>f2fs_journal</code> 保存的是有效 block 的数目 <code>vblocks</code> 以及它的 bitmap <code>valid_map</code>。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sit_journal</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sit_journal_entry</span> <span class="title">entries</span>[<span class="title">SIT_JOURNAL_ENTRIES</span>];</span></span><br><span class="line">	__u8 reserved[SIT_JOURNAL_RESERVED];</span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sit_journal_entry</span> &#123;</span></span><br><span class="line">	__le32 segno;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> <span class="title">se</span>;</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sit_entry</span> &#123;</span></span><br><span class="line">	__le16 vblocks;				<span class="comment">/* reference above */</span></span><br><span class="line">	__u8 valid_map[SIT_VBLOCK_MAP_SIZE];	<span class="comment">/* SIT_VBLOCK_MAP_SIZE = 64，64 * 8 = 512 可以表示每一个块的valid状态 */</span></span><br><span class="line">	__le64 mtime;				<span class="comment">/* segment age for cleaning */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><h3 id="一些机制的具体实现"><a href="#一些机制的具体实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#一些机制的具体实现"></a> 一些机制的具体实现</h3><h4 id="通过-journal-获取-node-的地址"><a href="#通过-journal-获取-node-的地址" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通过-journal-获取-node-的地址"></a> 通过 Journal 获取 Node 的地址</h4><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">f2fs_get_node_info</span><span class="params">(<span class="keyword">struct</span> f2fs_sb_info *sbi, <span class="type">nid_t</span> nid,</span></span><br><span class="line"><span class="params">						<span class="keyword">struct</span> node_info *ni)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nm_info</span> *<span class="title">nm_i</span> =</span> NM_I(sbi);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">curseg_info</span> *<span class="title">curseg</span> =</span> CURSEG_I(sbi, CURSEG_HOT_DATA);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_journal</span> *<span class="title">journal</span> =</span> curseg-&gt;journal;</span><br><span class="line">	<span class="type">nid_t</span> start_nid = START_NID(nid);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nat_block</span> *<span class="title">nat_blk</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_nat_entry</span> <span class="title">ne</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">nat_entry</span> *<span class="title">e</span>;</span></span><br><span class="line">	<span class="type">pgoff_t</span> index;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	ni-&gt;nid = nid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check nat cache */</span></span><br><span class="line">	down_read(&amp;nm_i-&gt;nat_tree_lock);</span><br><span class="line">	e = __lookup_nat_cache(nm_i, nid); <span class="comment">// 从cache里面找nid</span></span><br><span class="line">	<span class="keyword">if</span> (e) &#123; <span class="comment">// 如果有就返回</span></span><br><span class="line">		ni-&gt;ino = nat_get_ino(e);</span><br><span class="line">		ni-&gt;blk_addr = nat_get_blkaddr(e);</span><br><span class="line">		ni-&gt;version = nat_get_version(e);</span><br><span class="line">		up_read(&amp;nm_i-&gt;nat_tree_lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;ne, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> f2fs_nat_entry)); <span class="comment">// 初始化为0</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check current segment summary */</span></span><br><span class="line">	down_read(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line">	i = f2fs_lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, <span class="number">0</span>); <span class="comment">// 从NAT_JOURNAL里面找这个nid在journal中的offset</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		ne = nat_in_journal(journal, i); <span class="comment">// 将nat_entry返回出来</span></span><br><span class="line">		node_info_from_raw_nat(ni, &amp;ne); <span class="comment">// 读到node_info中</span></span><br><span class="line">	&#125;</span><br><span class="line">	up_read(&amp;curseg-&gt;journal_rwsem);</span><br><span class="line">	<span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		up_read(&amp;nm_i-&gt;nat_tree_lock);</span><br><span class="line">		<span class="keyword">goto</span> cache;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Fill node_info from nat page</span></span><br><span class="line"><span class="comment">	 * start_nid是根据nid找到管理这个nid的nat block偏移</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	index = current_nat_addr(sbi, nid);</span><br><span class="line">	up_read(&amp;nm_i-&gt;nat_tree_lock);</span><br><span class="line"></span><br><span class="line">	page = f2fs_get_meta_page(sbi, index); <span class="comment">// 从磁盘读取出f2fs_nat_block</span></span><br><span class="line">	nat_blk = (<span class="keyword">struct</span> f2fs_nat_block *)page_address(page);</span><br><span class="line">	ne = nat_blk-&gt;entries[nid - start_nid];</span><br><span class="line">	node_info_from_raw_nat(ni, &amp;ne);</span><br><span class="line">	f2fs_put_page(page, <span class="number">1</span>);</span><br><span class="line">cache:</span><br><span class="line">	<span class="comment">/* cache nat entry */</span></span><br><span class="line">	cache_nat_entry(sbi, nid, &amp;ne); <span class="comment">// 缓存这个node_entry</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="通过-checkpoint-将-journal-的信息写入到磁盘中"><a href="#通过-checkpoint-将-journal-的信息写入到磁盘中" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#通过-checkpoint-将-journal-的信息写入到磁盘中"></a> 通过 Checkpoint 将 journal 的信息写入到磁盘中</h4><p>简略的流程如下:</p><ol><li><code>f2fs_flush_nat_entries</code> 和 <code>f2fs_flush_sit_entries</code> 函数将 entry 都写入到 <code>curseg_info-&gt;f2fs_summary-&gt;journal</code> 的变量中。</li><li>do_checkpoint() 函数读取 <code>curseg_info-&gt;f2fs_summary</code>，然后通过函数 <code>f2fs_write_node_summaries</code> 或 <code>f2fs_write_data_summaries</code> 刷写到磁盘中。</li></ol><h2 id="f2fs_map_blocks-的作用与源码分析"><a href="#f2fs_map_blocks-的作用与源码分析" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_map_blocks-的作用与源码分析"></a> f2fs_map_blocks 的作用与源码分析</h2><p>函数 f2fs_map_blocks() 启到了地址映射的作用，主要作用是通过逻辑地址找到可以访问磁盘的物理地址。</p><h3 id="读写流程的作用"><a href="#读写流程的作用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#读写流程的作用"></a> 读写流程的作用</h3><ol><li>对读的作用: 通过该函数根据逻辑地址找到物理地址，然后从磁盘读取出数据。</li><li>对写的作用: 文件在写入数据之前，会执行一个 preallocate 的过程，这个过程会调用 <code>f2fs_map_blocks</code> 函数对即将要写入数据的逻辑块进行预处理，如果是 append 的方式写入数据，则将物理地址初始化为 NEW_ADDR; 如果是 rewrite 的方式写入数据，则不作改变。</li></ol><h3 id="核心数据结构"><a href="#核心数据结构" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#核心数据结构"></a> 核心数据结构</h3><p>f2fs_map_blocks() 函数的核心是 <code>f2fs_map_blocks</code> 数据结构，保存了一系列映射信息。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_map_blocks</span> &#123;</span></span><br><span class="line">	<span class="type">block_t</span> m_pblk; <span class="comment">// 保存的是物理地址，可以通过这个物理地址访问磁盘读取信息</span></span><br><span class="line">	<span class="type">block_t</span> m_lblk; <span class="comment">// 保存的逻辑地址，即文件的page-&gt;index</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_len; <span class="comment">// 需要读取的长度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> m_flags; <span class="comment">// flags表示获取数据状态，如F2FS_MAP_MAPPED</span></span><br><span class="line">	<span class="type">pgoff_t</span> *m_next_pgofs; <span class="comment">// 指向下一个offset</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h3 id="读流程的核心逻辑"><a href="#读流程的核心逻辑" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#读流程的核心逻辑"></a> 读流程的核心逻辑</h3><p>一般的读流程，会进行如下的数据结构初始化:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.m_lblk = block_in_file; <span class="comment">// 设置逻辑地址page-&gt;index</span></span><br><span class="line"><span class="built_in">map</span>.m_len = len; <span class="comment">// 设置需要读取的长度</span></span><br><span class="line">f2fs_map_blocks(inode, &amp;<span class="built_in">map</span>, <span class="number">0</span>, F2FS_GET_BLOCK_READ); <span class="comment">// 0设定非创建模式，F2FS_GET_BLOCK_READ设定搜索模式</span></span><br></pre></td></tr></table></div></figure><p>即通过逻辑地址和读取长度找到对应的物理地址，与<strong>读流程相关的核心逻辑</strong>如下所示:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_map_blocks</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> f2fs_map_blocks *<span class="built_in">map</span>, <span class="type">int</span> create, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> maxblocks = <span class="built_in">map</span>-&gt;m_len; <span class="comment">// 设定最大搜索长度</span></span><br><span class="line">	<span class="type">int</span> mode = create ? ALLOC_NODE : LOOKUP_NODE_RA; <span class="comment">// LOOKUP_NODE_RA模式</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>-&gt;m_len = <span class="number">0</span>; <span class="comment">// 将len重新设置为0</span></span><br><span class="line">	<span class="built_in">map</span>-&gt;m_flags = <span class="number">0</span>;</span><br><span class="line">	pgofs =	(<span class="type">pgoff_t</span>)<span class="built_in">map</span>-&gt;m_lblk; <span class="comment">// page-&gt;index</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一步：先从extent找，如果在extent找到，就可以马上返回</span></span><br><span class="line">	<span class="keyword">if</span> (!create &amp;&amp; f2fs_lookup_extent_cache(inode, pgofs, &amp;ei)) &#123;</span><br><span class="line">		<span class="built_in">map</span>-&gt;m_pblk = ei.blk + pgofs - ei.fofs;</span><br><span class="line">		<span class="built_in">map</span>-&gt;m_len = min((<span class="type">pgoff_t</span>)maxblocks, ei.fofs + ei.len - pgofs);</span><br><span class="line">		<span class="built_in">map</span>-&gt;m_flags = F2FS_MAP_MAPPED;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二步：根据page-&gt;index找到对应的dn，dn是一个包含了物理地址的数据结构</span></span><br><span class="line">	set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	err = get_dnode_of_data(&amp;dn, pgofs, mode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三步：从dn获取物理地址</span></span><br><span class="line">	blkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">map</span>-&gt;m_pblk = blkaddr;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="写流程的核心逻辑"><a href="#写流程的核心逻辑" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#写流程的核心逻辑"></a> 写流程的核心逻辑</h3><p>一般的读流程，会进行如下的数据结构初始化:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>.m_lblk = F2FS_BLK_ALIGN(iocb-&gt;ki_pos); <span class="comment">// 计算得到页偏移</span></span><br><span class="line"><span class="built_in">map</span>.m_len = F2FS_BYTES_TO_BLK(iocb-&gt;ki_pos + iov_iter_count(from)); <span class="comment">// 计算得到需要读取的页数</span></span><br><span class="line">f2fs_map_blocks(inode, &amp;<span class="built_in">map</span>, <span class="number">1</span>, F2FS_GET_BLOCK_PRE_AIO); <span class="comment">// 1设定创建模式，F2FS_GET_BLOCK_PRE_AIO表示用于预分配物理页</span></span><br></pre></td></tr></table></div></figure><p>写流程下的 f2fs_map_blocks() 函数作用是先根据逻辑地址读取物理地址出来，如果这个物理地址没有被分配过(NULL_ADDR)，则初始化为新地址(NEW_ADDR)，用于下一步的写入磁盘的操作，与<strong>写流程相关的核心逻辑</strong>如下所示:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">f2fs_map_blocks</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> f2fs_map_blocks *<span class="built_in">map</span>,</span></span><br><span class="line"><span class="params">						<span class="type">int</span> create, <span class="type">int</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> maxblocks = <span class="built_in">map</span>-&gt;m_len;</span><br><span class="line">	<span class="type">int</span> mode = create ? ALLOC_NODE : LOOKUP_NODE;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">map</span>-&gt;m_len = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">map</span>-&gt;m_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	pgofs =	(<span class="type">pgoff_t</span>)<span class="built_in">map</span>-&gt;m_lblk;</span><br><span class="line">	end = pgofs + maxblocks;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第一步：根据page-&gt;index找到对应的dn，dn是一个包含了物理地址的数据结构</span></span><br><span class="line">	set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	err = f2fs_get_dnode_of_data(&amp;dn, pgofs, mode);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第二步：从dn获取物理地址</span></span><br><span class="line">	blkaddr = datablock_addr(dn.inode, dn.node_page, dn.ofs_in_node);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 第三步：如果blkaddr == NULL_ADDR表示这个是从来未使用过的物理页，即目前运行的是append写，</span></span><br><span class="line">	<span class="comment">//  因此将其记录下来。</span></span><br><span class="line">	<span class="keyword">if</span> (flag == F2FS_GET_BLOCK_PRE_AIO) &#123;</span><br><span class="line">		<span class="keyword">if</span> (blkaddr == NULL_ADDR) &#123;</span><br><span class="line">			prealloc++; <span class="comment">// 记录需要与分配的物理页的数目</span></span><br><span class="line">			last_ofs_in_node = dn.ofs_in_node;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag == F2FS_GET_BLOCK_PRE_AIO &amp;&amp;</span><br><span class="line">			(pgofs == end || dn.ofs_in_node == end_offset)) &#123;</span><br><span class="line"></span><br><span class="line">		dn.ofs_in_node = ofs_in_node;</span><br><span class="line">		<span class="comment">// 第四步：根据prealloc记录的从未被使用过的块的数目，</span></span><br><span class="line">		<span class="comment">//  通过函数f2fs_reserve_new_blocks，将他们的值由NULL_ADDR转换为NEW_ADDR，用于下一步写入磁盘</span></span><br><span class="line">		err = f2fs_reserve_new_blocks(&amp;dn, prealloc);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			<span class="keyword">goto</span> sync_out;</span><br><span class="line"></span><br><span class="line">		<span class="built_in">map</span>-&gt;m_len += dn.ofs_in_node - ofs_in_node;</span><br><span class="line">		<span class="keyword">if</span> (prealloc &amp;&amp; dn.ofs_in_node != last_ofs_in_node + <span class="number">1</span>) &#123;</span><br><span class="line">			err = -ENOSPC;</span><br><span class="line">			<span class="keyword">goto</span> sync_out;</span><br><span class="line">		&#125;</span><br><span class="line">		dn.ofs_in_node = end_offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="物理地址寻址的实现"><a href="#物理地址寻址的实现" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#物理地址寻址的实现"></a> 物理地址寻址的实现</h2><p>VFS 的读写都依赖于物理地址的寻址。经典的读流程，VFS 会传入 inode 以及 page index 信息给文件系统，然后文件系统需要根据以上信息，找到物理地址，然后访问磁盘将其读取出来。F2FS 的物理地址寻址，是通过 f2fs_get_dnode_of_data() 函数实现。</p><p>在执行这个 f2fs_get_dnode_of_data() 函数之前，需要通过 set_new_dnode() 函数进行对数据结构 <code>struct dnode_of_data</code> 进行初始化:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dnode_of_data</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span>		<span class="comment">/* VFS inode结构 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">inode_page</span>;</span>	<span class="comment">/* f2fs_inode对应的node page */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">node_page</span>;</span>		<span class="comment">/* 用户需要访问的物理地址所在的node page，有可能跟inode_page一样*/</span></span><br><span class="line">	<span class="type">nid_t</span> nid;			<span class="comment">/* 用户需要访问的物理地址所在的node的nid，与上面的node_page对应*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ofs_in_node;	<span class="comment">/* 用户需要访问的物理地址位于上面的node_page对应的addr数组第几个位置 */</span></span><br><span class="line">	<span class="type">bool</span> inode_page_locked;		<span class="comment">/* inode page is locked or not */</span></span><br><span class="line">	<span class="type">bool</span> node_changed;		<span class="comment">/* is node block changed */</span></span><br><span class="line">	<span class="type">char</span> cur_level;			<span class="comment">/* 当前node_page的层次，按直接访问或者简介访问的深度区分 */</span></span><br><span class="line">	<span class="type">char</span> max_level;			<span class="comment">/* level of current page located */</span></span><br><span class="line">	<span class="type">block_t</span>	data_blkaddr;		<span class="comment">/* 用户需要访问的物理地址 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">set_new_dnode</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">		<span class="keyword">struct</span> page *ipage, <span class="keyword">struct</span> page *npage, <span class="type">nid_t</span> nid)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">memset</span>(dn, <span class="number">0</span>, <span class="keyword">sizeof</span>(*dn));</span><br><span class="line">	dn-&gt;inode = inode;</span><br><span class="line">	dn-&gt;inode_page = ipage;</span><br><span class="line">	dn-&gt;node_page = npage;</span><br><span class="line">	dn-&gt;nid = nid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>大部分情况下，仅需要传入 inode 进行初始化:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_new_dnode(&amp;dn, inode, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 0表示不清楚nid</span></span><br></pre></td></tr></table></div></figure><p>然后根据需要访问的 page index，执行 f2fs_get_dnode_of_data() 函数寻找:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err = f2fs_get_dnode_of_data(&amp;dn, page-&gt;index, type); <span class="comment">// type类型影响了寻址的行为</span></span><br><span class="line">blockt blkaddr = dn.data_blkaddr; <span class="comment">// 获得对应位置的物理地址信息</span></span><br></pre></td></tr></table></div></figure><p>接下来分析，函数是如何寻址，由于函数比较长和复杂，先分析一个比较重要的函数 get_node_path() 函数的作用，它的用法是:</p><h3 id="概念"><a href="#概念" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3><p>在分析之前，我们要明确几个概念。f2fs 有三种 node 的类型，<code>f2fs_inode</code>、<code>direct_node</code> 和 <code>indirect node</code>。其中 <code>f2fs_inode</code> 和 <code>direct_node</code> 都是直接保存数据的地址指针，因此一般统称为 direct node，若有下横线，例如 <code>direct_node</code>，则表示数据结构 <code>struct direct_node</code>，如果没有下横线，则表示直接保存数据的地址指针的 node，即 <code>f2fs_inode</code> 和 <code>direct_node</code>。另外 <code>indirect node</code> 保存的是间接寻址的 node 的 nid，因此一般直接称为 indirect node。</p><h3 id="函数用法"><a href="#函数用法" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#函数用法"></a> 函数用法</h3><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> level;</span><br><span class="line"><span class="type">int</span> offset[<span class="number">4</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> noffset[<span class="number">4</span>];</span><br><span class="line">level = get_node_path(inode, page-&gt;index, offset, noffset);</span><br></pre></td></tr></table></div></figure><p>这里 offset 和 noffset 分别表示 block offset 和 node offset，返回的 level 表示寻址的深度，一共有 4 个深度，使用 0~3 表示:</p><ul><li>level=0: 表示可以直接在 <code>f2fs_inode</code> 找到物理地址。</li><li>level=1: 表示可以在 <code>f2fs_inode-&gt;i_nid[0~1]</code> 对应的 <code>direct_node</code>能够找到物理地址。</li><li>level=2: 表示可以在 <code>f2fs_inode-&gt;i_nid[2~3]</code>对应的 <code>indirect_node</code> 下的 nid 对应的 <code>direct_node</code>能够找到物理地址。</li><li>level=3: 表示只能在 <code>f2fs_inode-&gt;i_nid[4]</code> 对应 <code>indirect_node</code>的 nid 对应的 <code>indirect_node</code> 的 nid 对应的 <code>direct_node</code> 才能找到地址。</li></ul><p>由于 offset 和 noffset，表示的是物理地址寻址信息，分别表示 block 偏移和 direct node 偏移来表示，它们是长度为 4 的数组，代表不同 level 0~3 的寻址信息。之后的函数可以通过 offset 和 noffset 将数据块计算出来。</p><h3 id="寻址原理"><a href="#寻址原理" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#寻址原理"></a> 寻址原理</h3><p>给定 page-&gt;index，计算出 level 之后，offset[level] 表示该 page 在所对应的 direct node 里面的 block 的偏移，noffset[level] 表示当前的 node 是属于这个文件的第几个 node(包括 f2fs_node, direct_node, indirect_node)，下面用几个例子展示一下(注意下面计算的是不使用 xattr 的 f2fs 版本，如果使用了 xattr 结果会不同，但是表示的含义是一样的):</p><h4 id="例子-1-物理地址位于-f2fs_inode"><a href="#例子-1-物理地址位于-f2fs_inode" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#例子-1-物理地址位于-f2fs_inode"></a> 例子 1: 物理地址位于 f2fs_inode</h4><p>例如我们要寻找 page-&gt;index = 665 的数据块所在的位置，显然 655 是位于 <code>f2fs_inode</code> 内，因此 level=0，因此我们只需要看 offset[0] 以及 noffset[0] 的信息。offset[0] = 665 表示这个数据块在当前 direct node(注意: f2fs_inode 也是 direct node 的一种)的位置；noffset[0] 表示当前 direct node 是属于这个文件的第几个 node，由于 f2fs_inode 是第一个 node，所以 noffset[0] = 0。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">level = <span class="number">0</span> <span class="comment">// 可以直接在f2fs_inode找到物理地址</span></span><br><span class="line">offset[<span class="number">0</span>] = <span class="number">665</span> <span class="comment">// 由于level=0，因此我们只需要看offset[level]=offset[0]的信息，这里offset[0] = 665表示地址位于f2fs_inode-&gt;i_addr[665]</span></span><br><span class="line">noffset[<span class="number">0</span>] = <span class="number">0</span> <span class="comment">// 对于level=0的情况，即看noffset[0]，因为level=0表示数据在唯一一个的f2fs_inode中，因此这里表示inode。</span></span><br></pre></td></tr></table></div></figure><h4 id="例子-2-物理地址位于-direct_node"><a href="#例子-2-物理地址位于-direct_node" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#例子-2-物理地址位于-direct_node"></a> 例子 2: 物理地址位于 direct_node</h4><p>例如我们要寻找 page-&gt;index = 2113 的数据块所在的位置，它位于第二个 direct_node，所以 level=1。我们只需要看 offset[1] 以及 noffset[1] 的信息。offset[1] = 172 表示这个数据块在当前 direct node 的位置，即 direct_node-&gt;addr[172]；noffset[1] 表示当前 direct node 是属于这个文件的第几个 node，由于它位于第二个 direct_node，前面还有一个 f2fs_inode 以及一个 direct node，所以这是第三个 node，因此 noffset[1] = 2。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">level = <span class="number">1</span> <span class="comment">// 表示可以在f2fs_inode-&gt;i_nid[0~1]对应的direct_node能够找到物理地址</span></span><br><span class="line">offset[<span class="number">1</span>] = <span class="number">172</span> <span class="comment">// 表示物理地址位于对应的node page的i_addr的第172个位置中，即direct_node-&gt;addr[172]</span></span><br><span class="line">noffset[<span class="number">1</span>] = <span class="number">2</span> <span class="comment">// 数据保存在总共第三个node中 (1个f2fs_inode，2个direct_node)</span></span><br></pre></td></tr></table></div></figure><h4 id="例子-3-物理地址位于-indirect_node"><a href="#例子-3-物理地址位于-indirect_node" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#例子-3-物理地址位于-indirect_node"></a> 例子 3: 物理地址位于 indirect_node</h4><p>例如我们要寻找 page-&gt;index = 4000 的数据块所在的位置，它位于第 1 个 indirect_node 的第 2 个 direct_node中，所以 level=2。我们只需要看 offset[2] 以及 noffset[2] 的信息。offset[2] = 23 表示这个数据块在当前 direct node 的位置；noffset[2] 表示当前 direct node 是属于这个文件的第几个 direct node，即这是第 6 个 node。(1 * f2fs_inode + 2 * direct_node + 1 * indirect_node + 2 * direct node)。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offset[<span class="number">2</span>] = <span class="number">23</span></span><br><span class="line">noffset[<span class="number">2</span>] = <span class="number">5</span></span><br></pre></td></tr></table></div></figure><h4 id="例子-4-物理地址位于-indirect_node-再-indiret_node-中-double-indirect-node"><a href="#例子-4-物理地址位于-indirect_node-再-indiret_node-中-double-indirect-node" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#例子-4-物理地址位于-indirect_node-再-indiret_node-中-double-indirect-node"></a> 例子 4: 物理地址位于 indirect_node 再 indiret_node 中 (double indirect node)</h4><p>例如我们要寻找 page-&gt;index = 2075624 的数据块所在的位置，它位于第一个 double indirect_node 的第一个 indirect_node 的第一个 direct_node 中，所以 level=3。同理我们只需要看 offset[3] 以及 noffset[3] 的信息，如下，可以自己计算一下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">offset[<span class="number">3</span>] = <span class="number">17</span></span><br><span class="line">noffset[<span class="number">3</span>] = <span class="number">2043</span></span><br></pre></td></tr></table></div></figure><p>从上面可以知道 get_node_path() 函数以后，执行可以根据 offset 和 noffset 直接知道 page-&gt;index 对应的物理地址，位于第几个 node page 的第几个 offset 对应的物理地址中。下面分析 f2fs_get_dnode_of_data() 的原理：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f2fs_get_dnode_of_data</span><span class="params">(<span class="keyword">struct</span> dnode_of_data *dn, <span class="type">pgoff_t</span> index, <span class="type">int</span> mode)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(dn-&gt;inode);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">npage</span>[4];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> offset[<span class="number">4</span>];</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> noffset[<span class="number">4</span>];</span><br><span class="line">	<span class="type">nid_t</span> nids[<span class="number">4</span>];</span><br><span class="line">	<span class="type">int</span> level, i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> err = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 通过计算得到offset, noffset，从而知道位于第几个node page的第几个offset对应的物理地址中</span></span><br><span class="line">	level = get_node_path(dn-&gt;inode, index, offset, noffset);</span><br><span class="line">	<span class="keyword">if</span> (level &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> level;</span><br><span class="line"></span><br><span class="line">	nids[<span class="number">0</span>] = dn-&gt;inode-&gt;i_ino;</span><br><span class="line">	npage[<span class="number">0</span>] = dn-&gt;inode_page;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!npage[<span class="number">0</span>]) &#123;</span><br><span class="line">		npage[<span class="number">0</span>] = f2fs_get_node_page(sbi, nids[<span class="number">0</span>]); <span class="comment">// 获取inode对应的f2fs_inode的node page</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	parent = npage[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (level != <span class="number">0</span>)</span><br><span class="line">		nids[<span class="number">1</span>] = get_nid(parent, offset[<span class="number">0</span>], <span class="literal">true</span>); <span class="comment">// 获取f2fs_inode-&gt;i_nid</span></span><br><span class="line">		</span><br><span class="line">	dn-&gt;inode_page = npage[<span class="number">0</span>];</span><br><span class="line">	dn-&gt;inode_page_locked = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= level; i++) &#123;</span><br><span class="line">		<span class="type">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!nids[i] &amp;&amp; mode == ALLOC_NODE) &#123; </span><br><span class="line">			<span class="comment">// 创建模式，常用，写入文件时，需要node page再写入数据，因此对于较大文件，在这里创建node page</span></span><br><span class="line">			<span class="keyword">if</span> (!f2fs_alloc_nid(sbi, &amp;(nids[i]))) &#123; <span class="comment">// 分配nid</span></span><br><span class="line">				err = -ENOSPC;</span><br><span class="line">				<span class="keyword">goto</span> release_pages;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			dn-&gt;nid = nids[i];</span><br><span class="line">			npage[i] = f2fs_new_node_page(dn, noffset[i]); <span class="comment">// 分配node page</span></span><br><span class="line">			<span class="comment">//  如果i == 1，表示f2fs_inode-&gt;nid[0~1]，即direct node，直接赋值到f2fs_inode-&gt;i_nid中</span></span><br><span class="line">			<span class="comment">//  如果i != 1，表示parent是indirect node类型的，要赋值到indirect_node-&gt;nid中</span></span><br><span class="line">			set_nid(parent, offset[i - <span class="number">1</span>], nids[i], i == <span class="number">1</span>); </span><br><span class="line">			f2fs_alloc_nid_done(sbi, nids[i]);</span><br><span class="line">			done = <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (mode == LOOKUP_NODE_RA &amp;&amp; i == level &amp;&amp; level &gt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="comment">// 预读模式，少用，将node page全部预读出来</span></span><br><span class="line">			npage[i] = f2fs_get_node_page_ra(parent, offset[i - <span class="number">1</span>]);</span><br><span class="line">			done = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">			dn-&gt;inode_page_locked = <span class="literal">false</span>;</span><br><span class="line">			unlock_page(parent);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			f2fs_put_page(parent, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!done) &#123;</span><br><span class="line">			npage[i] = f2fs_get_node_page(sbi, nids[i]); <span class="comment">// 根据nid获取node page</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (i &lt; level) &#123;</span><br><span class="line">			parent = npage[i]; <span class="comment">// 注意这里parent被递归地赋值，目的是处理direct node和indrect node的赋值问题</span></span><br><span class="line">			nids[i + <span class="number">1</span>] = get_nid(parent, offset[i], <span class="literal">false</span>); <span class="comment">// 计算下一个nid</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 全部完成后，将结果赋值到dn，然后退出函数</span></span><br><span class="line">	dn-&gt;nid = nids[level];</span><br><span class="line">	dn-&gt;ofs_in_node = offset[level];</span><br><span class="line">	dn-&gt;node_page = npage[level];</span><br><span class="line">	dn-&gt;data_blkaddr = datablock_addr(dn-&gt;inode, dn-&gt;node_page, dn-&gt;ofs_in_node); <span class="comment">// 这个就是根据page index所得到的物理地址</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="node-footer-的作用"><a href="#node-footer-的作用" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#node-footer-的作用"></a> Node Footer 的作用</h2><p><code>footer</code> 是 F2FS 中记录 node 的属性的一个数据，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">f2fs_node</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_inode</span> <span class="title">i</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">direct_node</span> <span class="title">dn</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">indirect_node</span> <span class="title">in</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node_footer</span> <span class="title">footer</span>;</span></span><br><span class="line">&#125; __packed;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node_footer</span> &#123;</span></span><br><span class="line">	__le32 nid;		<span class="comment">/* node id */</span></span><br><span class="line">	__le32 ino;		<span class="comment">/* inode nunmber */</span></span><br><span class="line">	__le32 flag;		<span class="comment">/* include cold/fsync/dentry marks and offset */</span></span><br><span class="line">	__le64 cp_ver;		<span class="comment">/* checkpoint version */</span></span><br><span class="line">	__le32 next_blkaddr;	<span class="comment">/* next node page block address */</span></span><br><span class="line">&#125; __packed;</span><br></pre></td></tr></table></div></figure><p>F2FS 有三种类型的 node，分别是 <code>f2fs_inode</code>、<code>direct_node</code>、<code>indirect_node</code>，每一种类型的 node 都有对应的 footer。</p><h3 id="footer-nid-和-footer-ino"><a href="#footer-nid-和-footer-ino" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#footer-nid-和-footer-ino"></a> footer-&gt;nid 和 footer-&gt;ino</h3><p>每一个 node 都有一个独特的 <code>nid</code>，它被记录在 <code>footer</code> 中，如果是 <code>direct_node</code> 或者 <code>indirect_node</code>，它们都有一个对应的 <code>f2fs_inode</code>，因此为了记录从属关系，还需要 <code>footer</code> 记录它所属于的 <code>f2fs_inode</code> 的 <code>nid</code>，即 <code>ino</code>。因此，如果 <code>footer-&gt;nid == footer-&gt;ino</code>，那么这个 node 就是 inode，反正这个 <code>node</code> 是 <code>direct_node</code> 或者 <code>indirect_node</code>。</p><h3 id="footer-flag"><a href="#footer-flag" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#footer-flag"></a> footer-&gt;flag</h3><p><code>footer-&gt;flag</code> 的作用是标记当前的 node 的属性。目前 F2FS 给 node 定义了三种属性:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">	COLD_BIT_SHIFT = <span class="number">0</span>,</span><br><span class="line">	FSYNC_BIT_SHIFT,</span><br><span class="line">	DENT_BIT_SHIFT,</span><br><span class="line">	OFFSET_BIT_SHIFT</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OFFSET_BIT_MASK		(0x07)	<span class="comment">/* (0x01 &lt;&lt; OFFSET_BIT_SHIFT) - 1 */</span></span></span><br></pre></td></tr></table></div></figure><p>其中 <code>footer-&gt;flag</code>：</p><ul><li>第 0 位表示这个 node 是否是 cold node。</li><li>第 1 位表示这个 node 是否执行了完整的 fsync。F2FS 为了 <code>fsync</code> 的效率做了一些改进，F2FS 不会在 <code>fsync</code> 刷写所有脏的 node page 进去磁盘，只会刷写一些根据 data 直接相关的 node page 进入磁盘，例如 <code>f2fs_inode</code> 和 <code>direct_node</code>。因此这个标志位是用来记录这个 node 是否执行了完整的 fsync，以便系统在 crash 中恢复。</li><li>第 3 位表示这个 node 是是用来保存文件数据，还是目录数据的，也是用于数据恢复。</li></ul><h3 id="footer-cp_ver-和-footer-next_blkaddr"><a href="#footer-cp_ver-和-footer-next_blkaddr" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#footer-cp_ver-和-footer-next_blkaddr"></a> footer-&gt;cp_ver 和 footer-&gt;next_blkaddr</h3><p><code>footer-&gt;cp_ver</code> 分别用来记录当前的 checkpoint 的 version，恢复的时候比较 version 版本确定如何进行数据恢复。</p><p><code>footer-&gt;next_blkaddr</code> 则是用来记录这个 node 对应下一个 node page 的地址，也是用来恢复数据。</p><h2 id="rename-流程"><a href="#rename-流程" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#rename-流程"></a> rename 流程</h2><h3 id="流程介绍"><a href="#流程介绍" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#流程介绍"></a> 流程介绍</h3><ol><li>sys_rename 函数。</li><li>do_renameat2 函数。</li><li>vfs_rename 函数。</li><li>f2fs_rename 函数。</li></ol><h3 id="sys_rename-函数"><a href="#sys_rename-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#sys_rename-函数"></a> sys_rename 函数</h3><p>sys_rename 函数是一个系统调用，是 rename 函数进入内核层的第一个函数:</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE2(rename, <span class="type">const</span> <span class="type">char</span> __user *, oldname, <span class="type">const</span> <span class="type">char</span> __user *, newname)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// AT_FDCWD表示以相对路径的方法找oldname和newname这个文件，flags=0</span></span><br><span class="line">	<span class="keyword">return</span> do_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="do_renameat2-函数"><a href="#do_renameat2-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#do_renameat2-函数"></a> do_renameat2 函数</h3><p>do_renameat2 函数比较长，考虑多个输入 flag 的作用，这里只考虑 sys_rename 函数 rename 一个文件的情形，即 flag=0，并以此精简函数。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">do_renameat2</span><span class="params">(<span class="type">int</span> olddfd, <span class="type">const</span> <span class="type">char</span> __user *oldname, <span class="type">int</span> newdfd,</span></span><br><span class="line"><span class="params">			<span class="type">const</span> <span class="type">char</span> __user *newname, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">old_dentry</span>, *<span class="title">new_dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">trap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">old_path</span>, <span class="title">new_path</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">old_last</span>, <span class="title">new_last</span>;</span></span><br><span class="line">	<span class="type">int</span> old_type, new_type;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">delegated_inode</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">from</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">filename</span> *<span class="title">to</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> lookup_flags = <span class="number">0</span>, target_flags = LOOKUP_RENAME_TARGET;</span><br><span class="line">	<span class="type">bool</span> should_retry = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="comment">// 接下来两个函数最重要的作用是根据oldname和newname找到父目录的dentry结构</span></span><br><span class="line">    <span class="comment">// 这两个dentry结构保存在old_path和new_path中(注意是父目录的dentry)</span></span><br><span class="line">	from = filename_parentat(olddfd, getname(oldname), lookup_flags,</span><br><span class="line">				&amp;old_path, &amp;old_last, &amp;old_type);</span><br><span class="line"></span><br><span class="line">	to = filename_parentat(newdfd, getname(newname), lookup_flags,</span><br><span class="line">				&amp;new_path, &amp;new_last, &amp;new_type);</span><br><span class="line">    </span><br><span class="line">retry_deleg:</span><br><span class="line">    <span class="comment">// 这个函数会触发一个全局的rename的互斥锁，然后锁两个父目录inode结构</span></span><br><span class="line">	trap = lock_rename(new_path.dentry, old_path.dentry);</span><br><span class="line">	<span class="comment">// 根据old path的父目录找到需要被rename的文件的dentry</span></span><br><span class="line">	old_dentry = __lookup_hash(&amp;old_last, old_path.dentry, lookup_flags);</span><br><span class="line">	<span class="comment">// 根据new path的父目录找到或创建新的dentry</span></span><br><span class="line">	new_dentry = __lookup_hash(&amp;new_last, new_path.dentry, lookup_flags | target_flags);</span><br><span class="line">	<span class="comment">// 调用vfs_rename函数进行重命名</span></span><br><span class="line">    <span class="comment">// 传入的是新旧两个目录的inode，以及需要重命名的两个dentry， flags = 0</span></span><br><span class="line">	error = vfs_rename(old_path.dentry-&gt;d_inode, old_dentry,</span><br><span class="line">			   new_path.dentry-&gt;d_inode, new_dentry,</span><br><span class="line">			   &amp;delegated_inode, flags);</span><br><span class="line"></span><br><span class="line">	dput(new_dentry);</span><br><span class="line"></span><br><span class="line">	dput(old_dentry);</span><br><span class="line">    <span class="comment">// 解锁全局rename互斥锁，释放两个inode锁</span></span><br><span class="line">	unlock_rename(new_path.dentry, old_path.dentry);</span><br><span class="line"></span><br><span class="line">	path_put(&amp;new_path);</span><br><span class="line">	putname(to);</span><br><span class="line"></span><br><span class="line">	path_put(&amp;old_path);</span><br><span class="line">	putname(from);</span><br><span class="line"><span class="built_in">exit</span>:</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="vfs_rename-函数"><a href="#vfs_rename-函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#vfs_rename-函数"></a> vfs_rename 函数</h3><p>vfs_rename 函数也会做简化，简化的情形是将文件 A 重命名到文件 B(B 可能已经存在，或者不存在)，flags=0。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vfs_rename</span><span class="params">(<span class="keyword">struct</span> inode *old_dir, <span class="keyword">struct</span> dentry *old_dentry,</span></span><br><span class="line"><span class="params">	       <span class="keyword">struct</span> inode *new_dir, <span class="keyword">struct</span> dentry *new_dentry,</span></span><br><span class="line"><span class="params">	       <span class="keyword">struct</span> inode **delegated_inode, <span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> error;</span><br><span class="line">	<span class="type">bool</span> is_dir = d_is_dir(old_dentry);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">source</span> =</span> old_dentry-&gt;d_inode; <span class="comment">// 旧文件inode</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">target</span> =</span> new_dentry-&gt;d_inode; <span class="comment">// 新文件inode</span></span><br><span class="line">	<span class="type">bool</span> new_is_dir = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">unsigned</span> max_links = new_dir-&gt;i_sb-&gt;s_max_links;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">name_snapshot</span> <span class="title">old_name</span>;</span></span><br><span class="line"></span><br><span class="line">	dget(new_dentry); <span class="comment">// 对新文件的引用计数+1</span></span><br><span class="line">	<span class="keyword">if</span> (target)</span><br><span class="line">		inode_lock(target); <span class="comment">// 如果新文件已经存在，则上锁</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	error = old_dir-&gt;i_op-&gt;rename(old_dir, old_dentry,</span><br><span class="line">				       new_dir, new_dentry, flags);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">	<span class="keyword">if</span> (target)</span><br><span class="line">		inode_unlock(target); <span class="comment">// 如果新文件已经存在，则解锁</span></span><br><span class="line">	dput(new_dentry); <span class="comment">// 对新文件的引用计数-1</span></span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="f2fs_rename函数"><a href="#f2fs_rename函数" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#f2fs_rename函数"></a> f2fs_rename函数</h3><p>f2fs_rename 函数也会做简化，简化的情形是将文件A 重命名到文件 B(B 可能已经存在，或者不存在)，flags=0。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">f2fs_rename</span><span class="params">(<span class="keyword">struct</span> inode *old_dir, <span class="keyword">struct</span> dentry *old_dentry,</span></span><br><span class="line"><span class="params">			<span class="keyword">struct</span> inode *new_dir, <span class="keyword">struct</span> dentry *new_dentry,</span></span><br><span class="line"><span class="params">			<span class="type">unsigned</span> <span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_sb_info</span> *<span class="title">sbi</span> =</span> F2FS_I_SB(old_dir);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">old_inode</span> =</span> d_inode(old_dentry);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">new_inode</span> =</span> d_inode(new_dentry);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">whiteout</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_dir_page</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">old_page</span>, *<span class="title">new_page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dir_entry</span> *<span class="title">old_dir_entry</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dir_entry</span> *<span class="title">old_entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">f2fs_dir_entry</span> *<span class="title">new_entry</span>;</span></span><br><span class="line">	<span class="type">bool</span> is_old_inline = f2fs_has_inline_dentry(old_dir);</span><br><span class="line">	<span class="type">int</span> err;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 输入显然是</span></span><br><span class="line">    <span class="comment">// 旧的父目录old_dir，旧的文件old_dentry</span></span><br><span class="line">    <span class="comment">// 新的父目录new_dir，新的文件new_dentry</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据旧文件的名字找到对应的f2fs_dir_entry，old_page保存的是磁盘上的dir_entry数据</span></span><br><span class="line">	old_entry = f2fs_find_entry(old_dir, &amp;old_dentry-&gt;d_name, &amp;old_page);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (new_inode) &#123; <span class="comment">// 如果新文件已经存在</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据新文件的名字找到对应的f2fs_dir_entry，new_page保存的是磁盘上的数据</span></span><br><span class="line">		new_entry = f2fs_find_entry(new_dir, &amp;new_dentry-&gt;d_name,</span><br><span class="line">						&amp;new_page);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// F2FS获取一个全局读信号量</span></span><br><span class="line">		f2fs_lock_op(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在管理orphan inode的全局结构中，将orphan inode的数目+1。</span></span><br><span class="line">		err = f2fs_acquire_orphan_inode(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里进行新旧inode的link的变化:</span></span><br><span class="line">        <span class="comment">// 将new_dentry所属的inode指向old_inode</span></span><br><span class="line">        <span class="comment">// 因为rename的时候新inode是已经存在了，因此rename的操作就是将</span></span><br><span class="line">        <span class="comment">// 新路径原来的inode无效掉，然后替换为旧路径的inode</span></span><br><span class="line">		f2fs_set_link(new_dir, new_entry, new_page, old_inode);</span><br><span class="line"></span><br><span class="line">		new_inode-&gt;i_ctime = current_time(new_inode);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">		down_write(&amp;F2FS_I(new_inode)-&gt;i_sem); <span class="comment">// 拿写信号量</span></span><br><span class="line">		<span class="comment">// 减少新inode一个引用计数，因为被rename了</span></span><br><span class="line">		f2fs_i_links_write(new_inode, <span class="literal">false</span>);</span><br><span class="line">		up_write(&amp;F2FS_I(new_inode)-&gt;i_sem); <span class="comment">// 释放写信号量</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果引用计数下降到0，则添加到orphan inode中，在checkpoint管理</span></span><br><span class="line">		<span class="keyword">if</span> (!new_inode-&gt;i_nlink)</span><br><span class="line">			f2fs_add_orphan_inode(new_inode);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			f2fs_release_orphan_inode(sbi); <span class="comment">// 否则管理结构将orphan inode的数目-1。</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个情况是新路径的Inode不存在</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// F2FS获取一个全局读信号量</span></span><br><span class="line">		f2fs_lock_op(sbi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于新inode是不存在的，因此直接将旧inode添加到新的f2fs_dir_entry中</span></span><br><span class="line">		err = f2fs_add_link(new_dentry, old_inode);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">	down_write(&amp;F2FS_I(old_inode)-&gt;i_sem);</span><br><span class="line">	<span class="keyword">if</span> (!old_dir_entry || whiteout)</span><br><span class="line">		file_lost_pino(old_inode);  <span class="comment">// 这个操作要保留着用于数据恢复</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		F2FS_I(old_inode)-&gt;i_pino = new_dir-&gt;i_ino;</span><br><span class="line">	up_write(&amp;F2FS_I(old_inode)-&gt;i_sem);</span><br><span class="line"></span><br><span class="line">	old_inode-&gt;i_ctime = current_time(old_inode);</span><br><span class="line">	f2fs_mark_inode_dirty_sync(old_inode, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的数据已经加入到新的f2fs_dir_entry，因此旧entry就去去除掉</span></span><br><span class="line">	f2fs_delete_entry(old_entry, old_page, old_dir, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// F2FS释放全局读信号量</span></span><br><span class="line">	f2fs_unlock_op(sbi);</span><br><span class="line"></span><br><span class="line">	f2fs_update_time(sbi, REQ_TIME);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="参考文档"><a href="#参考文档" class="heading-link"><i class="fas fa-link"></i></a><a class="markdownIt-Anchor" href="#参考文档"></a> 参考文档</h1><ol><li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/RiweiPan/F2FS-NOTES">RiweiPan/F2FS-NOTES: F2FS的学习笔记以及源码分析</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://blog.davidingplus.cn">DavidingPlus</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://blog.davidingplus.cn/posts/257909f0.html">https://blog.davidingplus.cn/posts/257909f0.html</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-reward reward"><div class="reward-button">大爷，赏个铜板呗~~~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/images/reward/alipay.webp"><div class="reward-qrcode-alipay__text">支付宝</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/images/reward/wechat-pay.webp"><div class="reward-qrcode-wechat__text">微信</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/posts/1b712153.html"><span class="paginator-prev__text">计算机高级图形学 期末复习</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-f2fs"><span class="toc-number">1.</span> <span class="toc-text">为什么需要 F2FS？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">总体结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.</span> <span class="toc-text">系统特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%8D%95%E4%BD%8D"><span class="toc-number">2.1.1.</span> <span class="toc-text">基本数据单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lfs-%E5%BC%82%E5%9C%B0%E6%9B%B4%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.2.</span> <span class="toc-text">LFS 异地更新特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multi-head-logging%E5%A4%9A%E5%A4%B4%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.3.</span> <span class="toc-text">Multi-head Logging（多头日志写入）特性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AA%E5%AD%98%E8%AE%BE%E5%A4%87%E7%89%A9%E7%90%86%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text">闪存设备物理布局</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#superblock-%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.</span> <span class="toc-text">SuperBlock 区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_super_block-%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">f2fs_super_block 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_sb_info-%E7%BB%93%E6%9E%84"><span class="toc-number">3.2.</span> <span class="toc-text">f2fs_sb_info 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#init_sb_info"><span class="toc-number">3.3.</span> <span class="toc-text">init_sb_info()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#checkpoint-%E5%8C%BA%E5%9F%9F"><span class="toc-number">4.</span> <span class="toc-text">CheckPoint 区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_checkpoint-%E7%BB%93%E6%9E%84"><span class="toc-number">4.1.</span> <span class="toc-text">f2fs_checkpoint 结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#orphan-node"><span class="toc-number">4.2.</span> <span class="toc-text">Orphan Node</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#active-segments"><span class="toc-number">4.3.</span> <span class="toc-text">Active Segments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">4.4.</span> <span class="toc-text">内存管理结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#segment-infomation-table-%E5%8C%BA%E5%9F%9F"><span class="toc-number">5.</span> <span class="toc-text">Segment Infomation Table 区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.</span> <span class="toc-text">元数据的物理结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84-2"><span class="toc-number">5.2.</span> <span class="toc-text">内存管理结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#node-address-table-%E5%8C%BA%E5%9F%9F"><span class="toc-number">6.</span> <span class="toc-text">Node Address Table 区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-2"><span class="toc-number">6.1.</span> <span class="toc-text">元数据的物理结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%BB%93%E6%9E%84-3"><span class="toc-number">6.2.</span> <span class="toc-text">内存管理结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#segment-summary-area-%E5%8C%BA%E5%9F%9F"><span class="toc-number">7.</span> <span class="toc-text">Segment Summary Area 区域</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84-3"><span class="toc-number">7.1.</span> <span class="toc-text">元数据的物理结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">文件数据组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_node-%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8"><span class="toc-number">8.1.</span> <span class="toc-text">f2fs_node 结构及其作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC-node-%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.1.</span> <span class="toc-text">基本 node 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_inode-%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.2.</span> <span class="toc-text">f2fs_inode 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#direct_node-%E5%92%8C-indirect_node-%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.3.</span> <span class="toc-text">direct_node 和 indirect_node 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wandering-tree-%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.4.</span> <span class="toc-text">Wandering Tree 问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="toc-number">8.2.</span> <span class="toc-text">普通文件数据的保存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E5%AD%98"><span class="toc-number">8.3.</span> <span class="toc-text">内联数据文件的保存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BF%E9%97%AE%E7%9A%84%E5%AE%9E%E9%99%85%E4%BE%8B%E5%AD%90"><span class="toc-number">8.4.</span> <span class="toc-text">文件访问的实际例子</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">读流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#generic_file_read_iter-%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">generic_file_read_iter 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#generic_file_buffered_read-%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">generic_file_buffered_read 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_read_data_page-f2fs_read_data_pages-%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">f2fs_read_data_page &amp; f2fs_read_data_pages 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_mpage_readpages%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">f2fs_mpage_readpages函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">写流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_file_write_iter%E5%87%BD%E6%95%B0"><span class="toc-number">10.1.</span> <span class="toc-text">f2fs_file_write_iter函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_write_begin-%E5%92%8C-f2fs_write_end-%E5%87%BD%E6%95%B0"><span class="toc-number">10.2.</span> <span class="toc-text">f2fs_write_begin 和 f2fs_write_end 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_write_data_pages-%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.</span> <span class="toc-text">f2fs_write_data_pages 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_write_data_pages-__f2fs_write_data_pages-%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.1.</span> <span class="toc-text">f2fs_write_data_pages &amp; __f2fs_write_data_pages 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_write_cache_pages-%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.2.</span> <span class="toc-text">f2fs_write_cache_pages 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#__write_data_page-%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.3.</span> <span class="toc-text">__write_data_page 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_do_write_data_page-%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.4.</span> <span class="toc-text">f2fs_do_write_data_page 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_outplace_write_data-%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.5.</span> <span class="toc-text">f2fs_outplace_write_data 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do_write_page-%E5%87%BD%E6%95%B0"><span class="toc-number">10.3.6.</span> <span class="toc-text">do_write_page 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">文件创建流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#inode-%E5%92%8C-f2fs_inode_info"><span class="toc-number">11.1.</span> <span class="toc-text">inode 和 f2fs_inode_info</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">11.1.1.</span> <span class="toc-text">相互转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfs-inode-%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81"><span class="toc-number">11.1.2.</span> <span class="toc-text">VFS inode 的创建和销毁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_create-%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">f2fs_create 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_new_inode-%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.1.</span> <span class="toc-text">f2fs_new_inode 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_add_link-%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.2.</span> <span class="toc-text">f2fs_add_link 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="toc-number">12.</span> <span class="toc-text">重要数据结构和函数分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_summary-%E5%92%8C-f2fs_summary_block"><span class="toc-number">12.1.</span> <span class="toc-text">f2fs_summary 和 f2fs_summary_block</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">12.1.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seg_entry-%E5%92%8C-sit_info"><span class="toc-number">12.2.</span> <span class="toc-text">seg_entry 和 sit_info</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#seg_entry-%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.1.</span> <span class="toc-text">seg_entry 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="toc-number">12.2.1.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-2"><span class="toc-number">12.2.1.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#curseg_info-%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.2.</span> <span class="toc-text">curseg_info 结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-3"><span class="toc-number">12.2.2.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#curseg_info-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.2.2.2.</span> <span class="toc-text">curseg_info 的作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs-journal-%E6%9C%BA%E5%88%B6"><span class="toc-number">12.3.</span> <span class="toc-text">F2FS Journal 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D-4"><span class="toc-number">12.3.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.3.2.</span> <span class="toc-text">涉及到的数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.3.3.</span> <span class="toc-text">一些机制的具体实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-journal-%E8%8E%B7%E5%8F%96-node-%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">12.3.3.1.</span> <span class="toc-text">通过 Journal 获取 Node 的地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-checkpoint-%E5%B0%86-journal-%E7%9A%84%E4%BF%A1%E6%81%AF%E5%86%99%E5%85%A5%E5%88%B0%E7%A3%81%E7%9B%98%E4%B8%AD"><span class="toc-number">12.3.3.2.</span> <span class="toc-text">通过 Checkpoint 将 journal 的信息写入到磁盘中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#f2fs_map_blocks-%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">12.4.</span> <span class="toc-text">f2fs_map_blocks 的作用与源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%B5%81%E7%A8%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.4.1.</span> <span class="toc-text">读写流程的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.4.2.</span> <span class="toc-text">核心数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%B5%81%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">12.4.3.</span> <span class="toc-text">读流程的核心逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%B5%81%E7%A8%8B%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91"><span class="toc-number">12.4.4.</span> <span class="toc-text">写流程的核心逻辑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%AF%BB%E5%9D%80%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.5.</span> <span class="toc-text">物理地址寻址的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">12.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95"><span class="toc-number">12.5.2.</span> <span class="toc-text">函数用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80%E5%8E%9F%E7%90%86"><span class="toc-number">12.5.3.</span> <span class="toc-text">寻址原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%BD%8D%E4%BA%8E-f2fs_inode"><span class="toc-number">12.5.3.1.</span> <span class="toc-text">例子 1: 物理地址位于 f2fs_inode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%BD%8D%E4%BA%8E-direct_node"><span class="toc-number">12.5.3.2.</span> <span class="toc-text">例子 2: 物理地址位于 direct_node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%BD%8D%E4%BA%8E-indirect_node"><span class="toc-number">12.5.3.3.</span> <span class="toc-text">例子 3: 物理地址位于 indirect_node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-4-%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E4%BD%8D%E4%BA%8E-indirect_node-%E5%86%8D-indiret_node-%E4%B8%AD-double-indirect-node"><span class="toc-number">12.5.3.4.</span> <span class="toc-text">例子 4: 物理地址位于 indirect_node 再 indiret_node 中 (double indirect node)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#node-footer-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.6.</span> <span class="toc-text">Node Footer 的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#footer-nid-%E5%92%8C-footer-ino"><span class="toc-number">12.6.1.</span> <span class="toc-text">footer-&gt;nid 和 footer-&gt;ino</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#footer-flag"><span class="toc-number">12.6.2.</span> <span class="toc-text">footer-&gt;flag</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#footer-cp_ver-%E5%92%8C-footer-next_blkaddr"><span class="toc-number">12.6.3.</span> <span class="toc-text">footer-&gt;cp_ver 和 footer-&gt;next_blkaddr</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rename-%E6%B5%81%E7%A8%8B"><span class="toc-number">12.7.</span> <span class="toc-text">rename 流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.7.1.</span> <span class="toc-text">流程介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sys_rename-%E5%87%BD%E6%95%B0"><span class="toc-number">12.7.2.</span> <span class="toc-text">sys_rename 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#do_renameat2-%E5%87%BD%E6%95%B0"><span class="toc-number">12.7.3.</span> <span class="toc-text">do_renameat2 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vfs_rename-%E5%87%BD%E6%95%B0"><span class="toc-number">12.7.4.</span> <span class="toc-text">vfs_rename 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#f2fs_rename%E5%87%BD%E6%95%B0"><span class="toc-number">12.7.5.</span> <span class="toc-text">f2fs_rename函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">13.</span> <span class="toc-text">参考文档</span></a></li></ol></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/android-chrome-512x512.webp" alt="avatar"></div><p class="sidebar-ov-author__text">Self-discipline is key in life.</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/DavidingPlus" target="_blank" rel="noopener" data-popover="GitHub" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/qq/" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="/wechat/" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="mailto:davidingplus@qq.com" target="_blank" rel="noopener" data-popover="davidingplus@qq.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">38</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">21</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">您已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023~2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>DavidingPlus</span><span class="footer__devider">|</span><span>蜀 ICP 备 2024088070 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.6</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("09/18/2023 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小破站已经安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒啦！"}setInterval("createtime()",250)</script></div><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;theme&quot;:&quot;default&quot;}" src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/mermaid.min.js"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></div></footer><div class="loading-animation" id="loading-animation"><div class="loading-animation__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-thumbs-up"></i></span></div><div class="back2bottom" id="back2bottom"><span class="back2bottom__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"><div class="search-btns">使用搜索：<span class="search-btns-item search-btns-item--bing"><i></i>必应</span><span class="search-btns-item search-btns-item--baidu"><i></i>百度</span></div></div><div class="search-results"></div></div><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/jquery.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity-ui.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/canvas-nest.js" color="255,255,255" opacity="1" count="99" zindex="-1"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/fancybox.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/masonry.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/lazyload.js"></script><script>function initSearch(){var e=!0,t="search.json";t?/json$/i.test(t)&&(e=!1):t="search.xml";var n="/"+t;$.ajax({url:n,dataType:e?"xml":"json",async:!0,success:function(t){var n=e?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,o=$(".search-input input"),i=$(".search-results"),c=100,r=1,a=function(){var e=o.val().toLowerCase().trim(),t=e.split(/[\s]+/),a=[];t.length>1&&t.push(e),e.length>0&&n.forEach(function(e){var n=!1,o=e.title&&e.title.trim()||"[ 文章无标题 ]",i=o&&o.toLowerCase(),s=e.content&&e.content.replace(/<[^>]+>/g,""),l=s&&s.toLowerCase(),u=e.url&&decodeURI(e.url).replace(/\/{2,}/g,"/"),h=[],d=[];t.forEach(function(e){function t(e,t,n,o){if(!e||!t)return[];var i=0,c=-1,r=[];for(n||(e=e.toLowerCase(),t=t.toLowerCase());-1!==(c=t.indexOf(e,i));){var a=!1;h.forEach(function(t){t.index===c&&t.word.length<e.length&&(t.word=e,a=!0)}),i=c+e.length,!a&&r.push({index:c,word:e,weight:o})}return r}h=h.concat(t(e,i,!1,c)),d=d.concat(t(e,l,!1,r))});var f=h.length,p=d.length;if((f>0||p>0)&&(n=!0),n){function w(e,t,n,o){if(e&&t&&t.length){var i="",c=n,r=o;return t.forEach(function(t){if(!(t.index<c)){var n=t.index+t.word.length;i+=e.slice(c,t.index),i+="<b>"+e.slice(t.index,n)+"</b>",c=n}}),i+=e.slice(c,r)}}[h,d].forEach(function(e){e.sort(function(e,t){return e.index-t.index})});var v,g={},x=h.length*c+d.length*r,y=w(o,h,0,o.length)||o;if(d.length>0){var S=d[0].index;v=w(s,d,S>20?S-20:0,S+180)}else v=s.slice(0,200);g.title=y,g.content=v,g.url=u,g.weight=x,a.push(g)}});var s="";a.length?(a.sort(function(e,t){return t.weight-e.weight}),s+="<ul>",a.forEach(function(e){s+='<li><a class="search-results-title" href="'+e.url+'">',s+=e.title,s+='</a><div class="search-results-content">',s+=e.content,s+="</div></li>"}),s+="</ul>"):s+='<div class="search-results-none"><i class="far fa-meh"></i></div>',i.html(s)};o.on("input",a),o.on("keyup",function(e){e.keyCode===Stun.utils.codeToKeyCode("Enter")&&a()})}})}function closeSearch(){$("body").css({overflow:"auto"}),$(".search-popup").css({display:"none"}),$(".search-mask").css({display:"none"})}function safeOpenUrl(e){var t=window.open();t.opener=null,t.location=e}function extSearch(e){var t=window.location.host,n=$(".search-input input").val().toLowerCase().trim();n?safeOpenUrl({google:"https://www.google.com/search?q=",bing:"https://cn.bing.com/search?q=",baidu:"https://www.baidu.com/s?ie=UTF-8&wd="}[e]+n+" site:"+t):Stun.utils.popAlert("warning","请输入字符")}window.addEventListener("DOMContentLoaded",function(){Stun.utils.pjaxReloadLocalSearch=function(){$(".header-nav-search").on("click",function(e){e.stopPropagation(),$("body").css("overflow","hidden"),$(".search-popup").velocity("stop").velocity("transition.expandIn",{duration:300,complete:function(){$(".search-popup input").focus()}}),$(".search-mask").velocity("stop").velocity("transition.fadeIn",{duration:300}),initSearch()}),$(".search-mask, .search-close").on("click",function(){closeSearch()}),$(document).on("keydown",function(e){e.keyCode===Stun.utils.codeToKeyCode("Escape")&&closeSearch()})},Stun.utils.pjaxReloadLocalSearch()},!1);var assistSearchList=window.CONFIG.assistSearch;Array.isArray(assistSearchList)&&assistSearchList.forEach(function(e){document.querySelector(".search-btns-item--"+e).addEventListener("click",function(){extSearch(e)},!1)})</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/pjax.js"></script><script>window.addEventListener("DOMContentLoaded",function(){new Pjax({selectors:["head title","#main",".pjax-reload",".header-banner"],history:!0,scrollTo:!1,scrollRestoration:!1,cacheBust:!1,debug:!1,currentUrlFullReload:!1,timeout:0});document.addEventListener("pjax:send",function(){$(".header-nav-menu").removeClass("show"),CONFIG.pjax&&CONFIG.pjax.avoidBanner&&$("html").velocity("scroll",{duration:500,offset:$("#header").height(),easing:"easeInOutCubic"}),$(".loading-animation").addClass("loading")},!1),window.addEventListener("pjax:complete",function(){if($(".loading-animation").removeClass("loading"),$("link[rel=prefetch], script[data-pjax-rm]").each(function(){$(this).remove()}),$("script[data-pjax], #pjax-reload script").each(function(){$(this).parent().append($(this).remove())}),Stun.utils.pjaxReloadBoot&&Stun.utils.pjaxReloadBoot(),Stun.utils.pjaxReloadScroll&&Stun.utils.pjaxReloadScroll(),Stun.utils.pjaxReloadSidebar&&Stun.utils.pjaxReloadSidebar(),"undefined"!=typeof mermaid){const e=Array.from(document.querySelectorAll(".mermaid")).filter(e=>!e.dataset.processed);mermaid.init(void 0,e)}},!1)},!1)</script><div id="pjax-reload"><link href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/katex.min.css" rel="stylesheet" type="text/css"><link href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/copy-tex.css" rel="stylesheet" type="text/css"><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/copy-tex.min.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/quicklink.js"></script><script>function initQuicklink(){quicklink({timeout:"10000",priority:!0,ignores:[i=>i.includes("#"),i=>"https://blog.davidingplus.cn/posts/257909f0.html"===i,/\/api\/?/,i=>i.includes(".xml"),i=>i.includes(".zip"),(i,t)=>t.hasAttribute("nofollow"),(i,t)=>t.hasAttribute("noprefetch")]})}initQuicklink()</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/busuanzi.js" async></script></div><script src="/js/utils.js?v=2.8.6"></script><script src="/js/stun-boot.js?v=2.8.6"></script><script src="/js/scroll.js?v=2.8.6"></script><script src="/js/header.js?v=2.8.6"></script><script src="/js/sidebar.js?v=2.8.6"></script><script type="application/json" src="/search.json"></script><script data-pjax="">function loadUtterances(){var t=document,e=t.createElement("script"),s=t.getElementById("utterances-container"),r=Stun.utils.getNightMode()?"photon-dark":"github-light";s&&(e.src="https://utteranc.es/client.js",e.setAttribute("repo","DavidingPlus/blog-comments"),e.setAttribute("issue-term","title"),e.setAttribute("label","utterances"),e.setAttribute("theme",r),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),e.setAttribute("data-pjax-rm",""),s.append(e))}loadUtterances()</script><script async src="/js/cursor/text.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="🤡快回来,粗大事了~~"+OriginTitile,clearTimeout(titleTime)):(document.title="😚欢迎回来!~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:160,height:290},mobile:{show:!0},log:!1})</script></body></html>