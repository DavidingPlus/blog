<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><script>window.MSInputMethodContext&&document.documentMode&&(window.location.href="https://support.dmeng.net/upgrade-your-browser.html")</script><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/favicon-16x16.webp?v=2.8.6" type="image/png" sizes="16x16"><link rel="icon" href="/assets/favicon-32x32.webp?v=2.8.6" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/assets/apple-touch-icon.webp?v=2.8.6" sizes="180x180"><meta name="description" content="面向对象高级开发                           Header头文件的防卫式声明       12345678910&#x2F;&#x2F;complex.h#ifndef __COMPLEX__#define __COMPLEX__&#x2F;&#x2F;含义:如果程序没有定义过，那么定义出来，走主体内容；如果程序定义过，第二次include时，那么就不走，直接返回，不会"><meta property="og:type" content="article"><meta property="og:title" content="侯捷老师 C++ 课程"><meta property="og:url" content="https://blog.davidingplus.cn/posts/2abc6e08.html"><meta property="og:site_name" content="DavidingPlus&#39;s Blog"><meta property="og:description" content="面向对象高级开发                           Header头文件的防卫式声明       12345678910&#x2F;&#x2F;complex.h#ifndef __COMPLEX__#define __COMPLEX__&#x2F;&#x2F;含义:如果程序没有定义过，那么定义出来，走主体内容；如果程序定义过，第二次include时，那么就不走，直接返回，不会"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412174017480.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412174017480.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412185656797.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412202635207.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412203303042.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412204435460.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412210437066.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412212341135.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230413163206633.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230413211543101.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414100854356.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414114802698.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414161555294.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414171828137.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415143355398.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415143409298.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415145105415.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415145711652.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415150557574.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415150706680.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415154938692.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415154949602.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415160759007.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415165550803.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416094923459.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095052581.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095559995.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095953933.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416101021861.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416101451151.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416102010067.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416102442772.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416105043344.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416105348361.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416110401962.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416154815162.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416160403390.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416163304200.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416171855901.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416174305071.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419170456164.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419170815213.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419190233258.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419192921703.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419195537174.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419195610102.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419201320469.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420164335846.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170120084.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170739434.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170150250.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420172205138.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420172617688.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420173341877.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420173832550.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420174307662.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193008988.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193316669.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193754702.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421103130501.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104600566.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104609426.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104723249.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421105352734.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421175541816.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421182526116.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421182650170.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421192116968.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421194843419.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422140640649.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422143136762.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422144338234.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422145128498.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422154019414.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422154054412.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422155807393.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422162235208.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422162614061.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422163446874.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422171334117.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422183037284.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423113446373.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423171745364.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423175336384.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423202430305.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423203719337.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423210411376.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424161751257.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424162149742.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424162843434.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424163242826.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424170726596.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424172134280.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425185823723.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425191652925.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425194548756.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425194051698.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425200558918.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425203641882.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425205345712.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230426151146418.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427111200767.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427112849536.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427170952730.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427171431489.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230430111248498.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504191205113.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504191639232.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504201206953.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504202940442.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504213412890.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504213510643.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505102818021.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505152557462.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505195009665.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505190504411.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505195056962.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505213553781.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230514163001551.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230514170850534.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230514171027632.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516105734995.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516114646497.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516165803938.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516203937375.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516205607537.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516212207244.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221129783.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221225536.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221737119.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230517141545661.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518140540645.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518140911306.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518143501227.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518150122803.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518154018869.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518160118276.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518161942376.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518163205880.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518164140667.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518170044346.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518171104774.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528130010432.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528141445828.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528144912141.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528145254800.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528150844128.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528151704324.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528152603160.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528153147163.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528153255732.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528160530816.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528155257804.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528160553832.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528171600254.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529203344173.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529204213232.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529205010426.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529210322971.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529210616933.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211045422.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211059007.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211708274.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530104526960.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530112053633.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530124448776.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530124835651.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530130901615.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530132204861.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530133728815.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530134659332.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530135356839.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530135902882.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530192809660.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530193556966.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530194432937.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200004843.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200614422.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200925564.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530215144034.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530220728994.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531095651457.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531095545741.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531105901120.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531110714412.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531113514416.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531112717690.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531133126758.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531134700621.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531143041896.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609153221116.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609155142232.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609160227418.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609161327736.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711103421403.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711103208976.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711110249938.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711111102518.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711111833403.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142511891.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142536025.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142846401.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711143546194.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711144447440.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711144615462.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711145211456.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711145521073.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711150915653.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711154726911.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155355589.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155536393.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155719096.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711161106242.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711161901208.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711162120179.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230712145001503.png"><meta property="article:published_time" content="2023-09-20T01:00:00.000Z"><meta property="article:modified_time" content="2023-09-20T01:00:00.000Z"><meta property="article:author" content="DavidingPlus"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412174017480.png"><title>侯捷老师 C++ 课程 | DavidingPlus's Blog</title><link ref="canonical" href="https://blog.davidingplus.cn/posts/2abc6e08.html"><link rel="dns-prefetch" href="https://cdn.davidingplus.cn"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fontawesome.css" type="text/css"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fancybox.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.6"><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,assistSearch:["bing","baidu"],fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"55px",tocMaxDepth:6},header:{enable:!0,showOnPost:!0,scrollDownIcon:!0},postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},back2bottom:{enable:!0},codeblock:{style:"default",highlight:"light",wordWrap:!0},reward:!0,fancybox:!0,zoomImage:{gapAside:"20px"},galleryWaterfall:{colWidth:"255px",gapX:"65px"},lazyload:!0,pjax:{avoidBanner:!0},externalLink:{icon:{enable:!0,name:"fas fa-external-link-alt"}},shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"恭喜亲亲，复制成功咧",copyError:"哎呀，复制失败了"},sourcePath:{js:"js",css:"css",images:"images"},utterancesTheme:{light:"github-light",dark:"photon-dark"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-bars"></i></span><span class="header-nav-menu-item__text">其他</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/friends/"><span class="header-nav-submenu-item__icon"><i class="fas fa-users"></i></span><span class="header-nav-submenu-item__text">友链</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/gallery/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" target="_blank" rel="noopener" href="https://davidingplus.cn/"><span class="header-nav-menu-item__icon"><i class="fas fa-pager"></i></span><span class="header-nav-menu-item__text">站点主页</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">DavidingPlus's Blog</div><div class="header-banner-info__subtitle">🕊️ world peace</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">侯捷老师 C++ 课程</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2023-09-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-09-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">47.6k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">386分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><meta name="referrer" content="no-referrer"><h1 id="面向对象高级开发"><a href="#面向对象高级开发" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向对象高级开发" class="headerlink" title="面向对象高级开发"></a>面向对象高级开发</h1><h2 id="Header头文件的防卫式声明"><a href="#Header头文件的防卫式声明" class="heading-link"><i class="fas fa-link"></i></a><a href="#Header头文件的防卫式声明" class="headerlink" title="Header头文件的防卫式声明"></a>Header头文件的防卫式声明</h2><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//complex.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __COMPLEX__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __COMPLEX__</span></span><br><span class="line"><span class="comment">//含义:如果程序没有定义过，那么定义出来，走主体内容；如果程序定义过，第二次include时，那么就不走，直接返回，不会有重复include的动作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主体内容</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><span id="more"></span><h2 id="inline-函数"><a href="#inline-函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#inline-函数" class="headerlink" title="inline 函数"></a>inline 函数</h2><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">    </span><br><span class="line">   	<span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> re; &#125;<span class="comment">//如果函数在类内声明并且定义完成，那么这个函数就是个inline函数</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> re,im;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">double</span></span></span><br><span class="line"><span class="function"><span class="title">real</span><span class="params">(<span class="type">const</span> complex&amp; x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.<span class="built_in">real</span>();</span><br><span class="line">&#125;<span class="comment">//inline的执行速度会快一点!</span></span><br></pre></td></tr></table></div></figure><p>为了减少时间开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++系统会自动将它们作为内置(inline)函数来处理。</p><p>C++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为这些成员函数已被隐含地指定为内置函数。</p><p>如果成员函数不在类体内定义，而在类体外定义，系统并不把它默认为内置(inline)函数，调用这些成员函数的过程和调用一般函数的过程是相同的。如果想将这些成员函数指定为内置函数，应当用inline作显式声明。</p><p>如果函数太复杂，编译器没有办法把他看成 inline 函数!! 所以我们在类内实现只是为了建议编译器将其看成 inline 函数来提高效率，但是实际上是不是 inline 函数要看编译器，我们也不知道！</p><h2 id="单例设计模式-构造函数在private部分"><a href="#单例设计模式-构造函数在private部分" class="heading-link"><i class="fas fa-link"></i></a><a href="#单例设计模式-构造函数在private部分" class="headerlink" title="单例设计模式(构造函数在private部分)"></a>单例设计模式(构造函数在private部分)</h2><p>例子：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件 Stu.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __STU__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __STU__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Stu &amp;<span class="title">getInstance</span><span class="params">()</span></span>;<span class="comment">//单例设计模式 在主程序当中只能使用一份这个类的数据 所有共享 所以静态变量放在堆区</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Stu</span>();</span><br><span class="line">    <span class="built_in">Stu</span>(<span class="type">int</span> id, string name);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _ID;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stu &amp;<span class="title">Stu::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> Stu stu;</span><br><span class="line">    <span class="keyword">return</span> stu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主程序 main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Stu.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 单例设计模式</span></span><br><span class="line">    <span class="comment">// 构造函数在private里面 整个类是放在static堆区的 所有用户只用一份这个类的数据</span></span><br><span class="line">    <span class="keyword">auto</span> stu = Stu::<span class="built_in">getInstance</span>(); <span class="comment">// 这样就创造出来了一个类 并且是静态变量!!!程序共享这一份</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="const-常量成员函数"><a href="#const-常量成员函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#const-常量成员函数" class="headerlink" title="const 常量成员函数"></a>const 常量成员函数</h2><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//complex类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;<span class="comment">//成员函数 不改变类成员属性的值 建议加上const修饰，换句话说就是拿数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> re, im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>成员函数不改变类成员属性的值建议加上const修饰，换句话说就是拿数据.例如上面的real()和imag()都不改变成员属性的值，所以加上了const修饰。</p><p>在上面的例子当中，如果那两个成员函数不加上const，会出现什么情况呢？</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="type">const</span> complex <span class="title">c</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;<span class="comment">//使用者定义这个类是不可以改变的</span></span><br><span class="line">std::cout&lt;&lt;c.<span class="built_in">real</span>();<span class="comment">//打印real()</span></span><br></pre></td></tr></table></div></figure><p>这是未加const的成员函数</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> im; &#125;</span><br></pre></td></tr></table></div></figure><p>打印real()会出问题，因为使用者不想要改变c里面元素的值，但是这个成员函数在访问的时候不加const，编译器认为有可能会改变成员函数的值，这两者是相互矛盾的，所以会报错，所以需要加上const来保证是不会改变值的。</p><h2 id="引用-指针常量-指针指向不可修改"><a href="#引用-指针常量-指针指向不可修改" class="heading-link"><i class="fas fa-link"></i></a><a href="#引用-指针常量-指针指向不可修改" class="headerlink" title="引用(指针常量 指针指向不可修改)"></a>引用(指针常量 指针指向不可修改)</h2><p>引用的本质: 是一个指针常量</p><p>为什么选择引用: 传递非常快，并且可以解决形参修改不改变实参的问题</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a=<span class="number">10</span>;</span><br><span class="line"><span class="comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span></span><br><span class="line"><span class="type">int</span>&amp; ref = a; </span><br><span class="line">ref = <span class="number">20</span>; <span class="comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span></span><br></pre></td></tr></table></div></figure><p>引用是不可修改的，因为引用本质是指针常量，该指针的值是不可修改的，也就是指向的地址区域(a)是不可以变动的，但是解引用修改指向区域的值是完全没有问题的。</p><p>所以考虑到这两个问题，在实际操作过程中尽量传入引用。</p><h2 id="friend-友元"><a href="#friend-友元" class="heading-link"><i class="fas fa-link"></i></a><a href="#friend-友元" class="headerlink" title="friend 友元"></a>friend 友元</h2><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//complex类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">complex</span>(<span class="type">double</span> r = <span class="number">0</span>, <span class="type">double</span> i = <span class="number">0</span>) : <span class="built_in">re</span>(r), <span class="built_in">im</span>(i) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> re; &#125;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">imag</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> im; &#125;<span class="comment">//成员函数 不改变类成员属性的值 建议加上const修饰，换句话说就是拿数据</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">double</span> re, im;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">friend</span> complex &amp;__doapl(complex*, <span class="type">const</span> complex&amp; );<span class="comment">//第二个参数传入另一个类对象的引用</span></span><br><span class="line">  <span class="comment">//friend友元表示另一个类对象可以访问本类当中的私有成员属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> complex &amp;</span><br><span class="line">__doapl(complex *ths, <span class="type">const</span> complex &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">  ths-&gt;re += r.re;<span class="comment">//这里就可以直接访问本类的私有成员属性</span></span><br><span class="line">  ths-&gt;im += r.im;</span><br><span class="line">  <span class="keyword">return</span> *ths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="重点："><a href="#重点：" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点：" class="headerlink" title="重点："></a>重点：</h3><p>相同class的各个objects互为friends 友元</p><p>还是上面的例子</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类内</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> complex&amp; param)</span></span>&#123; <span class="keyword">return</span> param.re + param.im;&#125;</span><br><span class="line"><span class="comment">//这里为什么可以直接访问私有成员属性</span></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line">c<span class="number">2.f</span>unc(c1);</span><br></pre></td></tr></table></div></figure><p>两种理解:</p><p>1.相同class的各个objects互为友元，所以可以访问私有属性</p><p>2.私有成员属性可以类内访问，类外不可以访问，需要访问需要成员函数接口</p><h2 id="return-by"><a href="#return-by" class="heading-link"><i class="fas fa-link"></i></a><a href="#return-by" class="headerlink" title="return by *"></a>return by *</h2><h3 id="return-by-reference"><a href="#return-by-reference" class="heading-link"><i class="fas fa-link"></i></a><a href="#return-by-reference" class="headerlink" title="return by reference"></a>return by reference</h3><p>传送着无需知道接收者是以reference接受</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex&amp;</span><br><span class="line">complex::<span class="keyword">operator</span> += (<span class="type">const</span> complex &amp;r)&#123;</span><br><span class="line">    <span class="keyword">return</span> __doapl(<span class="keyword">this</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>实现 +&#x3D; 号的重载(复数)</p><p>为什么要返回 &amp; ：因为不能创建新对象，我们的目的是修改原对象！！！</p><p>这样做可以实现连加操作 c1 +&#x3D; c2 + &#x3D;c3</p><p>关于运算符重载返回reference还有一个例子</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 类内的函数会默认为内置inline函数</span></span><br><span class="line">    <span class="built_in">Stu</span>();</span><br><span class="line">    <span class="built_in">Stu</span>(<span class="type">int</span> id, string name) : _ID(id), _name(name) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getID</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ID; &#125;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_name; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _ID;</span><br><span class="line">    string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这种特殊的操作符重载只能写在全局，因为写在类里面无法达到 cout&lt;&lt;p 的效果</span></span><br><span class="line"><span class="keyword">inline</span> ostream &amp; <span class="comment">//返回ostream标准流的引用</span></span><br><span class="line"><span class="comment">//关于返回值 需要考虑连传的话需要返回引用!!!</span></span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, Stu &amp;s)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; s.<span class="built_in">getID</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; s.<span class="built_in">getName</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Stu <span class="title">s</span><span class="params">(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s;<span class="comment">//这样可以实现连 &lt;&lt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="return-by-value"><a href="#return-by-value" class="heading-link"><i class="fas fa-link"></i></a><a href="#return-by-value" class="headerlink" title="return by value:"></a>return by value:</h3><p>什么时候只能return by value?我们应该优先考虑return by reference，但是在这个函数返回值的时候需要创建一个新的对象的时候只能return by value</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> complex</span><br><span class="line"><span class="keyword">operator</span>+(<span class="type">const</span> complex &amp;x,<span class="type">const</span> complex &amp;y)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">complex</span>(<span class="built_in">real</span>(x)+<span class="built_in">real</span>(y),<span class="built_in">imag</span>(x)+<span class="built_in">imag</span>(y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c2=c1+c2;<span class="comment">//这行代码的意思是c1+c2创建出来一个新的对象赋值给c2!!!</span></span><br></pre></td></tr></table></div></figure><h2 id="class-with-pointer-members-带有指针的类"><a href="#class-with-pointer-members-带有指针的类" class="heading-link"><i class="fas fa-link"></i></a><a href="#class-with-pointer-members-带有指针的类" class="headerlink" title="class with pointer members 带有指针的类"></a>class with pointer members 带有指针的类</h2><p>比较经典的类就是string字符串类,必须有拷贝构造 copy ctor和拷贝赋值 copy op&#x3D;</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *cstr = <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 只要类带指针，一定要重写以下两个函数!!!</span></span><br><span class="line">    <span class="comment">// 不重写的话编译器默认的构造函数是浅拷贝 两个指针指向同一块内存对象!!!</span></span><br><span class="line">    <span class="comment">// 当然这里的拷贝指的是深拷贝</span></span><br><span class="line">    <span class="built_in">String</span>(<span class="type">const</span> String &amp;str);            <span class="comment">// 拷贝构造</span></span><br><span class="line">    String &amp;<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;str); <span class="comment">// 拷贝赋值</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">String</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">get_c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *_data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>当然这里的拷贝指的是深拷贝!!!</p><p>Big Three:拷贝构造，拷贝赋值，析构函数!!!!!!</p><h3 id="拷贝赋值-检测自我赋值"><a href="#拷贝赋值-检测自我赋值" class="heading-link"><i class="fas fa-link"></i></a><a href="#拷贝赋值-检测自我赋值" class="headerlink" title="拷贝赋值:检测自我赋值"></a>拷贝赋值:检测自我赋值</h3><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> String &amp;String::<span class="keyword">operator</span>=(<span class="type">const</span> String &amp;str)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 深拷贝赋值 先把自身杀掉 然后重新创建</span></span><br><span class="line">    <span class="comment">// 检测自我赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;_data;</span><br><span class="line">    <span class="comment">// 深拷贝</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(<span class="keyword">this</span>-&gt;_data, str._data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这里为什么要检测自我赋值：因为不检测自我赋值的话，如果使用者调用自我赋值的时候，第一步就会把唯一的自身这个_data杀掉，后续就没有办法进行了，会出现安全隐患!!!这也是为了安全和严谨性考虑的</p><h2 id="一些对象的生命期"><a href="#一些对象的生命期" class="heading-link"><i class="fas fa-link"></i></a><a href="#一些对象的生命期" class="headerlink" title="一些对象的生命期"></a>一些对象的生命期</h2><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">complex <span class="title">c3</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">complex <span class="title">c1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> complex <span class="title">c2</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    complex *c4=<span class="keyword">new</span> <span class="built_in">complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">delete</span> c4;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>C++程序在执行时，将内存大方向划分为4个区域<br>代码区：存放函数体的二进制代码，由操作系统进行管理。<br>全局区：存放全局变量和静态变量以及常量。<br>栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。<br>堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。</p><p>c1 :存放在栈当中，当作用域(这里是main函数)结束的时候就会被自动清理</p><p>c2 :静态变量，存放于全局静态区，当整个程序结束之后才会被释放</p><p>c3: 全局变量，存放于全局区，当整个程序结束之后才会被释放</p><p>c4: new出来的，动态分配内存，存放于堆区，注意new了之后记得在作用域结束之前将其delete掉</p><p>​ 否则会出现内存泄露的问题，当作用域结束之后c4指针会被释放掉，但是他所指向的内存没有被释放!!!一般写析构函数解决这个问题</p><h2 id="new和delete"><a href="#new和delete" class="heading-link"><i class="fas fa-link"></i></a><a href="#new和delete" class="headerlink" title="new和delete"></a>new和delete</h2><h3 id="new-先分配内存空间，再调用构造函数"><a href="#new-先分配内存空间，再调用构造函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#new-先分配内存空间，再调用构造函数" class="headerlink" title="new: 先分配内存空间，再调用构造函数"></a>new: 先分配内存空间，再调用构造函数</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412174017480.png" alt="image-20230412174017480"></p><h3 id="delete-先调用析构函数，再释放内存空间"><a href="#delete-先调用析构函数，再释放内存空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#delete-先调用析构函数，再释放内存空间" class="headerlink" title="delete: 先调用析构函数，再释放内存空间"></a>delete: 先调用析构函数，再释放内存空间</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412174017480.png" alt="image-20230412174017480"></p><h3 id="array-new-一定要搭配-array-delete"><a href="#array-new-一定要搭配-array-delete" class="heading-link"><i class="fas fa-link"></i></a><a href="#array-new-一定要搭配-array-delete" class="headerlink" title="array new 一定要搭配 array delete!!!"></a>array new 一定要搭配 array delete!!!</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412185656797.png" alt="image-20230412185656797"></p><p>写了 [] 的话编译器才会知道你不仅要删除p这个类对象指针,还要把这个p对象指针指向的数组元素给全部删除掉，因为 String* p既可以表示单个的类对象指针也可以表示类对象数组的首元素地址指针!!! 所以必须要要写 [] ,否则只会删除掉p[0]所对应的元素!!!</p><h2 id="static-静态"><a href="#static-静态" class="heading-link"><i class="fas fa-link"></i></a><a href="#static-静态" class="headerlink" title="static 静态"></a>static 静态</h2><p>静态变量和静态函数很特殊，具体看下面代码:</p><p>静态函数由于没有this指针，所以只能处理静态变量!!!</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Account</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> _rate;                      <span class="comment">// 静态成员变量一个程序只有一份，类内声明，类外初始化</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;rate)</span></span>; <span class="comment">// 静态成员函数，调用时可以声明类对象，可以调用作用域直接访问，类外实现，类外实现的时候不用加关键字static,但是要加作用域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">double</span> Account::_rate = <span class="number">8.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Account::set_rate</span><span class="params">(<span class="type">const</span> <span class="type">double</span> &amp;rate)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Account::_rate = rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; Account::_rate &lt;&lt; endl;</span><br><span class="line">    Account::<span class="built_in">set_rate</span>(<span class="number">7.0</span>);</span><br><span class="line">    cout &lt;&lt; Account::_rate &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="进一步补充：把构造函数放在-private-里面，单例设计模式"><a href="#进一步补充：把构造函数放在-private-里面，单例设计模式" class="heading-link"><i class="fas fa-link"></i></a><a href="#进一步补充：把构造函数放在-private-里面，单例设计模式" class="headerlink" title="进一步补充：把构造函数放在 private 里面，单例设计模式"></a>进一步补充：把构造函数放在 private 里面，单例设计模式</h3><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Stu &amp;<span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setup</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ; <span class="comment">// 一系列的接口操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Stu</span>();</span><br><span class="line">    <span class="built_in">Stu</span>(<span class="type">int</span> id, string name);</span><br><span class="line">    <span class="type">int</span> _ID;</span><br><span class="line">    string _name;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> Stu s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>这里的就是把构造函数放在 private 当中，对外界的接口就是这个 getInstance()，这个函数返回静态变量 s ，只有一份，通过 setup() 接口进行对这个类内成员的访问和修改!!!</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stu::<span class="built_in">getInstance</span>().<span class="built_in">setup</span>();</span><br></pre></td></tr></table></div></figure><p>优化的写法：</p><p>由于这里在构建类的时候就引入了静态成员变量，在没有调用的时候可能会导致资源浪费，所以我们将这个静态成员变量在静态函数中创建就好了，在调用的时候创建，然后生命周期一直持续到程序结束</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Stu&amp; <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">static</span> Stu s;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="模板"><a href="#模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板" class="headerlink" title="模板"></a>模板</h2><h3 id="类模板"><a href="#类模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#类模板" class="headerlink" title="类模板:"></a>类模板:</h3><p>用的时候必须要明确指出里面参数的类型</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">complex</span>&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">complex</span>();</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    T real;</span><br><span class="line">    T imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    complex&lt;<span class="type">int</span>&gt;<span class="built_in">c1</span>();</span><br><span class="line">    complex&lt;<span class="type">double</span>&gt;<span class="built_in">c2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="函数模板"><a href="#函数模板" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数模板" class="headerlink" title="函数模板:"></a>函数模板:</h3><p>用的时候不需要指明函数参数的类型,因为编译器会进行实参的推导</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">stone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stone</span>();</span><br><span class="line">    <span class="built_in">stone</span>(<span class="type">int</span> w, <span class="type">int</span> h, <span class="type">int</span> weight) : _w(w), _h(h), _weight(weight) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> stone &amp;sto) &#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_weight &lt;= sto._weight; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _w, _h, _weight;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局函数 比大小</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T &amp;</span></span><br><span class="line"><span class="function"><span class="title">min</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt;= b ? a : b ?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c;</span><br><span class="line">    <span class="function">stone <span class="title">a1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span>, <span class="title">a2</span><span class="params">(<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>)</span>, a3</span>;</span><br><span class="line">    c = <span class="built_in">min</span>(a, b);</span><br><span class="line">    a3 = <span class="built_in">min</span>(a1, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="命名空间-namespace"><a href="#命名空间-namespace" class="heading-link"><i class="fas fa-link"></i></a><a href="#命名空间-namespace" class="headerlink" title="命名空间 namespace"></a>命名空间 namespace</h2><p>将自己写的东西封装在一个命名空间当中，可以防止与其他人名称一样功能不同的问题</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std&#123;</span><br><span class="line">	;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="复合-composition"><a href="#复合-composition" class="heading-link"><i class="fas fa-link"></i></a><a href="#复合-composition" class="headerlink" title="复合 composition"></a>复合 composition</h2><p>简单来理解就是 一个类包含另一个类对象,本类可以调用另一个类的底层函数</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Adapter</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">queue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	deque&lt;T&gt; c; <span class="comment">//底层容器</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//以下的操作全都是由c的底层函数执行</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span><span class="type">const</span></span>&#123;<span class="keyword">return</span> c.<span class="built_in">empty</span>();&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>这里其实包含另一种设计模式: Adapter</p><p>deque是双端队列，queue是单端队列，显然deque的功能要比queue功能强大，他完全可以适配(Adapter)queue的功能，所以可以采用复合的方式，queue的成员函数调用deque中的部分成员函数来实现自己的功能!!!</p><p>用图可以这样表示:</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412202635207.png" alt="image-20230412202635207"></p><h3 id="复合下的构造和析构"><a href="#复合下的构造和析构" class="heading-link"><i class="fas fa-link"></i></a><a href="#复合下的构造和析构" class="headerlink" title="复合下的构造和析构"></a>复合下的构造和析构</h3><p>构造: 构造由内而外 注意先调用的是内部的<strong>默认</strong>构造，编译器指定的，也符合我们的预期！</p><p>析构: 析构由外而内</p><p>这些是编译器帮我安排好的，上面是我们希望的设计</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412203303042.png" alt="image-20230412203303042"></p><h2 id="委托-Delefgation-–-Composition-by-reference"><a href="#委托-Delefgation-–-Composition-by-reference" class="heading-link"><i class="fas fa-link"></i></a><a href="#委托-Delefgation-–-Composition-by-reference" class="headerlink" title="委托 Delefgation – Composition by reference"></a>委托 Delefgation – Composition by reference</h2><p>把复合下面传入的参数类型改为指针!!!</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412204435460.png" alt="image-20230412204435460"></p><h3 id="Handle-x2F-Body-pimpl"><a href="#Handle-x2F-Body-pimpl" class="heading-link"><i class="fas fa-link"></i></a><a href="#Handle-x2F-Body-pimpl" class="headerlink" title="Handle&#x2F;Body (pimpl)"></a>Handle&#x2F;Body (pimpl)</h3><p>图示的这种写法很有名，左边是用户看到的类，里面有调用的接口这些，右边是真正字符串的类，用来封装字符串的类型这些。</p><p>reference counting: 这种写法在这个特殊例子当中可以实现，用户创建了三个String对象，但是每个对象下面对应的 rep 指针指向的对象其实是一块内存，因为他们的字符串是一样的，这样就可以减少内存的开销。</p><h2 id="继承-inheritance"><a href="#继承-inheritance" class="heading-link"><i class="fas fa-link"></i></a><a href="#继承-inheritance" class="headerlink" title="继承 inheritance"></a>继承 inheritance</h2><p>构造:由内而外 调用父类的<strong>默认</strong>构造函数，编译器指定的，也符合我们的预期！</p><p>析构:由外而内</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412210437066.png" alt="image-20230412210437066"></p><h3 id="虚函数"><a href="#虚函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚函数" class="headerlink" title="虚函数:"></a>虚函数:</h3><p>override 覆写：注意只能用在虚函数这里</p><p>non-virtual 函数: 父类不希望子类重写(override)它</p><p>virtual 函数：父类希望子类重写(override)它，父类对它一般已经有默认定义</p><p>pure virtual 函数(纯虚函数)：父类希望子类一定要重写(override)它，父类对它没有默认定义，例子：父类是个抽象类</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230412212341135.png" alt="image-20230412212341135"></p><p>注意:子类调用父类的函数，如果子类当中对父类的函数进行了override，那么在调用到这个虚函数的时候就会调用子函数覆写的版本，从而实现我们的需求！！！</p><p>下面还有个例子:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;喵喵喵&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;汪汪汪&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//用父类对象指针来接受子类对象 来达到子类调用父类对象成员函数的目的</span></span><br><span class="line">    Animal *cat = <span class="keyword">new</span> <span class="built_in">Cat</span>();</span><br><span class="line">    cat-&gt;<span class="built_in">speak</span>(); <span class="comment">// 喵喵喵</span></span><br><span class="line"></span><br><span class="line">    Animal *dog = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">    dog-&gt;<span class="built_in">speak</span>(); <span class="comment">// 汪汪汪</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>用父类对象指针来接受子类对象 来达到子类调用父类对象成员函数的目的，这样也可以实现多态.</p><h2 id="转换函数-conversion-function"><a href="#转换函数-conversion-function" class="heading-link"><i class="fas fa-link"></i></a><a href="#转换函数-conversion-function" class="headerlink" title="转换函数 conversion function"></a>转换函数 conversion function</h2><p>作用：可以用于类型的转换</p><p>重载 () 运算符 在括号的前面加上返回的类型，括号内不传参数，返回值由于在括号前面已经指定了，所以省略不写，编译器指定的</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_numerator / (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>整体的例子:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) : _numerator(num), _denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换函数</span></span><br><span class="line">    <span class="comment">// 没有返回值，转化的类型在括号前面已经指定</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_numerator / (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numerator;</span><br><span class="line">    <span class="type">int</span> _denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>, <span class="number">5</span>)</span></span>;<span class="comment">//这里首先创建了f对象，调用了构造函数</span></span><br><span class="line">    <span class="type">double</span> d = <span class="number">4</span> + f;</span><br><span class="line">    <span class="comment">//f是个类对象，他怎么能直接和double类型相加呢？</span></span><br><span class="line">    <span class="comment">//如果写了 + 号运算符重载那么就直接调用即可，但是这里没写啊？</span></span><br><span class="line">    <span class="comment">//所以这里编译器就去找什么东西可以把f里面的参数变为double 就找到了转换函数 这里的f经过编译之后就返回分数的值 也就是0.6</span></span><br><span class="line">    cout &lt;&lt; d &lt;&lt; endl;<span class="comment">//4.6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意main函数里面的细节!!!</p><h2 id="函数对象-仿函数-gt-谓词"><a href="#函数对象-仿函数-gt-谓词" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数对象-仿函数-gt-谓词" class="headerlink" title="函数对象(仿函数) -&gt; 谓词"></a>函数对象(仿函数) -&gt; 谓词</h2><p>谓词:</p><p>1.函数指针作谓词</p><p>2.函数对象(仿函数)作谓词</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针作谓词</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val1 &lt;= val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数对象(仿函数)作谓词</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fuck</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val1, <span class="type">int</span> val2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val1 &lt;= val2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">// sort(nums.begin(), nums.end(), Cmp);</span></span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), <span class="built_in">Fuck</span>());</span><br><span class="line">    for_each(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> val)</span><br><span class="line">             &#123; cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>仿函数(函数对象): function like classes</p><p>在类里面重载 () 运算符</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">identity</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> T&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> T&amp; x)</span></span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>调用的时候 identity() 这样就是一个函数对象</p><p>标准库里面有很多仿函数，这些仿函数都继承了一些标准库里面的父类，这些父类大小为0，没有成员函数。(标准库)</p><h2 id="模板补充-成员模板-member-template"><a href="#模板补充-成员模板-member-template" class="heading-link"><i class="fas fa-link"></i></a><a href="#模板补充-成员模板-member-template" class="headerlink" title="模板补充: 成员模板 member template"></a>模板补充: 成员模板 member template</h2><p>到目前为止，三种模板: 类模板 函数模板 成员模板</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230413163206633.png" alt="image-20230413163206633"></p><p>注意看注释进行理解!!!</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base1 鱼类 Derived1 鲫鱼</span></span><br><span class="line"><span class="comment">// Base2 鸟类 Derived2 麻雀</span></span><br><span class="line"><span class="comment">// 相应的有继承关系</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base1</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived2</span> : <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在定义一个pair类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pair</span></span><br><span class="line">&#123;</span><br><span class="line">    T1 _first;</span><br><span class="line">    T2 _second;</span><br><span class="line">    <span class="built_in">Pair</span>();</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">const</span> T1 &amp;a, <span class="type">const</span> T2 &amp;b) : _first(a), _second(b) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里有一个Pair的拷贝赋值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">Pair</span>(<span class="type">const</span> Pair&lt;U1, U2&gt; &amp;p) : _first(p._first), _second(p._second) &#123;&#125;</span><br><span class="line">    <span class="comment">// 这里怎么理解</span></span><br><span class="line">    <span class="comment">// 如果传入的类型是 T1 鱼类 T2 鸟类</span></span><br><span class="line">    <span class="comment">// 然后在调用拷贝赋值的时候传入的类型是 U1 鲫鱼 U2 麻雀</span></span><br><span class="line">    <span class="comment">// 显然 鲫鱼是鱼类 麻雀是鸟类 所以是可以传入的</span></span><br><span class="line">    <span class="comment">// 这个成员模板需要满足的条件就是 p._first这里是可以给自身的成员属性 _first 进行赋值的,在这里满足的是继承的关系</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></div></figure><p>这里其实就有考虑指针指向的问题</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base1 &#123; &#125;;</span><br><span class="line">Base1 *ptr=<span class="keyword">new</span> Derived1;<span class="comment">//这么写是完全ok的</span></span><br></pre></td></tr></table></div></figure><p>还是考虑 Base1 是鱼类，Derived1 是 鲫鱼，然后我们用鱼类的指针去指向鲫鱼对象，这显然是可以的，因为鲫鱼很明显是鱼，所以这么写是完全ok的。</p><p>并且恰好这么写可以使得子类调用父类的虚函数来实现不同的虚函数功能。</p><h2 id="命名空间"><a href="#命名空间" class="heading-link"><i class="fas fa-link"></i></a><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> my1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am in namespace my1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> my2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I am in namespace my2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    my1::<span class="built_in">test</span>();</span><br><span class="line">    my2::<span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>两个命名空间，即使里面的函数名称一样，传入参数等等方面完全一样，甚至还是静态的，虽然静态的存放于全局静态区只有一份，但是这里用了两个不同的命名空间将他们分割开来，这样就导致两个函数本质上是不同的，从下面的使用就可以看出来了。</p><h2 id="explicit"><a href="#explicit" class="heading-link"><i class="fas fa-link"></i></a><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>non-explicit-one-argument ctor(构造函数)</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// non-explicit-one-argument ctor</span></span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) : _numerator(num), _denominator(den) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是上面提到的转换函数</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_numerator / (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_denominator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numerator;</span><br><span class="line">    <span class="type">int</span> _denominator;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>我们先将转换函数去掉，重载加号运算符</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// non-explicit-one-argument ctor</span></span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) : _numerator(num), _denominator(den) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//重载加号运算符</span></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)&#123; ; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numerator;</span><br><span class="line">    <span class="type">int</span> _denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d=f<span class="number">+4</span>;</span><br><span class="line">    <span class="comment">//到这里的时候编译器发现f和4没办法直接相加 即使写了重载 因为需要传入Fraction类型</span></span><br><span class="line">    <span class="comment">//但是编译器看构造函数 默认值den=1 意思是可以传入一个参数，这就和现在的4很贴切了</span></span><br><span class="line">    <span class="comment">//所以编译器会将4转化为Fraction类对象和f进行相加得到对象d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>如果两个同时存在</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// non-explicit-one-argument ctor</span></span><br><span class="line">    <span class="built_in">Fraction</span>(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>) : _numerator(num), _denominator(den) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//conversion function</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_numerator / (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_denominator;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//重载加号运算符</span></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)&#123; ; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numerator;</span><br><span class="line">    <span class="type">int</span> _denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d=f<span class="number">+4</span>;</span><br><span class="line">    <span class="comment">//按照上面的思路是一种走法</span></span><br><span class="line">    <span class="comment">//但是有了转换函数之后编译器发现,f可以先转化为double数字再和4求和，求完和之后再转化为Fraction对象，这就是另一种思路了</span></span><br><span class="line">    <span class="comment">//所以 二义性 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>现在如果加上关键字 explicit 呢？</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Fraction</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// explicit-one-argument ctor</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Fraction</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> den = <span class="number">1</span>)</span> : _numerator(num), _denominator(den) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">//explict关键字的含义 防止类构造函数的隐式自动转换</span></span><br><span class="line">    <span class="comment">//就是说这里由于只需要传入一个参数，所以编译器很可能会把数字隐式转化为Fraction对象</span></span><br><span class="line">    <span class="comment">//但是加上了explict之后,明确指出不要让编译器这么干，要生成Fraction对象只能显式调用构造函数!!!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//conversion function</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_numerator / (<span class="type">double</span>)<span class="keyword">this</span>-&gt;_denominator;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//重载加号运算符</span></span><br><span class="line">    Fraction <span class="keyword">operator</span>+(<span class="type">const</span> Fraction&amp; f)&#123; ; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _numerator;</span><br><span class="line">    <span class="type">int</span> _denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Fraction <span class="title">f</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">    Fraction d=f<span class="number">+4</span>;<span class="comment">//这里仍然会错，因为4不会被转化为Fraction了，也就没有办法直接相加</span></span><br><span class="line">    <span class="type">double</span> e=f<span class="number">+4</span>;<span class="comment">//这里显然就可以了，因为存在转换函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个关键字 explicit 绝大部分都是用在构造函数前面来防止其他类型的隐式转换!!!!</p><h2 id="pointer-like-classes-关于智能指针和迭代器"><a href="#pointer-like-classes-关于智能指针和迭代器" class="heading-link"><i class="fas fa-link"></i></a><a href="#pointer-like-classes-关于智能指针和迭代器" class="headerlink" title="pointer-like classes 关于智能指针和迭代器"></a>pointer-like classes 关于智能指针和迭代器</h2><h3 id="智能指针-用一个类来模拟一般指针的作用"><a href="#智能指针-用一个类来模拟一般指针的作用" class="heading-link"><i class="fas fa-link"></i></a><a href="#智能指针-用一个类来模拟一般指针的作用" class="headerlink" title="智能指针: 用一个类来模拟一般指针的作用"></a>智能指针: 用一个类来模拟一般指针的作用</h3><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">shared_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *p) : _px(p) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//智能指针必然需要重载这两个运算符</span></span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_px);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T *<span class="keyword">operator</span>-&gt;() <span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *_px;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Foo&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> Foo)</span></span>;</span><br><span class="line">    <span class="function">Foo <span class="title">f</span><span class="params">(*sp)</span></span>;</span><br><span class="line">    sp-&gt;<span class="built_in">method</span>();<span class="comment">//这个就相当于 _px-&gt;method();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="迭代器-iterator-其本质也是一种智能指针"><a href="#迭代器-iterator-其本质也是一种智能指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器-iterator-其本质也是一种智能指针" class="headerlink" title="迭代器: iterator 其本质也是一种智能指针"></a>迭代器: iterator 其本质也是一种智能指针</h3><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="comment">//注意这个迭代器类型怎么写的</span></span><br><span class="line">    <span class="keyword">for</span> (list&lt;<span class="type">int</span>&gt;::iterator iter = l.<span class="built_in">begin</span>(); iter != l.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        cout &lt;&lt; *iter &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法2</span></span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="type">int</span> val)</span><br><span class="line">             &#123; cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="specialization-模板特化"><a href="#specialization-模板特化" class="heading-link"><i class="fas fa-link"></i></a><a href="#specialization-模板特化" class="headerlink" title="specialization 模板特化"></a>specialization 模板特化</h2><p>对于一个泛型模板，我们调用的时候里面的接口都是一样的。但是如果我们发现有的特殊的类型在某个函数下有更加好的实现方法，这个时候就可以用模板特化来操作了。可以类比子类继承父类(抽象类)的虚函数，特殊化实现，本质是一样的。</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230413211543101.png" alt="image-20230413211543101"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fuck</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fuck</span>&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意模板特化的语法</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fuck</span>&lt;string&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">string <span class="title">operator</span><span class="params">()</span><span class="params">(string ch)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> ch; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fuck</span>&lt;<span class="type">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">double</span> val)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 匿名对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Fuck</span>&lt;<span class="type">int</span>&gt;()(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Fuck</span>&lt;string&gt;()(<span class="string">&quot;fuck&quot;</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Fuck</span>&lt;<span class="type">double</span>&gt;()(<span class="number">3.14</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>模板特化语法第一行要加上，第二行就是具体类型类的具体操作</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fuck</span>&lt;type&gt;&#123;</span><br><span class="line">  	;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h2 id="partial-specialization-模板偏特化"><a href="#partial-specialization-模板偏特化" class="heading-link"><i class="fas fa-link"></i></a><a href="#partial-specialization-模板偏特化" class="headerlink" title="partial specialization 模板偏特化"></a>partial specialization 模板偏特化</h2><p>个数的偏</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Alloc= ...&gt;</span><br><span class="line"><span class="keyword">class</span> Vector&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板偏特化 就只特定其中的某个或者某几个元素 其实还是一个模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Alloc= ...&gt;</span><br><span class="line"><span class="keyword">class</span> Vector&lt;<span class="type">bool</span>,Alloc&gt;&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>范围的偏</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span> <span class="comment">// 泛化的TC类模板</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">functest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;泛化版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 偏特化：模板参数范围上的特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;<span class="type">const</span> T&gt; <span class="comment">// const的特化版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对特化版本做单独处理</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">functest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;偏特化const版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;T *&gt; <span class="comment">// T* 的特化版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">functest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;const T*特化版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;T &amp;&gt; <span class="comment">// T&amp; 的特化版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">functest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;T &amp;左值引用特化版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TC</span>&lt;T &amp;&amp;&gt; <span class="comment">// T&amp;&amp; 的特化版本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">functest</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;T &amp;&amp;右值引用特化版本&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TC&lt;<span class="type">double</span>&gt; td;</span><br><span class="line">    td.<span class="built_in">functest</span>();</span><br><span class="line"></span><br><span class="line">    TC&lt;<span class="type">const</span> <span class="type">double</span>&gt; td2;</span><br><span class="line">    td<span class="number">2.f</span>unctest();</span><br><span class="line"></span><br><span class="line">    TC&lt;<span class="type">double</span> *&gt; tpd;</span><br><span class="line">    tpd.<span class="built_in">functest</span>();</span><br><span class="line"></span><br><span class="line">    TC&lt;<span class="type">const</span> <span class="type">double</span> *&gt; tpd2;</span><br><span class="line">    tpd<span class="number">2.f</span>unctest();</span><br><span class="line"></span><br><span class="line">    TC&lt;<span class="type">int</span> &amp;&gt; tcyi;</span><br><span class="line">    tcyi.<span class="built_in">functest</span>();</span><br><span class="line"></span><br><span class="line">    TC&lt;<span class="type">int</span> &amp;&amp;&gt; tcyi2;</span><br><span class="line">    tcyi<span class="number">2.f</span>unctest();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">test</span>();</span><br><span class="line">    <span class="comment">//泛化版本</span></span><br><span class="line">	<span class="comment">//偏特化const版本</span></span><br><span class="line">	<span class="comment">//const T*特化版本</span></span><br><span class="line">	<span class="comment">//const T*特化版本</span></span><br><span class="line">	<span class="comment">//T &amp;左值引用特化版本</span></span><br><span class="line">	<span class="comment">//T &amp;&amp;右值引用特化版本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="C-标准库-体系结构与内存分析"><a href="#C-标准库-体系结构与内存分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-标准库-体系结构与内存分析" class="headerlink" title="C++标准库 体系结构与内存分析"></a>C++标准库 体系结构与内存分析</h1><h2 id="第一讲：STL标准库和泛型编程"><a href="#第一讲：STL标准库和泛型编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一讲：STL标准库和泛型编程" class="headerlink" title="第一讲：STL标准库和泛型编程"></a>第一讲：STL标准库和泛型编程</h2><h3 id="STL-体系结构"><a href="#STL-体系结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#STL-体系结构" class="headerlink" title="STL 体系结构"></a>STL 体系结构</h3><p>六大部件: 容器 分配器 算法 迭代器 适配器 仿函数</p><p>容器：各种数据结构</p><p>算法：algorithm</p><p>迭代器：泛型指针，重载了 * -&gt; ++ –操作的类</p><p>仿函数：从实现的角度看是重载了 operator() 的类</p><p>适配器：一种修饰容器，仿函数或者迭代器接口的东西</p><p>分配器：负责空间的配置和管理</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414100854356.png" alt="image-20230414100854356"></p><p>以下有一个程序的例子几乎包含了所有的元素：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414114802698.png" alt="image-20230414114802698" style="zoom:67%"><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ia[<span class="number">6</span>] = &#123;<span class="number">27</span>, <span class="number">210</span>, <span class="number">12</span>, <span class="number">47</span>, <span class="number">109</span>, <span class="number">83</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>, allocator&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">vi</span>(ia, ia + <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">40</span>))) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>下面来解释这里面所用到的东西:</p><ol><li><p>vector是容器，这里的用法和一般的使用方法不同，这里给出了分配器模板的指定参数</p></li><li><p>count_if第三个参数，本意是想比较迭代器 * iter 和40 的大小，然后使用的仿函数，但是less<int>()这个系统自带的仿函数的实现是这样的</int></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">less</span> : <span class="keyword">public</span> binary_function&lt;_Tp, _Tp, <span class="type">bool</span>&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    _GLIBCXX14_CONSTEXPR</span><br><span class="line">    <span class="type">bool</span></span><br><span class="line">    <span class="comment">//从这里可以看出他需要两个参数</span></span><br><span class="line">    <span class="built_in">operator</span>()(<span class="type">const</span> _Tp&amp; __x, <span class="type">const</span> _Tp&amp; __y) <span class="type">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span> __x &lt; __y; &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></div></figure><p>一般仿函数的用法:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;v&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(),v.<span class="built_in">end</span>(),<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;());<span class="comment">//仿函数作谓词</span></span><br></pre></td></tr></table></div></figure><p>所以这里用 <strong>bind2nd</strong> 将迭代器和40绑定在一起，也叫 function adapter(binder)。</p><p>然后最外面 <strong>not1</strong> 一样的，将条件取反，所以求的就是大于等于40的元素个数了,function adapter(negator)</p></li></ol><h3 id="基于范围的-for-语句"><a href="#基于范围的-for-语句" class="heading-link"><i class="fas fa-link"></i></a><a href="#基于范围的-for-语句" class="headerlink" title="基于范围的 for 语句"></a>基于范围的 for 语句</h3><p>个人感觉有点像python里面的 for i in range()</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历vector容器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;Type&gt; container)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : container)</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">double</span>&gt; nums&#123;<span class="number">1.1</span>, <span class="number">2.5</span>, <span class="number">6.33</span>, <span class="number">15.66</span>, <span class="number">1.44</span>, <span class="number">2.52</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 稍微修改一下</span></span><br><span class="line">    <span class="comment">// 注意传入引用才能修改实参!!!!!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;elem : nums)</span><br><span class="line">        elem -= <span class="number">1</span>; <span class="comment">// 减一</span></span><br><span class="line">    <span class="built_in">print</span>(nums);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="容器的结构和分类"><a href="#容器的结构和分类" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器的结构和分类" class="headerlink" title="容器的结构和分类"></a>容器的结构和分类</h3><p>总体来讲分为两类:</p><p>序列容器 Sequence Containers</p><p>关联式容器 Associate Containers 关联式容器采用键值对的方式存储数据，因此这一种容器查找元素的效率最高，最方便</p><p>无序容器 Unordered Containers 是关联式容器的一种，c++11新出的</p><p>相比于关联式容器的特点：</p><ul><li>无序容器内部存储的<strong>键值对是无序</strong>的，各键值对的存储位置取决于该键值对中的键</li><li>和关联式容器相比，无序容器擅长<strong>通过指定键查找对应的值</strong>（平均时间复杂度为 O(1)）；</li><li>但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。</li></ul><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414161555294.png" alt="image-20230414161555294"></p><h3 id="HashTable-Separate-Chaining"><a href="#HashTable-Separate-Chaining" class="heading-link"><i class="fas fa-link"></i></a><a href="#HashTable-Separate-Chaining" class="headerlink" title="HashTable Separate Chaining"></a>HashTable Separate Chaining</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230414171828137.png" alt="image-20230414171828137"></p><h3 id="Sequence-Containers-序列容器"><a href="#Sequence-Containers-序列容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Sequence-Containers-序列容器" class="headerlink" title="Sequence Containers 序列容器"></a>Sequence Containers 序列容器</h3><h4 id="array-c-11"><a href="#array-c-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#array-c-11" class="headerlink" title="array(c++11)"></a>array(c++11)</h4><p>array是STL自带的数组类，其本质就是一个固定大小的数组，里面存放的元素类型由用户指定</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> <span class="type">size_t</span> _size = <span class="number">100</span>;</span><br><span class="line">        array&lt;<span class="type">int</span>, _size&gt; arr;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _size; ++i)</span><br><span class="line">            <span class="comment">// 随机数 0-100</span></span><br><span class="line">            arr[i] = <span class="built_in">rand</span>() % <span class="number">101</span>;</span><br><span class="line">        <span class="comment">// 打印一些信息</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr.size()= &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr.front()= &quot;</span> &lt;&lt; arr.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr.back()= &quot;</span> &lt;&lt; arr.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr.data()= &quot;</span> &lt;&lt; arr.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    	cout&lt;&lt; <span class="string">&quot; &amp;arr[0]= &quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>] &lt;&lt; endl;<span class="comment">//第四行和第五行得到的结果是一样的</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p>array封装了固定长度数组的一些函数接口，其中data()函数是得到这个数组的首元素地址，也就是第五行，所以四五行结果相同</p><h4 id="vector"><a href="#vector" class="heading-link"><i class="fas fa-link"></i></a><a href="#vector" class="headerlink" title="vector"></a>vector</h4><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">            v.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">101</span>);</span><br><span class="line">        <span class="comment">// 打印</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v.size()= &quot;</span> &lt;&lt; v.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    	cout &lt;&lt; <span class="string">&quot;v.max_size()= &quot;</span> &lt;&lt; v.<span class="built_in">max_size</span>() &lt;&lt; endl;<span class="comment">//这里的max_size()是指vector容器能装下的最大的大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v.front()= &quot;</span> &lt;&lt; v.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v.back()= &quot;</span> &lt;&lt; v.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v.data()= &quot;</span> &lt;&lt; v.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;&amp;v[0]=&quot;</span> &lt;&lt; &amp;v[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;v.capacity()= &quot;</span> &lt;&lt; v.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p>这里得到我指定size是10000的时候，capacity是16384，恰好是2的14次方，那么为什么是这样呢？</p><p>vector当空间不够的时候如何开辟空间：<strong>2倍开辟</strong>!!!</p><p>比如现在有2个元素，想要放入第三个，空间不够会新开辟，那么新开辟之后vector的空间大小是4</p><p>即:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// v.size() == 3</span></span><br><span class="line"><span class="comment">// v.capacity() == 4</span></span><br></pre></td></tr></table></div></figure><p>所以当 size&#x3D;&#x3D;10000的时候，capacity为16384也不奇怪了</p><p>并且<strong>内存开辟成长机制</strong>：</p><p>当空间不够的时候，vector容器会去内存中找另一块空间是现在2倍的空间，重新开辟内存，并且把现在的内存释放掉，把现在的数据迁移到新的2倍内存当中去!!!!</p><h4 id="list"><a href="#list" class="heading-link"><i class="fas fa-link"></i></a><a href="#list" class="headerlink" title="list"></a>list</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415143355398.png" alt="image-20230415143355398"></p><p>list是个双端循环链表，注意不仅是双向链表，还是循环的!!!!</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        l.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">101</span>);<span class="comment">//list 提供了back和front两种插入方法,因为有begin()和end()迭代器</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.size()= &quot;</span> &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.max_size()= &quot;</span> &lt;&lt; l.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//注意 front和back的三种得到方式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.front()= &quot;</span> &lt;&lt; l.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.front()= &quot;</span> &lt;&lt; *l.<span class="built_in">begin</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.front()= &quot;</span> &lt;&lt; *(++l.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.back()= &quot;</span> &lt;&lt; l.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.back()= &quot;</span> &lt;&lt; *(--l.<span class="built_in">end</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">auto</span> iter = --l.<span class="built_in">begin</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;l.back()= &quot;</span> &lt;&lt; *(--iter) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>得到首部和尾部的方式:</p><p>1.内置函数 front()和back()</p><p>2.使用迭代器 begin() 和 end()</p><p>注意这里的迭代器是首闭尾开的形式,就是begin() 指向的第一个元素，end() 指向的最后一个元素的下一个没有值的内存空间,所以上一个区域就是最后一个元素的值 –end()</p><p>由于这个双端链表在内存中最后一个元素的末尾还多了一块未分配值的空间，考虑到是循环的，所以++end()就代表第一块元素的空间</p><p>但是，由于**大部分的迭代器没有重载 + 和 - 运算符(vector容器有)**，那么在求的时候不能直接用这两个符号，而得使用重载的++ 和 – 运算符!!!!!!!</p><h4 id="forward-list-c-11"><a href="#forward-list-c-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#forward-list-c-11" class="headerlink" title="forward_list(c++11)"></a>forward_list(c++11)</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415143409298.png" alt="image-20230415143409298"></p><p>本质就是一个单向链表，非循环链表</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; fl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        fl.<span class="built_in">push_front</span>(<span class="built_in">rand</span>() % <span class="number">101</span>); <span class="comment">// 只提供头插法,因为尾插法太慢了</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fl.max_size()= &quot;</span> &lt;&lt; fl.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fl.front()= &quot;</span> &lt;&lt; fl.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;fl.front()= &quot;</span> &lt;&lt; *(fl.<span class="built_in">begin</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;fl.back()= &quot; &lt;&lt; *(--fl.end()) &lt;&lt; endl; // error 没有重载 -- 运算符 只重载++运算符</span></span><br><span class="line">    <span class="comment">// 不存在 fl.back() 接口</span></span><br><span class="line">    <span class="comment">// 也不存在fl.size()接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意这个单向链表只有头插法，原因是尾插法每次都要遍历到最后，太慢了，头插法效率更高,所以这个容器也<strong>不存在back()函数接口</strong></p><p>这个单向链表begin()和end()迭代器都存在，但是大部分的时候遍历是使用begin()迭代器，因为<strong>只重载了 ++ 运算符，未重载 – 运算符!!!</strong></p><p>还有一点与list不同,这个容器<strong>没有 size() 接口</strong>!!!我也不知道为什么，标准库没有提供这个接口</p><h4 id="slist"><a href="#slist" class="heading-link"><i class="fas fa-link"></i></a><a href="#slist" class="headerlink" title="slist"></a>slist</h4><p>这个容器的实现和 forward_list 相同，只不过这个容器是c++之前就有了，而 forward_list 是c++11新提出的</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext\slist&gt;</span></span></span><br></pre></td></tr></table></div></figure><h4 id="deque"><a href="#deque" class="heading-link"><i class="fas fa-link"></i></a><a href="#deque" class="headerlink" title="deque"></a>deque</h4><p>双端开口队列</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415145105415.png" alt="image-20230415145105415"></p><p>但是在实现的时候采用的是<strong>分段连续</strong>的机制：</p><p>它真实的结构如下：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415145711652.png" alt="image-20230415145711652" style="zoom:67%"><p>到99的时候，迭代器进行++的操作，需要进行判断走到了这一块内存的末尾，需要移步到下一个buffer的起始位置，也就是0，这就需要对++和–操作符进行重载!!!</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        d.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">101</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d.size()= &quot;</span> &lt;&lt; d.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d.max_size()= &quot;</span> &lt;&lt; d.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d.front()= &quot;</span> &lt;&lt; d.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;d.back()= &quot;</span> &lt;&lt; d.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>和前面的使用没有大区别,只是<strong>deque不是循环的，而是两端延升的</strong></p><h4 id="stack"><a href="#stack" class="heading-link"><i class="fas fa-link"></i></a><a href="#stack" class="headerlink" title="stack"></a>stack</h4><p>deque的功能可以实现stack的所有功能，可以用复合composition的方式来实现stack类</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415150557574.png" alt="image-20230415150557574" style="zoom:67%"><h4 id="queue"><a href="#queue" class="heading-link"><i class="fas fa-link"></i></a><a href="#queue" class="headerlink" title="queue"></a>queue</h4><p>同stack，略</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415150706680.png" alt="image-20230415150706680" style="zoom:67%"><h3 id="Associate-Containers-关联式容器"><a href="#Associate-Containers-关联式容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#Associate-Containers-关联式容器" class="headerlink" title="Associate Containers 关联式容器"></a>Associate Containers 关联式容器</h3><p>关联式容器每个元素都存在 key 和 value，这样才能使得查询效率大大提高</p><h4 id="红黑树"><a href="#红黑树" class="heading-link"><i class="fas fa-link"></i></a><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><h4 id="Multiset-和-set"><a href="#Multiset-和-set" class="heading-link"><i class="fas fa-link"></i></a><a href="#Multiset-和-set" class="headerlink" title="Multiset 和 set"></a>Multiset 和 set</h4><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415154938692.png" alt="image-20230415154938692" style="zoom:67%"><p>这种容器的 <strong>key 和 value 值相同!</strong>!!!!</p><p>这两个容器的底层都是用<strong>二叉树</strong>(红黑树)实现的，元素在插入的时候都会被**进行自动排序(从小到大)**，唯一的不同点是，Multiset允许插入重复的元素，而set不允许出现重复的元素</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        s.<span class="built_in">insert</span>(<span class="built_in">rand</span>());<span class="comment">//注意插入的接口是insert()</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s.size()= &quot;</span> &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s.max_size()= &quot;</span> &lt;&lt; s.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// s.begin() s.end() 存在接口</span></span><br><span class="line">    <span class="comment">// 迭代器存在，因为底层是用二叉树实现的，并且进行了自动排序，所以肯定可以遍历，这个就是学底层的时候该考虑的问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>注意：Multiset 和 set 不能使用 [ ] 来做下标访问!!!!!</strong></p><p>第一，底层是红黑树，第二，标准库未重载 [ ] 符号!!!</p><h4 id="Multimap-和-map"><a href="#Multimap-和-map" class="heading-link"><i class="fas fa-link"></i></a><a href="#Multimap-和-map" class="headerlink" title="Multimap 和 map"></a>Multimap 和 map</h4><p>这种容器就有分别的 <strong>key 和 value</strong> 了，两者不一定相同，每个元素都是有两个元素!!!底层是用<strong>红黑树</strong>实现的!!!!!</p><p>插入元素的时候会<strong>按照key进行排序(从小到大)</strong></p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415154949602.png" alt="image-20230415154949602" style="zoom:67%"><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">        m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(i, <span class="built_in">rand</span>()));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m.size()= &quot;</span> &lt;&lt; m.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m.max_size()= &quot;</span> &lt;&lt; m.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// m.begin() m.end() 存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>同set一样，由于底层是用红黑树实现的，所以查询的时候也有迭代器接口，并且效率很高</p><p>map不能有重复的，这里的<strong>重复判断是看 key</strong> !!!!!! 两个value相同但是key不同是合法的!!! Multimap 就可以有相同的key!!!</p><p><strong>注意：Multimap不能使用 [ ] 来做下标访问!!!! Map可以，类似于python字典的用法!!!</strong></p><p>原因类似见上</p><h4 id="哈希表-其实原本名字前缀是hash-现在改名叫unordered"><a href="#哈希表-其实原本名字前缀是hash-现在改名叫unordered" class="heading-link"><i class="fas fa-link"></i></a><a href="#哈希表-其实原本名字前缀是hash-现在改名叫unordered" class="headerlink" title="哈希表(其实原本名字前缀是hash,现在改名叫unordered)"></a>哈希表(其实原本名字前缀是hash,现在改名叫unordered)</h4><h4 id="unordered-multiset-和-unorder-set"><a href="#unordered-multiset-和-unorder-set" class="heading-link"><i class="fas fa-link"></i></a><a href="#unordered-multiset-和-unorder-set" class="headerlink" title="unordered_multiset 和 unorder_set"></a>unordered_multiset 和 unorder_set</h4><p><strong>key和value值相同</strong>，与上面不同的是这个本质是用<strong>哈希表</strong>实现的!</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415160759007.png" alt="image-20230415160759007" style="zoom:67%"><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; us;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; ++i)</span><br><span class="line">            us.<span class="built_in">insert</span>(<span class="built_in">rand</span>());</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;us.size()= &quot;</span> &lt;&lt; us.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;us.max_size()= &quot;</span> &lt;&lt; us.<span class="built_in">max_size</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;us.bucket_count()= &quot;</span> &lt;&lt; us.<span class="built_in">bucket_count</span>() &lt;&lt; endl;<span class="comment">//篮子的大小</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;us.load_factor()= &quot;</span> &lt;&lt; us.<span class="built_in">load_factor</span>() &lt;&lt; endl;<span class="comment">//装载因子=元素个数/篮子个数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;us.max_load_factor()= &quot;</span> &lt;&lt; us.<span class="built_in">max_load_factor</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;us.max_bucket_count()= &quot;</span> &lt;&lt; us.<span class="built_in">max_bucket_count</span>() &lt;&lt; endl;<span class="comment">//最大的篮子个数,和最大元素个数相同</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure><p>unordered_set 通过一个<strong>哈希函数</strong>，将对象的值映射到一个数组下标，这个数组下标对应的是unordered_set中的一个“桶”，表示所有可以映射到这个下标的元素的集合，通常用链表表示。</p><p>这个vector数组我一般形象的称其为<strong>篮子</strong>。</p><p>篮子扩充机制：<strong>当元素个数size()不断增加，达到篮子个数bucket_count()的时候，vector容器进行近似2倍的扩充</strong>，具体略</p><p>所以，<strong>篮子个数一定大于元素个数</strong>!!!!</p><h4 id="unordered-multimap-和-unordered-map"><a href="#unordered-multimap-和-unordered-map" class="heading-link"><i class="fas fa-link"></i></a><a href="#unordered-multimap-和-unordered-map" class="headerlink" title="unordered_multimap 和 unordered_map"></a>unordered_multimap 和 unordered_map</h4><p>与上面的大概相同，不同的是，传入的数据类型是一个<strong>键值对 pair&lt;keyType,valueType&gt;</strong></p><p>其他略，具体实现后面再谈</p><h3 id="使用分配器-allocator"><a href="#使用分配器-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#使用分配器-allocator" class="headerlink" title="使用分配器 allocator"></a>使用分配器 allocator</h3><p>这部分先了解怎么使用分配器，后面会有专题来讲解分配器的原理</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230415165550803.png" alt="image-20230415165550803"></p><p><strong>虽然分配器有申请内存空间并且归还内存空间的接口，但是不建议直接使用分配器，因为这样分配器的负担太重了。而应该去使用容器，让分配器给容器分配空间，这样的效率会高很多!!!</strong></p><h2 id="第二讲：分配器-迭代器"><a href="#第二讲：分配器-迭代器" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二讲：分配器-迭代器" class="headerlink" title="第二讲：分配器 迭代器"></a>第二讲：分配器 迭代器</h2><h3 id="OOP-面向对象编程-和GP-泛型编程"><a href="#OOP-面向对象编程-和GP-泛型编程" class="heading-link"><i class="fas fa-link"></i></a><a href="#OOP-面向对象编程-和GP-泛型编程" class="headerlink" title="OOP(面向对象编程)和GP(泛型编程)"></a>OOP(面向对象编程)和GP(泛型编程)</h3><p>OOP将 data 和 methods 结合在一起,GP却将他们两个分开来</p><p>采用GP:</p><p>1.容器Containers和算法Algorithms可以各自闭门造车，通过迭代器Iterator连接起来即可</p><p>2.算法ALgorithms通过迭代器Iterator确定操作范围，并通过Iterator取用Container元素</p><h3 id="随机访问迭代器"><a href="#随机访问迭代器" class="heading-link"><i class="fas fa-link"></i></a><a href="#随机访问迭代器" class="headerlink" title="随机访问迭代器"></a>随机访问迭代器</h3><p>随机访问迭代器 RandomAccessIterator：能够随机访问容器中的任一元素，例如vector单端数组</p><p>这样的迭代器可以进行+ -号的运算，例如:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mid=(v.<span class="built_in">begin</span>()+v.<span class="built_in">end</span>())/<span class="number">2</span> <span class="comment">//随访访问迭代器才可以这么操作</span></span><br></pre></td></tr></table></div></figure><p>提到这里，就不得不提一下算法库里的全局函数 sort() 了</p><p><strong>sort()函数内部实现的机制调用了随机访问迭代器，进行了+-的运算，所以能调用的前提只能是随机访问迭代器，比如vector,deque</strong></p><p><strong>所以由于list不满足这个迭代器，所以他不能调用全局sort函数，只能用自己类实现的sort函数，即 l.sort()</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(list&lt;Type&gt; &amp;l)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    for_each(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> val)</span><br><span class="line">             &#123; cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        l.<span class="built_in">push_back</span>(<span class="number">9</span> - i);</span><br><span class="line">    <span class="built_in">print</span>(l);</span><br><span class="line">    <span class="comment">// sort(l.begin(), l.end(), less_equal&lt;int&gt;());//用不了 因为他不是RandomAccessIterator Error!!!</span></span><br><span class="line">    l.<span class="built_in">sort</span>(<span class="built_in">less_equal</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">print</span>(l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="GP-泛型编程举一个例子"><a href="#GP-泛型编程举一个例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#GP-泛型编程举一个例子" class="headerlink" title="GP 泛型编程举一个例子"></a>GP 泛型编程举一个例子</h3><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fuck</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> Type &amp;<span class="title">max</span><span class="params">(<span class="type">const</span> Type &amp;a, <span class="type">const</span> Type &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &lt; b ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, <span class="keyword">class</span> <span class="title class_">functor</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">const</span> Type &amp;<span class="title">max</span><span class="params">(<span class="type">const</span> Type &amp;a, <span class="type">const</span> Type &amp;b, functor &amp;cmp)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">cmp</span>(a, b) ? b : a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">strCmp</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s<span class="number">1.</span><span class="built_in">size</span>() &lt; s<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max of zoo and hello: &quot;</span> &lt;&lt; fuck::<span class="built_in">max</span>(<span class="built_in">string</span>(<span class="string">&quot;zoo&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)) &lt;&lt; endl;         <span class="comment">// zoo</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;max of zoo and hello: &quot;</span> &lt;&lt; fuck::<span class="built_in">max</span>(<span class="built_in">string</span>(<span class="string">&quot;zoo&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), strCmp) &lt;&lt; endl; <span class="comment">// hello</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这个例子很简单，就不多做解释了</p><h3 id="重载new运算符-operator-new"><a href="#重载new运算符-operator-new" class="heading-link"><i class="fas fa-link"></i></a><a href="#重载new运算符-operator-new" class="headerlink" title="重载new运算符 operator new"></a>重载new运算符 operator new</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416094923459.png" alt="image-20230416094923459"></p><p>可以看到，在c++当中，new关键字在调用之后都会走到c语言的malloc函数来分配内存，然后malloc函数分配内存的机制就是上面那个内存块所示</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095052581.png" alt="image-20230416095052581" style="zoom:67%"><p>size所包含的内容才是我想要的存放数据的内容部分，但是malloc会给我们开辟比size更大的空间，这些在另一门课里面会具体谈到。</p><h3 id="分配器-allocators"><a href="#分配器-allocators" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配器-allocators" class="headerlink" title="分配器 allocators"></a>分配器 allocators</h3><h4 id="VC6-allocator"><a href="#VC6-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#VC6-allocator" class="headerlink" title="VC6 allocator"></a>VC6 allocator</h4><p>VC6里面的分配器具体实现如下图：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095559995.png" alt="image-20230416095559995"></p><p>分配器当中最重要的就是 <strong>allocate 函数 和 deallocate 函数</strong></p><p>从上图中可以看出，VC提供的分配器在分配的时候，allocate函数在调用的时候会调用 new 关键字，也就是会调用 malloc 函数</p><p>在释放内存的时候调用deallocate 函数，也就是调用delete关键字，最终就是调用free 函数</p><p>结论：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095953933.png" alt="image-20230416095953933"></p><p>对于这个allocator，如果硬要用的话可以这么使用</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 建立分配器</span></span><br><span class="line"><span class="type">int</span> *p = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">512</span>, (<span class="type">int</span> *)<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 归还</span></span><br><span class="line"><span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p, <span class="number">512</span>);<span class="comment">//在归还的时候还需要之前的大小，所以非常不好用!!!</span></span><br></pre></td></tr></table></div></figure><h4 id="BC-allocator"><a href="#BC-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#BC-allocator" class="headerlink" title="BC++ allocator"></a>BC++ allocator</h4><p>BC5 STL中对分配器的设计和VC6一样，没有特殊设计</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416101021861.png" alt="image-20230416101021861"></p><p>操作略</p><h4 id="GCC2-9-allocator"><a href="#GCC2-9-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#GCC2-9-allocator" class="headerlink" title="GCC2.9 allocator"></a>GCC2.9 allocator</h4><p>和前面两个一样，也没有特殊设计，就是简单的调用malloc 和 free分配和释放内存</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416101451151.png" alt="image-20230416101451151"></p><p>右边这一段注释的意思就是虽然这里实现了符合标准的allocator，但是他自己的容器从来不去用这些分配器，这些分配器都有一个致命的缺点，就是因为本质是在调用mallloc和free函数，根据前面的内存分配机制很容易看出会产生很多的其他空间，从而被浪费，所以开销相对比较大，一般不用</p><h4 id="GCC2-9-自己使用的分配器：alloc-不是allocator"><a href="#GCC2-9-自己使用的分配器：alloc-不是allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#GCC2-9-自己使用的分配器：alloc-不是allocator" class="headerlink" title="GCC2.9 自己使用的分配器：alloc(不是allocator!!!)"></a>GCC2.9 自己使用的分配器：alloc(不是allocator!!!)</h4><p>这个分配器想必比allocator要好用的多</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416102010067.png" alt="image-20230416102010067"></p><p>其具体实现如下：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416102442772.png" alt="image-20230416102442772"></p><p><strong>怎么实现的呢？设计了16个链表，每个链表管理特定大小的区块，#0管理8个字节，#1管理16，以此类推，最后#15管理168个字节。所有使用这个分配器的元素的大小会被调整到8的倍数，比如50的大小会被调整到56。如果该链表下面没有挂内存块，那么会向操作系统用malloc函数申请一大块内存块，然后做切割，之后分出一块给该容器，用单项链表存储。这样的好处是避免了cookie的额外开销，减少了内存浪费。</strong></p><p>这个东西的缺陷到内存管理里面去讲。</p><h4 id="GCC4-9-使用的分配器：allocator-不是alloc"><a href="#GCC4-9-使用的分配器：allocator-不是alloc" class="heading-link"><i class="fas fa-link"></i></a><a href="#GCC4-9-使用的分配器：allocator-不是alloc" class="headerlink" title="GCC4.9 使用的分配器：allocator(不是alloc!!!)"></a>GCC4.9 使用的分配器：allocator(不是alloc!!!)</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416105043344.png" alt="image-20230416105043344"></p><p>发现 allocator 是继承的父类 new_allocator</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416105348361.png" alt="image-20230416105348361"></p><p><strong>发现GCC4.9使用的分配器和之前的分配器没什么区别，没有特殊设计，就是调用的malloc函数和free函数，不知道为什么(这个团队没解释)</strong></p><p><strong>但是但是！GCC4.9里面的__pool_alloc就是GCC2.9里面的alloc,非常好用的那个</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416110401962.png" alt="image-20230416110401962"></p><h3 id="容器之间的关系"><a href="#容器之间的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器之间的关系" class="headerlink" title="容器之间的关系"></a>容器之间的关系</h3><p>容器与容器之间的关系基本上都是复合的关系，比如set&#x2F;multiset和map&#x2F;multimap底层都是由rbtree红黑树实现的等等，具体见下图</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416154815162.png" alt="image-20230416154815162"></p><h3 id="区别size-和sizeof"><a href="#区别size-和sizeof" class="heading-link"><i class="fas fa-link"></i></a><a href="#区别size-和sizeof" class="headerlink" title="区别size()和sizeof()"></a>区别size()和sizeof()</h3><p>以容器list为例，list.size()和sizeof(list)是没有直接的大小联系的（单项链表forward_list不存在size()方法）</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在vscode+linux g++编译器中</span></span><br><span class="line">    list&lt;<span class="type">char</span>&gt; l;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        l.<span class="built_in">push_back</span>(<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; l.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 26</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(l) &lt;&lt; endl; <span class="comment">// 24</span></span><br></pre></td></tr></table></div></figure><p>l.size()指的是容器中存放的元素个数；sizeof(l)指的是需要形成list这个容器需要这个类所占的内存有多大，list类里面不仅存放了链表的指针，还有其他的成员属性来配合控制这个容器的运行.所以sizeof(l)和这个元素的个数一般没有关系。</p><h3 id="深入探索-list"><a href="#深入探索-list" class="heading-link"><i class="fas fa-link"></i></a><a href="#深入探索-list" class="headerlink" title="深入探索 list"></a>深入探索 list</h3><p>GCC2.9是这样写的</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416160403390.png" alt="image-20230416160403390"></p><p>可以看出，list里面非常重要的一点设计就是<strong>委托</strong>设计，<strong>即list本身的类并不是实际的双向链表，用户所能操作的这个类其实可以看作双向链表的管理类，里面有成员函数，迭代器，还有一根指向双向链表的指针，实际的双向链表结构就如上面所示,__list_node，这个才是真正的存储结构</strong>，这也是为什么sizeof()和size()是不一样的，因为设计者很好的把二者分开了，使得用户和写代码的人都能很好的管理自己的部分。</p><p>由于list的存储是不连续的，所以相应的他的迭代器也需要是智能指针，需要重载++和–运算符，(注意list的迭代器不是随机访问迭代器，所以不能使用+ -号运算符，也不能使用算法库的函数sort()，而需要使用自带的函数sort() )那么就应该是一个类了。<strong>进而推得所有的容器(除了vector和array)的迭代器，最好都写成一个类来实现。</strong></p><h4 id="list的迭代器"><a href="#list的迭代器" class="heading-link"><i class="fas fa-link"></i></a><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h4><p>这个迭代器最重要的就是重载 ++ 运算符，也就是前置++和后置++</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416163304200.png" alt="image-20230416163304200"></p><p>前置++和后置++的区别就是后置++的参数列表里面会有一个占位符int来表示他是后置++</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置++</span></span><br><span class="line">self&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">    node=(link_type)((*node).next);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里的self是指迭代器这个类，是个别名。这个实现还是比较容器理解的</span></span><br><span class="line"><span class="comment">//注意返回的是迭代器新的位置所以可以返回引用类型</span></span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">__list_iterator(<span class="type">const</span> iterator&amp; x):<span class="built_in">node</span>(x.node)&#123;&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载*</span></span><br><span class="line">reference <span class="keyword">operator</span>*()<span class="type">const</span>&#123;<span class="keyword">return</span> (*node).data;&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后置++</span></span><br><span class="line">self <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">	self tmp=*<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//这一步仔细看看，可能会调用拷贝构造(=)，可能也会调用*重载，但是*重载明显不符合要求</span></span><br><span class="line">    <span class="comment">//再加上 = 在前面，所以调用的是拷贝构造，*this已经被看作拷贝构造的参数，拷贝出来了一个新的原位置迭代器!!!!</span></span><br><span class="line">	++*<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//前置++</span></span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意由于需要返回原位置的迭代器，而现在的迭代器已经改变了，所以最好新创建一个，return by value</span></span><br></pre></td></tr></table></div></figure><h4 id="关于为什么后置-不能返回引用，比较有说服力的还有如下的原因："><a href="#关于为什么后置-不能返回引用，比较有说服力的还有如下的原因：" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于为什么后置-不能返回引用，比较有说服力的还有如下的原因：" class="headerlink" title="关于为什么后置++不能返回引用，比较有说服力的还有如下的原因："></a>关于为什么后置++不能返回引用，比较有说服力的还有如下的原因：</h4><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">2</span>;</span><br><span class="line">cout&lt;&lt; ++++i &lt;&lt; j++++ &lt;&lt; endl;</span><br></pre></td></tr></table></div></figure><p><strong>我们尝试将i和j分别进行前置和后置++分别加两次，c++的编译器允许前置++连续加，但是不允许后置++连续加，我们知道想要连续加的条件就是要返回引用继续修改原本的值，所以既然不允许连续后置++，那么就return by value，直接创建一个新对象</strong></p><p>然后类在重载这两个运算符的时候也会向编译器自带的规则看起，也不允许后置++连续加，所以就只能return by value</p><h4 id="关于-和-amp-运算符的重载"><a href="#关于-和-amp-运算符的重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于-和-amp-运算符的重载" class="headerlink" title="关于 * 和 &amp; 运算符的重载"></a>关于 * 和 &amp; 运算符的重载</h4><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fuck</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">fuck</span>(<span class="type">int</span> data = <span class="number">0</span>) : _data(data) &#123;&#125;<span class="comment">//构造函数，可以将int类型转化为类对象</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getData</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>-&gt;_data; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    list&lt;fuck&gt; l&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> iter = l.<span class="built_in">begin</span>();<span class="comment">//取得首个元素迭代器</span></span><br><span class="line">    <span class="comment">//*iter取得的是 fuck 对象,iter-&gt;取得的是 fuck对象指针</span></span><br><span class="line">    <span class="comment">//对于简单的类型 iter-&gt;没什么作用，比如int，这时候*iter就代表了value，但是对于类对象那就不一样了</span></span><br><span class="line">    cout &lt;&lt; (*iter).<span class="built_in">getData</span>() &lt;&lt; endl;</span><br><span class="line">    iter-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>*和-&gt;的具体实现,Type是类的类型</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Type&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> Type* pointer;</span><br><span class="line"><span class="comment">//* 返回的是类对象</span></span><br><span class="line">reference <span class="keyword">operator</span>*()&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;node);<span class="comment">//node是迭代器当中存放的链表指针对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//-&gt; 返回的是类对象指针</span></span><br><span class="line">pointer <span class="keyword">operator</span>-&gt;()&#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="G4-9-和-G2-9的区别"><a href="#G4-9-和-G2-9的区别" class="heading-link"><i class="fas fa-link"></i></a><a href="#G4-9-和-G2-9的区别" class="headerlink" title="G4.9 和 G2.9的区别"></a>G4.9 和 G2.9的区别</h4><p>具体区别就如下图所示：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416171855901.png" alt="image-20230416171855901"></p><p>在4.9版本当中</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230416174305071.png" alt="image-20230416174305071"></p><p><strong>刻意在list尾端加上一段空白的区域来复合STL迭代器前闭后开的特征!!!但是相应的这个设计的复杂度又大大增加了。</strong></p><h3 id="迭代器的设计原则"><a href="#迭代器的设计原则" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器的设计原则" class="headerlink" title="迭代器的设计原则"></a>迭代器的设计原则</h3><p>Iterator需要遵循的原则：在调用算法的时候，iterator作为中间桥梁连接容器和算法，所以算法需要知道Iterator的很多东西</p><p><strong>算法需要知道迭代器的必要信息，进而决定采取最优化的动作</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419170456164.png" alt="image-20230419170456164"></p><p>在C++标准库当中设计出五种标准类型:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iterator_category;</span><br><span class="line"><span class="comment">//迭代器的分类：只读，只写，允许写入型算法在迭代器区间上进行读写操作(Forward Iterator)，可双向移动，Random Access Iterator</span></span><br><span class="line">difference_type;<span class="comment">//用来表示迭代器之间的距离，也可以用来表示一个容器的最大容量</span></span><br><span class="line">value_type;<span class="comment">//迭代器所指对象的类型</span></span><br><span class="line"></span><br><span class="line">reference;</span><br><span class="line">pointer;<span class="comment">//最后两个基本没用到</span></span><br></pre></td></tr></table></div></figure><p>这五种类型被称作 <strong>associated type 相关类型</strong>；迭代器本身必须定义出来，以便回答算法</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419170815213.png" alt="image-20230419170815213"></p><p>比如我自己写一下链表list的五个相关类型</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCC4.9版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_Type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List_Iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::bidirectional_iterator_tag _iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> _difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Type _value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Type&amp; _reference;</span><br><span class="line">    <span class="keyword">typedef</span> _Type* _pointer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>引出问题：算法调用的时候传进去的可能不是个迭代器，可能是个指针，这个时候该怎么办呢？</strong></p><p>当然，指针是个<strong>退化</strong>的迭代器!!!</p><h3 id="Traits-萃取机"><a href="#Traits-萃取机" class="heading-link"><i class="fas fa-link"></i></a><a href="#Traits-萃取机" class="headerlink" title="Traits 萃取机"></a>Traits 萃取机</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419190233258.png" alt="image-20230419190233258"></p><p><strong>Iterator Traits用于区分是 class Iterators (也就是一般的迭代器)还是 non-class Iterators(即 native pointer)；两种情况对应不同的的处理!!</strong></p><p>在算法和迭代器之间加一层中间层Iterator traits来进行判断，好针对性的进行设计!!!</p><p>具体怎么做呢？</p><p>这时候算法里面就不能直接问迭代器的五个类型了，因为 native pointer 里面没有这五个参数,所以需要间接通过Traits去问!!!</p><p>下面的例子先回答了一个问题 value_type</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I,...&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">algorithm</span><span class="params">(...)</span></span>&#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::value_type v1;<span class="comment">//通过traits去问</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是class Iterator在这里</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">I</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> I::value_type value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个模板偏特化 pointer to T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pointer to const T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type; <span class="comment">//注意是T而不是const T</span></span><br><span class="line">    <span class="comment">//为什么是 T 而不是 const T？因为 value_type主要目的是去声明变量，const T没办法声明变量!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>下面把指针的全回答完毕</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pointer to T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;T*&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pointer to const T</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">iterator_traits</span>&lt;<span class="type">const</span> T*&gt;&#123;</span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> T&amp; reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="第三讲：容器"><a href="#第三讲：容器" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三讲：容器" class="headerlink" title="第三讲：容器"></a>第三讲：容器</h2><h3 id="深入探索vector"><a href="#深入探索vector" class="heading-link"><i class="fas fa-link"></i></a><a href="#深入探索vector" class="headerlink" title="深入探索vector"></a>深入探索vector</h3><p>其实自己都可以封装一个vector，当然所有的功能是不现实的，但是基本的功能还是可以</p><h4 id="GCC2-9的设计"><a href="#GCC2-9的设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#GCC2-9的设计" class="headerlink" title="GCC2.9的设计"></a>GCC2.9的设计</h4><p>直观感受就是简洁明了</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419192921703.png" alt="image-20230419192921703"></p><p>这里面有三根泛型指针，start，finish和end_of_storage</p><p><strong>下面就是比较重要的push_back()查数据，引出后面的二倍扩展空间!!!</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419195537174.png" alt="image-20230419195537174"></p><p><strong>else这里，调用insert_aux之后为什么还要进行一次判断呢？</strong></p><p><strong>这是因为由于insert_aux是一个辅助函数，那么在实际操作过程中可能会被其他类函数调用，比如insert，在这些函数的实现逻辑当中是需要进行判断的。</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419195610102.png" alt="image-20230419195610102"></p><p><strong>这段源码的大致意思就是：capacity不够了就在内存中找另一块2倍大小的内存用于存放新的vector，把原来的元素拷贝过去然后把原来的vector杀掉，各种值迁移到新内存这边去!!!</strong></p><p><strong>至于拷贝安插点后的原内容是因为这里可能会被insert函数给调用，这个部分是insert函数的逻辑!!!</strong></p><p><strong>Vector容器的迭代器</strong></p><p>既然vector是一个连续空间，那么iterator就不必要设置成为class了，只需要设置为pointer就可以</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//所以如上所示，vector的迭代器是一根指针</span></span><br><span class="line"><span class="keyword">typedef</span> value_type* iterator; <span class="comment">// T*</span></span><br></pre></td></tr></table></div></figure><h4 id="GCC4-9的设计"><a href="#GCC4-9的设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#GCC4-9的设计" class="headerlink" title="GCC4.9的设计"></a>GCC4.9的设计</h4><p>复杂，依托答辩</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230419201320469.png" alt="image-20230419201320469"></p><h3 id="深入探索-deque-和-queue-stack"><a href="#深入探索-deque-和-queue-stack" class="heading-link"><i class="fas fa-link"></i></a><a href="#深入探索-deque-和-queue-stack" class="headerlink" title="深入探索 deque 和 queue , stack"></a>深入探索 deque 和 queue , stack</h3><h4 id="deque-1"><a href="#deque-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#deque-1" class="headerlink" title="deque"></a>deque</h4><p>deque 双端队列的实现结构：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420164335846.png" alt="image-20230420164335846"></p><p><strong>具体实现：将deque的存储划分为若干个等大的区域，每个区域的首元素用一个指针存放在一个vector容器中(就是图中的map数组)，当缓冲区buffer的左端或者右端不够的时候，就新开一个缓冲区放在左边和右边，存入元素，并且把该buffer的首指针存入map数组的左边或者右边。因此deque的迭代器的就分为：</strong></p><p><strong>first 该缓冲区的首地址；last 该缓冲区的末尾(首闭尾开)；cur 元素的位置；node 存入map数组的指针!!!</strong></p><p>下面看一下deque的具体源代码设计：</p><p><strong>GCC2.9:</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170120084.png" alt="image-20230420170120084"></p><p>其中第三个参数 Bufsiz 是可以人为指定缓冲区的大小</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170739434.png" alt="image-20230420170739434"></p><p>从这里可以看出，上面调用了一个函数，如果 BufSiz 不为0，那么就设置大小为人为指定；如果为0，则表示设置为预设的值，需要查看要存放的类型的大小，大于512就指定一个缓冲区只放这一个元素，个数设置为1；小于的话就计算出个数，计算出个数之后就可以知道缓冲区的大小了</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170150250.png" alt="image-20230420170150250"></p><p>这个迭代器里面也包含了五个必要类型，写的非常严谨，也有了四个需要的参数!!!</p><p><strong>Insert函数:</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420172205138.png" alt="image-20230420172205138"></p><p>如果是在头部和尾部插入，那么和push_front()和push_back()没有区别</p><p>如果在中间插入就调用赋值函数 insert_aux()</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420172617688.png" alt="image-20230420172617688"></p><p>由于在中间插入必然会导致元素的拷贝过程，为了减少开销，提高效率，我们需要判断元素在deque靠近start和finish哪一端的位置，这样可以更好的去选择操作的方向</p><p><strong>deque如何模拟连续空间操作？(操作符重载)</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420173341877.png" alt="image-20230420173341877"></p><p><strong>deque 的 - 号操作符重载</strong></p><p>由于 deque 存储的缓冲区buffer机制，我们必须判断两个迭代器之间有多少个缓冲区buffer，然后再根据计算公式来进行计算得出两个迭代器之间元素的个数</p><p>具体就是这样!</p><p><strong>根据两个迭代器的node指针找到map数组里面两个指针距离的位置就可以知道两个中间差了多少个缓冲区buffer了，再加上本缓冲区内的距离就是两个迭代器之间的元素个数!!!</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420173832550.png" alt="image-20230420173832550"></p><p><strong>++ 和 – 操作符重载</strong></p><p>注意需要判断迭代器移动过程中是否超越了本缓冲区的界限移入另一个缓冲区!!!</p><p>一个比较好的编码习惯就是后++调用前++；后–调用前–</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420174307662.png" alt="image-20230420174307662"></p><p><strong>+&#x3D; + 号操作符重载</strong></p><p>在 +&#x3D; 运算符重载中，需要注意判断迭代器位置移动之后有没有超越边界，如果超越了边界，需要进行相应的边界修改</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193008988.png" alt="image-20230420193008988"></p><p>+&#x3D; 如果没有正确的缓冲区需要切换到正确的缓冲区；如果是正确的缓冲区那就很简单了</p><p><strong>-&#x3D; - 号运算符重载</strong></p><p>用的是+&#x3D;和+号的重载</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193316669.png" alt="image-20230420193316669"></p><p><strong>GCC 4.9:</strong> 依托答辩</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193754702.png" alt="image-20230420193754702"></p><h4 id="queue-1"><a href="#queue-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#queue-1" class="headerlink" title="queue"></a>queue</h4><p><strong>内部存了一个 deque 容器，二者形成了复合 composition 关系</strong></p><p>queue内部的函数，deque能完全满足它，所以调用 deque 的成员函数就可以了!!!</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421103130501.png" alt="image-20230421103130501"></p><p><strong>queue和stack，关于其iterator和底层容器</strong></p><p><strong>stack和queue不允许遍历，也不提供iterator!!!!</strong></p><p>因为他们的模式是先进后出和先进先出，这样的模式不允许能访问到任意位置的元素</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104600566.png" alt="image-20230421104600566"></p><p><strong>关于stack和queue的内部支撑容器，上面讲的是deque，其实也可以用list</strong></p><p>默认提供的是deque，这个效率比较快一点</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104609426.png" alt="image-20230421104609426"></p><p><strong>stack可以用vector做底部支撑；queue不可以用vector!!!</strong></p><p>因为vector没有 pop_front() 函数!!!</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104723249.png" alt="image-20230421104723249"></p><p><strong>关于其他的底部容器支撑，stack和queue都不可以选用set或者map做底部容器支撑，因为他们两个也没有相应的函数提供!!!</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421105352734.png" alt="image-20230421105352734"></p><p>关于这些底部容器支撑，如果你没有调用它不存在的函数，那其实调用还是可以的，但是总体来看是不行的!!!</p><h3 id="自己手写了一个简单的二叉树-创建二叉树函数不会"><a href="#自己手写了一个简单的二叉树-创建二叉树函数不会" class="heading-link"><i class="fas fa-link"></i></a><a href="#自己手写了一个简单的二叉树-创建二叉树函数不会" class="headerlink" title="自己手写了一个简单的二叉树(创建二叉树函数不会)"></a>自己手写了一个简单的二叉树(创建二叉树函数不会)</h3><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TreeNode.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TREENODE__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TREENODE__</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Left_Right</span></span><br><span class="line">&#123;</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结点类</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Type __ValueType;</span><br><span class="line">    <span class="keyword">typedef</span> TreeNode&lt;__ValueType&gt; __NodeType;</span><br><span class="line">    <span class="keyword">typedef</span> __NodeType *__pointer;</span><br><span class="line"></span><br><span class="line">    __ValueType val;</span><br><span class="line">    __pointer left;</span><br><span class="line">    __pointer right;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> __init__();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(__ValueType val, <span class="type">bool</span> is_left = Left)</span></span>; <span class="comment">// 1为左 0为右 默认为做左</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 虽然不给节点写构造函数但是写一个初始化没问题的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> TreeNode&lt;Type&gt;::__init__()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">this</span>-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入子树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> TreeNode&lt;Type&gt;::<span class="built_in">insert</span>(__ValueType val, <span class="type">bool</span> is_left)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (is_left == Left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;leftnode has already be used.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __pointer newNode = <span class="keyword">new</span> TreeNode&lt;__ValueType&gt;;</span><br><span class="line">        newNode-&gt;__init__();</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;rightnode has already be used.&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        __pointer newNode = <span class="keyword">new</span> TreeNode&lt;__ValueType&gt;;</span><br><span class="line">        newNode-&gt;__init__();</span><br><span class="line">        newNode-&gt;val = val;</span><br><span class="line">        <span class="keyword">this</span>-&gt;right = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// visit</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> TreeNode&lt;Type&gt;::<span class="built_in">visit</span>()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="keyword">this</span>-&gt;val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> TreeNode&lt;Type&gt;::<span class="built_in">PreOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">visit</span>();</span><br><span class="line">    left-&gt;<span class="built_in">PreOrder</span>();</span><br><span class="line">    right-&gt;<span class="built_in">PreOrder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> TreeNode&lt;Type&gt;::<span class="built_in">InOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    left-&gt;<span class="built_in">InOrder</span>();</span><br><span class="line">    <span class="built_in">visit</span>();</span><br><span class="line">    right-&gt;<span class="built_in">InOrder</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> TreeNode&lt;Type&gt;::<span class="built_in">PostOrder</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    left-&gt;<span class="built_in">PostOrder</span>();</span><br><span class="line">    right-&gt;<span class="built_in">PostOrder</span>();</span><br><span class="line">    <span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BinaryTree.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __BINARTTREE__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __BINARTTREE__</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TreeNode.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Order</span></span><br><span class="line">&#123;</span><br><span class="line">    pre,</span><br><span class="line">    in,</span><br><span class="line">    post</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写一个全局函数来删除二叉树</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">deleteNodes</span><span class="params">(TreeNode&lt;Type&gt; *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">        <span class="built_in">deleteNodes</span>(node-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">        <span class="built_in">deleteNodes</span>(node-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义整颗二叉树类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> Type __ValueType;</span><br><span class="line">    <span class="keyword">typedef</span> TreeNode&lt;__ValueType&gt; __NodeType;</span><br><span class="line">    <span class="keyword">typedef</span> __NodeType &amp;__reference;</span><br><span class="line">    <span class="keyword">typedef</span> __NodeType *__pointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// BinaryTree();</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">BinaryTree</span><span class="params">(__ValueType val = <span class="literal">NULL</span>)</span></span>; <span class="comment">// 不给默认值就是NULL</span></span><br><span class="line">    ~<span class="built_in">BinaryTree</span>() &#123; <span class="built_in">deleteTree</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteTree</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printTree</span><span class="params">(Order ord)</span></span>;</span><br><span class="line">    <span class="function">__reference <span class="title">getroot</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> *root; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    __pointer root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> BinaryTree&lt;Type&gt;::<span class="built_in">BinaryTree</span>(__ValueType val)</span><br><span class="line">&#123;</span><br><span class="line">    root = <span class="keyword">new</span> TreeNode&lt;Type&gt;;</span><br><span class="line">    root-&gt;val = val;</span><br><span class="line">    root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">    root-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 整棵树的析构函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BinaryTree&lt;Type&gt;::<span class="built_in">deleteTree</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">deleteNodes</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Type</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> BinaryTree&lt;Type&gt;::<span class="built_in">printTree</span>(Order ord)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ord)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> pre:</span><br><span class="line">        root-&gt;<span class="built_in">PreOrder</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> in:</span><br><span class="line">        root-&gt;<span class="built_in">InOrder</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> post:</span><br><span class="line">        root-&gt;<span class="built_in">PostOrder</span>();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BinaryTree.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">       1</span></span><br><span class="line"><span class="comment">   3         2</span></span><br><span class="line"><span class="comment">4    6    8</span></span><br><span class="line"><span class="comment">    7        0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">namespace</span> test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">BinaryTree&lt;<span class="type">int</span>&gt; <span class="title">sample</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">BinaryTree&lt;<span class="type">int</span>&gt; <span class="title">tree</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">        tree.<span class="built_in">getroot</span>().<span class="built_in">insert</span>(<span class="number">3</span>, Left);</span><br><span class="line">        <span class="comment">// left</span></span><br><span class="line">        <span class="keyword">auto</span> leftNode = tree.<span class="built_in">getroot</span>().left;</span><br><span class="line">        leftNode-&gt;<span class="built_in">insert</span>(<span class="number">4</span>, Left);</span><br><span class="line">        leftNode-&gt;<span class="built_in">insert</span>(<span class="number">6</span>, Right);</span><br><span class="line">        <span class="keyword">auto</span> leftNode2 = leftNode-&gt;right;</span><br><span class="line">        leftNode2-&gt;<span class="built_in">insert</span>(<span class="number">7</span>, Left);</span><br><span class="line">        <span class="comment">// right</span></span><br><span class="line">        tree.<span class="built_in">getroot</span>().<span class="built_in">insert</span>(<span class="number">2</span>, Right);</span><br><span class="line">        <span class="keyword">auto</span> rightNode = tree.<span class="built_in">getroot</span>().right;</span><br><span class="line">        rightNode-&gt;<span class="built_in">insert</span>(<span class="number">8</span>, Left);</span><br><span class="line">        <span class="keyword">auto</span> rightNode2 = rightNode-&gt;left;</span><br><span class="line">        rightNode2-&gt;<span class="built_in">insert</span>(<span class="number">0</span>, Right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> tree = test::<span class="built_in">sample</span>();</span><br><span class="line"></span><br><span class="line">    tree.<span class="built_in">printTree</span>(pre); <span class="comment">// 1 3 4 6 7 2 8 0</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    tree.<span class="built_in">printTree</span>(in); <span class="comment">// 4 3 7 6 1 8 0 2</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    tree.<span class="built_in">printTree</span>(post); <span class="comment">// 4 7 6 3 0 8 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="rb-Tree-红黑树"><a href="#rb-Tree-红黑树" class="heading-link"><i class="fas fa-link"></i></a><a href="#rb-Tree-红黑树" class="headerlink" title="rb_Tree 红黑树"></a>rb_Tree 红黑树</h3><p>红黑树是一种高度平衡的二叉搜寻树；由于它保持尽量的平衡，非常有利于search和insert的操作，并且在改变了元素的操作之后会继续保持树状态的平衡</p><h4 id="红黑树-rb-Tree-与二叉平衡树-AVL-的对比："><a href="#红黑树-rb-Tree-与二叉平衡树-AVL-的对比：" class="heading-link"><i class="fas fa-link"></i></a><a href="#红黑树-rb-Tree-与二叉平衡树-AVL-的对比：" class="headerlink" title="红黑树 rb_Tree 与二叉平衡树 AVL 的对比："></a>红黑树 rb_Tree 与二叉平衡树 AVL 的对比：</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421175541816.png" alt="image-20230421175541816"></p><p><strong>为什么要有红黑树？</strong></p><p>大多数二叉排序树 BST 的操作（查找、最大值、最小值、插入、删除等等）都是 O(h)O(h)O(h) 的时间复杂度，h 为树的高度。但是对于斜树而言（BST极端情况下出现），BST的这些操作的时间复杂度将达到 O(n) 。为了保证BST的所有操作的时间复杂度的上限为 O(logn)，就要想办法把一颗<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=BST%E6%A0%91&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:1246106121%7D">BST树</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的高度一直维持在logn，而红黑树就做到了这一点，红黑树的高度始终都维持在logn，n 为树中的顶点数目。</p><p>rb_Tree和AVL相比，虽然AVL更加平衡，但是条件更加苛刻，<strong>红黑树追求的是大致平衡。</strong> AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。<strong>所以涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树；当然，如果你的应用中涉及的插入和删除操作并不频繁，而是查找操作相对更频繁，那么就优先选择 AVL 树进行实现</strong></p><p>红黑树<strong>提供遍历操作以及迭代器iterator</strong>，但是这个迭代器是<strong>只读迭代器</strong>，因为<strong>不能修改节点上元素的值</strong>，如果修改了元素的值，那么会导致大小关系发生变化，整个红黑树的平衡性就发生变化了</p><p>图中第三段，按理来说红黑树的元素是不能通过迭代器修改元素值的，但是这个红黑树后面是用于set和map容器的，set的key和value相等不能修改；但是map的key和value没有必然联系，排序和查找都是基于key来进行的，value可以任意修改，所以可以通过迭代器修改value，这么做做是正确的</p><p>红黑树的设计当中存在两种设计 <strong>insert_unique() 和 insert_equal()</strong> ，表示key可以重复或者不重复，这样就可以引申出 set和 multiset，mal和 multimap</p><h4 id="标准库对红黑树的实现"><a href="#标准库对红黑树的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#标准库对红黑树的实现" class="headerlink" title="标准库对红黑树的实现:"></a>标准库对红黑树的实现:</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421182526116.png" alt="image-20230421182526116"></p><p><strong>这里标准库里面的value不是指我们理解的value值，这里的value是key和data合起来叫做value，也就是一整个节点的类型；第三个参数是说我们怎么样从这个节点value当中把重要的key拿出来!!!第四个参数是说如何根据key来进行比较，因为后续要进行排序操作!!!</strong></p><p>在rb_tree类当中，它的设计和我的设计差不多，都是把树和节点分开的来设计，所以在树rb_tree当中只用了三个参数来向外表现</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size_type node_count;<span class="comment">//节点的数量</span></span><br><span class="line">link_type header;<span class="comment">//头节点(类型是指针)</span></span><br><span class="line">Compare key_compare;<span class="comment">//比较key的函数指针或者仿函数</span></span><br></pre></td></tr></table></div></figure><p><strong>在红黑树的结构里有一个 header 节点，他的元素值为空，跟list的设计一样，前闭后开的区间!!!</strong></p><p>这样的设计会使后面的实现方便很多</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421182650170.png" alt="image-20230421182650170"></p><p>虽然红黑树不推荐直接使用，因为更好的做法是使用上层容器；但是可以简单的使用一下来测试我们对其的理解</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rb_tree&lt;<span class="type">int</span>,<span class="type">int</span>,identity&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt;,alloc&gt;;</span><br><span class="line"><span class="comment">//key和value类型相同，说明key和data是一个东西(否则返回的value不可 能是int类型而应该是个类)，这样的话从value中取出key就可以使用写好的identity函数对象，即你传什么给我我就给你返回什么</span></span><br></pre></td></tr></table></div></figure><p>使用红黑树的测试程序:(新版本的名称有些变化)</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stl_tree.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _Rb_tree&lt;<span class="type">int</span>, <span class="type">int</span>, _Identity&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;, allocator&lt;<span class="type">int</span>&gt;&gt; rbtree;</span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(rbtree) &lt;&lt; endl; <span class="comment">// 48 跟插不插元素没关系，因为里面存的是节点指针d</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">empty</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    rbtree._M_insert_unique(<span class="number">3</span>);</span><br><span class="line">    rbtree._M_insert_unique(<span class="number">8</span>);</span><br><span class="line">    rbtree._M_insert_unique(<span class="number">5</span>);</span><br><span class="line">    rbtree._M_insert_unique(<span class="number">9</span>);</span><br><span class="line">    rbtree._M_insert_unique(<span class="number">13</span>);</span><br><span class="line">    rbtree._M_insert_unique(<span class="number">3</span>);      <span class="comment">// unique 所以3插不进去</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">empty</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    rbtree._M_insert_equal(<span class="number">3</span>); <span class="comment">// equal 所以3能插进去</span></span><br><span class="line">    rbtree._M_insert_equal(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">// 7</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">empty</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="基于红黑树的set和map"><a href="#基于红黑树的set和map" class="heading-link"><i class="fas fa-link"></i></a><a href="#基于红黑树的set和map" class="headerlink" title="基于红黑树的set和map"></a>基于红黑树的set和map</h3><h4 id="set-x2F-multiset"><a href="#set-x2F-multiset" class="heading-link"><i class="fas fa-link"></i></a><a href="#set-x2F-multiset" class="headerlink" title="set&#x2F;multiset"></a>set&#x2F;multiset</h4><p>由于set&#x2F;multiset的key和value相同，所以没有办法通过迭代器修改元素的值，也就是修改key，error</p><p>set插入元素使用 insert_unique()；multiset可以重复，使用 insert_equal()</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421192116968.png" alt="image-20230421192116968"></p><p>注意不能修改迭代器的值，const_iterator，以下是示例代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;val : v)</span><br><span class="line">        ++val;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;val : v)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//会自动排序</span></span><br><span class="line">    set&lt;<span class="type">int</span>, less&lt;<span class="type">int</span>&gt;&gt; s&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="comment">// for (int &amp;val : s) // 这里就会报错,因为这个的迭代器是不可以更改值的</span></span><br><span class="line">    <span class="comment">//     ++val;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : s)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="map-x2F-multimap"><a href="#map-x2F-multimap" class="heading-link"><i class="fas fa-link"></i></a><a href="#map-x2F-multimap" class="headerlink" title="map&#x2F;multimap"></a>map&#x2F;multimap</h4><p><strong>map没有办法通过迭代器修改key的值，但是可以用过迭代器修改value的值!!!!!</strong></p><p>map插入元素使用 insert_unique()；multimap 可以重复，使用 insert_equal()</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230421194843419.png" alt="image-20230421194843419"></p><p><strong>key_type和data_type被包装成为一个pair&lt;const Key,T&gt;；注意这里const修饰代表key无法修改，然后value_type是真正的存放类型，然后select1st代表拿取pair里面的第一个元素!!!!</strong></p><p>使用红黑树测试map：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stl_tree.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 源代码这么写的，我没看懂</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectFirst</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Pair::first_type &amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(Pair &amp;x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// typename T::first_type &amp;</span></span><br><span class="line">    <span class="comment">// operator()(T &amp;x) const</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     return x.first;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">int</span> Key_Type;</span><br><span class="line">    <span class="keyword">typedef</span> pair&lt;<span class="type">const</span> <span class="type">int</span>, <span class="type">char</span>&gt; Value_Type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// _Rb_tree&lt;Key_Type, Value_Type, _Select1st&lt;Value_Type&gt;, less&lt;int&gt;&gt; rbtree;</span></span><br><span class="line">    _Rb_tree&lt;Key_Type, Value_Type, SelectFirst&lt;Value_Type&gt;, less&lt;<span class="type">int</span>&gt;&gt; rbtree; <span class="comment">// error</span></span><br><span class="line">    <span class="comment">// select1st怎么写不知道</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(rbtree) &lt;&lt; endl; <span class="comment">// 48 跟插不插元素没关系，因为里面存的是节点指针d</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">empty</span>() &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    rbtree._M_insert_unique(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    rbtree._M_insert_unique(<span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="string">&#x27;b&#x27;</span>));</span><br><span class="line">    rbtree._M_insert_unique(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&#x27;c&#x27;</span>));</span><br><span class="line">    rbtree._M_insert_unique(<span class="built_in">make_pair</span>(<span class="number">9</span>, <span class="string">&#x27;d&#x27;</span>));</span><br><span class="line">    rbtree._M_insert_unique(<span class="built_in">make_pair</span>(<span class="number">13</span>, <span class="string">&#x27;e&#x27;</span>));</span><br><span class="line">    rbtree._M_insert_unique(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&#x27;f&#x27;</span>)); <span class="comment">// unique 所以3插不进去</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">size</span>() &lt;&lt; endl;              <span class="comment">// 5</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">empty</span>() &lt;&lt; endl;             <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl;            <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    rbtree._M_insert_equal(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>)); <span class="comment">// equal 所以3能插进去</span></span><br><span class="line">    rbtree._M_insert_equal(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">// 7</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">empty</span>() &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">    cout &lt;&lt; rbtree.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>其他都没什么，其中第三个模板参数SelectFirst&lt;&gt;(我自己写的)不是很理解为什么这么写</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="comment">//不明白这里为什么要用两次模板并且第一次的模板参数没啥用</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SelectFirst</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Pair</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> Pair::first_type &amp;</span></span><br><span class="line"><span class="function">    <span class="title">operator</span><span class="params">()</span><span class="params">(Pair &amp;x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>使用map的示例代码:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一个参数是key(不可修改,所以进去后红黑树会自动转为const类型),第二个参数是data</span></span><br><span class="line">    <span class="comment">//元素会按照key自动排序!!!</span></span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">char</span>, less&lt;<span class="type">int</span>&gt;&gt; m&#123;<span class="built_in">make_pair</span>(<span class="number">9</span>, <span class="string">&#x27;a&#x27;</span>),</span><br><span class="line">                                <span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">                                <span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">                                <span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="string">&#x27;d&#x27;</span>),</span><br><span class="line">                                <span class="built_in">make_pair</span>(<span class="number">8</span>, <span class="string">&#x27;c&#x27;</span>),</span><br><span class="line">                                <span class="built_in">make_pair</span>(<span class="number">9</span>, <span class="string">&#x27;b&#x27;</span>),</span><br><span class="line">                                <span class="built_in">make_pair</span>(<span class="number">6</span>, <span class="string">&#x27;d&#x27;</span>),</span><br><span class="line">                                <span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="string">&#x27;a&#x27;</span>)&#125;;</span><br><span class="line">    m[<span class="number">0</span>] = <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;val : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//key不可修改，但是data可以修改</span></span><br><span class="line">        cout &lt;&lt; val.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; m[val.first] &lt;&lt; endl;<span class="comment">//类似于py的字典</span></span><br><span class="line">        val.second++;</span><br><span class="line">        cout &lt;&lt; val.first &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; val.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="map独特的-operator"><a href="#map独特的-operator" class="heading-link"><i class="fas fa-link"></i></a><a href="#map独特的-operator" class="headerlink" title="map独特的 operator [ ]!!!"></a>map独特的 operator [ ]!!!</h3><p><strong>作用：根据key传回data。注意只有map有，因为key不为data并且key是独一无二的!!!</strong></p><p><strong>如果key不存在的话，就会创建这个key并且data使用默认值!!!</strong>(和py的字典差不多)</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422140640649.png" alt="image-20230422140640649"></p><p>使用二分查找在有序的key当中查找目标key，如果找不到的话就进行insert操作创建一个新的key！！！</p><h3 id="hashtable-散列表"><a href="#hashtable-散列表" class="heading-link"><i class="fas fa-link"></i></a><a href="#hashtable-散列表" class="headerlink" title="hashtable 散列表"></a>hashtable 散列表</h3><p>哈希表的设计</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422143136762.png" alt="image-20230422143136762"></p><p><strong>在有限的空间之下根据哈希函数将元素(分为key和data)的key映射成为hashcode放到对应的位置下面，key下面用一个链表将key和data串起来!!!!</strong></p><p><strong>由于bucket数组存的是链表指针，这个链表如果串的元素太多了之后那么搜索效率会大大降低，这个状态就是非安全状态。程序员的经验告诉我们当所有的链表下面串的元素个数大于buckets数组的大小的时候就比较危险了。</strong></p><p><strong>这个时候需要打散hashtable，增大buckets数组的size，一般是两倍左右，并且数组的size最好是质数，并且将元素按照新的hash规则重新插入链表中!!!!</strong></p><p>总结就是：不能让hashtable下面串的链表太长，太长了需要增加buckets的size来打散哈希表重新回到安全状态。</p><p>GCC下面的buckets数组的size是这么确定的：<strong>大致都是2倍附近的质数</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422144338234.png" alt="image-20230422144338234"></p><p>来看看hashtable的实现：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422145128498.png" alt="image-20230422145128498"></p><p>Value代表key和data集合，key就是键值，HashFcn代表哈希函数，就是如何把key映射为编号hashcode，ExtractKey代表如何从value里面取出key；EqualKey代表如何判断两个key相同!!!</p><p>至于是单向链表还是双向链表，这个就看不同的版本了。</p><p><strong>参数模板里面最难的一点就是决定hashtable的hash函数，怎么样将hash的key值映射为hashcode!!!</strong></p><p>参考系统提供的hash模板函数</p><p><strong>注意：hash函数(一般是个仿函数)返回的值应该是一个编号，也就是 size_t</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422154019414.png" alt="image-20230422154019414"></p><p>定义了hash函数，然后什么也不做，后面进行一些特化的处理!!!</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422154054412.png" alt="image-20230422154054412"></p><p>注意这里的hash函数设计，我们在将key转化为hashcode的过程中，可以任意设计hash函数使得转化成为的hashcode<strong>尽量不重复，尽量够乱!!!</strong></p><p><strong>在算出hashcode之后还要放入篮子，这个时候就很简单了，就把hashcode求篮子的size的余数就可以知道放在哪里了!!!!</strong>(现在基本都是这么做的)</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422155807393.png" alt="image-20230422155807393"></p><p>使用hashtable的例子：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hashtable.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">eqstr</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str1, str2) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是自己设计就可以这么设计</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">size_t</span> _hash_string(<span class="type">const</span> <span class="type">char</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; *s != <span class="string">&#x27;\n&#x27;</span>; ++s)</span><br><span class="line">        ret = <span class="number">10</span> * ret + *s;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">fuck</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *s)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _hash_string(s); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __gnu_cxx::hashtable&lt;<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *,</span><br><span class="line">                         hash&lt;<span class="type">const</span> <span class="type">char</span> *&gt;, <span class="comment">// 标准库没有提供 hash&lt;std::string&gt;!!!!</span></span><br><span class="line">                         _Identity&lt;<span class="type">const</span> <span class="type">char</span> *&gt;,</span><br><span class="line">                         eqstr&gt; </span><br><span class="line">                 <span class="comment">// 不能直接放入strcmp，因为我们需要判断是否相同，返回的是true和false;而strcmp返回的是1 0 -1，接口不太一致</span></span><br><span class="line">        <span class="built_in">ht</span>(<span class="number">50</span>, <span class="built_in">hash</span>&lt;<span class="type">const</span> <span class="type">char</span> *&gt;(), <span class="built_in">eqstr</span>());<span class="comment">// 这个东西没有默认空的构造函数，需要提供一些东西</span></span><br><span class="line">    <span class="comment">// 从这里可以看出直接使用hashtable非常难用</span></span><br><span class="line"></span><br><span class="line">    ht.<span class="built_in">insert_unique</span>(<span class="string">&quot;kiwi&quot;</span>);</span><br><span class="line">    ht.<span class="built_in">insert_unique</span>(<span class="string">&quot;plum&quot;</span>);</span><br><span class="line">    ht.<span class="built_in">insert_unique</span>(<span class="string">&quot;apple&quot;</span>);</span><br><span class="line">    for_each(ht.<span class="built_in">begin</span>(), ht.<span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> data)</span><br><span class="line">             &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout &lt;&lt; hash&lt;int&gt;()(32) &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="第四讲：算法"><a href="#第四讲：算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四讲：算法" class="headerlink" title="第四讲：算法"></a>第四讲：算法</h2><h3 id="算法概述"><a href="#算法概述" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422162235208.png" alt="image-20230422162235208"></p><p>算法没有办法直接面对容器，他需要借助中间商迭代器才可以，换句话说，算法不关系容器是怎么样的，只关心容器提供给我的迭代器是怎么样的，而迭代器的设计的符号重载是普适的，这样就可以适用于大多数容器了。</p><h3 id="迭代器的五种分类：注意这五种都是类"><a href="#迭代器的五种分类：注意这五种都是类" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器的五种分类：注意这五种都是类" class="headerlink" title="迭代器的五种分类：注意这五种都是类!!!"></a>迭代器的五种分类：注意这五种都是类!!!</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422162614061.png" alt="image-20230422162614061"></p><p>random_access_iterator_tag 随机访问迭代器：可以跳着访问，任意一个都可以访问(重载了+ - +&#x3D; -&#x3D; ++ – 运算符)</p><p>bidirectional_iterator_tag 双向访问迭代器：可以往前走或者往后走，但是一次只能走一格(重载了 ++ – 运算符)</p><p>farward_iterator_tag 单向访问迭代器：只能向一个方向走，inin一次只能走一格</p><p>打印一下各种容器的iterator_category</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422163446874.png" alt="image-20230422163446874"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stream_iterator.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以只指定值不给参数</span></span><br><span class="line"><span class="type">void</span> __display_category(random_access_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;random_access_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __display_category(bidirectional_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;bidirectional_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __display_category(forward_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;forward_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __display_category(output_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;output_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> __display_category(input_iterator_tag)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;input_iterator&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> I&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display_category</span><span class="params">(I iter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 加上typename是为了是 I 就是迭代器类型(目前这么理解)</span></span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;I&gt;::iterator_category cagy; <span class="comment">// 去问萃取剂这个迭代器是什么类型</span></span><br><span class="line">    __display_category(cagy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">display_category</span>(array&lt;<span class="type">int</span>, <span class="number">10</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(vector&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(list&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(forward_list&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(deque&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">display_category</span>(set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(multiset&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(unordered_set&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(unordered_multiset&lt;<span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line">    <span class="built_in">display_category</span>(unordered_multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::<span class="built_in">iterator</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个不太一样，是从适配器adapter产生的</span></span><br><span class="line">    <span class="built_in">display_category</span>(<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line">    <span class="built_in">display_category</span>(<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="iterator-category对算法的效率影响"><a href="#iterator-category对算法的效率影响" class="heading-link"><i class="fas fa-link"></i></a><a href="#iterator-category对算法的效率影响" class="headerlink" title="iterator_category对算法的效率影响"></a>iterator_category对算法的效率影响</h3><p>不同的迭代器类型会导致在访问的过程中效率有区别</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422171334117.png" alt="image-20230422171334117"></p><p><strong>注意对右边代码的解读，这个distance函数是找两个迭代器之间的距离(ptrdiff_t 类型)，然后就问萃取机迭代器的类型是什么？然后针对函数调不同的重载函数就可以了!!!</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> Iterator &amp;_advance(Iterator &amp;iter, Distance n, std::random_access_iterator_tag)</span><br><span class="line">    &#123;</span><br><span class="line">        iter += n;</span><br><span class="line">        <span class="keyword">return</span> iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> Iterator &amp;_advance(Iterator &amp;iter, Distance n, std::bidirectional_iterator_tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">while</span> (n--)</span><br><span class="line">                ++iter;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">while</span> (n++)</span><br><span class="line">                --iter;</span><br><span class="line">        <span class="keyword">return</span> iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> Iterator &amp;_advance(Iterator &amp;iter, Distance n, std::input_iterator_tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (n--)</span><br><span class="line">            ++iter;</span><br><span class="line">        <span class="keyword">return</span> iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> Iterator <span class="title">Advance</span><span class="params">(Iterator iter, Distance n)</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 这里最好不传入引用类型，因为第一下面没有更改iter的值，不用担心实参形参的问题；</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 第二，外部可能传入的是begin()和end()这类没有办法直接修改的迭代器</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 我们在使用的时候都是声明了一个运动迭代器，他的初值是begin(),这样来操作的</span></span></span><br><span class="line"><span class="function">    <span class="comment">// 所以传入引用会出问题，最好传值，但是后面就可以传入引用了，因为我们是创建了一个新的迭代器对象</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;Iterator&gt;::iterator_category Iterator_Category;</span><br><span class="line">        <span class="keyword">return</span> _advance(iter, n, <span class="built_in">Iterator_Category</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">myadvance</span>().<span class="built_in">Advance</span>(v.<span class="built_in">begin</span>() + <span class="number">2</span>, <span class="number">-1</span>) &lt;&lt; endl; <span class="comment">// 5</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; l&#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">12</span>&#125;;</span><br><span class="line">    cout &lt;&lt; *<span class="built_in">myadvance</span>().<span class="built_in">Advance</span>(l.<span class="built_in">begin</span>(), <span class="number">4</span>) &lt;&lt; endl; <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意注释的内容，为什么这里该传引用，这里不该传引用!!!</p><p><strong>从这里我们可以看出，迭代器类型的不同会导致算法效率的不同，但是我们不是通过模板特化来实现的，是通过函数重载来实现的!!!</strong></p><p><strong>算法源码对 iterator_category 的暗示:</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230422183037284.png" alt="image-20230422183037284"></p><p>因为上面的迭代器都是模板，但是有些算法在实现的过程中只对某种类型的迭代器有效，所以设计者会暗示迭代器的类型来方便阅读和修改!!!</p><h3 id="算法源代码剖析"><a href="#算法源代码剖析" class="heading-link"><i class="fas fa-link"></i></a><a href="#算法源代码剖析" class="headerlink" title="算法源代码剖析"></a>算法源代码剖析</h3><p>C++ STL 库里面的标准算法格式</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line">std::<span class="built_in">Algorithm</span>(Iterator iter1,Iterator iter2)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//带比较的参数 一般是仿函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> Cmp&gt;</span><br><span class="line">std::<span class="built_in">Algorithm</span>(Iterator iter1,Iterator iter2,Cmp cmp)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="accumulate"><a href="#accumulate" class="heading-link"><i class="fas fa-link"></i></a><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h4><p>遍历整个容器对每个元素进行操作(可以是累加)然后返回值</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423113446373.png" alt="image-20230423113446373"></p><p>测试accumulate：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span> * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> x + <span class="number">3</span> * y; &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_accumulate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_accumulate()..........&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> init = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;using default accumulate: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init); <span class="comment">// 160</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;using functional&#x27;s minus: &quot;</span>;</span><br><span class="line">    <span class="comment">// minus 减法 仿函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, <span class="built_in">minus</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 40</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;using custom function: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, myfunc); <span class="comment">// 220</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;using custom object: &quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">accumulate</span>(nums, nums + <span class="number">3</span>, init, myobj); <span class="comment">// 280</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>自己实现以下accumulate:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stl_numeric.h&gt;</span> <span class="comment">//accumulate</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sum_Square</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value_Int</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Value_Int &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(Value_Int &amp;val, Value_Int val_iter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val += val_iter * val_iter;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">String_Append</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value_String</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> Value_String &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(Value_String &amp;val, Value_String val_iter)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val_iter.<span class="built_in">append</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        val.<span class="built_in">append</span>(val_iter);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Algorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">Value_Type</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> Value_Type <span class="title">Accumulate</span><span class="params">(Iterator begin, Iterator end, Value_Type val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; begin != end; ++begin)</span><br><span class="line">            val += *begin;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">Value_Type</span>, <span class="keyword">class</span> <span class="title class_">Binary_Operation</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> Value_Type <span class="title">Accumulate</span><span class="params">(Iterator begin, Iterator end, Value_Type val, Binary_Operation binary_op)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; begin != end; ++begin)</span><br><span class="line">            val = <span class="built_in">binary_op</span>(val, *begin);</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Algorithm::<span class="built_in">Accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span> &lt;&lt; endl; <span class="comment">// 33</span></span><br><span class="line">    cout &lt;&lt; Algorithm::<span class="built_in">Accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="built_in">Sum_Square</span>()) &lt;&lt; endl; <span class="comment">// 251</span></span><br><span class="line">    list&lt;string&gt; l&#123;<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;want&quot;</span>, <span class="string">&quot;to&quot;</span>, <span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;you&quot;</span>, <span class="string">&quot;my&quot;</span>, <span class="string">&quot;friend.&quot;</span>&#125;;</span><br><span class="line">    cout &lt;&lt; Algorithm::<span class="built_in">Accumulate</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>(), <span class="built_in">string</span>(), <span class="built_in">String_Append</span>()) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="for-each"><a href="#for-each" class="heading-link"><i class="fas fa-link"></i></a><a href="#for-each" class="headerlink" title="for_each"></a>for_each</h4><p>容器的遍历算法</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423171745364.png" alt="image-20230423171745364"></p><p>自己实现一下for_each</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Algorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">Function</span>&gt;</span><br><span class="line">    <span class="comment">//为什么要返回 Function 仿函数呢?(或者函数指针)</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> Function <span class="title">For_each</span><span class="params">(Iterator first, Iterator last, Function f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">            <span class="built_in">f</span>(*first); <span class="comment">// 注意是直接把数据传递给函数 f</span></span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不修改v1的值</span></span><br><span class="line">    Algorithm::<span class="built_in">For_each</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), [&amp;](<span class="type">int</span> val)</span><br><span class="line">                        &#123; val*=<span class="number">2</span>;v<span class="number">2.</span><span class="built_in">push_back</span>(val); &#125;);</span><br><span class="line"></span><br><span class="line">    for_each(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), [&amp;](<span class="keyword">auto</span> val)</span><br><span class="line">             &#123; cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>; &#125;);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : v2)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>看到for_each的返回值，我不得不思考为什么要返回Function仿函数呢？(很少情况下函数指针)</p><p><strong>原因是：可以监视仿函数对象在经过这个for_each操作之后的状态</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    for_each()它可以返回其仿函数(返回所传入的函数对象的最终状态).</span></span><br><span class="line"><span class="comment">    这样我们就可以通过for_each()的返回值来获取仿函数的状态.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 仿函数 */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CSum</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CSum</span>() &#123; m_sum = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; m_sum += n; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetSum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_sum; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_sum;</span><br><span class="line">&#125; cs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">        vi.<span class="built_in">push_back</span>(i);</span><br><span class="line">    <span class="comment">// 通过for_each返回值访问其最终状态(返回所传入的函数对象的最终状态).</span></span><br><span class="line">    cs = for_each(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), cs); <span class="comment">// 返回的是一个新创建的对象，未返回引用，不会修改实参</span></span><br><span class="line">    cout &lt;&lt; cs.<span class="built_in">GetSum</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="replace-replace-if-replace-copy-replace-copy-if"><a href="#replace-replace-if-replace-copy-replace-copy-if" class="heading-link"><i class="fas fa-link"></i></a><a href="#replace-replace-if-replace-copy-replace-copy-if" class="headerlink" title="replace,replace_if,replace_copy,replace_copy_if"></a>replace,replace_if,replace_copy,replace_copy_if</h4><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Container con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : con)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Algorithm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">Value_Type</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Replace</span><span class="params">(Iterator first, Iterator last, <span class="type">const</span> Value_Type oldval, <span class="type">const</span> Value_Type newval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">            <span class="keyword">if</span> (*first == oldval)</span><br><span class="line">                *first = newval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Iterator</span>, <span class="keyword">class</span> <span class="title class_">Value_Type</span>, <span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">    <span class="comment">// 给一个谓词来判断条件是否更改</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Replace_if</span><span class="params">(Iterator first, Iterator last, Predicate pred, <span class="type">const</span> Value_Type newval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">pred</span>(*first))<span class="comment">//这里谓词传递的参数只有一个值</span></span><br><span class="line">                *first = newval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面的算法当中传入的参数只有一个值，没传入如果需要比较的基准值</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value_Type</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Value_Type &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">5</span>;<span class="comment">//我们肯定不想在内部手动更改这个5，而是想在外面写代码的时候把5写进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了解决这个问题需要引用仿函数适配器 functor adapter</span></span><br><span class="line">    <span class="comment">// 标准库提供的 bind2nd() 用法 bind2nd(greater&lt;int&gt;,val)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">    Algorithm::<span class="built_in">Replace</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">1</span>, <span class="number">66</span>);</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    Algorithm::<span class="built_in">Replace_if</span>(v<span class="number">2.</span><span class="built_in">begin</span>(), v<span class="number">2.</span><span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">5</span>), <span class="number">666</span>);</span><br><span class="line">    <span class="built_in">print</span>(v2);</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">resize</span>(v.<span class="built_in">size</span>()); <span class="comment">// 注意这里要给v3预分配空间，不然会段错误</span></span><br><span class="line">    <span class="built_in">replace_copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v<span class="number">3.</span><span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">print</span>(v3);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="count-count-if"><a href="#count-count-if" class="heading-link"><i class="fas fa-link"></i></a><a href="#count-count-if" class="headerlink" title="count,count_if"></a>count,count_if</h4><p>这个差不多就不写了</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423175336384.png" alt="image-20230423175336384"></p><p>为什么要返回difference_type呢？</p><p>算法通过萃取机询问迭代器，迭代器之间的间距类型怎么表示，这个类型就是difference_type</p><p>标准库的定义是 ptrdiff_t，也就是 long long，这下就可以理解了</p><p>有些容器自带的成员函数，比如图中的，这些函数的执行效率肯定比全局的执行效率更高!!!</p><h4 id="find-find-if"><a href="#find-find-if" class="heading-link"><i class="fas fa-link"></i></a><a href="#find-find-if" class="headerlink" title="find,find_if"></a>find,find_if</h4><p>循序式查找，效率并不是很高，找不到返回last迭代器</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423202430305.png" alt="image-20230423202430305"></p><h4 id="sort"><a href="#sort" class="heading-link"><i class="fas fa-link"></i></a><a href="#sort" class="headerlink" title="sort"></a>sort</h4><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Container con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : con)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">myfunc</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i &lt; j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i &lt; j; &#125;</span><br><span class="line">&#125; myobj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 8&gt; arr = &#123;<span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(arr.begin(), arr.end())</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using default comparison (operator &lt;)</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>() + <span class="number">4</span>); <span class="comment">// 排序前四个 12 32 45 71 26 80 53 33</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using function as comp</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>() + <span class="number">4</span>, v.<span class="built_in">end</span>(), myfunc); <span class="comment">// 12 32 45 71 26 33 53 80</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using object as comp</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), myobj); <span class="comment">// 12 26 32 33 45 53 71 80</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// reverse iterators</span></span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">rbegin</span>(), v.<span class="built_in">rend</span>(), <span class="built_in">less</span>&lt;<span class="type">int</span>&gt;()); <span class="comment">// 80 71 53 45 33 32 26 12</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423203719337.png" alt="image-20230423203719337"></p><p><strong>注意一点的是stl标准库里面的 sort 函数要求的是 random_access_iterator_tag!!!!!</strong></p><p><strong>所以list和forward_list没办法调用，只能调用他们自己的类函数sort!!!</strong></p><h4 id="binary-search-通过二分查找确定元素在不在容器当中"><a href="#binary-search-通过二分查找确定元素在不在容器当中" class="heading-link"><i class="fas fa-link"></i></a><a href="#binary-search-通过二分查找确定元素在不在容器当中" class="headerlink" title="binary_search(通过二分查找确定元素在不在容器当中)"></a>binary_search(通过二分查找确定元素在不在容器当中)</h4><p><strong>二分查找一定只能适用于一个有序序列!!!!并且在库函数当中只能用于升序序列!!!!</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230423210411376.png" alt="image-20230423210411376"></p><p>使用例子：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Sort</span><span class="params">(Container &amp;con)</span> <span class="comment">// 传引用，不然不改变实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(con.<span class="built_in">begin</span>(), con.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rSort</span><span class="params">(Container &amp;con)</span> <span class="comment">// 传引用，不然不改变实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(con.<span class="built_in">rbegin</span>(), con.<span class="built_in">rend</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Container &amp;con)</span> <span class="comment">// 传引用，不然不改变实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : con)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Fuck</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Random_Iterator, <span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="type">bool</span> __Binary_Search(Random_Iterator first, Random_Iterator last, <span class="type">const</span> Value_Type &amp;val,</span><br><span class="line">                         random_access_iterator_tag)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先做一个检查 val比 *first大 那么找不到</span></span><br><span class="line">        <span class="keyword">if</span> (val &lt; *first)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first != last)</span><br><span class="line">        &#123;</span><br><span class="line">            Random_Iterator mid = first + (last - first) / <span class="number">2</span>; <span class="comment">// 没有两个迭代器相加的重载版本!!!!</span></span><br><span class="line">            <span class="keyword">if</span> (*mid &gt; val)</span><br><span class="line">                last = mid; <span class="comment">// 注意last要满足前闭后开</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*mid &lt; val)</span><br><span class="line">                first = ++mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Random_Iterator, <span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="type">bool</span> __Binary_Search(Random_Iterator first, Random_Iterator last, <span class="type">const</span> Value_Type &amp;val,</span><br><span class="line">                         random_access_iterator_tag, <span class="type">int</span>) <span class="comment">// 多一个int代表降序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 先做一个检查 val比 *first大 那么找不到</span></span><br><span class="line">        <span class="keyword">if</span> (val &gt; *first)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (first != last)</span><br><span class="line">        &#123;</span><br><span class="line">            Random_Iterator mid = first + (last - first) / <span class="number">2</span>; <span class="comment">// 没有两个迭代器相加的重载版本!!!!</span></span><br><span class="line">            <span class="keyword">if</span> (*mid &gt; val)</span><br><span class="line">                first = ++mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (*mid &lt; val)</span><br><span class="line">                last = mid; <span class="comment">// 注意last要满足前闭后开</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="comment">// 写了一个random_access_iterator的重载</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Binary_Search</span><span class="params">(Iterator first, Iterator last, <span class="type">const</span> Value_Type &amp;val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 想办法让其可以适用于降序序列</span></span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category Iterator_Category;</span><br><span class="line">        <span class="keyword">if</span> (*first &lt; *(last - <span class="number">1</span>)) <span class="comment">// 升序 保持前闭后开的规则!!!</span></span><br><span class="line">            <span class="keyword">return</span> __Binary_Search(first, last, val, <span class="built_in">Iterator_Category</span>());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> __Binary_Search(first, last, val, <span class="built_in">Iterator_Category</span>(), <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Sort</span>(v); <span class="comment">// 0 1 2 3 6 7 8 9</span></span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    cout &lt;&lt; Fuck::<span class="built_in">Binary_Search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; binary_search(v.begin(), v.end(), 5) &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">rSort</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    cout &lt;&lt; Fuck::<span class="built_in">Binary_Search</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="第五讲：仿函数-适配器"><a href="#第五讲：仿函数-适配器" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五讲：仿函数-适配器" class="headerlink" title="第五讲：仿函数 适配器"></a>第五讲：仿函数 适配器</h2><h3 id="仿函数-functors-注意要继承"><a href="#仿函数-functors-注意要继承" class="heading-link"><i class="fas fa-link"></i></a><a href="#仿函数-functors-注意要继承" class="headerlink" title="仿函数 functors(注意要继承)"></a>仿函数 functors(注意要继承)</h3><p>标准库提供的三大类型的仿函数：算术类 逻辑运算类 相对运算类</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424161751257.png" alt="image-20230424161751257"></p><p>还有之前提到过的几个仿函数：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424162149742.png" alt="image-20230424162149742"></p><p>标准库的示范：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424162843434.png" alt="image-20230424162843434"></p><p><strong>注意到一点：标准库提供的functors都存在继承关系!!!!只有这样才算是真正融入了STL体系，这样才能更好的运作。</strong></p><p><strong>仿函数的 adaptable可适配 条件</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424163242826.png" alt="image-20230424163242826"></p><p><strong>STL规定，每个Functor都应该挑选适当的类来继承，因为适配器adapter会提出一些问题!!!!</strong></p><p><strong>什么叫adaptable?如果你希望自己的仿函数是可以被适配器调整的话，那么就继承一个适当的类，这样可以完成更多的操作!!!为什么要继承呢？因为可能在被adapter改造的时候可能会问这些问题。这也和算法问迭代器的五个问题一样，那里是通过迭代器的萃取机 Iterator Traits (也叫迭代器适配器 Iterator Adapters )去问的，这里同理通过继承的关系去回答adapter的问题!!!</strong></p><h3 id="适配器-Adapter"><a href="#适配器-Adapter" class="heading-link"><i class="fas fa-link"></i></a><a href="#适配器-Adapter" class="headerlink" title="适配器 Adapter"></a>适配器 Adapter</h3><p>存在多种 Adapters ，还是那张图，注意关系</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424170726596.png" alt="image-20230424170726596" style="zoom:67%"><p>Adapter的关键是：</p><p><strong>这个Adapter要去改造某个东西(比如图中的container，functor，iterator)，这里就有两种解决方式，第一种是继承的方式，就是Adapter继承这个东西，拥有这个东西的属性来进行改造；第二种是内含的方式，Adapter内部有这个东西来进行改造!!!!</strong></p><p><strong>在标准库里面的实现绝大多数都是内含的方式!!!</strong></p><p>一下就是一些适配器的例子：</p><h4 id="容器适配器：stack-queue"><a href="#容器适配器：stack-queue" class="heading-link"><i class="fas fa-link"></i></a><a href="#容器适配器：stack-queue" class="headerlink" title="容器适配器：stack,queue"></a>容器适配器：stack,queue</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230424172134280.png" alt="image-20230424172134280"></p><p>这个之前用过很多次了，就是把默认的容器拿进来进行改造，比如这里给的默认值是 deque ，改造之后能够以一种全新的面貌展现给用户，能够更加准确的针对用户的需要来进行相应的操作。</p><h4 id="函数适配器：binder2nd"><a href="#函数适配器：binder2nd" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数适配器：binder2nd" class="headerlink" title="函数适配器：binder2nd"></a>函数适配器：binder2nd</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425185823723.png" alt="image-20230425185823723"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fuck</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 自己写一个bind2nd和binder2nd</span></span><br><span class="line">    <span class="comment">// 仔细敲打一下这段代码</span></span><br><span class="line">    <span class="comment">// 这里暗示了需要传入的是一个二元运算符 然后下面的类型名称是继承里面写好的类型名称</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Binary_Op</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_BinderSecond</span></span><br><span class="line">    <span class="comment">// 不继承这一行也可以运作，但是没办法进行后续的改造</span></span><br><span class="line">    <span class="comment">// 这里就不继承了!!!</span></span><br><span class="line">    <span class="comment">// : public unary_function&lt;typename Binary_Op::first_argument_type, typename Binary_Op::second_argument_type&gt;</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Binary_Op op;</span><br><span class="line">        <span class="keyword">typename</span> Binary_Op::second_argument_type value; <span class="comment">// 第二参数 需要设定的固定值</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ctor</span></span><br><span class="line">        _BinderSecond(<span class="type">const</span> Binary_Op &amp;x, <span class="type">const</span> <span class="keyword">typename</span> Binary_Op::second_argument_type &amp;y)</span><br><span class="line">            : <span class="built_in">op</span>(x), <span class="built_in">value</span>(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">typename</span> Binary_Op::result_type</span></span><br><span class="line"><span class="function">        <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Binary_Op::first_argument_type &amp;x)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">op</span>(x, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Binary_Op</span>, <span class="keyword">class</span> <span class="title class_">Value_Type</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> _BinderSecond&lt;Binary_Op&gt; _BindSecond(<span class="type">const</span> Binary_Op &amp;op, <span class="type">const</span> Value_Type &amp;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">typedef</span> <span class="keyword">typename</span> Binary_Op::second_argument_type second_type;<span class="comment">//这句话就是adapter在问问题</span></span><br><span class="line">        <span class="keyword">return</span> _BinderSecond(op, <span class="built_in">second_type</span>(val));</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),</span><br><span class="line">                     fuck::_BindSecond(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">5</span>)) <span class="comment">// 绑定第二参数</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>注意其中的一些代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> Binary_Op::second_argument_type value;</span><br></pre></td></tr></table></div></figure><p><strong>为什么要加上 typename ，是为了通过编译，因为这个时候我们不知道Binary_Op是什么类型，然后如果他是我们想要的，也就是其中含有这个类型定义，那么就能通过编译，否则在这里就会报错!!!!</strong></p><p><strong>仿函数functors的可适配(adaptable)条件</strong></p><p>继承(因为adapter会问问题，提问类型)，是一个functor</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425191652925.png" alt="image-20230425191652925"></p><h4 id="函数适配器：not1"><a href="#函数适配器：not1" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数适配器：not1" class="headerlink" title="函数适配器：not1"></a>函数适配器：not1</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425194548756.png" alt="image-20230425194548756"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fuck</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 对谓词做否定</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">_unary_negate</span></span><br><span class="line">        <span class="comment">// 继承为了后续的改造</span></span><br><span class="line">        : <span class="keyword">public</span> unary_function&lt;<span class="keyword">typename</span> Predicate::argument_type, <span class="type">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Predicate pred;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// ctor</span></span><br><span class="line">        _unary_negate(<span class="type">const</span> Predicate &amp;x) : <span class="built_in">pred</span>(x) &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> <span class="keyword">typename</span> Predicate::argument_type &amp;x)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="built_in">pred</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Predicate</span>&gt;</span><br><span class="line">    <span class="keyword">inline</span> _unary_negate&lt;Predicate&gt; _Not1(<span class="type">const</span> Predicate &amp;pred)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _unary_negate&lt;Predicate&gt;(pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(),</span><br><span class="line">                     fuck::_Not1(<span class="built_in">bind2nd</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), <span class="number">5</span>))) <span class="comment">// 绑定第二参数</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>观察发现这些adapter的实现方法基本都是一个模板辅助函数，调用一个模板类，这个类里面有构造函数和小括号重载!!!!</strong></p><h4 id="新型适配器：bind-since-c-11"><a href="#新型适配器：bind-since-c-11" class="heading-link"><i class="fas fa-link"></i></a><a href="#新型适配器：bind-since-c-11" class="headerlink" title="新型适配器：bind(since c++11)"></a>新型适配器：bind(since c++11)</h4><p>右边是老版本，左边是新版本!!!</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425194051698.png" alt="image-20230425194051698"></p><p>可见bind的实现是非常复杂的!!!!</p><p>下面是对bind的一些测试：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425200558918.png" alt="image-20230425200558918"></p><p><strong>bind 可以绑定：</strong></p><p><strong>functions函数；function objects 函数对象(仿函数)；</strong></p><p><strong>member functions 成员函数；data members 成员属性</strong></p><p>前两个比较好理解，其中第三个和第四个的绑定规则是：</p><p><strong>注意第一个参数传入的是传的是地址!!!!</strong></p><p><strong>member functions, _1;</strong></p><p><strong>data members,_1</strong></p><p><strong>必须有第二个参数，第二个参数必须是必须是某个object的地址，可以是一个占位符，在调用的时候被外界指定!!!</strong></p><p><strong>第一个参数可以理解为调用类里面的什么接口，第二个参数可以理解为谁来调用!!!!</strong></p><p>使用例子：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders; <span class="comment">// 使用占位符 _1 _2 _3这些</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">my_divide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x / y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> a, b;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">multiply</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bind_Functions</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// binding functions</span></span><br><span class="line">    <span class="keyword">auto</span> fn_five = <span class="built_in">bind</span>(my_divide, <span class="number">10</span>, <span class="number">2</span>); <span class="comment">// return 10.0/2.0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fn_five</span>() &lt;&lt; endl;             <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn_half = <span class="built_in">bind</span>(my_divide, _1, <span class="number">2</span>); <span class="comment">// return x/2.0</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fn_half</span>(<span class="number">10</span>) &lt;&lt; endl;           <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn_rounding = <span class="built_in">bind</span>(my_divide, _2, _1); <span class="comment">// 第一参数为除数，第二参数为被除数 return y/x</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fn_rounding</span>(<span class="number">10</span>, <span class="number">2</span>) &lt;&lt; endl;         <span class="comment">// 0.2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fn_invert = <span class="built_in">bind</span>&lt;<span class="type">int</span>&gt;(my_divide, _1, _2); <span class="comment">// int 代表希望返回的类型 return int(x/y)</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">fn_invert</span>(<span class="number">10</span>, <span class="number">3</span>) &lt;&lt; endl;              <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bind_Members</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MyPair ten_two&#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bound_memfn = <span class="built_in">bind</span>(&amp;MyPair::multiply, _1); <span class="comment">// return x.multiply()</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bound_memfn</span>(ten_two) &lt;&lt; endl;           <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bound_memdata = <span class="built_in">bind</span>(&amp;MyPair::a, ten_two); <span class="comment">// return tentwo.a</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bound_memdata</span>() &lt;&lt; endl;                <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bound_memdata2 = <span class="built_in">bind</span>(&amp;MyPair::b, _1); <span class="comment">// return x.b</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bound_memdata2</span>(ten_two) &lt;&lt; endl;    <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> _fn = <span class="built_in">bind</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), _fn) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">count_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind</span>(<span class="built_in">less</span>&lt;<span class="type">int</span>&gt;(), _1, <span class="number">5</span>)) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Bind_Functions</span>();</span><br><span class="line">    <span class="built_in">Bind_Members</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="迭代器适配器：rbegin，rend"><a href="#迭代器适配器：rbegin，rend" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器适配器：rbegin，rend" class="headerlink" title="迭代器适配器：rbegin，rend"></a>迭代器适配器：rbegin，rend</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425203641882.png" alt="image-20230425203641882"></p><p>这个迭代器就是在正向迭代器的基础之上进行改造的迭代器!!!</p><h4 id="迭代器适配器：inserter-没弄懂"><a href="#迭代器适配器：inserter-没弄懂" class="heading-link"><i class="fas fa-link"></i></a><a href="#迭代器适配器：inserter-没弄懂" class="headerlink" title="迭代器适配器：inserter(没弄懂)"></a>迭代器适配器：inserter(没弄懂)</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230425205345712.png" alt="image-20230425205345712"></p><p>注意copy是已经写死的函数，那么如何才能改变他的行为呢？</p><p><strong>答案是借助操作符重载，本例子就是重载了 &#x3D; 号运算符就是实现了由赋值操作变为插入操作了!!!!</strong></p><h2 id="第六讲：STL周围的细碎知识点"><a href="#第六讲：STL周围的细碎知识点" class="heading-link"><i class="fas fa-link"></i></a><a href="#第六讲：STL周围的细碎知识点" class="headerlink" title="第六讲：STL周围的细碎知识点"></a>第六讲：STL周围的细碎知识点</h2><h3 id="一个万用的-hash-function"><a href="#一个万用的-hash-function" class="heading-link"><i class="fas fa-link"></i></a><a href="#一个万用的-hash-function" class="headerlink" title="一个万用的 hash function"></a>一个万用的 hash function</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230426151146418.png" alt="image-20230426151146418"></p><p><strong>系统提供了一个非常不错的hashcode生成函数 hash_val() ，括号里面把元素的所有参数全部放进去就好！</strong></p><h4 id="hash-val-参数包"><a href="#hash-val-参数包" class="heading-link"><i class="fas fa-link"></i></a><a href="#hash-val-参数包" class="headerlink" title="hash_val(参数包)"></a>hash_val(参数包)</h4><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt; <span class="comment">// ... 的含义 接受任意数量的模板参数</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">size_t</span> <span class="title">hash_val</span><span class="params">(<span class="type">const</span> Types &amp;...args)</span></span></span><br><span class="line"><span class="function"><span class="comment">//创建一个种子，将种子和参数包绑定在一起</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="type">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line">       <span class="built_in">hash_val</span>(seed, args...);<span class="comment">//调用2号重载 修改seed</span></span><br><span class="line">       <span class="keyword">return</span> seed;<span class="comment">//最后返回seed就是最终的hashcode</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span> &amp;seed, <span class="type">const</span> Type &amp;val, <span class="type">const</span> Types &amp;...args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="comment">//注意这个函数接受的参数，有一个val,本来传入的是n个元素的参数包，出现val之后，就将其分开，分为1和n-1来处理</span></span><br><span class="line">       <span class="built_in">hash_combine</span>(seed, val);<span class="comment">//取出一个参数来对seed进行修改!!!!</span></span><br><span class="line">       <span class="built_in">hash_val</span>(seed, args...);<span class="comment">//处理剩余 n-1 个参数包 递归操作</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_val</span><span class="params">(<span class="type">size_t</span> &amp;seed, <span class="type">const</span> Type &amp;val)</span></span></span><br><span class="line"><span class="function"><span class="comment">//最终当只剩下一个参数的时候就最后更改一次就行了</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="built_in">hash_combine</span>(seed, val);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">hash_combine</span><span class="params">(<span class="type">size_t</span> &amp;seed, <span class="type">const</span> Type &amp;val)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       seed ^= std::<span class="built_in">hash</span>&lt;Type&gt;()(val) + <span class="number">0x9e3779b9</span> + (seed &lt;&lt; <span class="number">6</span>) + (seed &gt;&gt; <span class="number">2</span>);</span><br><span class="line">       <span class="comment">//前面第一个参数是调用系统提供的哈希函数，后面这些加和左移右移是为了让其更加混乱，没有规律可言</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></div></figure><p>上面的例子不是很好理解，这里写一个打印string的例子方便加深理解：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringPrint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">const</span> string &amp;str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _myprint(str);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">myprint</span><span class="params">(<span class="type">const</span> string &amp;str, <span class="type">const</span> Types &amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _myprint(str, args...);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">const</span> Types &amp;...args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//当我们想要知道包中有多少元素时，可以使用sizeof...运算符，该运算符返回一个常量表达式，并且不会对其实参求值</span></span><br><span class="line">        cout &lt;&lt; <span class="keyword">sizeof</span>...(Types) &lt;&lt; endl; <span class="comment">// 类型参数数目</span></span><br><span class="line">        cout &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; endl;  <span class="comment">// 函数参数数目</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> _myprint(<span class="type">const</span> string &amp;str)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受参数包，参数包是占位符的替换</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">void</span> _myprint(<span class="type">const</span> string &amp;str, <span class="type">const</span> Type &amp;val, <span class="type">const</span> Types &amp;...args)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 一个字符一个字符的读，直到碰到占位符 %</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = str.<span class="built_in">begin</span>(); iter != str.<span class="built_in">end</span>(); ++iter)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*iter != <span class="string">&#x27;%&#x27;</span>)</span><br><span class="line">                cout &lt;&lt; *iter;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 是占位符</span></span><br><span class="line">                cout &lt;&lt; val;</span><br><span class="line">                string newstr = <span class="built_in">string</span>(++iter, str.<span class="built_in">end</span>());</span><br><span class="line">                _myprint(newstr, args...);<span class="comment">//创建新的字符串并且传进去进行递归，注意不要忘了 return 递归出口</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; myPrint;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    myPrint.<span class="built_in">myprint</span>(<span class="string">&quot;Hello , I&#x27;m % , % years old.&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    myPrint.<span class="built_in">foo</span>(<span class="string">&quot;Hello , I&#x27;m % , % years old.&quot;</span>, <span class="string">&quot;David&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    myPrint.<span class="built_in">myprint</span>(<span class="string">&quot;fuck you!&quot;</span>);</span><br><span class="line">    myPrint.<span class="built_in">foo</span>(<span class="string">&quot;fuck you!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="Hash函数的三种形式"><a href="#Hash函数的三种形式" class="heading-link"><i class="fas fa-link"></i></a><a href="#Hash函数的三种形式" class="headerlink" title="Hash函数的三种形式"></a>Hash函数的三种形式</h4><p>1.仿函数 functor</p><p>2.函数指针</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仿函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomerHash</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Customer &amp;c)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">HashFunction</span>().<span class="built_in">hash_val</span>(c.fname, c.lname, c.no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数指针</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">customer_hash_func</span><span class="params">(<span class="type">const</span> Customer &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一种思路就是这个类里面简单类型的hashcode全部相加</span></span><br><span class="line">    <span class="comment">// 但是这么做的话设计者认为比较天真，没办法达到非常乱的结构</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">HashFunction</span>().<span class="built_in">hash_val</span>(c.fname, c.lname, c.no);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意在main函数创建的时候传入参数的时候需要注意</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unordered_set&lt;Customer, CustomerHash&gt; custset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> function_pointer = <span class="built_in">size_t</span> (*)(<span class="type">const</span> Customer &amp;); <span class="comment">// 定义函数指针</span></span><br><span class="line">    unordered_set&lt;Customer, function_pointer&gt; custset2; <span class="comment">//传入的是函数指针的形式!!!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>3.特化的版本</p><p>对于 unorder_set or unorder_map，如果不给hash函数，那么默认会使用系统的 hash<value_type>，这个时候可以通过这个对其进行特化处理</value_type></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放在std内表示在标准库std里面进行操作修改</span></span><br><span class="line"><span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;&gt;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">hash</span>&lt;Customer&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Customer &amp;c)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">HashFunction</span>().<span class="built_in">hash_val</span>(c.fname, c.lname, c.no);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>可以在我们的代码中对std里面的系统提供的hash函数进行特化版本的处理来实现</p><h3 id="tuple"><a href="#tuple" class="heading-link"><i class="fas fa-link"></i></a><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple是c++11新引入的一个好东西，他可以传入一个参数包，参数包里面可以放入任意大小，任意类型</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427111200767.png" alt="image-20230427111200767"></p><p>示例代码:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;29_tuple_print.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string,sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(string) &lt;&lt; endl;                   <span class="comment">// 32</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double,sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;                   <span class="comment">// 8</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float,sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;                     <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int,sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;                         <span class="comment">// 4</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;complex&lt;double&gt;,sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(complex&lt;<span class="type">double</span>&gt;) &lt;&lt; endl; <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">    tuple&lt;string, <span class="type">int</span>, <span class="type">int</span>, complex&lt;<span class="type">double</span>&gt;&gt; t;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tuple&lt;string,int,int,complex&lt;double&gt;,sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t) &lt;&lt; endl; <span class="comment">// 56</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>, string&gt; <span class="title">t1</span><span class="params">(<span class="number">41</span>, <span class="number">6.3</span>, <span class="string">&quot;nico&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;tuple&lt;int,float,string&gt;,sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(t1) &lt;&lt; endl;              <span class="comment">// 40</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1: &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t1) &lt;&lt; endl; <span class="comment">// 取出其中的元素用法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t2 = <span class="built_in">make_tuple</span>(<span class="number">22</span>, <span class="number">44.0</span>, <span class="string">&quot;stacy&quot;</span>);</span><br><span class="line">    <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t1) = <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t1: &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t1) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t1) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t1) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;t2: &quot;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t2) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(t2) &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(t2) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较大小</span></span><br><span class="line">    <span class="keyword">if</span> (t1 &lt; t2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;t1 &lt; t2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;t1 &gt; t2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;t1 == t2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    t1 = t2; <span class="comment">// 赋值操作</span></span><br><span class="line">    cout &lt;&lt; t2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> tuple&lt;<span class="type">int</span>, <span class="type">float</span>, string&gt; TupleType;</span><br><span class="line">    cout &lt;&lt; tuple_size&lt;TupleType&gt;::value &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> tuple_element&lt;<span class="number">1</span>, TupleType&gt;::type Type1; <span class="comment">// float</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(Type1).<span class="built_in">name</span>() &lt;&lt; endl;            <span class="comment">// f</span></span><br><span class="line"></span><br><span class="line">    <span class="function">tuple&lt;<span class="type">int</span>, <span class="type">float</span>, string&gt; <span class="title">t3</span><span class="params">(<span class="number">77</span>, <span class="number">1.1</span>, <span class="string">&quot;more light&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i1;</span><br><span class="line">    <span class="type">float</span> f1;</span><br><span class="line">    string s1;</span><br><span class="line">    <span class="built_in">tie</span>(i1, f1, s1) = t3; <span class="comment">// 将这t3的三个属性绑定到这三个变量上面</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i1 = &quot;</span> &lt;&lt; i1 &lt;&lt; <span class="string">&quot; f1 = &quot;</span> &lt;&lt; f1 &lt;&lt; <span class="string">&quot; s1= &quot;</span> &lt;&lt; s1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>这里面就有学问了，重载 这个参数包的 左移运算符(代码建议重复看!!!!)</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TUPLEPRINT__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TUPLEPRINT__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// get&lt;&gt; 尖括号里面不能放入变量，只能放入一个常量!!!!</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_print</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Tuple &amp;t, ostream &amp;out)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tuple_print&lt;Tuple, N - <span class="number">1</span>&gt;::<span class="built_in">print</span>(t, out);</span><br><span class="line">        out &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">get</span>&lt;N - <span class="number">1</span>&gt;(t);</span><br><span class="line">        <span class="comment">// 为什么要反着写？</span></span><br><span class="line">        <span class="comment">// 因为递归出来打印的顺序是从0 到 n-1!!!!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归出口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tuple&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">tuple_print</span>&lt;Tuple, <span class="number">1</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Tuple &amp;t, ostream &amp;out)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        out &lt;&lt; <span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载 左移运算符</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">inline</span> ostream &amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> tuple&lt;Types...&gt; &amp;t)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// decltype 可以得出变量的类型</span></span><br><span class="line">    <span class="comment">// 模板参数里面可以放入一个常量，根据常量不同的大小可以调用不同的重载或者特化版本</span></span><br><span class="line">    tuple_print&lt;<span class="keyword">decltype</span>(t), <span class="keyword">sizeof</span>...(Types)&gt;::<span class="built_in">print</span>(t, out);</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><p>那么这个这么好用的tuple是怎么实现的呢？</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427112849536.png" alt="image-20230427112849536"></p><p><strong>他的大概意思就是接受参数包，然后将参数包分为1和n-1，本类继承上一级(n-1)的类，以此往上继承；由于本类当中的成员是head，就是这个1对应的元素，所以继承过后本类会获得所有的元素，可以通过head和tail接口进行调用!!!!!!</strong></p><p>注意图中右上角的继承关系!!!</p><p>tuple里面有两个head和tail函数，这两个在现在的c++里面不太好用，因为新加了很多东西，接口也变了，所以就不用了</p><h1 id="C-2-0-新特性"><a href="#C-2-0-新特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#C-2-0-新特性" class="headerlink" title="C++ 2.0 新特性"></a>C++ 2.0 新特性</h1><h2 id="第一讲：语言"><a href="#第一讲：语言" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一讲：语言" class="headerlink" title="第一讲：语言"></a>第一讲：语言</h2><h3 id="variatic-templates-参数包"><a href="#variatic-templates-参数包" class="heading-link"><i class="fas fa-link"></i></a><a href="#variatic-templates-参数包" class="headerlink" title="variatic templates 参数包"></a>variatic templates 参数包</h3><p><strong>在类模板中，模板参数包必须是最后一个模板形参. 而在函数模板中则不必!!!!</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427170952730.png" alt="image-20230427170952730"></p><p>这个之前提过了，就不细谈了</p><p>下面那三个分别对应：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span>... Types <span class="comment">//模板参数包</span></span><br><span class="line"><span class="type">const</span> Types&amp;... args <span class="comment">//函数参数类型包</span></span><br><span class="line"><span class="built_in">print</span>(args...) <span class="comment">//函数参数包</span></span><br></pre></td></tr></table></div></figure><p>利用参数包也可以实现万用的hashcode的实现: 之前写过就不细看了</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230427171431489.png" alt="image-20230427171431489"></p><h3 id="零碎知识点"><a href="#零碎知识点" class="heading-link"><i class="fas fa-link"></i></a><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h3><h4 id="nullptr"><a href="#nullptr" class="heading-link"><i class="fas fa-link"></i></a><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h4><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call of int&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;call of void*&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(<span class="number">0</span>); <span class="comment">// calls f(int)</span></span><br><span class="line">    <span class="comment">// f(NULL);    // 这里会报错，因为NULL既可以指是int 也可以是指针</span></span><br><span class="line">    <span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// calls f(void*)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="auto"><a href="#auto" class="heading-link"><i class="fas fa-link"></i></a><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>提醒：不要有了auto就以后都不写类型了，能不用就不用，除非是在类型名太长或者太复杂的类型才用一下，我们心里需要明白这到底是怎么类型，不要编译器知道了我们不知道</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的返回值也可以是auto</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> val &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注意函数指针的写法</span></span><br><span class="line">    <span class="keyword">auto</span> func = [](<span class="type">const</span> <span class="type">int</span> &amp;val) -&gt; <span class="type">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">bool</span> (*func2)(<span class="type">const</span> <span class="type">int</span> &amp;val) = Func;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func2</span>(<span class="number">-1</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="initializer-list-lt-gt"><a href="#initializer-list-lt-gt" class="heading-link"><i class="fas fa-link"></i></a><a href="#initializer-list-lt-gt" class="headerlink" title="initializer_list&lt;&gt;"></a>initializer_list&lt;&gt;</h3><h4 id="uniform-initialization-统一初始化"><a href="#uniform-initialization-统一初始化" class="heading-link"><i class="fas fa-link"></i></a><a href="#uniform-initialization-统一初始化" class="headerlink" title="uniform initialization 统一初始化"></a>uniform initialization 统一初始化</h4><p>任何初始化动作都可以用一个共同语法：{ &#x2F;&#x2F;填入值 }</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> values[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;string&gt;cities&#123;</span><br><span class="line"><span class="string">&quot;Berlin&quot;</span>,<span class="string">&quot;New York&quot;</span>,<span class="string">&quot;London&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>示例代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Container &amp;con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : con)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    vector&lt;string&gt; cities&#123;</span><br><span class="line">        <span class="string">&quot;Berlin&quot;</span>, <span class="string">&quot;New York&quot;</span>, <span class="string">&quot;London&quot;</span>&#125;;</span><br><span class="line">    <span class="built_in">print</span>(v);</span><br><span class="line">    <span class="built_in">print</span>(cities);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在编译器看到 {} 的时候会自动创建出来一个 initializer_list，这是一个类，具体代码实现如下：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">_E</span>&gt;</span><br><span class="line"><span class="comment">// 这个东西背后是一个 array ,编译器在看见大括号的时候就会预先准备一个 array</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">initializer_list</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _E value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> _E &amp;reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> _E &amp;const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> _E *iterator;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> _E *const_iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    iterator _M_array;</span><br><span class="line">    size_type _M_len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The compiler can call a private constructor.</span></span><br><span class="line">    <span class="comment">// 编译器在这里能调用私有的构造函数(编译器可以，我们不可以)</span></span><br><span class="line">    <span class="comment">// 到这里会把array的头指针和长度传递给array参数,本身并没有内含array(有点像委托)</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">(const_iterator __a, size_type __l)</span></span></span><br><span class="line"><span class="function">        : _M_array(__a), _M_len(__l) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">initializer_list</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">        : _M_array(<span class="number">0</span>), _M_len(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Number of elements.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> size_type</span></span><br><span class="line"><span class="function">    <span class="title">size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_len; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First element.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">    <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> _M_array; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// One past the last element.</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> const_iterator</span></span><br><span class="line"><span class="function">    <span class="title">end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">begin</span>() + <span class="built_in">size</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p><strong>关于这个类的拷贝构造，可以看由于在类里面没有对拷贝构造的重写，导致两个initializer_list在拷贝的时候是浅拷贝，两个指针指向同一块内存空间，可能会出现危险，这个需要注意</strong></p><p>STL的容器是如何引入initializer_list的？</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230430111248498.png" alt="image-20230430111248498"></p><p>initializer_list&lt;&gt;里面内置了一个array数组的指针和这个数组的长度，编译器会读取{}里面的元素来进行容器的插入操作以实现初始化操作</p><p>示例代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Algorithm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 传入的是一个initializer_list&lt;&gt;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="keyword">inline</span> Value_Type</span><br><span class="line">    _min(<span class="type">const</span> initializer_list&lt;Value_Type&gt; &amp;init_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Min</span>(init_list.<span class="built_in">begin</span>(), init_list.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="keyword">inline</span> Value_Type</span><br><span class="line">    _max(<span class="type">const</span> initializer_list&lt;Value_Type&gt; &amp;init_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Max</span>(init_list.<span class="built_in">begin</span>(), init_list.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input_Iterator&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Input_Iterator&gt;::<span class="function">value_type</span></span><br><span class="line"><span class="function">    <span class="title">Min</span><span class="params">(Input_Iterator first, Input_Iterator last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> Min = *first;</span><br><span class="line">        <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">            Min = Min &lt;= *first ? Min : *first;</span><br><span class="line">        <span class="keyword">return</span> Min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Input_Iterator&gt;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Input_Iterator&gt;::<span class="function">value_type</span></span><br><span class="line"><span class="function">    <span class="title">Max</span><span class="params">(Input_Iterator first, Input_Iterator last)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> Max = *first;</span><br><span class="line">        <span class="keyword">for</span> (; first != last; ++first)</span><br><span class="line">            Max = Max &gt;= *first ? Max : *first;</span><br><span class="line">        <span class="keyword">return</span> Max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Container &amp;con)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : con)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">69</span>, <span class="number">83</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">69</span>, <span class="number">83</span>, <span class="number">50</span>&#125;)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v3;</span><br><span class="line">    v3 = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">13</span>, <span class="number">69</span>, <span class="number">83</span>, <span class="number">50</span>&#125;;</span><br><span class="line">    v<span class="number">3.</span><span class="built_in">insert</span>(v<span class="number">3.</span><span class="built_in">begin</span>() + <span class="number">2</span>, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    <span class="built_in">print</span>(v3);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">Algorithm</span>()._max(&#123;<span class="number">54</span>, <span class="number">16</span>, <span class="number">48</span>, <span class="number">5</span>&#125;) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">Algorithm</span>()._min(&#123;<span class="built_in">string</span>(<span class="string">&quot;Ace&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;Hello&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;Fuck&quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;Zion&quot;</span>)&#125;) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="explicit-1"><a href="#explicit-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#explicit-1" class="headerlink" title="explicit"></a>explicit</h3><p><strong>explicit for ctor taking one argument</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> real, imag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Complex</span><span class="params">(<span class="type">int</span> re, <span class="type">int</span> im = <span class="number">0</span>)</span> : real(re), imag(im) &#123;</span>&#125;</span><br><span class="line">    <span class="comment">//explict关键字的含义 防止类构造函数的隐式自动转换</span></span><br><span class="line">    <span class="comment">//就是说这里由于只需要传入一个参数，所以编译器很可能会把数字隐式转化为Complex对象</span></span><br><span class="line">    <span class="comment">//但是加上了explict之后,明确指出不要让编译器这么干，要生成Complex对象只能显式调用构造函数!!!!</span></span><br><span class="line"></span><br><span class="line">    Complex <span class="keyword">operator</span>+(<span class="type">const</span> Complex &amp;x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Complex</span>(real + x.real, imag + x.imag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ostream &amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> Complex &amp;x)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; x.real &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; x.imag &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Complex <span class="title">c1</span><span class="params">(<span class="number">12</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Complex c2 = c1 + 5; // 加了explicit关键字就不允许编译器直接把5转化为 Complex 类型了</span></span><br><span class="line">    cout &lt;&lt; c1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这是一个实参加上 explicit 关键字的情况，前面已经提过很多了</p><p><strong>explicit for ctors taking more than one argument</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">P</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">P</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; cout &lt;&lt; <span class="string">&quot;P (int a , int b) &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// P(initializer_list&lt;int&gt;) &#123; cout &lt;&lt; &quot;P (initializer_list&lt;int&gt;) &quot; &lt;&lt; endl; &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">P</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;explicit P (int a , int b , int c) &quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">P <span class="title">p1</span><span class="params">(<span class="number">77</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">    P p2&#123;<span class="number">77</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    P p3 = &#123;<span class="number">77</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    P p4&#123;<span class="number">77</span>, <span class="number">5</span>, <span class="number">42</span>&#125;;</span><br><span class="line">    <span class="comment">// 这个是可以的,因为它既可以看作传入了三个参数，也可以看作传入了初始化序列</span></span><br><span class="line">    <span class="comment">// 而如果像下面一样加上括号并且有 explicit 关键字就只能传入 三个参数的形式</span></span><br><span class="line"></span><br><span class="line">    <span class="function">P <span class="title">p5</span><span class="params">(&#123;<span class="number">77</span>, <span class="number">5</span>, <span class="number">42</span>&#125;)</span></span>; </span><br><span class="line">    <span class="comment">// 这个在有 explicit 关键字的情况下没有办法把 initializer_list 的形式转化为 a,b,c 的形式，会报错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="x3D-delete-x3D-default"><a href="#x3D-delete-x3D-default" class="heading-link"><i class="fas fa-link"></i></a><a href="#x3D-delete-x3D-default" class="headerlink" title="&#x3D;delete,&#x3D;default"></a>&#x3D;delete,&#x3D;default</h3><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经定义了一个ctor，那么编译器就不会给一个默认的ctor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Zoo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Zoo</span>(<span class="type">int</span> i1, <span class="type">int</span> i2) : <span class="built_in">d1</span>(i1), <span class="built_in">d2</span>(i2) &#123;&#125;</span><br><span class="line">    <span class="built_in">Zoo</span>(<span class="type">const</span> Zoo &amp;) = <span class="keyword">delete</span>; <span class="comment">// delete表示我不要这一个重载</span></span><br><span class="line">    <span class="built_in">Zoo</span>(Zoo &amp;&amp;) = <span class="keyword">default</span>;     <span class="comment">// default表示我需要这一个重载并且是编译器默认提供给我的这个重载</span></span><br><span class="line">    Zoo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Zoo &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Zoo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Zoo &amp;&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Zoo</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> d1, d2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Zoo <span class="title">z1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="comment">// Zoo z2(z1); // 无法使用因为他是已删除的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>一般是应用在 Big 3 上面，即 构造函数，拷贝构造，拷贝赋值和析构函数</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504191205113.png" alt="image-20230504191205113"></p><p>其中出现了右值引用，这个目前不了解</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Zoo</span>(<span class="type">const</span> Zoo&amp;)=<span class="keyword">delete</span>;<span class="comment">// copy ctor</span></span><br><span class="line"><span class="built_in">Zoo</span>(Zoo&amp;&amp;)=<span class="keyword">default</span>;<span class="comment">// move ctor</span></span><br></pre></td></tr></table></div></figure><p>一个更细的例子：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504191639232.png" alt="image-20230504191639232"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ctor</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> i) : _i(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy ctor</span></span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;x) : _i(x._i) &#123;&#125;</span><br><span class="line">    <span class="comment">// Foo(const Foo &amp;) = default; // error 都已经定义出来了还要默认的，不行</span></span><br><span class="line">    <span class="comment">// Foo(const Foo &amp;) = delete;  // error 都已经定义出来又不要了，不行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy assign</span></span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Foo &amp;x)</span><br><span class="line">    &#123;</span><br><span class="line">        _i = x._i;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Foo &amp;operator=(const Foo &amp;x) = default; // error 都已经定义出来了还要默认的，不行</span></span><br><span class="line">    <span class="comment">// Foo &amp;operator=(const Foo &amp;x) = delete;  // error 都已经定义出来又不要了，不行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// void func1() = default; // error 一般的函数没有默认版本，只能用于 big five上面</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>= <span class="keyword">delete</span>; <span class="comment">// delete可以用在任何函数上面(=0 只能用于 virtual 函数)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ~Foo() = delete;//error 不能删除析构函数，这会导致使用Foo对象错误!!!!</span></span><br><span class="line">    ~<span class="built_in">Foo</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo f1; <span class="comment">// 如果不写 Foo() = default 编译器不会提供默认构造函数，会报错</span></span><br><span class="line">    <span class="function">Foo <span class="title">f2</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="function">Foo <span class="title">f3</span><span class="params">(f1)</span></span>;</span><br><span class="line">    f3 = f2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>对于一个空的类，编译器在处理的时候会提供默认的big 3，即 构造函数，拷贝构造，拷贝赋值，析构函数</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//空的，但是编译器会提供</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Empty</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//ctor</span></span><br><span class="line">    <span class="built_in">Empty</span>()&#123; ... &#125;</span><br><span class="line">    <span class="comment">//copy ctor</span></span><br><span class="line">    <span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp; rhs)&#123; ... &#125;</span><br><span class="line">    <span class="comment">//copy assign</span></span><br><span class="line">    Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp; rhs)&#123; ... &#125;</span><br><span class="line">    <span class="comment">//dctor</span></span><br><span class="line">    ~<span class="built_in">Empty</span>()&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下代码对于一个空类是合法的</span></span><br><span class="line">&#123;</span><br><span class="line">    Empty e1;</span><br><span class="line">    <span class="function">Empty <span class="title">e2</span><span class="params">(e1)</span></span>;</span><br><span class="line">    e2=e1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>那么我们怎么确认是用默认的还是自己写的呢？</p><p>classes with or without pointer members!!!!</p><p><strong>带有指针的类基本上都需要重写 big 3；不带指针的基本都不需要写!!!!!</strong></p><h4 id="No-Copy-and-Private-Copy"><a href="#No-Copy-and-Private-Copy" class="heading-link"><i class="fas fa-link"></i></a><a href="#No-Copy-and-Private-Copy" class="headerlink" title="No-Copy and Private-Copy"></a>No-Copy and Private-Copy</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504201206953.png" alt="image-20230504201206953"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Nocopy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Nocopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Nocopy</span>(<span class="type">const</span> Nocopy &amp;) = <span class="keyword">delete</span>;            <span class="comment">// no copy</span></span><br><span class="line">    Nocopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Nocopy &amp;) = <span class="keyword">delete</span>; <span class="comment">// no assign</span></span><br><span class="line">    ~<span class="built_in">Nocopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NoDtor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NoDtor</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">NoDtor</span>() = <span class="keyword">delete</span>; <span class="comment">// 非常不建议这么去做</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testNoDtor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// NoDtor nd;//栈区对象的生命周期在这个函数结束就销毁了，这时候会自动调用dtor，没有则报错</span></span><br><span class="line">    NoDtor *p = <span class="keyword">new</span> NoDtor; <span class="comment">// 动态开辟是允许的，但是无法销毁</span></span><br><span class="line">    <span class="comment">// delete p;               // 不允许销毁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateCopy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 这个类无法被一般的代码调用，但是可以被friend和member调用copy</span></span><br><span class="line">    <span class="comment">// 如果要禁止，不仅需要放到private里面，还要加上 = delete</span></span><br><span class="line">    <span class="built_in">PrivateCopy</span>(<span class="type">const</span> PrivateCopy &amp;);</span><br><span class="line">    PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="type">const</span> PrivateCopy &amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PrivateCopy</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">PrivateCopy</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testNoDtor</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="Alias-化名-Template-template-typedef-模板的化名"><a href="#Alias-化名-Template-template-typedef-模板的化名" class="heading-link"><i class="fas fa-link"></i></a><a href="#Alias-化名-Template-template-typedef-模板的化名" class="headerlink" title="Alias(化名) Template (template typedef) 模板的化名"></a>Alias(化名) Template (template typedef) 模板的化名</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504202940442.png" alt="image-20230504202940442"></p><p><strong>值得注意的是下面两个没办法实现我们想要的结果!!!!</strong></p><h4 id="test-moveable函数测试"><a href="#test-moveable函数测试" class="heading-link"><i class="fas fa-link"></i></a><a href="#test-moveable函数测试" class="headerlink" title="test_moveable函数测试"></a>test_moveable函数测试</h4><p>这么写始终会报错，看起来是没有办法把容器和容器模板的类型分开来进行传入的</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504213412890.png" alt="image-20230504213412890"></p><p>所以可以这么写：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230504213510643.png" alt="image-20230504213510643"></p><h3 id="template-template-parameter-双重模板参数"><a href="#template-template-parameter-双重模板参数" class="heading-link"><i class="fas fa-link"></i></a><a href="#template-template-parameter-双重模板参数" class="headerlink" title="template template parameter 双重模板参数"></a>template template parameter 双重模板参数</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505102818021.png" alt="image-20230505102818021"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 1e6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">output_static_data</span><span class="params">(<span class="type">const</span> Type &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static_data: &quot;</span> &lt;&lt; endl; <span class="comment">// 输出静态成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template template paremeter 双重模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value_Type</span>,</span><br><span class="line">          <span class="keyword">template</span> &lt;<span class="keyword">class</span>&gt; <span class="comment">// 这样写表示 Container模板使用 Value_Type 类型</span></span><br><span class="line">          <span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line"><span class="comment">// 这里由于传入的是容器，绝大多数的容器都有两个参数，第一个是元素类型，第二个是分配器，然而分配器又是以元素类型的模板</span></span><br><span class="line"><span class="comment">// 编译器无法推导第二个分配器的参数，虽然有默认值，所以就需要用到 Alias 来设置</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XCls</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Container&lt;Value_Type&gt; c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">XCls</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; SIZE; ++i)</span><br><span class="line">            c.<span class="built_in">insert</span>(c.<span class="built_in">end</span>(), <span class="built_in">Value_Type</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">output_static_data</span>(<span class="built_in">Value_Type</span>());</span><br><span class="line">        <span class="function">Container&lt;Value_Type&gt; <span class="title">c1</span><span class="params">(c)</span></span>;</span><br><span class="line">        <span class="function">Container&lt;Value_Type&gt; <span class="title">c2</span><span class="params">(std::move(c))</span></span>;</span><br><span class="line">        c<span class="number">1.</span><span class="built_in">swap</span>(c2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pool_allocator.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Alias</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="keyword">using</span> Vec = vector&lt;Value_Type, __gnu_cxx::__pool_alloc&lt;Value_Type&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="keyword">using</span> Lst = list&lt;Value_Type, __gnu_cxx::__pool_alloc&lt;Value_Type&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line">    <span class="keyword">using</span> Deq = deque&lt;Value_Type, __gnu_cxx::__pool_alloc&lt;Value_Type&gt;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Alias;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XCls&lt;string, Vec&gt; c;</span><br><span class="line">    XCls&lt;string, Lst&gt; c2;</span><br><span class="line">    XCls&lt;string, Deq&gt; c3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="type-alias-类型化名"><a href="#type-alias-类型化名" class="heading-link"><i class="fas fa-link"></i></a><a href="#type-alias-类型化名" class="headerlink" title="type alias 类型化名"></a>type alias 类型化名</h3><p>type alias 和 typedef 没有任何的不同</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// type alias 和 typedef 没有任何的不同</span></span><br><span class="line"><span class="keyword">namespace</span> Test</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;test01&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Container</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> Value_Type = T;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt;</span><br><span class="line">    <span class="keyword">using</span> mystring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Container</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fn2</span><span class="params">(<span class="type">const</span> Container &amp;con)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> Value_Type = <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> Container::iterator&gt;::value_type;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;fn2&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Test;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// func现在指向参数如下的函数</span></span><br><span class="line">    <span class="keyword">using</span> func = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br><span class="line">    func f1 = test01;</span><br><span class="line">    <span class="built_in">f1</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    mystring&lt;<span class="type">char</span>&gt; str;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fn2</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="noexcept-保证不会抛出异常"><a href="#noexcept-保证不会抛出异常" class="heading-link"><i class="fas fa-link"></i></a><a href="#noexcept-保证不会抛出异常" class="headerlink" title="noexcept 保证不会抛出异常"></a>noexcept 保证不会抛出异常</h3><p><strong>我们必须通知C++(特别是 std::vector)，move ctor 和 move assignment 和 dtor不会抛出异常，前两个都是右值引用</strong></p><p><strong>以vector为例，vector容器在扩充空间的时候，是以2倍空间扩充，需要新找一块内存将当前的数据移动到新数据块中，这就需要用到 move ctor，并且如果不是noexcept，vector不敢调用它，只有是noexcept的时候vector才会调用它</strong></p><p>注意：growable containers只有两种：vector和deque</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505152557462.png" alt="image-20230505152557462"></p><p>至于move ctor和move assignment，到后面再说</p><h3 id="override-覆写-特用于虚函数重写上面"><a href="#override-覆写-特用于虚函数重写上面" class="heading-link"><i class="fas fa-link"></i></a><a href="#override-覆写-特用于虚函数重写上面" class="headerlink" title="override 覆写 特用于虚函数重写上面"></a>override 覆写 特用于虚函数重写上面</h3><p><strong>这个需要保证子类和父类这个虚函数的名称，返回值，参数类型，个数，位置完全相同!!!!!</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Base func float&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived1</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 第一个是定义了一个新的虚函数,不是override</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived1 func int&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="comment">// 第二个才是上面父类的override</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span>)</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived1 func float&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">Derived1</span>().<span class="built_in">func</span>(<span class="number">1.1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="final"><a href="#final" class="heading-link"><i class="fas fa-link"></i></a><a href="#final" class="headerlink" title="final"></a>final</h3><p>用来修饰class表示不允许类继承自己；用来修饰虚函数virtual表示不允许子类override这个函数</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base1</span> <span class="keyword">final</span> <span class="comment">// final表示不允许有类继承自己</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  error</span></span><br><span class="line"><span class="comment">// struct Derived1 : Base1</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Base2</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">final</span></span>; <span class="comment">// final表示不允许子类覆写这个函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Derived2</span> : Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// void f(); //error</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="decltype"><a href="#decltype" class="heading-link"><i class="fas fa-link"></i></a><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h3><p>用来得到一个表达式的类型，有三大应用:</p><p>1.declare return types</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type1, <span class="keyword">typename</span> Value_Type2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">const</span> Value_Type1&amp; x, <span class="type">const</span> Value_Type2&amp; y)</span></span></span><br><span class="line"><span class="function">    -&gt; <span class="title">decltype</span><span class="params">(x + y)</span> </span>&#123;  <span class="comment">// 不写在前面是因为编译器先后次序编译不认识x,y，所以放在后面用 -&gt; 来指明auto的类型</span></span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Test;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>2.in metaprogramming 元编程 就是用在泛型里面</p><p>3.lambdas</p><p>一个应用：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Person</span>(string firstname, string lastname)</span><br><span class="line">        : _firstname(firstname), _lastname(lastname) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string _firstname;</span><br><span class="line">    string _lastname;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&#x27;(&#x27;</span> &lt;&lt; p._firstname &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; p._lastname &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> CmpPerson = [](<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2) &#123;</span><br><span class="line">    <span class="built_in">return</span> (p<span class="number">1.</span>_lastname &lt; p<span class="number">2.</span>_lastname) ||</span><br><span class="line">           (p<span class="number">1.</span>_lastname == p<span class="number">2.</span>_lastname) &amp;&amp; (p<span class="number">1.</span>_firstname &lt; p<span class="number">2.</span>_firstname);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cmp</span></span><br><span class="line">    : binary_function&lt;Person, Person, <span class="type">bool</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 被比较的不能被修改，编译器非常灵敏，需要加上const</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Person&amp; p1, <span class="type">const</span> Person&amp; p2)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (p<span class="number">1.</span>_lastname &lt; p<span class="number">2.</span>_lastname) ||</span><br><span class="line">               (p<span class="number">1.</span>_lastname == p<span class="number">2.</span>_lastname) &amp;&amp; (p<span class="number">1.</span>_firstname &lt; p<span class="number">2.</span>_firstname);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; cmps;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Container&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> Container&amp; con)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : con)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Test;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Wall&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;David&quot;</span>, <span class="string">&quot;Paul&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;Steve&quot;</span>, <span class="string">&quot;Paul&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要如果括号里不给CmpPerson参数，会调用CmpPerson的默认构造函数，不幸的是没有默认构造，所以需要给出</span></span><br><span class="line">    <span class="function">set&lt;Person, <span class="title">decltype</span><span class="params">(CmpPerson)</span>&gt; <span class="title">s</span><span class="params">(&#123;p1, p2, p3&#125;, CmpPerson)</span></span>;</span><br><span class="line">    <span class="built_in">print</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505195009665.png" alt="image-20230505195009665" style="zoom:67%"><h3 id="lambdas"><a href="#lambdas" class="heading-link"><i class="fas fa-link"></i></a><a href="#lambdas" class="headerlink" title="lambdas"></a>lambdas</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505190504411.png" alt="image-20230505190504411"></p><p>[ ]里可以指定是以 value 还是以 reference 的形式传入，( )后面那三个东西是可选的，但是只要有一个出现那么( )就必须写出来，所以建议都写上( )</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    []() -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello lambda&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;();  <span class="comment">// 前三个是格式 最后一个括号代表调用</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> I = []() -&gt; <span class="type">void</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;hello lambda&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">I</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> id1 = <span class="number">0</span>, id2 = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为什么下面打印出来是0 1 2</span></span><br><span class="line">    <span class="comment">// 因为这里的id1传进去是0，还没走到下面</span></span><br><span class="line">    <span class="comment">// 由于是 value 传递，所以是copy操作，内部的id不会影响外面的id</span></span><br><span class="line">    <span class="keyword">auto</span> f = [id1, &amp;id2]() <span class="keyword">mutable</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不写 mutable ，这个id进来之后只能read only，不能++</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id1: &quot;</span> &lt;&lt; id1 &lt;&lt; <span class="string">&#x27;,&#x27;</span> &lt;&lt; <span class="string">&quot;id2: &quot;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line">        ++id1;</span><br><span class="line">        ++id2;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面lambda表达式的相对接近的写法(不对等，有小区别)</span></span><br><span class="line">    <span class="comment">// class Functor &#123;</span></span><br><span class="line">    <span class="comment">// private:</span></span><br><span class="line">    <span class="comment">//     int id1;  // copy of outside id1</span></span><br><span class="line">    <span class="comment">//     int id2;  // reference of outside id2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public:</span></span><br><span class="line">    <span class="comment">//     void operator()() &#123;</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; &quot;id1: &quot; &lt;&lt; id1 &lt;&lt; &#x27;,&#x27; &lt;&lt; &quot;id2: &quot; &lt;&lt; id2 &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//         ++id1;</span></span><br><span class="line">    <span class="comment">//         ++id2;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;;</span></span><br><span class="line">    <span class="comment">// Functor f;</span></span><br><span class="line"></span><br><span class="line">    id1 = <span class="number">42</span>, id2 = <span class="number">42</span>;</span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 0 42</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 1 43</span></span><br><span class="line">    <span class="built_in">f</span>();  <span class="comment">// 2 44</span></span><br><span class="line">    cout &lt;&lt; id1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; id2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>与上一个的例子联系起来，也让我们对set的底层实现有了更多的理解</p><p><strong>这也解释了为什么在传入lambda的时候需要在括号里面指定这个函数变量，看他的构造就行了</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505195056962.png" alt="image-20230505195056962"></p><p>所以在functor和lambda之后，选择functor显然会稍微好一点</p><p>另一个例子：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LambdaFunctor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LambdaFunctor</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">        : _x(x), _y(y) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; _x &amp;&amp; val &lt; _y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _x;</span><br><span class="line">    <span class="type">int</span> _y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> vector&lt;Value_Type&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : vec)</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">30</span>, y = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v1&#123;<span class="number">5</span>, <span class="number">28</span>, <span class="number">50</span>, <span class="number">83</span>, <span class="number">70</span>, <span class="number">590</span>, <span class="number">245</span>, <span class="number">59</span>, <span class="number">24</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v2&#123;<span class="number">5</span>, <span class="number">28</span>, <span class="number">50</span>, <span class="number">83</span>, <span class="number">70</span>, <span class="number">590</span>, <span class="number">245</span>, <span class="number">59</span>, <span class="number">24</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意remove系列操作是假remove，需要erase才能真正删除</span></span><br><span class="line">    <span class="keyword">auto</span> newEnd1 = <span class="built_in">remove_if</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), [x, y](<span class="type">int</span> val) &#123;</span><br><span class="line">        <span class="keyword">return</span> val &gt; x &amp;&amp; val &lt; y;</span><br><span class="line">    &#125;);</span><br><span class="line">    v<span class="number">1.</span><span class="built_in">erase</span>(newEnd1, v<span class="number">1.</span><span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    v<span class="number">2.</span><span class="built_in">erase</span>(<span class="built_in">remove_if</span>(v<span class="number">1.</span><span class="built_in">begin</span>(), v<span class="number">1.</span><span class="built_in">end</span>(), <span class="built_in">LambdaFunctor</span>(x, y)), v<span class="number">2.</span><span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printVector</span>(v1);</span><br><span class="line">    <span class="built_in">printVector</span>(v2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="variadic-templates"><a href="#variadic-templates" class="heading-link"><i class="fas fa-link"></i></a><a href="#variadic-templates" class="headerlink" title="variadic templates"></a>variadic templates</h3><p>之前已经提到过很多次了，举一些例子：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _func() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> _func(<span class="type">const</span> Value_Type&amp; firstArg, <span class="type">const</span> Types&amp;... args) &#123;</span><br><span class="line">    ++value;</span><br><span class="line">    _func(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    _func(args...);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value: &quot;</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace Test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Test;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);             <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&quot;string&quot;</span>, <span class="string">&quot;fuck&quot;</span>, <span class="number">2</span>, <span class="number">1.2</span>);  <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>第二个例子：用c++模拟printf函数(简易版)</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Print &#123;</span><br><span class="line"><span class="comment">// 代码中抛出异常的部分先不管</span></span><br><span class="line"><span class="comment">// 用参数包重写printf函数 理解</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++str) != <span class="string">&#x27;%&#x27;</span>)  <span class="comment">// 已经没有参数包了还有控制符号，不对劲，抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">runtime_error</span>(<span class="string">&quot;invalid format string: missing arguments.&quot;</span>);</span><br><span class="line">        cout &lt;&lt; *str++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type, <span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">myprintf</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* str, <span class="type">const</span> Value_Type&amp; val, <span class="type">const</span> Types&amp;... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*str == <span class="string">&#x27;%&#x27;</span> &amp;&amp; *(++str) != <span class="string">&#x27;%&#x27;</span>) &#123;  <span class="comment">// 遇到控制符号了</span></span><br><span class="line">            cout &lt;&lt; val;</span><br><span class="line">            <span class="built_in">myprintf</span>(++str, args...);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; *str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">logic_error</span>(<span class="string">&quot;extra arguments provided to myprintf&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace Print</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Print;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myprintf</span>(<span class="string">&quot;hello\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* pi = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line">    <span class="comment">// 但是这么模拟有一个很大的问题，就是控制符号我们没去管，但是介于只是一个简单的模拟，还是可以的</span></span><br><span class="line">    <span class="built_in">myprintf</span>(<span class="string">&quot;%d %s %p %f\n&quot;</span>, <span class="number">15</span>, <span class="string">&quot;This is Ace.&quot;</span>, pi, <span class="number">3.1415926535</span>);</span><br><span class="line">    <span class="keyword">delete</span> pi;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="打印tuple-这个例子非常巧妙"><a href="#打印tuple-这个例子非常巧妙" class="heading-link"><i class="fas fa-link"></i></a><a href="#打印tuple-这个例子非常巧妙" class="headerlink" title="打印tuple(这个例子非常巧妙)"></a>打印tuple(这个例子非常巧妙)</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230505213553781.png" alt="image-20230505213553781"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> PRINT &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> index, <span class="type">int</span> max, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple_Print</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="built_in">get</span>&lt;index&gt;(t) &lt;&lt; (index + <span class="number">1</span> != max ? <span class="string">&quot;,&quot;</span> : <span class="string">&quot;&quot;</span>);  <span class="comment">// 如果不是最后一个就是 , 号</span></span><br><span class="line">        Tuple_Print&lt;index + <span class="number">1</span>, max, Args...&gt;::<span class="built_in">print</span>(os, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归终点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> max, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tuple_Print</span>&lt;max, max, Args...&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">static</span> <span class="type">void</span> <span class="title">print</span><span class="params">(ostream&amp; os, <span class="type">const</span> tuple&lt;Args...&gt;&amp; t)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace PRINT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="keyword">inline</span> ostream&amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> tuple&lt;Args...&gt;&amp; t) &#123;</span><br><span class="line">    os &lt;&lt; <span class="string">&quot;[&quot;</span>;</span><br><span class="line">    PRINT::Tuple_Print&lt;<span class="number">0</span>, <span class="keyword">sizeof</span>...(Args), Args...&gt;::<span class="built_in">print</span>(os, t);</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">make_tuple</span>(<span class="number">7.5</span>, <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>), <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">42</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="第二讲：标准库"><a href="#第二讲：标准库" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二讲：标准库" class="headerlink" title="第二讲：标准库"></a>第二讲：标准库</h2><h3 id="右值引用"><a href="#右值引用" class="heading-link"><i class="fas fa-link"></i></a><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>记住：</p><ul><li><strong>左值 !&#x3D; 左值引用</strong></li><li><strong>右值 !&#x3D; 右值引用</strong></li></ul><p>Lvalue：只能出现在operator &#x3D; 左边</p><p>Rvalue：只能出现再operator &#x3D; 右边</p><p><strong>临时对象是一个右值，右值不能出现在 &#x3D; 号的左边，临时对象tmp一定被当作右值!!!!!</strong></p><p>注意copy ctor和move ctor之间的区别：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230514163001551.png" alt="image-20230514163001551"></p><p><strong>move()：标准库提供的可以把左值变为右值的函数</strong></p><p><strong>Perfect Forwarding:在途中把Vtype(buf)(右值)交给Mystring的move ctor的时候会先经过insert函数在调用move ctor，这就有一个中间传递的过程，所以如何做到Perfect Forwarding是一个非常重要的事情，确保该传递的信息不能丢失</strong></p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230514170850534.png" alt="image-20230514170850534" style="zoom:67%"><p>Unperfect Forwarding</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230514171027632.png" alt="image-20230514171027632"></p><p>Perfect Forwarding的具体实现：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516105734995.png" alt="image-20230516105734995"></p><p>写一个 move aware class</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516114646497.png" alt="image-20230516114646497"></p><p>在 move ctor 当中，为什么要把原来的指针设为nullptr呢？(打断)</p><p><strong>这是因为假如传入的右值对象是临时对象，临时对象的生命周期就只有这一句代码，执行完过后就会被释放，如果不打断，对于这里的string而言，就会调用析构函数把这个临时对象以及临时对象指向的区域给释放掉，因此就影响到了_data的部分，虽然这个临时对象今后不再用了，但是我们还是要把它与我们偷来的数据进行打断，并且配套的在析构函数的部分将其释放，否则会出现上面的问题</strong></p><p>move ctor和move asgn的测试</p><p>MyString.h</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYSTRING_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MYSTRING_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">// 写一个 move aware class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mystring</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> DCtor;  <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> Ctor;   <span class="comment">// 累计 ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> CCtor;  <span class="comment">// 累计 copy-ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> CAsgn;  <span class="comment">// 累计 copy-asgn呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> MCtor;  <span class="comment">// 累计 move-ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> MAsgn;  <span class="comment">// 累计 move-asgn呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> Dtor;   <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line">    <span class="type">size_t</span> _len;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _init_data(<span class="type">const</span> <span class="type">char</span>* s) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(_data, s, _len);  <span class="comment">// 这是一个深拷贝</span></span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default-ctor</span></span><br><span class="line">    <span class="built_in">Mystring</span>() : _data(<span class="literal">nullptr</span>), _len(<span class="number">0</span>) &#123; ++DCtor; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctor</span></span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> <span class="type">char</span>* p) : _len(<span class="built_in">strlen</span>(p)) &#123;</span><br><span class="line">        ++Ctor;</span><br><span class="line">        _init_data(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy-ctor</span></span><br><span class="line">    <span class="built_in">Mystring</span>(<span class="type">const</span> Mystring&amp; str) : _len(str._len) &#123;</span><br><span class="line">        ++CCtor;</span><br><span class="line">        _init_data(str._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy-asgn</span></span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Mystring&amp; str) &#123;</span><br><span class="line">        ++CAsgn;</span><br><span class="line">        <span class="comment">// 自我赋值检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">            _len = str._len;</span><br><span class="line">            _init_data(str._data);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;cannot assign yourself.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move ctor, with noexcept</span></span><br><span class="line">    <span class="built_in">Mystring</span>(Mystring&amp;&amp; str) <span class="keyword">noexcept</span> : _data(str._data), _len(str._len) &#123;  <span class="comment">// 指针相同表示指向同一块内存，就是一个偷的动作，是浅拷贝!!!</span></span><br><span class="line">        <span class="comment">// 完事之后将原来的str处理一下，能够传入右值引用都表示今后这个东西不用了</span></span><br><span class="line">        <span class="comment">// 所以不用了，但是也不要删除掉</span></span><br><span class="line">        ++MCtor;</span><br><span class="line">        str._len = <span class="number">0</span>;</span><br><span class="line">        str._data = <span class="literal">nullptr</span>;  <span class="comment">// 重要!!!</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// move asgn, with noexcept</span></span><br><span class="line">    Mystring&amp; <span class="keyword">operator</span>=(Mystring&amp;&amp; str) &#123;</span><br><span class="line">        ++MAsgn;</span><br><span class="line">        <span class="comment">// 自我赋值检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">            _data = str._data;</span><br><span class="line">            _len = str._len;</span><br><span class="line"></span><br><span class="line">            str._len = <span class="number">0</span>;</span><br><span class="line">            str._data = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dtor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Mystring</span>() &#123;</span><br><span class="line">        ++DCtor;</span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">            <span class="keyword">delete</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator &lt;</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Mystring&amp; rhs) <span class="type">const</span> &#123;  <span class="comment">// 为了set</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>-&gt;_data) &lt; <span class="built_in">string</span>(rhs._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator ==</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Mystring&amp; rhs) <span class="type">const</span> &#123;  <span class="comment">// 为了set</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>-&gt;_data) == <span class="built_in">string</span>(rhs._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态变量</span></span><br><span class="line"><span class="type">size_t</span> Mystring::DCtor = <span class="number">0</span>;  <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> Mystring::Ctor = <span class="number">0</span>;   <span class="comment">// 累计 ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> Mystring::CCtor = <span class="number">0</span>;  <span class="comment">// 累计 copy-ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> Mystring::CAsgn = <span class="number">0</span>;  <span class="comment">// 累计 copy-asgn呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> Mystring::MCtor = <span class="number">0</span>;  <span class="comment">// 累计 move-ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> Mystring::MAsgn = <span class="number">0</span>;  <span class="comment">// 累计 move-asgn呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> Mystring::Dtor = <span class="number">0</span>;   <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理hashcode 放在std中和标准库合并</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;Mystring&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> Mystring&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(<span class="built_in">string</span>(s.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace std</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><p>MyStrNoMove.h</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _MYSTRNOMOVE_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _MYSTRNOMOVE_H_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStrNoMove</span> &#123;</span><br><span class="line">    <span class="comment">// 拿掉move ctor和 move asgn</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> DCtor;  <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> Ctor;   <span class="comment">// 累计 ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> CCtor;  <span class="comment">// 累计 copy-ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> CAsgn;  <span class="comment">// 累计 copy-asgn呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> MCtor;  <span class="comment">// 累计 move-ctor呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> MAsgn;  <span class="comment">// 累计 move-asgn呼叫次数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> Dtor;   <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* _data;</span><br><span class="line">    <span class="type">size_t</span> _len;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> _init_data(<span class="type">const</span> <span class="type">char</span>* s) &#123;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="type">char</span>[_len + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">memcpy</span>(_data, s, _len);  <span class="comment">// 这是一个深拷贝</span></span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// default-ctor</span></span><br><span class="line">    <span class="built_in">MyStrNoMove</span>() : _data(<span class="literal">nullptr</span>), _len(<span class="number">0</span>) &#123; ++DCtor; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctor</span></span><br><span class="line">    <span class="built_in">MyStrNoMove</span>(<span class="type">const</span> <span class="type">char</span>* p) : _len(<span class="built_in">strlen</span>(p)) &#123;</span><br><span class="line">        ++Ctor;</span><br><span class="line">        _init_data(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy-ctor</span></span><br><span class="line">    <span class="built_in">MyStrNoMove</span>(<span class="type">const</span> MyStrNoMove&amp; str) : _len(str._len) &#123;</span><br><span class="line">        ++CCtor;</span><br><span class="line">        _init_data(str._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy-asgn</span></span><br><span class="line">    MyStrNoMove&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyStrNoMove&amp; str) &#123;</span><br><span class="line">        ++CAsgn;</span><br><span class="line">        <span class="comment">// 自我赋值检查</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">            _len = str._len;</span><br><span class="line">            _init_data(str._data);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;cannot assign yourself.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dtor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">MyStrNoMove</span>() &#123;</span><br><span class="line">        ++DCtor;</span><br><span class="line">        <span class="keyword">if</span> (_data)</span><br><span class="line">            <span class="keyword">delete</span> _data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator &lt;</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyStrNoMove&amp; rhs) <span class="type">const</span> &#123;  <span class="comment">// 为了set</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>-&gt;_data) &lt; <span class="built_in">string</span>(rhs._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// operator ==</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyStrNoMove&amp; rhs) <span class="type">const</span> &#123;  <span class="comment">// 为了set</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>(<span class="keyword">this</span>-&gt;_data) == <span class="built_in">string</span>(rhs._data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化静态变量</span></span><br><span class="line"><span class="type">size_t</span> MyStrNoMove::DCtor = <span class="number">0</span>;  <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> MyStrNoMove::Ctor = <span class="number">0</span>;   <span class="comment">// 累计 ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> MyStrNoMove::CCtor = <span class="number">0</span>;  <span class="comment">// 累计 copy-ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> MyStrNoMove::CAsgn = <span class="number">0</span>;  <span class="comment">// 累计 copy-asgn呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> MyStrNoMove::MCtor = <span class="number">0</span>;  <span class="comment">// 累计 move-ctor呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> MyStrNoMove::MAsgn = <span class="number">0</span>;  <span class="comment">// 累计 move-asgn呼叫次数</span></span><br><span class="line"><span class="type">size_t</span> MyStrNoMove::Dtor = <span class="number">0</span>;   <span class="comment">// 累计 default-ctor呼叫次数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理hashcode 放在std中和标准库合并</span></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hash</span>&lt;MyStrNoMove&gt; &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> MyStrNoMove&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;()(<span class="built_in">string</span>(s.<span class="built_in">get</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;  <span class="comment">// namespace std</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><p>test.h</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TEST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TEST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;25_MyStrNoMove.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;25_Mystring.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Test &#123;</span><br><span class="line"><span class="comment">//--------------------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MyString&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output_static_data</span><span class="params">(<span class="type">const</span> MyString &amp;str)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">typeid</span>(str).<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot;--&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;CCtor= &quot;</span> &lt;&lt; MyString::CCtor</span><br><span class="line">         &lt;&lt; <span class="string">&quot; MCtor= &quot;</span> &lt;&lt; MyString::MCtor</span><br><span class="line">         &lt;&lt; <span class="string">&quot; CAsgn= &quot;</span> &lt;&lt; MyString::CAsgn</span><br><span class="line">         &lt;&lt; <span class="string">&quot; MAsgn= &quot;</span> &lt;&lt; MyString::MAsgn</span><br><span class="line">         &lt;&lt; <span class="string">&quot; Dtor= &quot;</span> &lt;&lt; MyString::Dtor</span><br><span class="line">         &lt;&lt; <span class="string">&quot; Ctor= &quot;</span> &lt;&lt; MyString::Ctor</span><br><span class="line">         &lt;&lt; <span class="string">&quot; DCtor= &quot;</span> &lt;&lt; MyString::DCtor</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_moveable</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M, <span class="keyword">typename</span> NM&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_moveable</span><span class="params">(M c1, NM c2, <span class="type">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 moveable</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest, with moveable elements&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> M::iterator&gt;::value_type V1type;</span><br><span class="line">    <span class="type">clock_t</span> timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());</span><br><span class="line">        <span class="keyword">auto</span> ite = c<span class="number">1.</span><span class="built_in">end</span>();</span><br><span class="line">        c<span class="number">1.</span><span class="built_in">insert</span>(ite, <span class="built_in">V1type</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;construction, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()= &quot;</span> &lt;&lt; c<span class="number">1.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">output_static_data</span>(*(c<span class="number">1.</span><span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="function">M <span class="title">c11</span><span class="params">(c1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="function">M <span class="title">c12</span><span class="params">(std::move(c1))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move copy, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    c<span class="number">11.</span><span class="built_in">swap</span>(c12);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试 non-moveable</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest, with non-moveable elements&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> iterator_traits&lt;<span class="keyword">typename</span> NM::iterator&gt;::value_type V2type;</span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> i = <span class="number">0</span>; i &lt; value; ++i) &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buf, <span class="number">10</span>, <span class="string">&quot;%d&quot;</span>, <span class="built_in">rand</span>());</span><br><span class="line">        <span class="keyword">auto</span> ite = c<span class="number">2.</span><span class="built_in">end</span>();</span><br><span class="line">        c<span class="number">2.</span><span class="built_in">insert</span>(ite, <span class="built_in">V2type</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;construction, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size()= &quot;</span> &lt;&lt; c<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">output_static_data</span>(*(c<span class="number">2.</span><span class="built_in">begin</span>()));</span><br><span class="line"></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="function">NM <span class="title">c21</span><span class="params">(c2)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;copy, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    <span class="function">NM <span class="title">c22</span><span class="params">(std::move(c2))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;move copy, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    timeStart = <span class="built_in">clock</span>();</span><br><span class="line">    c<span class="number">21.</span><span class="built_in">swap</span>(c22);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;swap, milli-seconds : &quot;</span> &lt;&lt; <span class="built_in">double</span>(<span class="built_in">clock</span>() - timeStart) / <span class="number">1000</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将标识位 清0</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Mystring::DCtor = <span class="number">0</span>;</span><br><span class="line">    Mystring::Ctor = <span class="number">0</span>;</span><br><span class="line">    Mystring::CCtor = <span class="number">0</span>;</span><br><span class="line">    Mystring::CAsgn = <span class="number">0</span>;</span><br><span class="line">    Mystring::MCtor = <span class="number">0</span>;</span><br><span class="line">    Mystring::MAsgn = <span class="number">0</span>;</span><br><span class="line">    Mystring::Dtor = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    MyStrNoMove::DCtor = <span class="number">0</span>;</span><br><span class="line">    MyStrNoMove::Ctor = <span class="number">0</span>;</span><br><span class="line">    MyStrNoMove::CCtor = <span class="number">0</span>;</span><br><span class="line">    MyStrNoMove::CAsgn = <span class="number">0</span>;</span><br><span class="line">    MyStrNoMove::MCtor = <span class="number">0</span>;</span><br><span class="line">    MyStrNoMove::MAsgn = <span class="number">0</span>;</span><br><span class="line">    MyStrNoMove::Dtor = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_vector</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_vector</span><span class="params">(<span class="type">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_vector().......... \n&quot;</span>;</span><br><span class="line">    <span class="built_in">test_moveable</span>(<span class="built_in">vector</span>&lt;Mystring&gt;(), <span class="built_in">vector</span>&lt;MyStrNoMove&gt;(), value);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_list</span><span class="params">(<span class="type">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_list().......... \n&quot;</span>;</span><br><span class="line">    <span class="built_in">test_moveable</span>(<span class="built_in">list</span>&lt;Mystring&gt;(), <span class="built_in">list</span>&lt;MyStrNoMove&gt;(), value);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_deque</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_deque</span><span class="params">(<span class="type">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_deque().......... \n&quot;</span>;</span><br><span class="line">    <span class="built_in">test_moveable</span>(<span class="built_in">deque</span>&lt;Mystring&gt;(), <span class="built_in">deque</span>&lt;MyStrNoMove&gt;(), value);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_multiset</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_multiset</span><span class="params">(<span class="type">long</span> &amp;value)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\ntest_multiset().......... \n&quot;</span>;</span><br><span class="line">    <span class="built_in">test_moveable</span>(<span class="built_in">multiset</span>&lt;Mystring&gt;(), <span class="built_in">multiset</span>&lt;MyStrNoMove&gt;(), value);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test_unordered_multiset</span></span><br><span class="line"><span class="comment">// void test_unordered_multiset(long &amp;value) &#123;</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; &quot;\ntest_unordered_multiset().......... \n&quot;;</span></span><br><span class="line"><span class="comment">//     test_moveable(unordered_multiset&lt;Mystring&gt;(), unordered_multiset&lt;MyStrNoMove&gt;(), value);</span></span><br><span class="line"><span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;  <span class="comment">// namespace Test</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><p>main.cpp</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;25_MyStrNoMove.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;25_Mystring.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;25_test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> value = <span class="number">3</span> * <span class="number">10e5</span>;</span><br><span class="line"></span><br><span class="line">    Test::<span class="built_in">test_vector</span>(value);</span><br><span class="line">    Test::<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    Test::<span class="built_in">test_list</span>(value);</span><br><span class="line">    Test::<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    Test::<span class="built_in">test_deque</span>(value);</span><br><span class="line">    Test::<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    Test::<span class="built_in">test_multiset</span>(value);</span><br><span class="line">    Test::<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Test::test_unordered_multiset(value);</span></span><br><span class="line">    <span class="comment">// Test::clear();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516165803938.png" alt="image-20230516165803938"></p><h3 id="适配器-Adapter-补充"><a href="#适配器-Adapter-补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#适配器-Adapter-补充" class="headerlink" title="适配器 Adapter 补充"></a>适配器 Adapter 补充</h3><h4 id="X适配器：ostream-iterator"><a href="#X适配器：ostream-iterator" class="heading-link"><i class="fas fa-link"></i></a><a href="#X适配器：ostream-iterator" class="headerlink" title="X适配器：ostream_iterator"></a>X适配器：ostream_iterator</h4><p>可以用来连接 cout</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516203937375.png" alt="image-20230516203937375"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">//std::copy</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>   <span class="comment">//std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>   <span class="comment">//std::ostream_iterator</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span>     <span class="comment">//std::vector</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) v.<span class="built_in">push_back</span>(i * <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_it</span><span class="params">(std::cout, <span class="string">&quot;,&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), out_it);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="istream-iterator"><a href="#istream-iterator" class="heading-link"><i class="fas fa-link"></i></a><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a>istream_iterator</h4><p>可以用来连接 cin</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516205607537.png" alt="image-20230516205607537"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  <span class="comment">//std::cin std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>  <span class="comment">//std::istream_iterator</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value1, value2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Please,insert two values: &quot;</span>;</span><br><span class="line">    std::istream_iterator&lt;<span class="type">double</span>&gt; eos;             <span class="comment">// end-of-stream iterator</span></span><br><span class="line">    <span class="function">std::istream_iterator&lt;<span class="type">double</span>&gt; <span class="title">iter</span><span class="params">(std::cin)</span></span>;  <span class="comment">// stdin iterator</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (iter != eos)</span><br><span class="line">        value1 = *iter;</span><br><span class="line">    ++iter;</span><br><span class="line">    <span class="keyword">if</span> (iter != eos)</span><br><span class="line">        value2 = *iter;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; value1 &lt;&lt; <span class="string">&quot; * &quot;</span> &lt;&lt; value2 &lt;&lt; <span class="string">&quot; == &quot;</span> &lt;&lt; value1 * value2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="type-traits"><a href="#type-traits" class="heading-link"><i class="fas fa-link"></i></a><a href="#type-traits" class="headerlink" title="type traits"></a>type traits</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516212207244.png" alt="image-20230516212207244"></p><p>以前的版本由于标准的限制，最好写自定义类的时候也要带上这个 __type_traits&lt;&gt;</p><p>C++2.0 新版本</p><p><strong>trivial 不重要的</strong><br><strong>POD plain old data 平淡的旧风格的，指的就是C风格的，也就是只有成员变量没有成员方法</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221129783.png" alt="image-20230516221129783"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221225536.png" alt="image-20230516221225536"></p><p>type traits 测试</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221737119.png" alt="image-20230516221737119" style="zoom:67%"><p>type_traits 实现 is_void(了解)</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230517141545661.png" alt="image-20230517141545661"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// my_isVoid 简单版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Value_Type</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_isVoid</span> : <span class="keyword">public</span> false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">my_isVoid</span>&lt;<span class="type">void</span>&gt; : <span class="keyword">public</span> true_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; my_isVoid&lt;<span class="type">int</span>&gt;::value &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; my_isVoid&lt;<span class="type">void</span>&gt;::value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="内存管理"><a href="#内存管理" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="第一讲：primitives"><a href="#第一讲：primitives" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一讲：primitives" class="headerlink" title="第一讲：primitives"></a>第一讲：primitives</h2><h3 id="c-应用程序"><a href="#c-应用程序" class="heading-link"><i class="fas fa-link"></i></a><a href="#c-应用程序" class="headerlink" title="c++应用程序"></a>c++应用程序</h3><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518140540645.png" alt="image-20230518140540645" style="zoom:67%"><h4 id="c-内存的基本工具"><a href="#c-内存的基本工具" class="heading-link"><i class="fas fa-link"></i></a><a href="#c-内存的基本工具" class="headerlink" title="c++内存的基本工具"></a>c++内存的基本工具</h4><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518140911306.png" alt="image-20230518140911306" style="zoom:50%"><p>测试程序：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pool_allocator.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 三种使用方法</span></span><br><span class="line">    <span class="type">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">512</span>);  <span class="comment">// 512 bytes</span></span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"></span><br><span class="line">    complex&lt;<span class="type">int</span>&gt;* p2 = <span class="keyword">new</span> complex&lt;<span class="type">int</span>&gt;;</span><br><span class="line">    cout &lt;&lt; p2 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p3 = ::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="number">512</span>);  <span class="comment">// 512 bytes</span></span><br><span class="line">    cout &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下使用 C++ 标准库提供的 allocators。</span></span><br><span class="line"><span class="comment">// 虽然接口都有标准规格，但是调用方式略有区别</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _MSC_VER</span></span><br><span class="line">    <span class="comment">// 以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">3</span>, (<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __BORLANDC__</span></span><br><span class="line">    <span class="comment">// 以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.</span></span><br><span class="line">    <span class="type">int</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>(p4, <span class="number">5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用这一个</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __GNUC__</span></span><br><span class="line">    <span class="comment">// 以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.</span></span><br><span class="line">    <span class="comment">// void* p4 = alloc::allocate(512);</span></span><br><span class="line">    <span class="comment">// alloc::deallocate(p4, 512);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.</span></span><br><span class="line">    <span class="type">void</span>* p4 = <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; p4 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">allocator</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p4, <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.</span></span><br><span class="line">    <span class="type">void</span>* p5 = __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">allocate</span>(<span class="number">9</span>);</span><br><span class="line">    cout &lt;&lt; p5 &lt;&lt; endl;</span><br><span class="line">    __gnu_cxx::__pool_alloc&lt;<span class="type">int</span>&gt;().<span class="built_in">deallocate</span>((<span class="type">int</span>*)p5, <span class="number">9</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="new-expression"><a href="#new-expression" class="heading-link"><i class="fas fa-link"></i></a><a href="#new-expression" class="headerlink" title="new expression"></a>new expression</h3><p>使用new关键字之后编译器会把这串代码翻译为如下：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518143501227.png" alt="image-20230518143501227"></p><p><strong>new关键字使用之后重要的就执行了两步，第一步是分配内存，第二步是调用构造函数</strong></p><h4 id="delete-expression"><a href="#delete-expression" class="heading-link"><i class="fas fa-link"></i></a><a href="#delete-expression" class="headerlink" title="delete expression"></a>delete expression</h4><p>与new相对应的就有delete关键字</p><p><strong>delete关键字使用的时候执行了两步，第一步是调用析构函数，第二步是释放内存</strong></p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518150122803.png" alt="image-20230518150122803" style="zoom:67%"><p>上面两副图片当中，<strong>通过指针，构造函数不能被直接调用，而析构函数可以被直接调用</strong></p><p><strong>如果非要调用的话，可以用 placement new</strong> (现在不理解什么意思)</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(p) <span class="built_in">Complex</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></div></figure><p>以下是一个测试程序：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> id) : _id(id) &#123; cout &lt;&lt; <span class="string">&quot;ctor. this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id = &quot;</span> &lt;&lt; id &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor. this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string* pstr = <span class="keyword">new</span> string;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str= &quot;</span> &lt;&lt; *pstr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pstr-&gt;string::string(&quot;hello&quot;);  // ‘class std::__cxx11::basic_string&lt;char&gt;’ has no member named ‘string’</span></span><br><span class="line">    <span class="comment">// pstr-&gt;~string();//crash</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str= &quot;</span> &lt;&lt; *pstr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    A* pA = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; pA-&gt;_id &lt;&lt; endl;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// pA-&gt;A::A(3);//cannot call constructor ‘A::A’ directly</span></span><br><span class="line">    <span class="comment">// A::A(5);</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; pA-&gt;_id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pA;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="array-new-array-delete"><a href="#array-new-array-delete" class="heading-link"><i class="fas fa-link"></i></a><a href="#array-new-array-delete" class="headerlink" title="array new,array delete"></a>array new,array delete</h3><p>注意：array new 一定要搭配 array delete，否则就极容易发生内存泄漏</p><p><strong>这个内存泄露对于尤其是class with pointers，通常带有影响</strong></p><p>因为对于没有指针的类，只需要释放这个类对象的指针就可以了，因此调用一次和三次的dtor没有明显的区别，换句话说就是这个类的dtor是trivial(不重要的)，但是带有指针的类就不一样了</p><p>比如下面string那个例子，只换起一次dtor，那么三个string指向的东西只被释放了一个，然后整体就被释放了，剩余的两块内存怎么办呢？因此会导致内存泄漏</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518154018869.png" alt="image-20230518154018869"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> size 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() : _id(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;default ctor. this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id = &quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> id) : _id(id) &#123; cout &lt;&lt; <span class="string">&quot;ctor. this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id = &quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor. this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id = &quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A* buf = <span class="keyword">new</span> A[size];  <span class="comment">// A必须有默认构造函数，否则会报错</span></span><br><span class="line">    A* tmp = buf;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;buf= &quot;</span> &lt;&lt; buf &lt;&lt; <span class="string">&quot; tmp= &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">        <span class="keyword">new</span> (tmp++) <span class="built_in">A</span>(i);  <span class="comment">// placement new , ctor 三次</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;buf= &quot;</span> &lt;&lt; buf &lt;&lt; <span class="string">&quot; tmp= &quot;</span> &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[] buf;  <span class="comment">// dtor 3次，次序反过来 3 2 1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518160118276.png" alt="image-20230518160118276" style="zoom:67%"><h4 id="内存分布"><a href="#内存分布" class="heading-link"><i class="fas fa-link"></i></a><a href="#内存分布" class="headerlink" title="内存分布"></a>内存分布</h4><p>内存的底层开辟和释放都是调用的malloc和free，那么调用了malloc之后会给我们的内存分布就如下所示：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518161942376.png" alt="image-20230518161942376"></p><p>可以浅谈一下这个内存是怎么分配的(后面都会进行深入的探究，以及每一块的作用)</p><p><strong>Demo对象：3个int，占据12个字节，3个总共36个字节；</strong></p><p><strong>由于他带有指针，所以需要额外记录这个数组对象包含Demo的个数，4个字节；</strong></p><p><strong>这个真正有效的数据区域上下(黄色的部分)，分别占据32 + 4 个字节；</strong></p><p><strong>内存块上下的两个cookie，各自4个字节，总共8个字节；</strong></p><p><strong>上面一共加起来84个字节，需要调整到16个字节的倍数，也就是96个字节，多出的12个字节存放在Pad中</strong></p><h3 id="placement-new"><a href="#placement-new" class="heading-link"><i class="fas fa-link"></i></a><a href="#placement-new" class="headerlink" title="placement new"></a>placement new</h3><p><strong>placement new允许我们将对象建造在已经分配好的内存当中！！</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518163205880.png" alt="image-20230518163205880"></p><p><strong>编译器翻译成为的那三个操作，在 placement new 下面，第一条由于传入了一个指针，那么会调用重载的版本，其实就是表示不用新开内存，把原来的给我就行；然后第三条编译器就调用构造函数在已有的内存上进行创建对象初始化!!!!</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Complex</span>() : _re(<span class="number">0</span>), _im(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Complex</span>(<span class="type">double</span> re, <span class="type">double</span> im) : _re(re), _im(im) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> _re, _im;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span>* buf = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">sizeof</span>(Complex) * <span class="number">3</span>];</span><br><span class="line">    <span class="comment">// 现在想把一个Complex对象动态开辟在buf的一个Complex单元，调用placement new</span></span><br><span class="line">    Complex* pc = <span class="built_in">new</span> (buf) <span class="built_in">Complex</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span>[]buf;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="重载"><a href="#重载" class="heading-link"><i class="fas fa-link"></i></a><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518164140667.png" alt="image-20230518164140667"></p><p><strong>重载比较多的就是在类中去重载 operator new和 operator delete，这样编译器在调用new或者delete关键字解析到那两步的时候就会优先调用我们重载的版本，在我们重载的版本当中可以设计一些专用于这个类的设计，这样或许能够提高效率和节省开销</strong></p><p>在类里面重载</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518170044346.png" alt="image-20230518170044346"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230518171104774.png" alt="image-20230518171104774"></p><p>delete中的第二参数是optional的，可以写也可以不写</p><h4 id="重载示例"><a href="#重载示例" class="heading-link"><i class="fas fa-link"></i></a><a href="#重载示例" class="headerlink" title="重载示例"></a>重载示例</h4><p>在类当中进行简单的重载，和全局的输出做对比</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> _id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() : _id(<span class="number">0</span>) &#123; cout &lt;&lt; <span class="string">&quot;default ctor.this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id = &quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> id) : _id(id) &#123; cout &lt;&lt; <span class="string">&quot;ctor.this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id = &quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// virtual</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;dtor.this = &quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">&quot; id = &quot;</span> &lt;&lt; _id &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size);</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr, <span class="type">size_t</span> size);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo *p = <span class="built_in">static_cast</span>&lt;Foo *&gt;(<span class="built_in">malloc</span>(size));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Foo::operator new(), size = &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;\treturn : &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Foo::operator delete(), ptr = &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;\tsize = &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *Foo::<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    Foo *p = <span class="built_in">static_cast</span>&lt;Foo *&gt;(<span class="built_in">malloc</span>(size));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Foo::operator new[](), size = &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;\treturn : &quot;</span> &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> Foo::<span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *ptr, <span class="type">size_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Foo::operator delete[](), ptr = &quot;</span> &lt;&lt; ptr &lt;&lt; <span class="string">&quot;\tsize = &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sizeof(Foo) = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Foo) &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Foo------------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Foo *p = <span class="keyword">new</span> Foo;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Foo *pArray = <span class="keyword">new</span> Foo[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">delete</span>[] pArray;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; <span class="string">&quot;Global------------------------------------------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Foo *p2 = ::<span class="keyword">new</span> Foo;</span><br><span class="line">    ::<span class="keyword">delete</span> p2;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Foo *pArray2 = ::<span class="keyword">new</span> Foo[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    ::<span class="keyword">delete</span>[] pArray2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>输出结果：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528130010432.png" alt="image-20230528130010432"></p><p><strong>注意：</strong></p><p>我们可以重载class member operator new()，可以写出多个版本，前提是每一个版本都必须声明独特的参数列，并且第一个参数是size_t，其余参数以new指定的placement arguments为初值，出现在new(…)当中的就是所谓的placement arguments.</p><p>这样就可以写出很多的placement new.</p><p>例如：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> * Foo::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size,<span class="type">long</span> extra,<span class="type">char</span> ch)</span></span>;</span><br><span class="line"><span class="comment">//这么用</span></span><br><span class="line">Foo* pf=<span class="built_in">new</span>(<span class="number">300</span>,<span class="string">&#x27;c&#x27;</span>) Foo;</span><br></pre></td></tr></table></div></figure><p>测试代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bad</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>() &#123; cout &lt;&lt; <span class="string">&quot;Foo::Foo()&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Foo::Foo(int)&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Bad</span>(); <span class="comment">// 故意在这里抛出异常，测试调用placement operator delete</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(1) 這個就是一般的 operator new() 的重載</span></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t size), size= &quot;</span> &lt;&lt; size &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2) 這個就是標準庫已經提供的 placement new() 的重載 (形式)</span></span><br><span class="line">    <span class="comment">//    (所以我也模擬 standard placement new 的動作, just return ptr)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span> *start)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t size, void* start), size= &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&quot;  start= &quot;</span> &lt;&lt; start &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3) 這個才是嶄新的 placement new</span></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">long</span> extra)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t size, long extra)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(4) 這又是一個 placement new</span></span><br><span class="line">    <span class="function"><span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">long</span> extra, <span class="type">char</span> init)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator new(size_t size, long extra, char init)  &quot;</span> &lt;&lt; size &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; extra &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; init &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">malloc</span>(size + extra);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(5) 這又是一個 placement new, 但故意寫錯第一參數的 type (它必須是 size_t 以滿足正常的 operator new)</span></span><br><span class="line">    <span class="comment">//!  	void* operator new(long extra, char init) &#123; //[Error] &#x27;operator new&#x27; takes type &#x27;size_t&#x27; (&#x27;unsigned int&#x27;) as first parameter [-fpermissive]</span></span><br><span class="line">    <span class="comment">//!	  	cout &lt;&lt; &quot;op-new(long,char)&quot; &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//!    	return malloc(extra);</span></span><br><span class="line">    <span class="comment">//!  	&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下是搭配上述 placement new 的各個 called placement delete.</span></span><br><span class="line">    <span class="comment">// 當 ctor 發出異常，這兒對應的 operator (placement) delete 就會被喚起.</span></span><br><span class="line">    <span class="comment">// 應該是要負責釋放其搭檔兄弟 (placement new) 分配所得的 memory.</span></span><br><span class="line">    <span class="comment">//(1) 這個就是一般的 operator delete() 的重載</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete(void*,size_t)  &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(2) 這是對應上述的 (2)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *, <span class="type">void</span> *)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete(void*,void*)  &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(3) 這是對應上述的 (3)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *, <span class="type">long</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete(void*,long)  &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//(4) 這是對應上述的 (4)</span></span><br><span class="line">    <span class="comment">// 如果沒有一一對應, 也不會有任何編譯報錯</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *, <span class="type">long</span>, <span class="type">char</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;operator delete(void*,long,char)  &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_overload_placement_new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_overload_placement_new()..........&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Foo start; <span class="comment">// Foo::Foo</span></span><br><span class="line"></span><br><span class="line">    Foo *p1 = <span class="keyword">new</span> Foo;            <span class="comment">// op-new(size_t)</span></span><br><span class="line">    Foo *p2 = <span class="built_in">new</span> (&amp;start) Foo;   <span class="comment">// op-new(size_t,void*)</span></span><br><span class="line">    Foo *p3 = <span class="built_in">new</span> (<span class="number">100</span>) Foo;      <span class="comment">// op-new(size_t,long)</span></span><br><span class="line">    Foo *p4 = <span class="built_in">new</span> (<span class="number">100</span>, <span class="string">&#x27;a&#x27;</span>) Foo; <span class="comment">// op-new(size_t,long,char)</span></span><br><span class="line"></span><br><span class="line">    Foo *p5 = <span class="built_in">new</span> (<span class="number">100</span>) <span class="built_in">Foo</span>(<span class="number">1</span>);      <span class="comment">// op-new(size_t,long)  op-del(void*,long)</span></span><br><span class="line">    <span class="comment">//这里故意调用int版本的构造函数，在构造函数当中会抛出异常</span></span><br><span class="line">    <span class="comment">//为什么会抛出异常呢？因为我们担心这个placement operator new 我们已经分配出来的空间用在构造函数上面不够</span></span><br><span class="line">    <span class="comment">//不够的时候怎么办呢？内存都已经分配出来了，那就只能释放掉，调用相应的placement operator delete</span></span><br><span class="line">    Foo *p6 = <span class="built_in">new</span> (<span class="number">100</span>, <span class="string">&#x27;a&#x27;</span>) <span class="built_in">Foo</span>(<span class="number">1</span>); <span class="comment">//</span></span><br><span class="line">    Foo *p7 = <span class="built_in">new</span> (&amp;start) <span class="built_in">Foo</span>(<span class="number">1</span>);   <span class="comment">//</span></span><br><span class="line">    Foo *p8 = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">1</span>);            <span class="comment">//</span></span><br><span class="line">                                     <span class="comment">// VC6 warning C4291: &#x27;void *__cdecl Foo::operator new(unsigned int)&#x27;</span></span><br><span class="line">                                     <span class="comment">// no matching operator delete found; memory will not be freed if</span></span><br><span class="line">                                     <span class="comment">// initialization throws an exception</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_overload_placement_new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p><strong>注意这里：</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo *p5 = <span class="built_in">new</span> (<span class="number">100</span>) <span class="built_in">Foo</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//这里故意调用int版本的构造函数，在构造函数当中会抛出异常</span></span><br><span class="line"><span class="comment">//为什么会抛出异常呢？因为我们担心这个placement operator new 我们已经分配出来的空间用在构造函数上面不够</span></span><br><span class="line"><span class="comment">//不够的时候怎么办呢？内存都已经分配出来了，那就只能释放掉，调用相应的placement operator delete</span></span><br></pre></td></tr></table></div></figure><p><strong>只有这种情况下，ctor中抛出异常，对应的operator delete才会被调用起来；如果不写，那就是放心这个构造函数并且不去处理这个异常</strong></p><h4 id="basic-string使用new-extra-申请扩充量"><a href="#basic-string使用new-extra-申请扩充量" class="heading-link"><i class="fas fa-link"></i></a><a href="#basic-string使用new-extra-申请扩充量" class="headerlink" title="basic_string使用new(extra)申请扩充量"></a>basic_string使用new(extra)申请扩充量</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528141445828.png" alt="image-20230528141445828"></p><h3 id="per-class-allocator-版本1-重点看"><a href="#per-class-allocator-版本1-重点看" class="heading-link"><i class="fas fa-link"></i></a><a href="#per-class-allocator-版本1-重点看" class="headerlink" title="per-class allocator 版本1 (重点看)"></a>per-class allocator 版本1 (重点看)</h3><p>设计一个小型的内存池，小型的内存分配器，目前是第一版本</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528144912141.png" alt="image-20230528144912141"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Screen</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Screen</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Screen</span>(<span class="type">int</span> x) : _i(x)&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> _i; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Screen *next; <span class="comment">// 这种设计会引发一个疑问，就是多消耗了一个指针的内存空间，但是可以抹除数组元素之间的cookie，只在数组头尾放cookie</span></span><br><span class="line">    <span class="type">static</span> Screen *freeStore;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> screenChunk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> _i;</span><br><span class="line">&#125;;</span><br><span class="line">Screen *Screen::freeStore = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Screen::screenChunk = <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *Screen::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Screen *p;</span><br><span class="line">    <span class="keyword">if</span> (!freeStore)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// linked list 是空的，所以攫取一大塊 memory</span></span><br><span class="line">        <span class="comment">// 以下呼叫的是 global operator new</span></span><br><span class="line">        <span class="type">size_t</span> chunk = screenChunk * size; <span class="comment">// 这是乘法，计算需要的字节数</span></span><br><span class="line">        freeStore = p =</span><br><span class="line">            <span class="built_in">reinterpret_cast</span>&lt;Screen *&gt;(<span class="keyword">new</span> <span class="type">char</span>[chunk]);</span><br><span class="line">        <span class="comment">// 將分配得來的一大塊 memory 當做 linked list 般小塊小塊串接起來</span></span><br><span class="line">        <span class="keyword">for</span> (; p != &amp;freeStore[screenChunk - <span class="number">1</span>]; ++p)</span><br><span class="line">            p-&gt;next = p + <span class="number">1</span>;</span><br><span class="line">        p-&gt;next = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = freeStore;</span><br><span class="line">    freeStore = freeStore-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! void Screen::operator delete(void *p)		//(1)</span></span><br><span class="line"><span class="function"><span class="type">void</span> Screen::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span>)</span> <span class="comment">//(2)二擇一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 將 deleted object 收回插入 free list 前端</span></span><br><span class="line">    (<span class="built_in">static_cast</span>&lt;Screen *&gt;(p))-&gt;next = freeStore;</span><br><span class="line">    freeStore = <span class="built_in">static_cast</span>&lt;Screen *&gt;(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_per_class_allocator_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_per_class_allocator_1().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Screen) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> <span class="type">const</span> N = <span class="number">100</span>;</span><br><span class="line">    Screen *p[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        p[i] = <span class="keyword">new</span> <span class="built_in">Screen</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 輸出前 10 個 pointers, 用以比較其間隔</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">delete</span> p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_global_allocator</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_global_allocator().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Screen) &lt;&lt; endl; <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> <span class="type">const</span> N = <span class="number">100</span>;</span><br><span class="line">    Screen *p[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        p[i] = ::<span class="keyword">new</span> <span class="built_in">Screen</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 輸出前 10 個 pointers, 用以比較其間隔</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        ::<span class="keyword">delete</span> p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test_per_class_allocator_1</span>();</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test_global_allocator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528145254800.png" alt="image-20230528145254800" style="zoom:67%"><p>可以看出，设计之后的内存之间没有了cookie，节省了空间，这就是我们自己的一个小型内存池</p><h4 id="per-class-allocator2-版本2"><a href="#per-class-allocator2-版本2" class="heading-link"><i class="fas fa-link"></i></a><a href="#per-class-allocator2-版本2" class="headerlink" title="per-class allocator2 版本2"></a>per-class allocator2 版本2</h4><p><strong>和前面的思路基本一样：就是要一大块内存，当数组形式要进来分配内存的时候，如果这一大块内存还有空间，就链在后面就行；如果没有了，就要再要一大块空间进行同样的操作就可以了，最后在前后加上cookie就可以了。而这一切的发生都必须依赖于静态变量static headOfFreeList!!!!他在整个程序中只有一份，当然可以标识。</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528150844128.png" alt="image-20230528150844128"></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span> &#123;  <span class="comment">// 支援 customized memory management</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">AirplaneRep</span> &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> miles;</span><br><span class="line">        <span class="type">char</span> type;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        AirplaneRep rep;  <span class="comment">// 此針對 used object</span></span><br><span class="line">        Airplane *next;   <span class="comment">// 此針對 free list</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">getMiles</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.miles; &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> <span class="title">getType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> rep.type; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> m, <span class="type">char</span> t)</span> </span>&#123;</span><br><span class="line">        rep.miles = m;</span><br><span class="line">        rep.type = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *deadObject, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BLOCK_SIZE;</span><br><span class="line">    <span class="type">static</span> Airplane *headOfFreeList;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Airplane *Airplane::headOfFreeList;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Airplane::BLOCK_SIZE = <span class="number">512</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> *Airplane::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果大小錯誤，轉交給 ::operator new()</span></span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Airplane))</span><br><span class="line">        <span class="keyword">return</span> ::<span class="keyword">operator</span> <span class="built_in">new</span>(size);</span><br><span class="line"></span><br><span class="line">    Airplane *p = headOfFreeList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 p 有效，就把list頭部移往下一個元素</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        headOfFreeList = p-&gt;next;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// free list 已空。配置一塊夠大記憶體，</span></span><br><span class="line">        <span class="comment">// 令足夠容納 BLOCK_SIZE 個 Airplanes</span></span><br><span class="line">        Airplane *newBlock = <span class="built_in">static_cast</span>&lt;Airplane *&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(BLOCK_SIZE * <span class="built_in">sizeof</span>(Airplane)));</span><br><span class="line">        <span class="comment">// 組成一個新的 free list：將小區塊串在一起，但跳過</span></span><br><span class="line">        <span class="comment">// #0 元素，因為要將它傳回給呼叫者。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; BLOCK_SIZE - <span class="number">1</span>; ++i)</span><br><span class="line">            newBlock[i].next = &amp;newBlock[i + <span class="number">1</span>];</span><br><span class="line">        newBlock[BLOCK_SIZE - <span class="number">1</span>].next = <span class="number">0</span>;  <span class="comment">// 以null結束</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 p 設至頭部，將 headOfFreeList 設至</span></span><br><span class="line">        <span class="comment">// 下一個可被運用的小區塊。</span></span><br><span class="line">        p = newBlock;</span><br><span class="line">        headOfFreeList = &amp;newBlock[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// operator delete 接獲一塊記憶體。</span></span><br><span class="line"><span class="comment">// 如果它的大小正確，就把它加到 free list 的前端</span></span><br><span class="line"><span class="function"><span class="type">void</span> Airplane::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *deadObject,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deadObject == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="built_in">sizeof</span>(Airplane)) &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(deadObject)</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Airplane *carcass =</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;Airplane *&gt;(deadObject);</span><br><span class="line"></span><br><span class="line">    carcass-&gt;next = headOfFreeList;</span><br><span class="line">    headOfFreeList = carcass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_per_class_allocator_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_per_class_allocator_2().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Airplane) &lt;&lt; endl;  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> <span class="type">const</span> N = <span class="number">100</span>;</span><br><span class="line">    Airplane *p[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        p[i] = <span class="keyword">new</span> Airplane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隨機測試 object 正常否</span></span><br><span class="line">    p[<span class="number">1</span>]-&gt;<span class="built_in">set</span>(<span class="number">1000</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    p[<span class="number">5</span>]-&gt;<span class="built_in">set</span>(<span class="number">2000</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    p[<span class="number">9</span>]-&gt;<span class="built_in">set</span>(<span class="number">500000</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">1</span>]-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">1</span>]-&gt;<span class="built_in">getMiles</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">5</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">5</span>]-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">5</span>]-&gt;<span class="built_in">getMiles</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">9</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">9</span>]-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">9</span>]-&gt;<span class="built_in">getMiles</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 輸出前 10 個 pointers, 用以比較其間隔</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        <span class="keyword">delete</span> p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_global_allocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_global_allocator().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(Airplane) &lt;&lt; endl;  <span class="comment">// 8</span></span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> <span class="type">const</span> N = <span class="number">100</span>;</span><br><span class="line">    Airplane *p[N];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        p[i] = ::<span class="keyword">new</span> Airplane;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隨機測試 object 正常否</span></span><br><span class="line">    p[<span class="number">1</span>]-&gt;<span class="built_in">set</span>(<span class="number">1000</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    p[<span class="number">5</span>]-&gt;<span class="built_in">set</span>(<span class="number">2000</span>, <span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    p[<span class="number">9</span>]-&gt;<span class="built_in">set</span>(<span class="number">500000</span>, <span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    cout &lt;&lt; p[<span class="number">1</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">1</span>]-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">1</span>]-&gt;<span class="built_in">getMiles</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">5</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">5</span>]-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">5</span>]-&gt;<span class="built_in">getMiles</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p[<span class="number">9</span>] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">9</span>]-&gt;<span class="built_in">getType</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[<span class="number">9</span>]-&gt;<span class="built_in">getMiles</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 輸出前 10 個 pointers, 用以比較其間隔</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        cout &lt;&lt; p[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">        ::<span class="keyword">delete</span> p[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_per_class_allocator_2</span>();</span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">test_global_allocator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528151704324.png" alt="image-20230528151704324" style="zoom:67%"><p><strong>但是这个设计有一个问题，就是你一次性拿了很多的内存，假如剩下的空白内存还很多的话，在释放的时候理应将他们还给内存，但是在上面的operator delete当中并没有将其归还给操作系统，这样不能说好也不能说不好。首先就是归还这个技术操作太难了，其次就是虽然我没有归还，但是我也没有发生内存泄漏啊，这一段内存还是在我的手上，只是被归入了freeList当中而已。</strong></p><h4 id="static-allocator-版本3"><a href="#static-allocator-版本3" class="heading-link"><i class="fas fa-link"></i></a><a href="#static-allocator-版本3" class="headerlink" title="static allocator 版本3"></a>static allocator 版本3</h4><p>上面的内存分配的设计对于某个指定的类是非常有效果的，但是我们不可能对于每一个类都这么干吧，所以我们需要找到一个普遍的设计方法来解决这个问题。</p><p>所以我们把上面的操作(挖一大块内存……)封装成为一个类，这个类就叫做allocator</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528152603160.png" alt="image-20230528152603160"></p><p>static allocator具体可以在类里面就这么用，内存管理复杂的方面就交给这个类去管理了，不用我们对每一个类都特殊处理</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528153147163.png" alt="image-20230528153147163"></p><p><strong>注意一点就是，static变量需要在类外初始化或者定义，如图就是类外的定义。</strong></p><p>那么allocator里面具体干什么呢？回顾一下</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528153255732.png" alt="image-20230528153255732"></p><p>测试代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;complex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;__allocator.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// macro 宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_POOL_ALLOC()                                           \</span></span><br><span class="line"><span class="meta">public:                                                                \</span></span><br><span class="line"><span class="meta">    void *operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; \</span></span><br><span class="line"><span class="meta">    void operator delete(void *p) &#123; myAlloc.deallocate(p, 0); &#125;        \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">protected:                                                             \</span></span><br><span class="line"><span class="meta">    static __allocator myAlloc;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span></span><br><span class="line"><span class="meta">    __allocator class_name::myAlloc;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">DECLARE_POOL_ALLOC</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> L;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">long</span> l) : <span class="built_in">L</span>(l) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in class implementation file</span></span><br><span class="line"><span class="built_in">IMPLEMENT_POOL_ALLOC</span>(Foo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  in class definition file</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goo</span> &#123;</span><br><span class="line">    <span class="built_in">DECLARE_POOL_ALLOC</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    complex&lt;<span class="type">double</span>&gt; c;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Goo</span>(<span class="type">const</span> complex&lt;<span class="type">double</span>&gt; &amp;x) : <span class="built_in">c</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in class implementation file</span></span><br><span class="line"><span class="built_in">IMPLEMENT_POOL_ALLOC</span>(Goo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_static_allocator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_static_allocator().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        Foo *p[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(Foo)= &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Foo) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">23</span>; ++i) &#123;  <span class="comment">// 23,任意數, 隨意看看結果</span></span><br><span class="line">            p[i] = <span class="keyword">new</span> <span class="built_in">Foo</span>(i);</span><br><span class="line">            cout &lt;&lt; p[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;L &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Foo::myAlloc.check();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">23</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">delete</span> p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Foo::myAlloc.check();</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        Goo *p[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;sizeof(Goo)= &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Goo) &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; ++i) &#123;  <span class="comment">// 17,任意數, 隨意看看結果</span></span><br><span class="line">            p[i] = <span class="keyword">new</span> <span class="built_in">Goo</span>(<span class="built_in">complex</span>&lt;<span class="type">double</span>&gt;(i, i));</span><br><span class="line">            cout &lt;&lt; p[i] &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; p[i]-&gt;c &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Goo::myAlloc.check();</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">17</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">delete</span> p[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Goo::myAlloc.check();</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_static_allocator</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528160530816.png" alt="image-20230528160530816" style="zoom:67%"><h4 id="macro-for-static-allocator-版本4-偷懒"><a href="#macro-for-static-allocator-版本4-偷懒" class="heading-link"><i class="fas fa-link"></i></a><a href="#macro-for-static-allocator-版本4-偷懒" class="headerlink" title="macro for static allocator 版本4 (偷懒)"></a>macro for static allocator 版本4 (偷懒)</h4><p>因为上面的static allocator的格式写的非常固定，所以我们可以想办法给他简化一下，偷偷懒</p><p>用C++中的宏来替代，可以得出很多有趣的东西</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528155257804.png" alt="image-20230528155257804"></p><p>改进后的代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// macro 宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_POOL_ALLOC()                                           \</span></span><br><span class="line"><span class="meta">public:                                                                \</span></span><br><span class="line"><span class="meta">    void *operator new(size_t size) &#123; return myAlloc.allocate(size); &#125; \</span></span><br><span class="line"><span class="meta">    void operator delete(void *p) &#123; myAlloc.deallocate(p, 0); &#125;        \</span></span><br><span class="line"><span class="meta">                                                                       \</span></span><br><span class="line"><span class="meta">protected:                                                             \</span></span><br><span class="line"><span class="meta">    static __allocator myAlloc;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IMPLEMENT_POOL_ALLOC(class_name) \</span></span><br><span class="line"><span class="meta">    __allocator class_name::myAlloc;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">DECLARE_POOL_ALLOC</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> L;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">long</span> l) : <span class="built_in">L</span>(l) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in class implementation file</span></span><br><span class="line"><span class="built_in">IMPLEMENT_POOL_ALLOC</span>(Foo)</span><br><span class="line"></span><br><span class="line"><span class="comment">//  in class definition file</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goo</span> &#123;</span><br><span class="line">    <span class="built_in">DECLARE_POOL_ALLOC</span>()</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    complex&lt;<span class="type">double</span>&gt; c;</span><br><span class="line">    string str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Goo</span>(<span class="type">const</span> complex&lt;<span class="type">double</span>&gt; &amp;x) : <span class="built_in">c</span>(x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// in class implementation file</span></span><br><span class="line"><span class="built_in">IMPLEMENT_POOL_ALLOC</span>(Goo)</span><br></pre></td></tr></table></div></figure><h3 id="global-allocator-标准库的那个非常棒的alloc"><a href="#global-allocator-标准库的那个非常棒的alloc" class="heading-link"><i class="fas fa-link"></i></a><a href="#global-allocator-标准库的那个非常棒的alloc" class="headerlink" title="global allocator 标准库的那个非常棒的alloc"></a>global allocator 标准库的那个非常棒的alloc</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528160553832.png" alt="image-20230528160553832"></p><h3 id="new-handler"><a href="#new-handler" class="heading-link"><i class="fas fa-link"></i></a><a href="#new-handler" class="headerlink" title="new handler"></a>new handler</h3><p>当operator new没有能力为我们分配成功我们所申请的memory的时候，会抛出异常 std::bad_alloc，我们应该要采取一些措施来应对这个</p><p>如果想要编译器一定要返回0而不是抛出异常的话可以这么做:</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span>(nothrow) Foo;</span><br></pre></td></tr></table></div></figure><p>当然标准库在抛出异常之前会调用依次可以由用户指定的handler，如何设计如下所示：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230528171600254.png" alt="image-20230528171600254"></p><p>这样就可以在抛出异常之前自定义一些处理操作，例如Abort()或者exit()等等</p><p>设计良好的new handler有两个作用：</p><ul><li>让更多的内存可用</li><li>调用abort()或者exit()</li></ul><p><strong>注意：new handler必须return void，然后没有参数</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// new handler必须return void，然后没有参数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">noMoreMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;out of memory\n&quot;</span>;</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_set_new_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_set_new_handler().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">set_new_handler</span>(noMoreMemory);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000000000</span>];  <span class="comment">// well, so BIG!</span></span><br><span class="line">    <span class="built_in">assert</span>(p);</span><br><span class="line"></span><br><span class="line">    p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000000000</span>];  <span class="comment">//[Warning] integer constant is too large for its type</span></span><br><span class="line">    <span class="built_in">assert</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_set_new_handler</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>在这个程序当中，如果不调用abort()函数，那么程序就会卡在这一行，</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">100000000000000</span>];  <span class="comment">// well, so BIG!</span></span><br></pre></td></tr></table></div></figure><p>会一直输出自定义的错误信息 out of memory</p><h3 id="x3D-default-x3D-delete"><a href="#x3D-default-x3D-delete" class="heading-link"><i class="fas fa-link"></i></a><a href="#x3D-default-x3D-delete" class="headerlink" title="&#x3D;default,&#x3D;delete"></a>&#x3D;default,&#x3D;delete</h3><p>注意：</p><p><strong>&#x3D;default 只能用default只能用在big three中，即default ctor(默认构造),copy&#x2F;move asgn(拷贝&#x2F;移动赋值),copy&#x2F;move ctor(拷贝&#x2F;移动构造),dtor(析构函数)当中，因为其他的函数编译器没有提供默认的版本</strong></p><p>&#x3D;delete 则不限</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">long</span> x = <span class="number">0</span>) : _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这两个东西不能default，因为编译器没有默认的版本，default只能用在big three当中，即default ctor,copy/move asgn,copy/move ctor,dtor当中</span></span><br><span class="line">    <span class="comment">// static void *operator new(size_t size) = default;                 //[Error] cannot be defaulted</span></span><br><span class="line">    <span class="comment">// static void operator delete(void *pdead, size_t size) = default;  //[Error] cannot be defaulted</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span> *pdead, <span class="type">size_t</span> size) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Goo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">long</span> _x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Goo</span>(<span class="type">long</span> x = <span class="number">0</span>) : _x(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *pdead, <span class="type">size_t</span> size)</span> </span>= <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_delete_and_default_for_new</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_delete_and_default_for_new().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    Foo *p1 = <span class="keyword">new</span> <span class="built_in">Foo</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">delete</span> p1;</span><br><span class="line">    <span class="comment">// Foo* pF = new Foo[10];	//[Error] use of deleted function &#x27;static void* Foo::operator new [](size_t)&#x27;</span></span><br><span class="line">    <span class="comment">// delete [] pF;			//[Error] use of deleted function &#x27;static void Foo::operator delete [](void*, size_t)&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Goo* p2 = new Goo(7);	//[Error] use of deleted function &#x27;static void* Goo::operator new(size_t)&#x27;</span></span><br><span class="line">    <span class="comment">// delete p2;				//[Error] use of deleted function &#x27;static void Goo::operator delete(void*, size_t)&#x27;</span></span><br><span class="line">    Goo *pG = <span class="keyword">new</span> Goo[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">delete</span>[] pG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_delete_and_default_for_new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="第二讲：std-allocator"><a href="#第二讲：std-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二讲：std-allocator" class="headerlink" title="第二讲：std::allocator"></a>第二讲：std::allocator</h2><h3 id="malloc"><a href="#malloc" class="heading-link"><i class="fas fa-link"></i></a><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529203344173.png" alt="image-20230529203344173" style="zoom:67%"><p><strong>当我们调用malloc函数的时候，图当中block size的部分是真实的存放我们的数据的地方，除此之外还会有其他的东西，在上下会有两包东西分别叫debug header和debug tail(这个是什么现在不去管)，在整个部分的上下会有固定两个大小的cookie，记录这一段区块的大小(只有区块大小相同才可以去除cookie)，也就是类似于前面per-class allocator的设计，VC6是上下各四个字节共八个字节；然后他要求这个内存块必须要满足字节数是16的倍数(不同的设计可能不同)，需要有一个pad块来进行调整，整个就是malloc分配给我们的内存</strong></p><h3 id="不同版本allocator的实现"><a href="#不同版本allocator的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#不同版本allocator的实现" class="headerlink" title="不同版本allocator的实现"></a>不同版本allocator的实现</h3><p>不同的编译器对于分配器allocator的实现都是不一样的，下面将举几个版本的例子：</p><h4 id="VC6"><a href="#VC6" class="heading-link"><i class="fas fa-link"></i></a><a href="#VC6" class="headerlink" title="VC6"></a>VC6</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529204213232.png" alt="image-20230529204213232"></p><p>VC6的版本里面没有做特殊设计，就是调用operator new&#x2F;delete，进而调用malloc，free，没有对内存进行特殊管理</p><h4 id="BC5"><a href="#BC5" class="heading-link"><i class="fas fa-link"></i></a><a href="#BC5" class="headerlink" title="BC5"></a>BC5</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529205010426.png" alt="image-20230529205010426"></p><p>同样BC5的版本也没有做特殊设计</p><h4 id="Gc2-9"><a href="#Gc2-9" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gc2-9" class="headerlink" title="Gc2.9"></a>Gc2.9</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529210322971.png" alt="image-20230529210322971"></p><p>Gc2.9的分配器allocator也没有做特殊设计</p><p>但是Gc2.9的容器使用的分配器却不是这个allocator，而是一个设计的非常好的alloc</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529210616933.png" alt="image-20230529210616933"></p><p>下面将会介绍</p><h4 id="pool-alloc-Gc4-9-非常棒的版本"><a href="#pool-alloc-Gc4-9-非常棒的版本" class="heading-link"><i class="fas fa-link"></i></a><a href="#pool-alloc-Gc4-9-非常棒的版本" class="headerlink" title="pool alloc(Gc4.9) 非常棒的版本"></a>pool alloc(Gc4.9) 非常棒的版本</h4><p>以下是Gc2.9和Gc4.9对这个的实现</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211045422.png" alt="image-20230529211045422"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211059007.png" alt="image-20230529211059007"></p><p>Gc4.9有很多扩充的alloctors，其中 __gnu_cxx::__pool_alloc&lt;&gt; 就是这个非常好的分配器</p><p>调用这个非常好的分配器的时候还要引入头文件</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pool_allocator.h&gt;</span></span></span><br></pre></td></tr></table></div></figure><p><strong>注意：Gc4.9当中标准库使用的分配器并不是这个很好的alloc,而是上面提到的allocator!!!</strong></p><h4 id="Gc4-9标准分配器allocator-不是alloc-的实现"><a href="#Gc4-9标准分配器allocator-不是alloc-的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gc4-9标准分配器allocator-不是alloc-的实现" class="headerlink" title="Gc4.9标准分配器allocator(不是alloc)的实现"></a>Gc4.9标准分配器allocator(不是alloc)的实现</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211708274.png" alt="image-20230529211708274"></p><p>这个分配器就是一般的调用malloc和free，不做特殊设计</p><p><strong>那么使用alloc不适用allocator的好处是什么呢？</strong></p><p><strong>答案是去除了cookie，比如放入一百万个元素，使用cookie就节省了八百万个字节的空间，这样减少了内存开销</strong></p><h3 id="Gc2-9-std-alloc-很好的分配器-的实现"><a href="#Gc2-9-std-alloc-很好的分配器-的实现" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gc2-9-std-alloc-很好的分配器-的实现" class="headerlink" title="Gc2.9 std::alloc(很好的分配器)的实现"></a>Gc2.9 std::alloc(很好的分配器)的实现</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530104526960.png" alt="image-20230530104526960"></p><p><strong>这个东西的基本原理和我们设计的per-class allocator是一样的，但是现在他设计了16条free_list,分别管理不同大小的内存，大小从小到大，8个字节，16个字节等等等；如果用户需要的大小不是8的倍数会被调整到8的倍数，然后进入对应的链表中；在该链表中一次性去取一大块的内存，在图中的设计中是20为标准量，比如可以取20*32字节的内存，这样相邻的之间就没有cookie，新的需求进来之后如果还有空间就移动指针存储就好了，没有就继续挖一大块，这样就形成了去除cookie，也是一个非常好的内存池的设计；现在如果需要的内存大小超过这个链表可以维护的最大大小，这个分配器就不用这么精妙的设计去做了，因为数据块的大小比cookie大多了，浪费是可以接受的，这个时候就调用一般的malloc就可以了</strong></p><p>关于挖内存，这个设计还有一些细节：</p><p><strong>当挖内存的时候，比如就32字节的那块，如果设计者设计的是20*32，但是实际上挖出来的是2个20块，每一块32个字节；其中前20块就给32字节的区块去用，后20块作为备用区块(战备池)，暂时不处理，可以给负责其他大小的区块取用以此节省空间。比如这时候要64个字节，按理来说应该7号链表去挖，但是他观察到3号链表的后备区块有空间，他的指针就指向这一块，所以图中这两块是连续的，也就是说这个后备区块可以存放10个64字节的空间</strong></p><p>所以每次要的时候都是要两倍的空间，留相同大小(这里是20个)的空间作为战备池(memory pool)</p><h4 id="embedded-pointers-内嵌入式指针"><a href="#embedded-pointers-内嵌入式指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#embedded-pointers-内嵌入式指针" class="headerlink" title="embedded pointers 内嵌入式指针"></a>embedded pointers 内嵌入式指针</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530112053633.png" alt="image-20230530112053633"></p><p>关于free_list的指针：</p><p>这个设计非常巧妙，由于分配的次序和归还的次序在实际操作的过程中可能并不是完全符合逆向，所以对于free_list他们的内存可能不是完全连续的，这很正常</p><p>但是呢，free_list之间是用指针传递的，本身是一个链表，也就不存在连续不连续的问题了</p><p><strong>因此，free_list指向的每一个区块都是提前挖出来的内存块，为了存放下一个free块的指针，这里借用了这一个区块的前4个字节(64位电脑是8个字节)作为指针，指向下一块free内存，当这一块内存被分配给用户的时候，数据值会覆盖掉这个指针，但是没有关系，这个时候我的free_list已经通过这个指针指向下一块free内存了，这一块内存也就不属于free_list的范畴了，属于用户持有的内存了</strong></p><p>那么为什么要这么设计呢？如果额外拿出4或者8个字节来分配给指针，一个cookie上下加起来才8个字节，那不是相当于消除了原来的cookie增添了新的指针负担吗？所以需要使用embedded pointers</p><p>那么这里考虑到一个问题，就是如果客户需要的空间本来就小于4或者8个即一个指针的大小，那这个时候指针是不是就不能借用了呢？这是正确的，但是对于工业级别的绝大多数情况，客户需要的大小肯定都是大于一根指针的大小的，所以不太需要担心这个问题</p><h3 id="Gc2-9-std-alloc-运行一瞥-一个非常好的设计-1-13"><a href="#Gc2-9-std-alloc-运行一瞥-一个非常好的设计-1-13" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gc2-9-std-alloc-运行一瞥-一个非常好的设计-1-13" class="headerlink" title="Gc2.9 std::alloc 运行一瞥(一个非常好的设计) 1-13"></a>Gc2.9 std::alloc 运行一瞥(一个非常好的设计) 1-13</h3><p>01</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530124448776.png" alt="image-20230530124448776"></p><p>02</p><p><strong>注意：这些链表都是指向的是free_list，而不是用户分配到的内存块</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530124835651.png" alt="image-20230530124835651"></p><p>在申请内存的时候，比如申请32字节，free_list上没有，首先去找战备池有没有合适的，没有的话就在#3(对应32字节)下面申请 32 * 20 * 2 + RoundUp(0&gt;&gt;4) &#x3D; 1280的空间</p><p>注意：</p><p>1.<strong>在实作的时候，总是优先先把分配好的内存放到战备池当中，然后再分配出去内存，比如给一块给用户，剩余19块挂在free_list[3]上面</strong>，不这么实现其实问题也不大，但是标准库这么实现了代码会漂亮很多</p><p>2.<strong>RoundUp(0&gt;&gt;4)是一个函数，表示一个追加量</strong>，是实现这个的这个公司设计的，具体原因不清楚，表示把一个数字调整到一定的边界，后面再说，一开始(目前)是0</p><p>然后对于cookie，在我们这样的设计之后，这一整块是用malloc拿到的，所以这一整块上下会有两个cookie</p><p>03</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530130901615.png" alt="image-20230530130901615"></p><p>接上，现在我申请64字节，free_list上没有，肯定是优先查看战备池的空间，这里够用，<strong>所以把战备池当中的一块分给用户，剩余9块挂在free_list[7]上面，注意的是这两块空间在内存上是连续的!这时战备池用光了</strong></p><p><strong>规定：在后面在战备池上面取出空间去划分的时候，一次性划分的个数不能超过20个!!!!</strong></p><p>04</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530132204861.png" alt="image-20230530132204861"></p><p>现在继续申请96字节，free_list上没有，战备池为空，需要重新申请内存，申请96 * 20 * 2 + RoundUp(1280&gt;&gt;4) 的内存大小，其中一块给用户，19块放到free_list[11]上，剩余的2000就是战备池</p><p>注意：关于追加量的计算</p><p><strong>RoundUp(x&gt;&gt;4)：用目前的累计申请量(例如现在没申请前是1280)右移4位，即除以16，然后调到8的边界</strong></p><p>可以看出这个追加量会越来越大，随着内存的开辟</p><p>05</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530133728815.png" alt="image-20230530133728815"></p><p>现在申请88字节，即#10，free_list上没有，先看战备池，最多可以划出20块，20 * 88 &lt; 2000 ，则划分20块出去，战备池剩余2000 - 88 * 20 &#x3D; 240个字节的大小</p><p>划分出去的空间一块给用户，剩余19块传到free_list[10]上面去</p><p>06</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530134659332.png" alt="image-20230530134659332"></p><p>连续申请三次88字节，由于free_list[10]上有空间，直接分配给用户即可，将free_list[10]指针后移</p><p>07</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530135356839.png" alt="image-20230530135356839"></p><p>接着申请8字节，free_list上没有，先看战备池，由于8 * 20 &lt; 240 ，分配出去，战备池空间还剩80，划分出一块给用户，剩余的挂在free_list[0]上面，战备池剩余80</p><p>08</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530135902882.png" alt="image-20230530135902882"></p><p><strong>碎片处理：</strong></p><p>这时候申请104字节大小，free_list上没有，上一次的战备池剩余80，连一个都没有办法满足；<strong>这个时候会把这个80挂载到#9号的free_list[9]上面，这个时候战备池就为空了，然后重新用malloc申请内存</strong>，各项参数如上所示</p><p>09</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530192809660.png" alt="image-20230530192809660"></p><p>申请112个字节，free_list上没有，先找战备池，由于112 * 20 &#x3D; 2240 &lt; 2408，所以分配出去，现在战备池剩余168</p><p>10</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530193556966.png" alt="image-20230530193556966"></p><p>申请48个字节，free_list上没有，找战备池，168 &#x2F; 48 &#x3D; 3，分配3个出去，一个给用户，剩下两个挂在free_list[5]上，战备池剩余24</p><p>11</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530194432937.png" alt="image-20230530194432937"></p><p><strong>现在申请72，free_list上没有，先找战备池，24满足不了，那么会申请内存，但是现在为了观察系统边界，手动将系统堆的大小设置小，现在如果在索取内存就超出边界了，显然不行，所以满足不了这次申请，那么就找距离72最近的free_list，在这里就是80，即9号，上面有一个空白的区块，好，把他切成72 + 8 的形式，72分配给用户，8就是战备池，这个时候 #8 和 #9 都没有free_list，他们的链表都是空的!!!!</strong></p><p>12</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200004843.png" alt="image-20230530200004843"></p><p>再申请72，没有free_list,，战备池不够，同时好的又malloc失败了，这个时候只有去找 #10 的空白区块了，<strong>先处理原来的战备池，将其挂到#0号free_list的首部，即如图所示，</strong>然后把 #10 号的第一个空白区块分成72和16，72给用户，16作为战备池</p><p>13 山穷水尽</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200614422.png" alt="image-20230530200614422"></p><p>申请120，#14 没有free_list，战备池空间不够，malloc好的不出意外又失败了，这个时候就去找#15，哦豁没有，找不到，那么就g啦！！！战备池归0</p><p>针对目前的这个现状，可以做一些思考：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200925564.png" alt="image-20230530200925564"></p><ul><li>图中还有很多空白的区块未分配给用户，那么可不可以把白色的小区块合并成为大区块给用户呢？(难度太高了)</li><li>system heap还剩余 10000 - 9688 &#x3D; 312，可不可以把剩下的312继续用光呢？</li></ul><h3 id="Gc2-9-std-alloc的源码剖析"><a href="#Gc2-9-std-alloc的源码剖析" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gc2-9-std-alloc的源码剖析" class="headerlink" title="Gc2.9  std::alloc的源码剖析"></a>Gc2.9 std::alloc的源码剖析</h3><p><strong>第二级分配器：第二级分配器就是上面提到的alloc，当这个分配器分配不出内存的时候，实际上不会立即山穷水尽，会调用第一级分配器调用new_handler来对分配不出内存进行处理</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530215144034.png" alt="image-20230530215144034"></p><p>模板参数 bool threads和int inst，在我们目前所研究的范围当中都没有派上用场</p><p>Round_Up()：计算追加量</p><p>embedded pointers：嵌入式指针</p><p><strong>在这个类里面最先定义这个指针成员，也就达到了我们需要的借用头部作为指针，后面容器进来之后覆盖并且移动指针到下一个位置就可以了</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">obj</span>&#123;</span><br><span class="line">	<span class="keyword">union</span> <span class="title class_">obj</span>* free_list_link;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>free_list[]：静态，全局只有一份，代表那16个链表</p><p>FREELIST_INDEX()：计算数组下标，计算出由第几号链表提供服务</p><p>战备池相关</p><ul><li>start_free：指向pool首部</li><li>end_free：指向pool尾部</li></ul><p>head_size：统计累计分配量</p><p>还有两个函数目前尚不清楚怎么实现：</p><p><strong>refill()：从内存池中申请空间并构建free list，然后从free list中分配空间给用户</strong></p><p><strong>chunk_alloc()：从内存池中分配空间</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230530220728994.png" alt="image-20230530220728994"></p><p>然后就是最重要的allocate()和deallocate()函数</p><p>allocate函数中：<strong>如果需要的空间太大超过范围就调用第一级分配器；然后去查询free_list当中是否可以分配，如果可以分配那么就分配就好了；如果没有就调用refill()函数，从内存池中申请空间并且构建free_list，然后分配一块给用户，至于是战备池还是战备池不够处理碎片然后malloc申请，或者是malloc失败去找后面的空白区块，这就是refill的事情了，现在尚不清楚</strong></p><p>deallocate函数中：<strong>如果空间太大，调用第一级，与allocate配套；否则把free_list[]指针前移</strong></p><p><strong>那么问题来了，为什么这里不调用free()释放还给操作系统呢？</strong></p><p><strong>前面知道，由于各种原因，free_list[]的指向并不一定是连续的，但是他们之间是用链表实现的，给我们的感官是这样的；不连续的话贸然去free()就可能会出问题，所以他不还给操作系统</strong>（个人感觉这里不是很合理）</p><p><strong>另一个问题就是没有对这个p指针进行检查，如果他不是这个分配器给出来的指针，他指向空间的大小可能就不是8的倍数，这样如果执行这段代码可能就会造成不可逆转的结果了</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531095651457.png" alt="image-20230531095651457"></p><p>refill()函数：</p><p>这个函数的作用就是在free_list没有空间的时候，内部调用chunk_alloc()申请内存池并且分配给用户和free_list，然后把申请到的free_list给串起来</p><p>然后拿一大块内存的事情就交给chunk_alloc()函数去实现</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531095545741.png" alt="image-20230531095545741"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531105901120.png" alt="image-20230531105901120"></p><p>chunk_alloc()函数：</p><p>这里就是去要一大块内存，先去看战备池，他这里是先看能不能满足最大的需求，就是规定的战备池最多提供20块，不能的话看能切出几块，然后修改指针；</p><p><strong>如果无法满足那么就代表战备池无法满足，那么就把这个碎片进行处理(给他放到对应的free_list的首部)，然后准备计算接下来需要malloc拿到的空间，然后尝试去拿取；malloc拿到的空间前面提到是2 * 20 * 32 比如，先全部放到战备池当中，然后切出一半来给用户和free_list分配；失败了说明系统heap空间不够了，那么就尝试去这个大小的链表后面去找可用的空间，将其一块分为用户和战备池，如果这还找不到就山穷水尽，g!</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531110714412.png" alt="image-20230531110714412"></p><p>然后就剩下一些类外的初始化和typedef的操作了</p><p>整合了一下代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一级分配器</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STD_ALLOC_1ST_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STD_ALLOC_1ST_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __THROW_BAD_ALLOC            \</span></span><br><span class="line"><span class="meta">    cerr &lt;&lt; <span class="string">&quot;out of memory&quot;</span> &lt;&lt; endl; \</span></span><br><span class="line"><span class="meta">    exit(1)</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// 第1級配置器。</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__malloc_alloc_template</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="type">void</span> *, <span class="type">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*__malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">malloc</span>(n);  <span class="comment">// 直接使用 malloc()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == result)</span><br><span class="line">            result = <span class="built_in">oom_malloc</span>(n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* n */</span>)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);  <span class="comment">// 直接使用 free()</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> <span class="comment">/* old_sz */</span>, <span class="type">size_t</span> new_sz)</span> </span>&#123;</span><br><span class="line">        <span class="type">void</span> *result = <span class="built_in">realloc</span>(p, new_sz);  <span class="comment">// 直接使用 realloc()</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == result)</span><br><span class="line">            result = <span class="built_in">oom_realloc</span>(p, new_sz);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="title">void</span> <span class="params">(*set_malloc_handler(<span class="type">void</span> (*f)()))</span><span class="params">()</span> </span>&#123;  <span class="comment">// 類似 C++ 的 set_new_handler().</span></span><br><span class="line">        <span class="built_in">void</span> (*old)() = __malloc_alloc_oom_handler;</span><br><span class="line">        __malloc_alloc_oom_handler = f;</span><br><span class="line">        <span class="keyword">return</span> (old);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="built_in">void</span> (*__malloc_alloc_template&lt;inst&gt;::__malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_malloc</span>(<span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="built_in">void</span> (*my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 不斷嘗試釋放、配置、再釋放、再配置…</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)();  <span class="comment">// 呼叫處理常式，企圖釋放記憶體</span></span><br><span class="line">        result = <span class="built_in">malloc</span>(n);      <span class="comment">// 再次嘗試配置記憶體</span></span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> (result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__malloc_alloc_template&lt;inst&gt;::<span class="built_in">oom_realloc</span>(<span class="type">void</span> *p, <span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="built_in">void</span> (*my_malloc_handler)();</span><br><span class="line">    <span class="type">void</span> *result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 不斷嘗試釋放、配置、再釋放、再配置…</span></span><br><span class="line">        my_malloc_handler = __malloc_alloc_oom_handler;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == my_malloc_handler) &#123;</span><br><span class="line">            __THROW_BAD_ALLOC;</span><br><span class="line">        &#125;</span><br><span class="line">        (*my_malloc_handler)();  <span class="comment">// 呼叫處理常式，企圖釋放記憶體。</span></span><br><span class="line">        result = <span class="built_in">realloc</span>(p, n);  <span class="comment">// 再次嘗試配置記憶體。</span></span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> (result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __malloc_alloc_template&lt;<span class="number">0</span>&gt; malloc_alloc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Alloc</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">simple_alloc</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> == n ? <span class="number">0</span> : (T *)Alloc::<span class="built_in">allocate</span>(n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> T *<span class="title">allocate</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T *)Alloc::<span class="built_in">allocate</span>(<span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="type">size_t</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> != n)</span><br><span class="line">            Alloc::<span class="built_in">deallocate</span>(p, n * <span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span> </span>&#123;</span><br><span class="line">        Alloc::<span class="built_in">deallocate</span>(p, <span class="built_in">sizeof</span>(T));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二级分配器</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _STD_ALLOC_2ND_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _STD_ALLOC_2ND_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_alloc_1st.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二級配置器</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    __ALIGN = <span class="number">8</span></span><br><span class="line">&#125;;  <span class="comment">// 小區塊的上調邊界</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    __MAX_BYTES = <span class="number">128</span></span><br><span class="line">&#125;;  <span class="comment">// 小區塊的上限</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    __NFREELISTS = __MAX_BYTES / __ALIGN</span><br><span class="line">&#125;;  <span class="comment">// free-lists 個數</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 本例中兩個 template 參數完全沒有派上用場</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__default_alloc_template</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 實際上應使用 static const int x = N</span></span><br><span class="line">    <span class="comment">// 取代 enum &#123; x = N &#125;, 但目前支援該性質的編譯器不多</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">ROUND_UP</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN - <span class="number">1</span>) &amp; ~(__ALIGN - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">union</span> <span class="title class_">obj</span> &#123;</span><br><span class="line">        <span class="keyword">union</span> <span class="title class_">obj</span> *free_list_link;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> obj *<span class="keyword">volatile</span> free_list[__NFREELISTS];</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">size_t</span> <span class="title">FREELIST_INDEX</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (((bytes) + __ALIGN - <span class="number">1</span>) / __ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns an object of size n, and optionally adds to size n free list.</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">refill</span><span class="params">(<span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocates a chunk for nobjs of size &quot;size&quot;.  nobjs may be reduced</span></span><br><span class="line">    <span class="comment">// if it is inconvenient to allocate the requested number.</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">char</span> *<span class="title">chunk_alloc</span><span class="params">(<span class="type">size_t</span> size, <span class="type">int</span> &amp;nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Chunk allocation state.</span></span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *start_free;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> *end_free;</span><br><span class="line">    <span class="type">static</span> <span class="type">size_t</span> heap_size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">allocate</span><span class="params">(<span class="type">size_t</span> n)</span>  <span class="comment">// n must be &gt; 0</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj *<span class="keyword">volatile</span> *my_free_list;  <span class="comment">// obj** my_free_list;</span></span><br><span class="line">        obj *result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123;</span><br><span class="line">            <span class="keyword">return</span> (malloc_alloc::<span class="built_in">allocate</span>(n));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">        result = *my_free_list;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">void</span> *r = <span class="built_in">refill</span>(<span class="built_in">ROUND_UP</span>(n));</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        *my_free_list = result-&gt;free_list_link;</span><br><span class="line">        <span class="keyword">return</span> (result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> n)</span>  <span class="comment">// p may not be 0</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        obj *q = (obj *)p;</span><br><span class="line">        obj *<span class="keyword">volatile</span> *my_free_list;  <span class="comment">// obj** my_free_list;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n &gt; (<span class="type">size_t</span>)__MAX_BYTES) &#123;</span><br><span class="line">            malloc_alloc::<span class="built_in">deallocate</span>(p, n);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line">        q-&gt;free_list_link = *my_free_list;</span><br><span class="line">        *my_free_list = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> *<span class="title">reallocate</span><span class="params">(<span class="type">void</span> *p, <span class="type">size_t</span> old_sz, <span class="type">size_t</span> new_sz)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// We allocate memory in large chunks in order to</span></span><br><span class="line"><span class="comment">// avoid fragmentingthe malloc heap too much.</span></span><br><span class="line"><span class="comment">// We assume that size is properly aligned.</span></span><br><span class="line"><span class="comment">// We hold the allocation lock.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span> *</span><br><span class="line">__default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line">    <span class="built_in">chunk_alloc</span>(<span class="type">size_t</span> size, <span class="type">int</span> &amp;nobjs) &#123;</span><br><span class="line">    <span class="type">char</span> *result;</span><br><span class="line">    <span class="type">size_t</span> total_bytes = size * nobjs;</span><br><span class="line">    <span class="type">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (result);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= size) &#123;</span><br><span class="line">        nobjs = bytes_left / size;</span><br><span class="line">        total_bytes = size * nobjs;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> (result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> bytes_to_get =</span><br><span class="line">            <span class="number">2</span> * total_bytes + <span class="built_in">ROUND_UP</span>(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// Try to make use of the left-over piece.</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            obj *<span class="keyword">volatile</span> *my_free_list =</span><br><span class="line">                free_list + <span class="built_in">FREELIST_INDEX</span>(bytes_left);</span><br><span class="line"></span><br><span class="line">            ((obj *)start_free)-&gt;free_list_link = *my_free_list;</span><br><span class="line">            *my_free_list = (obj *)start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        start_free = (<span class="type">char</span> *)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == start_free) &#123;</span><br><span class="line">            <span class="type">int</span> i;</span><br><span class="line">            obj *<span class="keyword">volatile</span> *my_free_list, *p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Try to make do with what we have. That can&#x27;t</span></span><br><span class="line">            <span class="comment">// hurt. We do not try smaller requests, since that tends</span></span><br><span class="line">            <span class="comment">// to result in disaster on multi-process machines.</span></span><br><span class="line">            <span class="keyword">for</span> (i = size; i &lt;= __MAX_BYTES; i += __ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(i);</span><br><span class="line">                p = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">0</span> != p) &#123;</span><br><span class="line">                    *my_free_list = p-&gt;free_list_link;</span><br><span class="line">                    start_free = (<span class="type">char</span> *)p;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">                    <span class="comment">// Any leftover piece will eventually make it to the</span></span><br><span class="line">                    <span class="comment">// right free list.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            end_free = <span class="number">0</span>;  <span class="comment">// In case of exception.</span></span><br><span class="line">            start_free = (<span class="type">char</span> *)malloc_alloc::<span class="built_in">allocate</span>(bytes_to_get);</span><br><span class="line">            <span class="comment">// This should either throw an exception or</span></span><br><span class="line">            <span class="comment">// remedy the situation. Thus we assume it</span></span><br><span class="line">            <span class="comment">// succeeded.</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + bytes_to_get;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">chunk_alloc</span>(size, nobjs));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// Returns an object of size n, and optionally adds</span></span><br><span class="line"><span class="comment">// to size n free list.We assume that n is properly aligned.</span></span><br><span class="line"><span class="comment">// We hold the allocation lock.</span></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">void</span> *__default_alloc_template&lt;threads, inst&gt;::</span><br><span class="line">    <span class="built_in">refill</span>(<span class="type">size_t</span> n) &#123;</span><br><span class="line">    <span class="type">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> *chunk = <span class="built_in">chunk_alloc</span>(n, nobjs);</span><br><span class="line">    obj *<span class="keyword">volatile</span> *my_free_list;  <span class="comment">// obj** my_free_list;</span></span><br><span class="line">    obj *result;</span><br><span class="line">    obj *current_obj;</span><br><span class="line">    obj *next_obj;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">1</span> == nobjs)</span><br><span class="line">        <span class="keyword">return</span> (chunk);</span><br><span class="line">    my_free_list = free_list + <span class="built_in">FREELIST_INDEX</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build free list in chunk</span></span><br><span class="line">    result = (obj *)chunk;</span><br><span class="line">    *my_free_list = next_obj = (obj *)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>;; ++i) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj *)((<span class="type">char</span> *)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current_obj-&gt;free_list_link = next_obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::start_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">char</span> *__default_alloc_template&lt;threads, inst&gt;::end_free = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="type">size_t</span> __default_alloc_template&lt;threads, inst&gt;::heap_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> threads, <span class="type">int</span> inst&gt;</span><br><span class="line"><span class="keyword">typename</span> __default_alloc_template&lt;threads, inst&gt;::obj *<span class="keyword">volatile</span> __default_alloc_template&lt;threads, inst&gt;::free_list[__NFREELISTS] = &#123;</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------</span></span><br><span class="line"><span class="comment">// 令第2級配置器的名稱為 alloc</span></span><br><span class="line"><span class="keyword">using</span> alloc = __default_alloc_template&lt;<span class="literal">false</span>, <span class="number">0</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;std_alloc_2nd.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_G29_alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_global_allocator_with_16_freelist().......... \n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *p1 = alloc::<span class="built_in">allocate</span>(<span class="number">120</span>);</span><br><span class="line">    <span class="type">void</span> *p2 = alloc::<span class="built_in">allocate</span>(<span class="number">72</span>);</span><br><span class="line">    <span class="type">void</span> *p3 = alloc::<span class="built_in">allocate</span>(<span class="number">60</span>);  <span class="comment">// 不是 8 倍數</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p1 &lt;&lt; endl</span><br><span class="line">         &lt;&lt; p2 &lt;&lt; endl</span><br><span class="line">         &lt;&lt; p3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    alloc::<span class="built_in">deallocate</span>(p1, <span class="number">120</span>);</span><br><span class="line">    alloc::<span class="built_in">deallocate</span>(p2, <span class="number">72</span>);</span><br><span class="line">    alloc::<span class="built_in">deallocate</span>(p3, <span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以下, 不能搭配容器來測試, 因為新版 G++ 對於 allocator 有更多要求 (詢問更多 typedef 而 alloc 都無法回答)</span></span><br><span class="line">    <span class="comment">// 它其實就是 G4.9 __pool_alloc，所以讓 G4.9容器使用 __pool_alloc 也就等同於這裡所要的測試</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        vector&lt;int, simple_alloc&lt;int,alloc&gt;&gt; v;</span></span><br><span class="line"><span class="comment">        for(int i=0; i&lt; 1000; ++i)</span></span><br><span class="line"><span class="comment">            v.push_back(i);</span></span><br><span class="line"><span class="comment">        for(int i=700; i&lt; 720; ++i)</span></span><br><span class="line"><span class="comment">            cout &lt;&lt; v[i] &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test_G29_alloc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531113514416.png" alt="image-20230531113514416"></p><h3 id="Gc2-9-std-alloc观念大整理"><a href="#Gc2-9-std-alloc观念大整理" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gc2-9-std-alloc观念大整理" class="headerlink" title="Gc2.9 std::alloc观念大整理"></a>Gc2.9 std::alloc观念大整理</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531112717690.png" alt="image-20230531112717690"></p><p>假设这里list&lt;&gt;使用的分配器是std::alloc，list除了本身的Foo之外，还带有list的两根指针，如果sizeof(Foo) + 2 * 指针大小 &lt; 128，那么可以调用alloc分配器；</p><p>第二行list&lt;&gt;容器调用push_back()插入操作，Foo(1)是临时对象，放在栈区，然后调用copy ctor，把他放到alloc创造的空间当中，这一段空间不带有cookie；</p><p>第二个操作把一个由malloc动态开辟出来带有cookie的空间copy到alloc创造的空间当中，同样也不带有cookie</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531133126758.png" alt="image-20230531133126758"></p><p>注意等号判断的写法，这里推荐把右值放在等号左边，为什么呢？</p><p><strong>这样的话，如果我不小心把 &#x3D;&#x3D; 号写成了 &#x3D; 号，那么 0 &#x3D; start_free是没办法通过的，会报错，如果交换顺序则会通过，造成的后果是非常严重的，所以强烈建议判断 &#x3D;&#x3D; 的时候把右值放在等号左边！！</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531134700621.png" alt="image-20230531134700621"></p><p><strong>当没有内存可以分配的时候，分配器会去找已有的内存，也就是上面往后找一块free_list下的内存块划分给用户和战备池，如果这都没有的话就g啦。但是当时我们提到过，可以把剩余的内存(比如9688到10000还有312)，可以把剩余的内存减半再减半，直到可以被分配出来，这样不是可以更好的利用内存吗？想法是肯定的，但是上面说在多进程的机器上会带来大灾难，这里的理解不一了，一种理解是这不是更好的利用内存了嘛？另一种是你把内存尽可能的使用了，其他人怎么办呢？Gc2.9选择了后者，如果想实现前者，也不是不可以，只是难度比较大</strong></p><p>另外一个问题就是他的deallocate()函数不进行内存的归还，这也是受限制于这个设计先天的缺陷吧，链表指来指去，内存不一定连续，这样就没有把握free内存</p><p>测试代码：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/pool_allocator.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Value_Type&gt;</span><br><span class="line"><span class="keyword">using</span> listPool = list&lt;Value_Type, __gnu_cxx::__pool_alloc&lt;Value_Type&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> countNew = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> countDel = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> countArrayNew = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> countArrayDel = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> timesNew = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个函数</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">myAlloc</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFree</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载全局operator new/delete</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;global new(), \t&quot; &lt;&lt; size &lt;&lt; &quot;\t&quot;;</span></span><br><span class="line">    countNew += size;</span><br><span class="line">    ++timesNew;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="keyword">new</span>[](<span class="type">size_t</span> size) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;global new[](), \t&quot; &lt;&lt; size &lt;&lt; &quot;\t&quot;;</span></span><br><span class="line">    countArrayNew += size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* p = <span class="built_in">myAlloc</span>(size);</span><br><span class="line">    cout &lt;&lt; p &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">myAlloc</span>(size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 天啊, 以下(1)(2)可以並存並由(2)抓住流程 (但它對我這兒的測試無用).</span></span><br><span class="line"><span class="comment">// 當只存在 (1) 時, 抓不住流程.</span></span><br><span class="line"><span class="comment">// 在 class members 中二者只能擇一 (任一均可)</span></span><br><span class="line"><span class="comment">//(1)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;global delete(ptr,size), \t&quot; &lt;&lt; ptr &lt;&lt; &quot;\t&quot; &lt;&lt; size &lt;&lt; endl;</span></span><br><span class="line">    countDel += size;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;global delete(ptr), \t&quot; &lt;&lt; ptr &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//(1)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr, <span class="type">size_t</span> size) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;global delete[](ptr,size), \t&quot; &lt;&lt; ptr &lt;&lt; &quot;\t&quot; &lt;&lt; size &lt;&lt; endl;</span></span><br><span class="line">    countArrayDel += size;</span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2)</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="keyword">delete</span>[](<span class="type">void</span>* ptr) &#123;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; &quot;global delete[](ptr), \t&quot; &lt;&lt; ptr &lt;&lt; endl;</span></span><br><span class="line">    <span class="built_in">myFree</span>(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_overload_global_new</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;test_overload_global_new().......... \n&quot;</span></span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//***** 測試時, main() 中的其他測試全都 remark, 獨留本測試 *****</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countNew= &quot;</span> &lt;&lt; ::countNew &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countDel= &quot;</span> &lt;&lt; ::countDel &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::timesNew= &quot;</span> &lt;&lt; ::timesNew &lt;&lt; endl;  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">        string* p = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;My name is Ace&quot;</span>);  <span class="comment">// jjhou global new(), 4 	(註：這是 string size)</span></span><br><span class="line">                                                   <span class="comment">// jjhou global new(), 27	(註：這是 sizeof(Rep)+extra)</span></span><br><span class="line">        <span class="keyword">delete</span> p;                                  <span class="comment">// jjhou global delete(ptr), 0x3e3e48</span></span><br><span class="line">                                                   <span class="comment">// jjhou global delete(ptr), 0x3e3e38</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countNew= &quot;</span> &lt;&lt; ::countNew &lt;&lt; endl;  <span class="comment">// 31 ==&gt; 4+27</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::timesNew= &quot;</span> &lt;&lt; ::timesNew &lt;&lt; endl;  <span class="comment">// 2</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countDel= &quot;</span> &lt;&lt; ::countDel &lt;&lt; endl;  <span class="comment">// 0 &lt;== 本測試顯然我永遠觀察不到我所要觀察的</span></span><br><span class="line">                                                       <span class="comment">//       因為進不去 operator delete(ptr,size) 版</span></span><br><span class="line"></span><br><span class="line">        p = <span class="keyword">new</span> string[<span class="number">3</span>];  <span class="comment">// jjhou global new[](), 16 (註：其中內含 arraySize field: 4 bytes,</span></span><br><span class="line">                            <span class="comment">// 所以 16-4 = 12 ==&gt; 4*3, 也就是 3 個 string 每個佔 4 bytes)</span></span><br><span class="line">        <span class="comment">// jjhou global new(), 13  	//Nil string</span></span><br><span class="line">        <span class="comment">// jjhou global new(), 13	//Nil string</span></span><br><span class="line">        <span class="comment">// jjhou global new(), 13	//Nil string</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] p;  <span class="comment">// jjhou global delete(ptr),   0x3e3e88</span></span><br><span class="line">                     <span class="comment">// jjhou global delete(ptr),   0x3e3e70</span></span><br><span class="line">                     <span class="comment">// jjhou global delete(ptr),   0x3e39c8</span></span><br><span class="line">                     <span class="comment">// jjhou global delete[](ptr), 0x3e3978</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countNew= &quot;</span> &lt;&lt; ::countNew &lt;&lt; endl;            <span class="comment">// 70 ==&gt; 4+27+13+13+13</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::timesNew= &quot;</span> &lt;&lt; ::timesNew &lt;&lt; endl;            <span class="comment">// 5</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countArrayNew= &quot;</span> &lt;&lt; ::countArrayNew &lt;&lt; endl;  <span class="comment">// 16 (這個數值其實對我而言無意義)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 測試: global operator new 也會帶容器帶來影響</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// jjhou global new(), 	40  	0x3e3ea0  (註：10 ints)</span></span><br><span class="line">                              <span class="comment">// 註：vector object 本身不是 dynamic allocated.</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// jjhou global new(), 	80		0x3e3ed0</span></span><br><span class="line">        <span class="comment">// jjhou global delete(ptr), 	0x3e3ea0</span></span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countNew= &quot;</span> &lt;&lt; ::countNew &lt;&lt; endl;  <span class="comment">// 190 ==&gt; 70+40+80</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::timesNew= &quot;</span> &lt;&lt; ::timesNew &lt;&lt; endl;  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line">        list&lt;<span class="type">int</span>&gt; lst;                                 <span class="comment">// 註：list object 本身不是 dynamic allocated.</span></span><br><span class="line">        lst.<span class="built_in">push_back</span>(<span class="number">1</span>);                              <span class="comment">// jjhou global new(), 	12	(註：每個 node是 12 bytes)</span></span><br><span class="line">        lst.<span class="built_in">push_back</span>(<span class="number">1</span>);                              <span class="comment">// jjhou global new(), 	12</span></span><br><span class="line">        lst.<span class="built_in">push_back</span>(<span class="number">1</span>);                              <span class="comment">// jjhou global new(), 	12</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countNew= &quot;</span> &lt;&lt; ::countNew &lt;&lt; endl;  <span class="comment">// 226 ==&gt; 190+12+12+12</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::timesNew= &quot;</span> &lt;&lt; ::timesNew &lt;&lt; endl;  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// jjhou global delete(ptr), 	0x3e3978</span></span><br><span class="line">        <span class="comment">// jjhou global delete(ptr), 	0x3e39c8</span></span><br><span class="line">        <span class="comment">// jjhou global delete(ptr), 	0x3e3e70</span></span><br><span class="line">        <span class="comment">// jjhou global delete(ptr), 	0x3e3ed0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reset countNew</span></span><br><span class="line">        countNew = <span class="number">0</span>;</span><br><span class="line">        timesNew = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// list&lt;double, __gnu_cxx::__pool_alloc&lt;double&gt;&gt; lst;</span></span><br><span class="line">        <span class="comment">// 上一行改用 C++/11 alias template 來寫 :</span></span><br><span class="line">        listPool&lt;<span class="type">double</span>&gt; lst;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">            lst.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countNew= &quot;</span> &lt;&lt; ::countNew &lt;&lt; endl;  <span class="comment">// 16752832 (注意, node 都不帶 cookie)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::timesNew= &quot;</span> &lt;&lt; ::timesNew &lt;&lt; endl;  <span class="comment">// 122</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl</span><br><span class="line">         &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// reset countNew</span></span><br><span class="line">        countNew = <span class="number">0</span>;</span><br><span class="line">        timesNew = <span class="number">0</span>;</span><br><span class="line">        list&lt;<span class="type">double</span>&gt; lst;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; ++i)</span><br><span class="line">            lst.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::countNew= &quot;</span> &lt;&lt; ::countNew &lt;&lt; endl;  <span class="comment">// 16000000 (注意, node 都帶 cookie)</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;::timesNew= &quot;</span> &lt;&lt; ::timesNew &lt;&lt; endl;  <span class="comment">// 1000000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 为了防止刷屏我把operator new/delete里面输出的内容给注释了</span></span><br><span class="line">    <span class="built_in">test_overload_global_new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230531143041896.png" alt="image-20230531143041896" style="zoom:80%"><h2 id="第四讲：loki-allocator"><a href="#第四讲：loki-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四讲：loki-allocator" class="headerlink" title="第四讲：loki::allocator"></a>第四讲：loki::allocator</h2><p>第三讲将malloc和free，太难了，这部分暂时没听.</p><h3 id="Loki-allocator设计"><a href="#Loki-allocator设计" class="heading-link"><i class="fas fa-link"></i></a><a href="#Loki-allocator设计" class="headerlink" title="Loki::allocator设计"></a>Loki::allocator设计</h3><p><strong>Loki分配器和std::alloc分配器的区别，std::alloc分配器的致命伤是他要到一大块内存之后进行设计，然后分配给用户之后，用户发出释放内存的操作的时候，分配器内部的实现是不归还给操作系统的，他很霸道，官方的解释是一是实现很难，二是归还这个操作可能在多任务进程中会影响其他进程的操作，而Loki分配器就解决了这个问题</strong></p><p>如何设计？</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609153221116.png" alt="image-20230609153221116"></p><p>三层结构如上：</p><p>最下层Chunk，存放这一块的指针，这一块的索引和目前还可以供应的区块</p><p>中间层FixedAllocator，存放vector&lt; Chunk &gt;和两根指向Chunk的指针</p><p>最上面的层SmallObjAllocator，<strong>也就是用户面对的层次</strong>，存放vector&lt; FixedAllocator &gt;和两根指向FixedAllocator的指针</p><p><strong>至于为什么要指向某两个，这两个可能还有其他的特殊作用，这个后面再说</strong></p><h3 id="源代码"><a href="#源代码" class="heading-link"><i class="fas fa-link"></i></a><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><h4 id="Chunk类"><a href="#Chunk类" class="heading-link"><i class="fas fa-link"></i></a><a href="#Chunk类" class="headerlink" title="Chunk类"></a>Chunk类</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609155142232.png" alt="image-20230609155142232"></p><p>这些函数都是高层的类调用底层的类的，我们用户在实际操作的时候没有必要直接调用这个</p><p>Init()函数：挖出一大块内存用于操作，单位大小和区块个数都经过了调整</p><p>Reset()函数：对这大块内存进行分配，就是标出Chunk那三块， 其中用流水线的方式表示索引，把最前面一个字节的空间占据l来当作索引，概念类似于embedded pointer(嵌入式指针)，只不过这里是嵌入式索引</p><p><strong>重头戏：allocate()和deallocate()</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609160227418.png" alt="image-20230609160227418"></p><p><strong>allocate()函数：在初始化Init()函数之后调用allocate()函数，这个时候每一个block的大小都是blocksize，firstAvaliableBlock代表了这个时候第一块空白的内存，存放的是索引，就是从0开始按顺序去数，并且优先度最高，它里面存放的区块索引是之前设计好的，就是第二高的优先度，第一块内存分配给用户之后，第二块就上来了，变成了firstAvailableBlock的内容，然后blocksAvailable减减</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230609161327736.png" alt="image-20230609161327736"></p><p><strong>deallocate()函数：给一个指针，当然需要先判断这跟指针位于哪个Chunk结构当中，这就一个一个去查询(查询指针的位置)就好了，找到之后把这一块内存free掉，做allocate()函数的逆操作，把目前状态的firstAvailable的区块索引填入该区块，然后该区块索引取代他成为firstAvailableBlock，然后blocksAvailable加加，这就保证了操作的严谨和自洽</strong></p><h4 id="FixedAllocator类"><a href="#FixedAllocator类" class="heading-link"><i class="fas fa-link"></i></a><a href="#FixedAllocator类" class="headerlink" title="FixedAllocator类"></a>FixedAllocator类</h4><p>FixedAllocator类的结构：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711103421403.png" alt="image-20230711103421403"></p><p>除了存放vector&lt; Chunk &gt;之外，还有两根指针，<strong>用来标识最近一次alloc的Chunk和dealloc的Chunk，这么做的含义是，可以从这个最近的区块当中看是否可以继续分配或者回收来提高效率</strong></p><p>Allocate代码：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711103208976.png" alt="image-20230711103208976"></p><p><strong>如果标识allocChunk为0(例如最开始的时候没有分配内存)或者allocChunk指向的blockAvailable为0代表没有课余空间，那么表明allocChunk不可用，需要从头重新开始查找</strong></p><p><strong>在查找过程中如果发现可用的，记下地址然后去分配，如果没有可用的(都用光了)，这时候加一个新的chunk进去用于新的分配!!!</strong></p><p><strong>注意加了新的chunk之后记得更改allocChunk和deallocChunk的值，allocChunk就设置为改Chunk就可以，因为这是新生成的，可以进行分配；deallocChunk设置为头部</strong></p><p><strong>但是为什么要重设呢？因为vector在push_back操作中可能出现2倍扩张导致move的问题，这个时候原来的指针就失效了，显然需要重新设置!!!</strong></p><p>deallocate代码：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711110249938.png" alt="image-20230711110249938"></p><p>拿到一个需要释放的指针，先找到需要释放的Chunk区块，通过VicinityFind()实现，然后通过DoDeallocate()进行释放</p><p>VicinityFind()函数：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711111102518.png" alt="image-20230711111102518"></p><p>他这种写法其实没有特别的数学依据，大致思想就是从上一个deallocChunk开始，将其分为上下两个部分，上面找一个，下面找一个，直到找到对应的区块，然后进行修改</p><p>但是如果给的p不是Chunk分配拿出的指针，那么显然是找不到的，所以会死循环</p><p>DoDeallocate()函数：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711111833403.png" alt="image-20230711111833403"></p><p>这里要注意如果回收之后这一块Chunk变为全空，需要把这一块进行回收嘛？这就不是内存分配的重点了</p><h2 id="第五讲：other-issues"><a href="#第五讲：other-issues" class="heading-link"><i class="fas fa-link"></i></a><a href="#第五讲：other-issues" class="headerlink" title="第五讲：other issues"></a>第五讲：other issues</h2><h3 id="new-allocator"><a href="#new-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#new-allocator" class="headerlink" title="new_allocator"></a>new_allocator</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142511891.png" alt="image-20230711142511891"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142536025.png" alt="image-20230711142536025"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142846401.png" alt="image-20230711142846401"></p><p>这几个版本实现不同，但是其实本质上没有进行额外的设计，就是对c runtime libirary里面malloc和free的调用</p><h3 id="array-allocator"><a href="#array-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#array-allocator" class="headerlink" title="array_allocator"></a>array_allocator</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711143546194.png" alt="image-20230711143546194"></p><p><strong>这个分配器的目的是分出一块静态内存array(C++数组)，然后分配给用户，由于是静态，所以不需要进行回收，因此按道理来说不需要deallocate()。但是分配器都需要提供这些统一的接口，所以他do nothing.</strong></p><p><strong>注意第二个模板参数传入的参数必须是array&lt;&gt;!!!</strong></p><p>例子：</p><p>静态数组充当分配单元</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711144447440.png" alt="image-20230711144447440"></p><p>动态开辟的空间充当分配单元</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711144615462.png" alt="image-20230711144615462"></p><h3 id="debug-allocator"><a href="#debug-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#debug-allocator" class="headerlink" title="debug_allocator"></a>debug_allocator</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711145211456.png" alt="image-20230711145211456"></p><p><strong>用途：包裹其另一个分配器分配的空间，添加一个extra的空间用来记录分配的大小(类似于cookie，因为cookie当中也记录着整块的大小)</strong></p><p><strong>但是感觉没什么用，试想一下我刚好去除了cookie构造了一个不错的内存池，然后用这个debug_allocator又添加了一个类似于cookie的debug header，这不是很鸡肋嘛</strong></p><h3 id="Gc2-9使用的std-alloc-pool-alloc"><a href="#Gc2-9使用的std-alloc-pool-alloc" class="heading-link"><i class="fas fa-link"></i></a><a href="#Gc2-9使用的std-alloc-pool-alloc" class="headerlink" title="Gc2.9使用的std::alloc (__pool_alloc)"></a>Gc2.9使用的std::alloc (__pool_alloc)</h3><p>太熟悉啦！</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711145521073.png" alt="image-20230711145521073"></p><h3 id="bitmap-allocator"><a href="#bitmap-allocator" class="heading-link"><i class="fas fa-link"></i></a><a href="#bitmap-allocator" class="headerlink" title="bitmap_allocator"></a>bitmap_allocator</h3><p><strong>该分配器就allocate()和deallocate()函数做了两种；</strong></p><p><strong>就容器需要的元素种类个数为1和以上做了区分，但是实际上绝大多数情况下容器存放的东西都是一种类型，不同的类型很少</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711150915653.png" alt="image-20230711150915653"></p><p>下面他的设计用图示实现</p><h4 id="allocate过程："><a href="#allocate过程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#allocate过程：" class="headerlink" title="allocate过程："></a>allocate过程：</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711154726911.png" alt="image-20230711154726911"></p><p><strong>还是以内存池的形式，挖出一大块内存然后进行分配。在这里这个团队设计的是一开始挖出64个指定类型的区块，然后填上bitmap，use count和一个头部记录super block size，因此这一整块就叫做super block。</strong></p><p><strong>注意bitmap是怎么确定大小的，bitmap里面存的是16进制数，数组的形式，一个数组值4个字节，也就是可以放图中的4 * 16 &#x3D; 64 个block的状态，1代表已存放，0代表未存放</strong></p><p><strong>整个super block大小的计算如上</strong></p><p><strong>对于整个bitmap_allocator的控制，使用的是自己设计的一个建议__mini_vector，因为标准库的vector底层还有分配器，用他的话就相当于套娃了，这里就是一个简单的版本，里面同样有三根指针，然后同样是2倍扩充，机制是一样的</strong></p><p>当填充进数据：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155355589.png" alt="image-20230711155355589"></p><p>记得修改use count；</p><p><strong>修改bitmap数组的值，这里的顺序是反着来的，已分配设为0，未分配设为1，图中的1110代表 block的前四位 第一位0 分配出去了，所以就是E</strong></p><p>当第一个super_block用尽，启动第二个super_block：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155536393.png" alt="image-20230711155536393"></p><p>block的个数由64加倍，变为128；然后记得修改__mini_vector的值，记得vector是两倍成长的</p><p>继续：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155719096.png" alt="image-20230711155719096"></p><p>当需要启动第三个super_block的时候，这个时候进行2倍扩张，就变成了4个区块</p><p>这个团队规定：如果不全回收，分配规模不断增大；如果全回收了下一次规模减半</p><p><strong>这个vector的value_type并没有限制，因为他的每一个区块都是在自己的value_type之下构成的，我的vector只起了一个管理的作用!!!</strong></p><p><strong>从图中也可以看出我们的vector里面存放的只是两根指针，指向值的第一个block和最后一个block!!!</strong></p><h4 id="deallocate过程："><a href="#deallocate过程：" class="heading-link"><i class="fas fa-link"></i></a><a href="#deallocate过程：" class="headerlink" title="deallocate过程："></a>deallocate过程：</h4><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711161106242.png" alt="image-20230711161106242"></p><p><strong>如果把第一个super block全回收了，那么第一个super block会被放入一个free_list当中(最多64个，多了会被归还给操作系统)用作下一个分配的备用空间，然后在__mini_vector当中，会把第一个元素给删除掉，做类似于erase()的操作，只不过erase()函数需要减少size的，但是这里并没有减少，只是看起来是将元素向前推了，多出的空间就是空白</strong></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711161901208.png" alt="image-20230711161901208"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230711162120179.png" alt="image-20230711162120179"></p><p>整个过程大致就是这样</p><h3 id="谈谈const"><a href="#谈谈const" class="heading-link"><i class="fas fa-link"></i></a><a href="#谈谈const" class="headerlink" title="谈谈const"></a>谈谈const</h3><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/01/30/image-20230712145001503.png" alt="image-20230712145001503"></p><p><strong>当成员函数的const和non-const版本同时存在，const对象只能调用const版本，non-const对象只能调用non-const版本</strong></p><p><strong>因此，const也是区分函数是否相同的标志，同一个函数加上const和不加就相当于是一个重载的版本了</strong></p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fuck</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fuck</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;const version&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fuck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;non-const version&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Fuck f1;</span><br><span class="line">    f<span class="number">1.f</span>uck();<span class="comment">// const version</span></span><br><span class="line"></span><br><span class="line">    Fuck f2;</span><br><span class="line">    f<span class="number">2.f</span>uck();<span class="comment">// non-const version</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">test</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://blog.davidingplus.cn">DavidingPlus</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://blog.davidingplus.cn/posts/2abc6e08.html">https://blog.davidingplus.cn/posts/2abc6e08.html</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-reward reward"><div class="reward-button">大爷，赏个铜板呗~~~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/images/reward/alipay.webp"><div class="reward-qrcode-alipay__text">支付宝</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/images/reward/wechat-pay.webp"><div class="reward-qrcode-wechat__text">微信</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/posts/ff333d31.html"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">牛客 Linux</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/posts/fe75e45c.html"><span class="paginator-prev__text">计算机网络 期末复习</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">面向对象高级开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Header%E5%A4%B4%E6%96%87%E4%BB%B6%E7%9A%84%E9%98%B2%E5%8D%AB%E5%BC%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text">Header头文件的防卫式声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inline-%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">inline 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%9C%A8private%E9%83%A8%E5%88%86"><span class="toc-number">1.3.</span> <span class="toc-text">单例设计模式(构造函数在private部分)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E5%B8%B8%E9%87%8F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.</span> <span class="toc-text">const 常量成员函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8-%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F-%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9"><span class="toc-number">1.5.</span> <span class="toc-text">引用(指针常量 指针指向不可修改)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#friend-%E5%8F%8B%E5%85%83"><span class="toc-number">1.6.</span> <span class="toc-text">friend 友元</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A"><span class="toc-number">1.6.1.</span> <span class="toc-text">重点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#return-by"><span class="toc-number">1.7.</span> <span class="toc-text">return by *</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#return-by-reference"><span class="toc-number">1.7.1.</span> <span class="toc-text">return by reference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#return-by-value"><span class="toc-number">1.7.2.</span> <span class="toc-text">return by value:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class-with-pointer-members-%E5%B8%A6%E6%9C%89%E6%8C%87%E9%92%88%E7%9A%84%E7%B1%BB"><span class="toc-number">1.8.</span> <span class="toc-text">class with pointer members 带有指针的类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC-%E6%A3%80%E6%B5%8B%E8%87%AA%E6%88%91%E8%B5%8B%E5%80%BC"><span class="toc-number">1.8.1.</span> <span class="toc-text">拷贝赋值:检测自我赋值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E6%9C%9F"><span class="toc-number">1.9.</span> <span class="toc-text">一些对象的生命期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new%E5%92%8Cdelete"><span class="toc-number">1.10.</span> <span class="toc-text">new和delete</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-%E5%85%88%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%86%8D%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.1.</span> <span class="toc-text">new: 先分配内存空间，再调用构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete-%E5%85%88%E8%B0%83%E7%94%A8%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%86%8D%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">1.10.2.</span> <span class="toc-text">delete: 先调用析构函数，再释放内存空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-new-%E4%B8%80%E5%AE%9A%E8%A6%81%E6%90%AD%E9%85%8D-array-delete"><span class="toc-number">1.10.3.</span> <span class="toc-text">array new 一定要搭配 array delete!!!</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E9%9D%99%E6%80%81"><span class="toc-number">1.11.</span> <span class="toc-text">static 静态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E8%A1%A5%E5%85%85%EF%BC%9A%E6%8A%8A%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%94%BE%E5%9C%A8-private-%E9%87%8C%E9%9D%A2%EF%BC%8C%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.11.1.</span> <span class="toc-text">进一步补充：把构造函数放在 private 里面，单例设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.12.</span> <span class="toc-text">模板</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.12.1.</span> <span class="toc-text">类模板:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.12.2.</span> <span class="toc-text">函数模板:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-namespace"><span class="toc-number">1.13.</span> <span class="toc-text">命名空间 namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E5%90%88-composition"><span class="toc-number">1.14.</span> <span class="toc-text">复合 composition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E4%B8%8B%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="toc-number">1.14.1.</span> <span class="toc-text">复合下的构造和析构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98-Delefgation-%E2%80%93-Composition-by-reference"><span class="toc-number">1.15.</span> <span class="toc-text">委托 Delefgation – Composition by reference</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Handle-x2F-Body-pimpl"><span class="toc-number">1.15.1.</span> <span class="toc-text">Handle&#x2F;Body (pimpl)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-inheritance"><span class="toc-number">1.16.</span> <span class="toc-text">继承 inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.16.1.</span> <span class="toc-text">虚函数:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0-conversion-function"><span class="toc-number">1.17.</span> <span class="toc-text">转换函数 conversion function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-%E4%BB%BF%E5%87%BD%E6%95%B0-gt-%E8%B0%93%E8%AF%8D"><span class="toc-number">1.18.</span> <span class="toc-text">函数对象(仿函数) -&gt; 谓词</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%A1%A5%E5%85%85-%E6%88%90%E5%91%98%E6%A8%A1%E6%9D%BF-member-template"><span class="toc-number">1.19.</span> <span class="toc-text">模板补充: 成员模板 member template</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">1.20.</span> <span class="toc-text">命名空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-number">1.21.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pointer-like-classes-%E5%85%B3%E4%BA%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.22.</span> <span class="toc-text">pointer-like classes 关于智能指针和迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-%E7%94%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%9D%A5%E6%A8%A1%E6%8B%9F%E4%B8%80%E8%88%AC%E6%8C%87%E9%92%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.22.1.</span> <span class="toc-text">智能指针: 用一个类来模拟一般指针的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-iterator-%E5%85%B6%E6%9C%AC%E8%B4%A8%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">1.22.2.</span> <span class="toc-text">迭代器: iterator 其本质也是一种智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#specialization-%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="toc-number">1.23.</span> <span class="toc-text">specialization 模板特化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#partial-specialization-%E6%A8%A1%E6%9D%BF%E5%81%8F%E7%89%B9%E5%8C%96"><span class="toc-number">1.24.</span> <span class="toc-text">partial specialization 模板偏特化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">C++标准库 体系结构与内存分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9ASTL%E6%A0%87%E5%87%86%E5%BA%93%E5%92%8C%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">第一讲：STL标准库和泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.</span> <span class="toc-text">STL 体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84-for-%E8%AF%AD%E5%8F%A5"><span class="toc-number">2.1.2.</span> <span class="toc-text">基于范围的 for 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%88%86%E7%B1%BB"><span class="toc-number">2.1.3.</span> <span class="toc-text">容器的结构和分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashTable-Separate-Chaining"><span class="toc-number">2.1.4.</span> <span class="toc-text">HashTable Separate Chaining</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sequence-Containers-%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.5.</span> <span class="toc-text">Sequence Containers 序列容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#array-c-11"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">array(c++11)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">vector</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#list"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">list</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-list-c-11"><span class="toc-number">2.1.5.4.</span> <span class="toc-text">forward_list(c++11)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slist"><span class="toc-number">2.1.5.5.</span> <span class="toc-text">slist</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deque"><span class="toc-number">2.1.5.6.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stack"><span class="toc-number">2.1.5.7.</span> <span class="toc-text">stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue"><span class="toc-number">2.1.5.8.</span> <span class="toc-text">queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Associate-Containers-%E5%85%B3%E8%81%94%E5%BC%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">2.1.6.</span> <span class="toc-text">Associate Containers 关联式容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.1.6.1.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multiset-%E5%92%8C-set"><span class="toc-number">2.1.6.2.</span> <span class="toc-text">Multiset 和 set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multimap-%E5%92%8C-map"><span class="toc-number">2.1.6.3.</span> <span class="toc-text">Multimap 和 map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8-%E5%85%B6%E5%AE%9E%E5%8E%9F%E6%9C%AC%E5%90%8D%E5%AD%97%E5%89%8D%E7%BC%80%E6%98%AFhash-%E7%8E%B0%E5%9C%A8%E6%94%B9%E5%90%8D%E5%8F%ABunordered"><span class="toc-number">2.1.6.4.</span> <span class="toc-text">哈希表(其实原本名字前缀是hash,现在改名叫unordered)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-multiset-%E5%92%8C-unorder-set"><span class="toc-number">2.1.6.5.</span> <span class="toc-text">unordered_multiset 和 unorder_set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unordered-multimap-%E5%92%8C-unordered-map"><span class="toc-number">2.1.6.6.</span> <span class="toc-text">unordered_multimap 和 unordered_map</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%88%86%E9%85%8D%E5%99%A8-allocator"><span class="toc-number">2.1.7.</span> <span class="toc-text">使用分配器 allocator</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2%EF%BC%9A%E5%88%86%E9%85%8D%E5%99%A8-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.</span> <span class="toc-text">第二讲：分配器 迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OOP-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B-%E5%92%8CGP-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">OOP(面向对象编程)和GP(泛型编程)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.2.</span> <span class="toc-text">随机访问迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GP-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E4%B8%BE%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">2.2.3.</span> <span class="toc-text">GP 泛型编程举一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BDnew%E8%BF%90%E7%AE%97%E7%AC%A6-operator-new"><span class="toc-number">2.2.4.</span> <span class="toc-text">重载new运算符 operator new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E5%99%A8-allocators"><span class="toc-number">2.2.5.</span> <span class="toc-text">分配器 allocators</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VC6-allocator"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">VC6 allocator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BC-allocator"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">BC++ allocator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCC2-9-allocator"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">GCC2.9 allocator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCC2-9-%E8%87%AA%E5%B7%B1%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%9Aalloc-%E4%B8%8D%E6%98%AFallocator"><span class="toc-number">2.2.5.4.</span> <span class="toc-text">GCC2.9 自己使用的分配器：alloc(不是allocator!!!)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCC4-9-%E4%BD%BF%E7%94%A8%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8%EF%BC%9Aallocator-%E4%B8%8D%E6%98%AFalloc"><span class="toc-number">2.2.5.5.</span> <span class="toc-text">GCC4.9 使用的分配器：allocator(不是alloc!!!)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.6.</span> <span class="toc-text">容器之间的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%ABsize-%E5%92%8Csizeof"><span class="toc-number">2.2.7.</span> <span class="toc-text">区别size()和sizeof()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-list"><span class="toc-number">2.2.8.</span> <span class="toc-text">深入探索 list</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#list%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.8.1.</span> <span class="toc-text">list的迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8E%E7%BD%AE-%E4%B8%8D%E8%83%BD%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8%EF%BC%8C%E6%AF%94%E8%BE%83%E6%9C%89%E8%AF%B4%E6%9C%8D%E5%8A%9B%E7%9A%84%E8%BF%98%E6%9C%89%E5%A6%82%E4%B8%8B%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A"><span class="toc-number">2.2.8.2.</span> <span class="toc-text">关于为什么后置++不能返回引用，比较有说服力的还有如下的原因：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-%E5%92%8C-amp-%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">2.2.8.3.</span> <span class="toc-text">关于 * 和 &amp; 运算符的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#G4-9-%E5%92%8C-G2-9%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.8.4.</span> <span class="toc-text">G4.9 和 G2.9的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">2.2.9.</span> <span class="toc-text">迭代器的设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Traits-%E8%90%83%E5%8F%96%E6%9C%BA"><span class="toc-number">2.2.10.</span> <span class="toc-text">Traits 萃取机</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%AE%B2%EF%BC%9A%E5%AE%B9%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text">第三讲：容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2vector"><span class="toc-number">2.3.1.</span> <span class="toc-text">深入探索vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GCC2-9%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">GCC2.9的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GCC4-9%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">GCC4.9的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E6%8E%A2%E7%B4%A2-deque-%E5%92%8C-queue-stack"><span class="toc-number">2.3.2.</span> <span class="toc-text">深入探索 deque 和 queue , stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deque-1"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">deque</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queue-1"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E6%89%8B%E5%86%99%E4%BA%86%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91-%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E5%87%BD%E6%95%B0%E4%B8%8D%E4%BC%9A"><span class="toc-number">2.3.3.</span> <span class="toc-text">自己手写了一个简单的二叉树(创建二叉树函数不会)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rb-Tree-%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">2.3.4.</span> <span class="toc-text">rb_Tree 红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91-rb-Tree-%E4%B8%8E%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91-AVL-%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">红黑树 rb_Tree 与二叉平衡树 AVL 的对比：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">标准库对红黑树的实现:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84set%E5%92%8Cmap"><span class="toc-number">2.3.5.</span> <span class="toc-text">基于红黑树的set和map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#set-x2F-multiset"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">set&#x2F;multiset</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map-x2F-multimap"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">map&#x2F;multimap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%8B%AC%E7%89%B9%E7%9A%84-operator"><span class="toc-number">2.3.6.</span> <span class="toc-text">map独特的 operator [ ]!!!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">2.3.7.</span> <span class="toc-text">hashtable 散列表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2%EF%BC%9A%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">第四讲：算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="toc-number">2.4.1.</span> <span class="toc-text">算法概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E4%BA%94%E7%A7%8D%E5%88%86%E7%B1%BB%EF%BC%9A%E6%B3%A8%E6%84%8F%E8%BF%99%E4%BA%94%E7%A7%8D%E9%83%BD%E6%98%AF%E7%B1%BB"><span class="toc-number">2.4.2.</span> <span class="toc-text">迭代器的五种分类：注意这五种都是类!!!</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iterator-category%E5%AF%B9%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%88%E7%8E%87%E5%BD%B1%E5%93%8D"><span class="toc-number">2.4.3.</span> <span class="toc-text">iterator_category对算法的效率影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%BA%90%E4%BB%A3%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">2.4.4.</span> <span class="toc-text">算法源代码剖析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#accumulate"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">accumulate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for-each"><span class="toc-number">2.4.4.2.</span> <span class="toc-text">for_each</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replace-replace-if-replace-copy-replace-copy-if"><span class="toc-number">2.4.4.3.</span> <span class="toc-text">replace,replace_if,replace_copy,replace_copy_if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#count-count-if"><span class="toc-number">2.4.4.4.</span> <span class="toc-text">count,count_if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#find-find-if"><span class="toc-number">2.4.4.5.</span> <span class="toc-text">find,find_if</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sort"><span class="toc-number">2.4.4.6.</span> <span class="toc-text">sort</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#binary-search-%E9%80%9A%E8%BF%87%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E5%9C%A8%E4%B8%8D%E5%9C%A8%E5%AE%B9%E5%99%A8%E5%BD%93%E4%B8%AD"><span class="toc-number">2.4.4.7.</span> <span class="toc-text">binary_search(通过二分查找确定元素在不在容器当中)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2%EF%BC%9A%E4%BB%BF%E5%87%BD%E6%95%B0-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">2.5.</span> <span class="toc-text">第五讲：仿函数 适配器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BF%E5%87%BD%E6%95%B0-functors-%E6%B3%A8%E6%84%8F%E8%A6%81%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.1.</span> <span class="toc-text">仿函数 functors(注意要继承)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8-Adapter"><span class="toc-number">2.5.2.</span> <span class="toc-text">适配器 Adapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Astack-queue"><span class="toc-number">2.5.2.1.</span> <span class="toc-text">容器适配器：stack,queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Abinder2nd"><span class="toc-number">2.5.2.2.</span> <span class="toc-text">函数适配器：binder2nd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Anot1"><span class="toc-number">2.5.2.3.</span> <span class="toc-text">函数适配器：not1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%9E%8B%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Abind-since-c-11"><span class="toc-number">2.5.2.4.</span> <span class="toc-text">新型适配器：bind(since c++11)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Arbegin%EF%BC%8Crend"><span class="toc-number">2.5.2.5.</span> <span class="toc-text">迭代器适配器：rbegin，rend</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Ainserter-%E6%B2%A1%E5%BC%84%E6%87%82"><span class="toc-number">2.5.2.6.</span> <span class="toc-text">迭代器适配器：inserter(没弄懂)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E8%AE%B2%EF%BC%9ASTL%E5%91%A8%E5%9B%B4%E7%9A%84%E7%BB%86%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.6.</span> <span class="toc-text">第六讲：STL周围的细碎知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%B8%87%E7%94%A8%E7%9A%84-hash-function"><span class="toc-number">2.6.1.</span> <span class="toc-text">一个万用的 hash function</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-val-%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">hash_val(参数包)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hash%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.6.1.2.</span> <span class="toc-text">Hash函数的三种形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tuple"><span class="toc-number">2.6.2.</span> <span class="toc-text">tuple</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-2-0-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">C++ 2.0 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9A%E8%AF%AD%E8%A8%80"><span class="toc-number">3.1.</span> <span class="toc-text">第一讲：语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#variatic-templates-%E5%8F%82%E6%95%B0%E5%8C%85"><span class="toc-number">3.1.1.</span> <span class="toc-text">variatic templates 参数包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">3.1.2.</span> <span class="toc-text">零碎知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#nullptr"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">nullptr</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">auto</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initializer-list-lt-gt"><span class="toc-number">3.1.3.</span> <span class="toc-text">initializer_list&lt;&gt;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#uniform-initialization-%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">uniform initialization 统一初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#explicit-1"><span class="toc-number">3.1.4.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-delete-x3D-default"><span class="toc-number">3.1.5.</span> <span class="toc-text">&#x3D;delete,&#x3D;default</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#No-Copy-and-Private-Copy"><span class="toc-number">3.1.5.1.</span> <span class="toc-text">No-Copy and Private-Copy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Alias-%E5%8C%96%E5%90%8D-Template-template-typedef-%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%8C%96%E5%90%8D"><span class="toc-number">3.1.6.</span> <span class="toc-text">Alias(化名) Template (template typedef) 模板的化名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#test-moveable%E5%87%BD%E6%95%B0%E6%B5%8B%E8%AF%95"><span class="toc-number">3.1.6.1.</span> <span class="toc-text">test_moveable函数测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#template-template-parameter-%E5%8F%8C%E9%87%8D%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0"><span class="toc-number">3.1.7.</span> <span class="toc-text">template template parameter 双重模板参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#type-alias-%E7%B1%BB%E5%9E%8B%E5%8C%96%E5%90%8D"><span class="toc-number">3.1.8.</span> <span class="toc-text">type alias 类型化名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#noexcept-%E4%BF%9D%E8%AF%81%E4%B8%8D%E4%BC%9A%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">3.1.9.</span> <span class="toc-text">noexcept 保证不会抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#override-%E8%A6%86%E5%86%99-%E7%89%B9%E7%94%A8%E4%BA%8E%E8%99%9A%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E4%B8%8A%E9%9D%A2"><span class="toc-number">3.1.10.</span> <span class="toc-text">override 覆写 特用于虚函数重写上面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">3.1.11.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#decltype"><span class="toc-number">3.1.12.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambdas"><span class="toc-number">3.1.13.</span> <span class="toc-text">lambdas</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#variadic-templates"><span class="toc-number">3.1.14.</span> <span class="toc-text">variadic templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8D%B0tuple-%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E9%9D%9E%E5%B8%B8%E5%B7%A7%E5%A6%99"><span class="toc-number">3.1.15.</span> <span class="toc-text">打印tuple(这个例子非常巧妙)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">3.2.</span> <span class="toc-text">第二讲：标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8-Adapter-%E8%A1%A5%E5%85%85"><span class="toc-number">3.2.2.</span> <span class="toc-text">适配器 Adapter 补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#X%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%9Aostream-iterator"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">X适配器：ostream_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#istream-iterator"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">istream_iterator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#type-traits"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">type traits</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%AE%B2%EF%BC%9Aprimitives"><span class="toc-number">4.1.</span> <span class="toc-text">第一讲：primitives</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.1.1.</span> <span class="toc-text">c++应用程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E5%86%85%E5%AD%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">c++内存的基本工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-expression"><span class="toc-number">4.1.2.</span> <span class="toc-text">new expression</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#delete-expression"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">delete expression</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-new-array-delete"><span class="toc-number">4.1.3.</span> <span class="toc-text">array new,array delete</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E5%B8%83"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">内存分布</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#placement-new"><span class="toc-number">4.1.4.</span> <span class="toc-text">placement new</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">重载示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#basic-string%E4%BD%BF%E7%94%A8new-extra-%E7%94%B3%E8%AF%B7%E6%89%A9%E5%85%85%E9%87%8F"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">basic_string使用new(extra)申请扩充量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#per-class-allocator-%E7%89%88%E6%9C%AC1-%E9%87%8D%E7%82%B9%E7%9C%8B"><span class="toc-number">4.1.5.</span> <span class="toc-text">per-class allocator 版本1 (重点看)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#per-class-allocator2-%E7%89%88%E6%9C%AC2"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">per-class allocator2 版本2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static-allocator-%E7%89%88%E6%9C%AC3"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">static allocator 版本3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#macro-for-static-allocator-%E7%89%88%E6%9C%AC4-%E5%81%B7%E6%87%92"><span class="toc-number">4.1.5.3.</span> <span class="toc-text">macro for static allocator 版本4 (偷懒)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#global-allocator-%E6%A0%87%E5%87%86%E5%BA%93%E7%9A%84%E9%82%A3%E4%B8%AA%E9%9D%9E%E5%B8%B8%E6%A3%92%E7%9A%84alloc"><span class="toc-number">4.1.6.</span> <span class="toc-text">global allocator 标准库的那个非常棒的alloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-handler"><span class="toc-number">4.1.7.</span> <span class="toc-text">new handler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x3D-default-x3D-delete"><span class="toc-number">4.1.8.</span> <span class="toc-text">&#x3D;default,&#x3D;delete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%AE%B2%EF%BC%9Astd-allocator"><span class="toc-number">4.2.</span> <span class="toc-text">第二讲：std::allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc"><span class="toc-number">4.2.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%ACallocator%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.</span> <span class="toc-text">不同版本allocator的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#VC6"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">VC6</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BC5"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">BC5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gc2-9"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">Gc2.9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pool-alloc-Gc4-9-%E9%9D%9E%E5%B8%B8%E6%A3%92%E7%9A%84%E7%89%88%E6%9C%AC"><span class="toc-number">4.2.2.4.</span> <span class="toc-text">pool alloc(Gc4.9) 非常棒的版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Gc4-9%E6%A0%87%E5%87%86%E5%88%86%E9%85%8D%E5%99%A8allocator-%E4%B8%8D%E6%98%AFalloc-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.2.5.</span> <span class="toc-text">Gc4.9标准分配器allocator(不是alloc)的实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gc2-9-std-alloc-%E5%BE%88%E5%A5%BD%E7%9A%84%E5%88%86%E9%85%8D%E5%99%A8-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">Gc2.9 std::alloc(很好的分配器)的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#embedded-pointers-%E5%86%85%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%8C%87%E9%92%88"><span class="toc-number">4.2.3.1.</span> <span class="toc-text">embedded pointers 内嵌入式指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gc2-9-std-alloc-%E8%BF%90%E8%A1%8C%E4%B8%80%E7%9E%A5-%E4%B8%80%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%A5%BD%E7%9A%84%E8%AE%BE%E8%AE%A1-1-13"><span class="toc-number">4.2.4.</span> <span class="toc-text">Gc2.9 std::alloc 运行一瞥(一个非常好的设计) 1-13</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gc2-9-std-alloc%E7%9A%84%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90"><span class="toc-number">4.2.5.</span> <span class="toc-text">Gc2.9 std::alloc的源码剖析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gc2-9-std-alloc%E8%A7%82%E5%BF%B5%E5%A4%A7%E6%95%B4%E7%90%86"><span class="toc-number">4.2.6.</span> <span class="toc-text">Gc2.9 std::alloc观念大整理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E8%AE%B2%EF%BC%9Aloki-allocator"><span class="toc-number">4.3.</span> <span class="toc-text">第四讲：loki::allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Loki-allocator%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.3.1.</span> <span class="toc-text">Loki::allocator设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E4%BB%A3%E7%A0%81"><span class="toc-number">4.3.2.</span> <span class="toc-text">源代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Chunk%E7%B1%BB"><span class="toc-number">4.3.2.1.</span> <span class="toc-text">Chunk类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FixedAllocator%E7%B1%BB"><span class="toc-number">4.3.2.2.</span> <span class="toc-text">FixedAllocator类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E8%AE%B2%EF%BC%9Aother-issues"><span class="toc-number">4.4.</span> <span class="toc-text">第五讲：other issues</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new-allocator"><span class="toc-number">4.4.1.</span> <span class="toc-text">new_allocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#array-allocator"><span class="toc-number">4.4.2.</span> <span class="toc-text">array_allocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#debug-allocator"><span class="toc-number">4.4.3.</span> <span class="toc-text">debug_allocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gc2-9%E4%BD%BF%E7%94%A8%E7%9A%84std-alloc-pool-alloc"><span class="toc-number">4.4.4.</span> <span class="toc-text">Gc2.9使用的std::alloc (__pool_alloc)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitmap-allocator"><span class="toc-number">4.4.5.</span> <span class="toc-text">bitmap_allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#allocate%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.4.5.1.</span> <span class="toc-text">allocate过程：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deallocate%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.4.5.2.</span> <span class="toc-text">deallocate过程：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88const"><span class="toc-number">4.4.6.</span> <span class="toc-text">谈谈const</span></a></li></ol></li></ol></li></ol></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/android-chrome-512x512.webp" alt="avatar"></div><p class="sidebar-ov-author__text">Self-discipline is key in life.</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/DavidingPlus" target="_blank" rel="noopener" data-popover="GitHub" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/qq/" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="/wechat/" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="mailto:davidingplus@qq.com" target="_blank" rel="noopener" data-popover="davidingplus@qq.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">36</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">20</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">您已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023~2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>DavidingPlus</span><span class="footer__devider">|</span><span>蜀 ICP 备 2024088070 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.6</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("09/18/2023 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小破站已经安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒啦！"}setInterval("createtime()",250)</script></div><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;theme&quot;:&quot;default&quot;}" src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/mermaid.min.js"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></div></footer><div class="loading-animation" id="loading-animation"><div class="loading-animation__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-thumbs-up"></i></span></div><div class="back2bottom" id="back2bottom"><span class="back2bottom__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"><div class="search-btns">使用搜索：<span class="search-btns-item search-btns-item--bing"><i></i>必应</span><span class="search-btns-item search-btns-item--baidu"><i></i>百度</span></div></div><div class="search-results"></div></div><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/jquery.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity-ui.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/canvas-nest.js" color="255,255,255" opacity="1" count="99" zindex="-1"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/fancybox.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/masonry.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/lazyload.js"></script><script>function initSearch(){var e=!0,t="search.json";t?/json$/i.test(t)&&(e=!1):t="search.xml";var n="/"+t;$.ajax({url:n,dataType:e?"xml":"json",async:!0,success:function(t){var n=e?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,o=$(".search-input input"),i=$(".search-results"),c=100,r=1,a=function(){var e=o.val().toLowerCase().trim(),t=e.split(/[\s]+/),a=[];t.length>1&&t.push(e),e.length>0&&n.forEach(function(e){var n=!1,o=e.title&&e.title.trim()||"[ 文章无标题 ]",i=o&&o.toLowerCase(),s=e.content&&e.content.replace(/<[^>]+>/g,""),l=s&&s.toLowerCase(),u=e.url&&decodeURI(e.url).replace(/\/{2,}/g,"/"),h=[],d=[];t.forEach(function(e){function t(e,t,n,o){if(!e||!t)return[];var i=0,c=-1,r=[];for(n||(e=e.toLowerCase(),t=t.toLowerCase());-1!==(c=t.indexOf(e,i));){var a=!1;h.forEach(function(t){t.index===c&&t.word.length<e.length&&(t.word=e,a=!0)}),i=c+e.length,!a&&r.push({index:c,word:e,weight:o})}return r}h=h.concat(t(e,i,!1,c)),d=d.concat(t(e,l,!1,r))});var f=h.length,p=d.length;if((f>0||p>0)&&(n=!0),n){function w(e,t,n,o){if(e&&t&&t.length){var i="",c=n,r=o;return t.forEach(function(t){if(!(t.index<c)){var n=t.index+t.word.length;i+=e.slice(c,t.index),i+="<b>"+e.slice(t.index,n)+"</b>",c=n}}),i+=e.slice(c,r)}}[h,d].forEach(function(e){e.sort(function(e,t){return e.index-t.index})});var v,g={},x=h.length*c+d.length*r,y=w(o,h,0,o.length)||o;if(d.length>0){var S=d[0].index;v=w(s,d,S>20?S-20:0,S+180)}else v=s.slice(0,200);g.title=y,g.content=v,g.url=u,g.weight=x,a.push(g)}});var s="";a.length?(a.sort(function(e,t){return t.weight-e.weight}),s+="<ul>",a.forEach(function(e){s+='<li><a class="search-results-title" href="'+e.url+'">',s+=e.title,s+='</a><div class="search-results-content">',s+=e.content,s+="</div></li>"}),s+="</ul>"):s+='<div class="search-results-none"><i class="far fa-meh"></i></div>',i.html(s)};o.on("input",a),o.on("keyup",function(e){e.keyCode===Stun.utils.codeToKeyCode("Enter")&&a()})}})}function closeSearch(){$("body").css({overflow:"auto"}),$(".search-popup").css({display:"none"}),$(".search-mask").css({display:"none"})}function safeOpenUrl(e){var t=window.open();t.opener=null,t.location=e}function extSearch(e){var t=window.location.host,n=$(".search-input input").val().toLowerCase().trim();n?safeOpenUrl({google:"https://www.google.com/search?q=",bing:"https://cn.bing.com/search?q=",baidu:"https://www.baidu.com/s?ie=UTF-8&wd="}[e]+n+" site:"+t):Stun.utils.popAlert("warning","请输入字符")}window.addEventListener("DOMContentLoaded",function(){Stun.utils.pjaxReloadLocalSearch=function(){$(".header-nav-search").on("click",function(e){e.stopPropagation(),$("body").css("overflow","hidden"),$(".search-popup").velocity("stop").velocity("transition.expandIn",{duration:300,complete:function(){$(".search-popup input").focus()}}),$(".search-mask").velocity("stop").velocity("transition.fadeIn",{duration:300}),initSearch()}),$(".search-mask, .search-close").on("click",function(){closeSearch()}),$(document).on("keydown",function(e){e.keyCode===Stun.utils.codeToKeyCode("Escape")&&closeSearch()})},Stun.utils.pjaxReloadLocalSearch()},!1);var assistSearchList=window.CONFIG.assistSearch;Array.isArray(assistSearchList)&&assistSearchList.forEach(function(e){document.querySelector(".search-btns-item--"+e).addEventListener("click",function(){extSearch(e)},!1)})</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/pjax.js"></script><script>window.addEventListener("DOMContentLoaded",function(){new Pjax({selectors:["head title","#main",".pjax-reload",".header-banner"],history:!0,scrollTo:!1,scrollRestoration:!1,cacheBust:!1,debug:!1,currentUrlFullReload:!1,timeout:0});document.addEventListener("pjax:send",function(){$(".header-nav-menu").removeClass("show"),CONFIG.pjax&&CONFIG.pjax.avoidBanner&&$("html").velocity("scroll",{duration:500,offset:$("#header").height(),easing:"easeInOutCubic"}),$(".loading-animation").addClass("loading")},!1),window.addEventListener("pjax:complete",function(){if($(".loading-animation").removeClass("loading"),$("link[rel=prefetch], script[data-pjax-rm]").each(function(){$(this).remove()}),$("script[data-pjax], #pjax-reload script").each(function(){$(this).parent().append($(this).remove())}),Stun.utils.pjaxReloadBoot&&Stun.utils.pjaxReloadBoot(),Stun.utils.pjaxReloadScroll&&Stun.utils.pjaxReloadScroll(),Stun.utils.pjaxReloadSidebar&&Stun.utils.pjaxReloadSidebar(),"undefined"!=typeof mermaid){const e=Array.from(document.querySelectorAll(".mermaid")).filter(e=>!e.dataset.processed);mermaid.init(void 0,e)}},!1)},!1)</script><div id="pjax-reload"><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/quicklink.js"></script><script>function initQuicklink(){quicklink({timeout:"10000",priority:!0,ignores:[i=>i.includes("#"),i=>"https://blog.davidingplus.cn/posts/2abc6e08.html"===i,/\/api\/?/,i=>i.includes(".xml"),i=>i.includes(".zip"),(i,t)=>t.hasAttribute("nofollow"),(i,t)=>t.hasAttribute("noprefetch")]})}initQuicklink()</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/busuanzi.js" async></script></div><script src="/js/utils.js?v=2.8.6"></script><script src="/js/stun-boot.js?v=2.8.6"></script><script src="/js/scroll.js?v=2.8.6"></script><script src="/js/header.js?v=2.8.6"></script><script src="/js/sidebar.js?v=2.8.6"></script><script type="application/json" src="/search.json"></script><script data-pjax="">function loadUtterances(){var t=document,e=t.createElement("script"),s=t.getElementById("utterances-container"),r=Stun.utils.getNightMode()?"photon-dark":"github-light";s&&(e.src="https://utteranc.es/client.js",e.setAttribute("repo","DavidingPlus/blog-comments"),e.setAttribute("issue-term","title"),e.setAttribute("label","utterances"),e.setAttribute("theme",r),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),e.setAttribute("data-pjax-rm",""),s.append(e))}loadUtterances()</script><script async src="/js/cursor/text.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="🤡快回来,粗大事了~~"+OriginTitile,clearTimeout(titleTime)):(document.title="😚欢迎回来!~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:160,height:290},mobile:{show:!0},log:!1})</script></body></html>