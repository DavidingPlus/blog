<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><script>window.MSInputMethodContext&&document.documentMode&&(window.location.href="https://support.dmeng.net/upgrade-your-browser.html")</script><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/favicon-16x16.webp?v=2.8.6" type="image/png" sizes="16x16"><link rel="icon" href="/assets/favicon-32x32.webp?v=2.8.6" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/assets/apple-touch-icon.webp?v=2.8.6" sizes="180x180"><meta name="description" content="Rtems 源码阅读       RTEMS（Real‑Time Executive for Multiprocessor Systems）是一款始于 1988 年、1993 年正式发布的开源实时操作系统，专为多处理器嵌入式环境设计，支持 POSIX 和 BSD 套接字等开放标准 API，并可运行于 ARM、PowerPC、SPARC、MIPS、RISC"><meta property="og:type" content="article"><meta property="og:title" content="Rtems Source Code"><meta property="og:url" content="https://blog.davidingplus.cn/posts/4936fe45.html"><meta property="og:site_name" content="DavidingPlus&#39;s Blog"><meta property="og:description" content="Rtems 源码阅读       RTEMS（Real‑Time Executive for Multiprocessor Systems）是一款始于 1988 年、1993 年正式发布的开源实时操作系统，专为多处理器嵌入式环境设计，支持 POSIX 和 BSD 套接字等开放标准 API，并可运行于 ARM、PowerPC、SPARC、MIPS、RISC"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2025-05-19T12:50:00.000Z"><meta property="article:modified_time" content="2025-06-18T17:20:00.000Z"><meta property="article:author" content="DavidingPlus"><meta name="twitter:card" content="summary"><title>Rtems Source Code | DavidingPlus's Blog</title><link ref="canonical" href="https://blog.davidingplus.cn/posts/4936fe45.html"><link rel="dns-prefetch" href="https://cdn.davidingplus.cn"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fontawesome.css" type="text/css"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fancybox.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.6"><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,assistSearch:["bing","baidu"],fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"55px",tocMaxDepth:6},header:{enable:!0,showOnPost:!0,scrollDownIcon:!0},postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},back2bottom:{enable:!0},codeblock:{style:"default",highlight:"light",wordWrap:!0},reward:!0,fancybox:!0,zoomImage:{gapAside:"20px"},galleryWaterfall:{colWidth:"255px",gapX:"65px"},lazyload:!0,pjax:{avoidBanner:!0},externalLink:{icon:{enable:!0,name:"fas fa-external-link-alt"}},shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"恭喜亲亲，复制成功咧",copyError:"哎呀，复制失败了"},sourcePath:{js:"js",css:"css",images:"images"},utterancesTheme:{light:"github-light",dark:"photon-dark"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-bars"></i></span><span class="header-nav-menu-item__text">其他</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/friends/"><span class="header-nav-submenu-item__icon"><i class="fas fa-users"></i></span><span class="header-nav-submenu-item__text">友链</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/gallery/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" target="_blank" rel="noopener" href="https://davidingplus.cn/"><span class="header-nav-menu-item__icon"><i class="fas fa-pager"></i></span><span class="header-nav-menu-item__text">站点主页</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">DavidingPlus's Blog</div><div class="header-banner-info__subtitle">🕊️ world peace</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Rtems Source Code</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2025-05-19</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2025-06-18</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">9.5k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">60分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><meta name="referrer" content="no-referrer"><h1 id="Rtems-源码阅读"><a href="#Rtems-源码阅读" class="heading-link"><i class="fas fa-link"></i></a><a href="#Rtems-源码阅读" class="headerlink" title="Rtems 源码阅读"></a>Rtems 源码阅读</h1><p>RTEMS（Real‑Time Executive for Multiprocessor Systems）是一款始于 1988 年、1993 年正式发布的开源实时操作系统，专为多处理器嵌入式环境设计，支持 POSIX 和 BSD 套接字等开放标准 API，并可运行于 ARM、PowerPC、SPARC、MIPS、RISC‑V 等 18 种处理器架构及近 200 个 BSP（Board Support Package）上。它以库形式发布，应用程序与内核静态链接为单一映像，采用单地址空间、无用户&#x2F;内核隔离设计，从而简化资源管理并确保确定性响应。2025 年 1 月 22 日发布的 6.1 版本全面将构建系统由 GNU Autotools 切换到基于 Python 的 Waf，大幅提升了构建速度并优化了依赖管理，同时引入了改进的调度算法和增强的 SMP 支持。</p><p>本文章用于记录阅读 Rtems 内核源码的笔记，尝试理解其中的逻辑。Rtems 内核的版本是 6.1，在线代码网站见 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://rtems.davidingplus.cn/lxr/source/">https://rtems.davidingplus.cn/lxr/source/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p>本文章中涉及到的源码摘抄见项目 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://github.com/DavidingPlus/rtems-source-code">DavidingPlus&#x2F;rtems-source-code: Rtems 源码阅读。</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><span id="more"></span><h1 id="文件系统"><a href="#文件系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="系统调用"><a href="#系统调用" class="heading-link"><i class="fas fa-link"></i></a><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><h3 id="open"><a href="#open" class="heading-link"><i class="fas fa-link"></i></a><a href="#open" class="headerlink" title="open()"></a>open()</h3><p>open() 函数的调用流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始 open 函数] --> B[初始化变量 rv=0, mode=0, iop=NULL]
    B --> C[va_start 开始处理可变参数]
    C --> D[获取 mode 参数]
    D --> E{是否成功分配 iop}
    E -- 是 --> F[调用 do_open 打开文件]
    F --> G[设置 rv 为 do_open 返回值]
    E -- 否 --> H[设置 errno = ENFILE]
    H --> I[rv = -1]
    G --> J[va_end 结束可变参数处理]
    I --> J
    J --> K[返回 rv]</pre> <h4 id="struct-rtems-libio-t"><a href="#struct-rtems-libio-t" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-rtems-libio-t" class="headerlink" title="struct rtems_libio_t"></a>struct rtems_libio_t</h4><p>rtems_libio_t 结构体定义如下。该结构体用于表示一个文件描述符的内部状态，Rtems 中每打开一个文件都会关联一个该结构体的实例，通常简称为 iop（I&#x2F;O pointer）。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtems_libio_tt</span> <span class="title">rtems_libio_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtems_libio_tt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 文件状态标志，使用原子类型以支持线程安全操作。</span></span><br><span class="line">    <span class="comment">// 可能标志：是否打开、读/写权限、文件类型等。</span></span><br><span class="line">    Atomic_Uint flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前文件偏移量，用于读写操作时定位文件指针位置。</span></span><br><span class="line">    <span class="type">off_t</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件路径定位信息，类似于 inode。</span></span><br><span class="line">    <span class="comment">// 包含挂载点、节点、驱动等信息，用于实际文件访问。</span></span><br><span class="line">    <span class="type">rtems_filesystem_location_info_t</span> pathinfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驱动或文件系统使用的私有字段。</span></span><br><span class="line">    <span class="comment">// 通常用于存储轻量级状态、句柄或标志值。</span></span><br><span class="line">    <span class="type">uint32_t</span> data0;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 驱动或文件系统使用的扩展字段。</span></span><br><span class="line">    <span class="comment">// 可指向任意类型数据，支持更复杂的上下文管理。</span></span><br><span class="line">    <span class="type">void</span> *data1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h5 id="struct-rtems-filesystem-location-info-t"><a href="#struct-rtems-filesystem-location-info-t" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-rtems-filesystem-location-info-t" class="headerlink" title="struct rtems_filesystem_location_info_t"></a>struct rtems_filesystem_location_info_t</h5><p>rtems_filesystem_location_info_t 结构体定义如下。它表示一个路径位置，用于描述文件系统中某个具体节点（如文件或目录）的位置及其访问方式。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示文件系统中一个节点（如文件或目录）的位置及其访问信息。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtems_filesystem_location_info_tt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 用于将该节点插入到挂载点的链表中（如目录项列表）。</span></span><br><span class="line">    rtems_chain_node mt_entry_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向具体节点的访问结构，一般是与具体文件系统实现相关的 inode 或数据结构。</span></span><br><span class="line">    <span class="type">void</span> *node_access;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可选的第二个访问字段，供文件系统使用，如软链接或扩展元数据。</span></span><br><span class="line">    <span class="type">void</span> *node_access_2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向该节点所使用的文件操作处理器集合（如 open、read、write、close 等函数指针）。</span></span><br><span class="line">    <span class="type">const</span> rtems_filesystem_file_handlers_r *handlers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点所属的挂载表条目，表示该节点来自哪个挂载的文件系统。</span></span><br><span class="line">    <span class="type">rtems_filesystem_mount_table_entry_t</span> *mt_entry;</span><br><span class="line"></span><br><span class="line">&#125; <span class="type">rtems_filesystem_location_info_t</span>;</span><br></pre></td></tr></table></div></figure><h5 id="struct-rtems-filesystem-file-handlers-r"><a href="#struct-rtems-filesystem-file-handlers-r" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-rtems-filesystem-file-handlers-r" class="headerlink" title="struct rtems_filesystem_file_handlers_r"></a>struct rtems_filesystem_file_handlers_r</h5><p>比较重要的成员是 <code>const rtems_filesystem_file_handlers_r *handlers</code>，该结构类似于 Linux 内核中的 file_operations，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief File system node operations table.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">rtems_filesystem_file_handlers_r</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 打开文件的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_open_t</span> open_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_close_t</span> close_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_read_t</span> read_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_write_t</span> write_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 控制操作（如设备控制）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_ioctl_t</span> ioctl_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件位置指针移动（如 lseek）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_lseek_t</span> lseek_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件状态信息的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_fstat_t</span> fstat_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截断文件大小的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_ftruncate_t</span> ftruncate_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将文件缓冲区数据同步到存储设备的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_fsync_t</span> fsync_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步文件数据（但不一定包括元数据）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_fdatasync_t</span> fdatasync_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件控制（如修改文件描述符属性）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_fcntl_t</span> fcntl_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 轮询文件状态（如是否可读写）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_poll_t</span> poll_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于事件过滤（BSD kqueue）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_kqfilter_t</span> kqfilter_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取多个缓冲区（向量读）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_readv_t</span> readv_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入多个缓冲区（向量写）的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_writev_t</span> writev_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存映射文件的处理函数指针。</span></span><br><span class="line">    <span class="type">rtems_filesystem_mmap_t</span> mmap_h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h5 id="struct-rtems-filesystem-mount-table-entry-tt"><a href="#struct-rtems-filesystem-mount-table-entry-tt" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-rtems-filesystem-mount-table-entry-tt" class="headerlink" title="struct rtems_filesystem_mount_table_entry_tt"></a>struct rtems_filesystem_mount_table_entry_tt</h5><p>另一个成员是 struct rtems_filesystem_mount_table_entry_tt。这个结构体的作用是为每一个已挂载的文件系统提供一个集中式的描述，包含了文件系统的根节点信息、挂载点、类型、设备、访问控制状态等关键信息。对每个文件系统，Rtems 会维护一个这样的挂载表链表。在挂载和卸载文件系统时，Rtems 会对这个结构体进行相应的初始化、操作或释放。文件系统的挂载、查找路径、访问权限、卸载等都依赖于这个结构体中记录的信息。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtems_filesystem_mount_table_entry_tt</span></span></span><br><span class="line"><span class="class">    <span class="title">rtems_filesystem_mount_table_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 表示一个挂载的文件系统实例，是 Rtems 文件系统挂载表中的一项。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rtems_filesystem_mount_table_entry_tt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 用于将该挂载点插入全局挂载链表。</span></span><br><span class="line">    rtems_chain_node mt_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统私有信息，由具体文件系统实现定义，如 ext2 的 superblock 信息。</span></span><br><span class="line">    <span class="type">void</span> *fs_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向文件系统操作函数表，定义如 mount、unmount、eval_path 等。</span></span><br><span class="line">    <span class="type">const</span> rtems_filesystem_operations_table *ops;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统的常量信息，不可变，例如初始挂载参数。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *immutable_fs_info;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该文件系统中所有节点的全局链表，便于遍历。</span></span><br><span class="line">    rtems_chain_control location_chain;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示该文件系统挂载在哪个目录（挂载点）上。</span></span><br><span class="line">    <span class="type">rtems_filesystem_global_location_t</span> *mt_point_node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示该文件系统的根节点位置。</span></span><br><span class="line">    <span class="type">rtems_filesystem_global_location_t</span> *mt_fs_root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否已挂载成功。</span></span><br><span class="line">    <span class="type">bool</span> mounted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持写操作。</span></span><br><span class="line">    <span class="type">bool</span> writeable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否禁止创建设备节点和普通文件（mknod）。</span></span><br><span class="line">    <span class="type">bool</span> no_regular_file_mknod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该文件系统的路径名限制和选项。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">rtems_filesystem_limits_and_options_t</span> *pathconf_limits_and_options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载点路径字符串，例如 &quot;/mnt/usb&quot;。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统类型名称，例如 &quot;imfs&quot;、&quot;devfs&quot;、&quot;nfs&quot; 等。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设备名称，如 &quot;/dev/sda1&quot;，以字符串形式表示，供底层文件系统使用。</span></span><br><span class="line">    <span class="type">char</span> *dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发起卸载操作的任务 ID，卸载完成后通过事件通知该任务。</span></span><br><span class="line">    rtems_id unmount_task;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>在 RTEMS 中，文件系统的操作由 rtems_filesystem_operations_table 结构体统一管理，它定义了路径解析、节点创建、删除、克隆等核心操作函数，作用上相当于 Linux 中的 inode_operations。每个挂载的文件系统通过 rtems_filesystem_mount_table_entry_t 表示，类似于 Linux 的 super_block，其中包含了指向操作表 ops 的指针。当用户发起如 open、read、write 等文件访问请求时，系统首先通过 eval_path_h 函数解析路径并定位到目标节点，然后使用该节点中挂载的 rtems_filesystem_file_handlers_r（类似 Linux 的 file_operations）来完成具体操作。整个设计将挂载管理、路径解析和文件操作职责分离，形成清晰的模块边界，同时借鉴了 Linux 文件系统架构的思想。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">rtems_filesystem_operations_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 挂载点加锁函数，防止并发访问挂载点结构。</span></span><br><span class="line">    <span class="type">rtems_filesystem_mt_entry_lock_t</span> lock_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载点解锁函数，与 lock_h 成对使用。</span></span><br><span class="line">    <span class="type">rtems_filesystem_mt_entry_unlock_t</span> unlock_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路径解析函数，将路径转换为文件系统节点。</span></span><br><span class="line">    <span class="type">rtems_filesystem_eval_path_t</span> eval_path_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建硬链接的函数。</span></span><br><span class="line">    <span class="type">rtems_filesystem_link_t</span> link_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断两个节点是否表示同一对象的函数。</span></span><br><span class="line">    <span class="type">rtems_filesystem_are_nodes_equal_t</span> are_nodes_equal_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建文件系统节点（如文件、目录、设备节点）的函数。</span></span><br><span class="line">    <span class="type">rtems_filesystem_mknod_t</span> mknod_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除文件系统节点的函数。</span></span><br><span class="line">    <span class="type">rtems_filesystem_rmnod_t</span> rmnod_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改节点权限的函数，相当于 chmod。</span></span><br><span class="line">    <span class="type">rtems_filesystem_fchmod_t</span> fchmod_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更改节点所有者信息的函数，相当于 chown。</span></span><br><span class="line">    <span class="type">rtems_filesystem_chown_t</span> chown_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆节点的函数，通常用于目录项引用增加时复制节点。</span></span><br><span class="line">    <span class="type">rtems_filesystem_clonenode_t</span> clonenod_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放节点资源的函数，通常在节点引用减少到 0 时调用。</span></span><br><span class="line">    <span class="type">rtems_filesystem_freenode_t</span> freenod_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统挂载处理函数，处理实际挂载逻辑。</span></span><br><span class="line">    <span class="type">rtems_filesystem_mount_t</span> mount_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统卸载处理函数，释放挂载相关资源。</span></span><br><span class="line">    <span class="type">rtems_filesystem_unmount_t</span> unmount_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统自定义卸载钩子，用于挂载入口被清理时的回调。</span></span><br><span class="line">    <span class="type">rtems_filesystem_fsunmount_me_t</span> fsunmount_me_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改节点时间戳信息的函数，相当于 utimensat。</span></span><br><span class="line">    <span class="type">rtems_filesystem_utimens_t</span> utimens_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建符号链接的函数。</span></span><br><span class="line">    <span class="type">rtems_filesystem_symlink_t</span> symlink_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取符号链接目标路径的函数。</span></span><br><span class="line">    <span class="type">rtems_filesystem_readlink_t</span> readlink_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重命名文件或目录的函数。</span></span><br><span class="line">    <span class="type">rtems_filesystem_rename_t</span> rename_h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取文件系统统计信息的函数，如空间大小、inode 数等。</span></span><br><span class="line">    <span class="type">rtems_filesystem_statvfs_t</span> statvfs_h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h4 id="rtems-libio-allocate"><a href="#rtems-libio-allocate" class="heading-link"><i class="fas fa-link"></i></a><a href="#rtems-libio-allocate" class="headerlink" title="rtems_libio_allocate()"></a>rtems_libio_allocate()</h4><p>open 函数中分配文件描述符结构使用的函数是 rtems_libio_allocate()，执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始 rtems_libio_allocate 函数] --> B[加锁保护空闲链表]
    B --> C[从空闲链表头获取 iop]
    C --> D{iop 是否为 NULL?}
    D -- 否 --> E[获取 iop->data1 到 next]
    E --> F[更新空闲链表头指针为 next]
    F --> G{next 是否为 NULL}
    G -- 是 --> H[更新尾指针为 &rtems_libio_iop_free_head]
    G -- 否 --> I[不操作]
    D -- 是 --> I
    H --> J[解锁释放访问]
    I --> J
    J --> K[返回 iop]</pre> <h5 id="rtems-libio-iop-free-head"><a href="#rtems-libio-iop-free-head" class="heading-link"><i class="fas fa-link"></i></a><a href="#rtems-libio-iop-free-head" class="headerlink" title="rtems_libio_iop_free_head"></a>rtems_libio_iop_free_head</h5><p>rtems_libio_iop_free_head 是一个全局变量，用于维护 Rtems 文件描述符（rtems_libio_t）的空闲链表头指针。</p><p>在初始化阶段，Rtems 会预分配一定数量的 rtems_libio_t 结构，并通过 data1 字段将它们串成一个单向链表。rtems_libio_iop_free_head 指向第一个可用节点。每次 rtems_libio_allocate() 被调用时，从头部取出一个节点，并更新链表。如果分配后链表为空，rtems_libio_iop_free_tail 会被指向 &amp;rtems_libio_iop_free_head，表示空了。释放节点时会调用一个对应的 rtems_libio_free(iop)，将节点重新挂回链表尾部。</p><p>那其实对于 rtems_libio_t 链表而言，在预分配的时候就需要将 rtems_filesystem_location_info_tt 中关于文件系统全局的 rtems_filesystem_file_handlers_r 和 rtems_filesystem_mount_table_entry_tt 信息写入，这样才能保证系统调用的时候能够成功调用底层函数。</p><p>初始化阶段的函数逻辑如下：</p> <pre class="mermaid">flowchart TD
    A[开始 rtems_libio_init 函数] --> B{rtems_libio_number_iops > 0?}
    B -- 否 --> Z[结束函数]
    B -- 是 --> C[设置空闲链表头指针]
    C --> D[初始化循环变量 i = 0]
    D --> E{i + 1 < rtems_libio_number_iops?}
    E -- 是 --> F[设置 iop->data1 = iop + 1]
    F --> G[i++, iop++]
    G --> E
    E -- 否 --> H[设置最后一个 iop->data1 = NULL]
    H --> I[设置链表尾指针 rtems_libio_iop_free_tail = &iop->data1]
    I --> Z</pre> <p>rtems_libio_iops 是 Rtems 预先分配的 I&#x2F;O 控制块数组，配置了 CONFIGURE_MAXIMUM_FILE_DESCRIPTORS 以后，会预先创建出这个数组。</p><p>问题来了：有了这个数组，为什么还要一个额外的 free list 链表来管理呢？</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> CONFIGURE_MAXIMUM_FILE_DESCRIPTORS &gt; 0</span></span><br><span class="line"><span class="type">rtems_libio_t</span> rtems_libio_iops[CONFIGURE_MAXIMUM_FILE_DESCRIPTORS];</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">uint32_t</span> rtems_libio_number_iops = RTEMS_ARRAY_SIZE(rtems_libio_iops);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></div></figure><h4 id="do-open"><a href="#do-open" class="heading-link"><i class="fas fa-link"></i></a><a href="#do-open" class="headerlink" title="do_open()"></a>do_open()</h4><p>open() 函数中分配好文件描述符结构以后，最终会到达 do_open() 函数的位置进行处理。</p><p>函数开始时，从 iop 获取文件描述符 fd，并根据 oflag 解析读写权限、创建、独占、截断和目录打开等标志。然后确定是否跟随符号链接，组合路径解析所需的权限标志 eval_flags。</p><p>接着初始化路径解析上下文，解析路径并获取当前文件系统位置。若支持创建普通文件且路径未结束，则调用创建文件的函数。随后判断是否以目录方式打开，并检查写权限和目录类型的合法性，防止写目录或以目录方式打开非目录。</p><p>路径信息保存到 iop-&gt;pathinfo，清理路径解析上下文后，设置文件控制标志，调用底层驱动的 open 函数打开文件。若成功且指定截断，则调用 ftruncate 截断文件内容，截断失败时关闭文件。</p><p>最后，若操作全部成功，设置文件打开标志并返回文件描述符；失败时释放资源并返回错误。整个过程确保了路径解析、权限检查和文件打开的正确性和安全性。</p><p>do_open() 函数的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始 do_open] --> B[解析参数和标志]
    B --> C[路径解析启动: rtems_filesystem_eval_path_start]
    C --> D[获取 currentloc 和是否支持创建文件]
    D --> E{是否需要创建普通文件?}
    E -- 是 --> F[create_regular_file]
    E -- 否 --> G[跳过创建]
    F --> H[是否为目录打开或需要写权限?]
    G --> H
    H --> I{路径类型检查}
    I -- 错误: 写目录 --> J[设置 EISDIR 错误]
    I -- 错误: 非目录 --> K[设置 ENOTDIR 错误]
    I --> L[提取 pathinfo 并清理上下文]

    L --> M[设置 LibIO 打开标志]
    M --> N[调用底层 open 函数]
    N --> O{open 是否成功?}
    O -- 否 --> P[释放 iop 并返回 -1]
    O -- 是 --> Q{是否需要截断?}
    Q -- 是 --> R{是否有写权限?}
    R -- 否 --> S[errno = EINVAL, 返回错误]
    R -- 是 --> T[调用 ftruncate]
    T --> U{ftruncate 成功?}
    U -- 否 --> V[调用 close, 返回 -1]
    U -- 是 --> W[设置 LIBIO_FLAGS_OPEN, 返回 fd]
    Q -- 否 --> W
    S --> P
    V --> P</pre> <h5 id="路径解析过程"><a href="#路径解析过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#路径解析过程" class="headerlink" title="路径解析过程"></a>路径解析过程</h5><p>do_open() 涉及到的路径解析代码片段如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动路径解析，准备解析文件路径。</span></span><br><span class="line">rtems_filesystem_eval_path_start(&amp;ctx, path, eval_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取解析后的当前路径位置信息。</span></span><br><span class="line">currentloc = rtems_filesystem_eval_path_get_currentloc(&amp;ctx);</span><br></pre></td></tr></table></div></figure><p>rtems_filesystem_eval_path_start() 的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[调用 rtems_filesystem_eval_path_start] --> B[调用 rtems_filesystem_eval_path_start_with_root_and_current]
    B --> C[清空上下文 memset]
    C --> D[设置 ctx 路径和长度]
    D --> E[设置 ctx 标志位]
    E --> F[初始化起始位置 set_startloc]
    F --> G[锁定起始位置 rtems_filesystem_instance_lock]
    G --> H[复制 startloc 到 currentloc]
    H --> I[继续解析路径 rtems_filesystem_eval_path_continue]
    I --> J[返回 ctx currentloc]</pre> <p>可以看出最后进入了 rtems_filesystem_eval_path_continue() 函数，嵌套太深了。目前看不懂整个路径的解析过程。</p><p>路径解析完毕后，do_open() 函数中执行以下函数用于维护状态：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取解析后的当前路径位置信息。</span></span><br><span class="line">currentloc = rtems_filesystem_eval_path_get_currentloc(&amp;ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前路径所在文件系统是否允许创建普通文件。</span></span><br><span class="line">create_reg_file = !currentloc-&gt;mt_entry-&gt;no_regular_file_mknod;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将路径解析得到的当前路径信息保存到 iop 的 pathinfo 中。</span></span><br><span class="line">rtems_filesystem_eval_path_extract_currentloc(&amp;ctx, &amp;iop-&gt;pathinfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理路径解析上下文，释放资源。</span></span><br><span class="line">rtems_filesystem_eval_path_cleanup(&amp;ctx);</span><br></pre></td></tr></table></div></figure><h5 id="底层文件系统的-open-函数"><a href="#底层文件系统的-open-函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#底层文件系统的-open-函数" class="headerlink" title="底层文件系统的 open 函数"></a>底层文件系统的 open 函数</h5><p>拿到所有信息以后，do_open() 函数中调用底层文件系统的 open() 函数真正打开文件：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用底层文件系统的 open 函数打开文件。</span></span><br><span class="line">rv = (*iop-&gt;pathinfo.handlers-&gt;open_h)(iop, path, oflag, mode);</span><br></pre></td></tr></table></div></figure><h3 id="close"><a href="#close" class="heading-link"><i class="fas fa-link"></i></a><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>close() 函数的执行流程图如下。在前面更改完状态标志位后，还是会进入到底层文件系统的 close_h 函数。</p> <pre class="mermaid">flowchart TD
  A[开始关闭 fd] --> B{文件描述符是否越界}
  B -- 是 --> C[设置错误码坏文件描述符并返回失败]
  B -- 否 --> D[获取对应的 I/O 对象]
  D --> E[读取 I/O 对象标志]
  E --> F{标志中是否包含打开状态}
  F -- 否 --> G[设置错误码坏文件描述符并返回失败]
  F -- 是 --> H[清除引用计数部分]
  H --> I[构造去掉打开标志的新标志]
  I --> J[执行原子比较交换操作]
  J --> K{比较交换是否成功}
  K -- 是 --> L[继续关闭处理]
  K -- 否 --> M{标志中是否有非法状态}
  M -- 是 --> N[设置错误码设备忙并返回失败]
  M -- 否 --> F

  L --> O[调用文件系统的关闭函数]
  O --> P[释放 I/O 对象]
  P --> Q[返回关闭结果]</pre> <h3 id="read"><a href="#read" class="heading-link"><i class="fas fa-link"></i></a><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>read() 函数的执行流程图如下。可以看出除了做了一些检查以外，直接调用了底层文件系统的 read_h() 函数。</p> <pre class="mermaid">flowchart TD
  A[开始调用 read 函数] --> B[确认缓冲区指针有效]
  B --> C[确认读取长度合理]
  C --> D{尝试获取对应的 I/O 对象并检查是否可读}
  D -- 失败 --> E[设置错误码为坏文件描述符并返回失败]
  D -- 成功 --> F[调用底层读操作完成读取]
  F --> G[释放 I/O 资源]
  G --> H[返回读取到的字节数或者错误码]</pre> <h3 id="write"><a href="#write" class="heading-link"><i class="fas fa-link"></i></a><a href="#write" class="headerlink" title="write()"></a>write()</h3><p>write() 函数的执行流程图如下。大致逻辑同样同 read 函数。</p> <pre class="mermaid">flowchart TD
  A[开始调用 write 函数] --> B[确认缓冲区指针有效]
  B --> C[确认写入字节数合理]
  C --> D{尝试获取对应的 I/O 对象并检查是否可写}
  D -- 失败 --> E[设置错误码坏文件描述符并返回失败]
  D -- 成功 --> F[调用底层写操作完成写入]
  F --> G[释放 I/O 资源]
  G --> H[返回写入的字节数或错误码]</pre> <h2 id="文件系统启动流程"><a href="#文件系统启动流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件系统启动流程" class="headerlink" title="文件系统启动流程"></a>文件系统启动流程</h2><h3 id="rtems-filesystem-initialize"><a href="#rtems-filesystem-initialize" class="heading-link"><i class="fas fa-link"></i></a><a href="#rtems-filesystem-initialize" class="headerlink" title="rtems_filesystem_initialize()"></a>rtems_filesystem_initialize()</h3><p>该函数用于初始化 Rtems 的根文件系统，通常是 IMFS。<span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://docs.rtems.org/docs/6.1/filesystem/system_init.html">官方文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 提到，其他文件系统可以被挂载，但它们只能挂载到基础文件系统中的某个目录挂载点。对于我们想注册的自定义文件系统，有两种手段，一种是在根文件系统挂载好以后，找到某个目录手动挂载新文件系统，另一种是直接修改 rtems_filesystem_root_configuration 根文件系统的配置，使用我们自己的文件系统，这样 Rtems 在启动的时候就会默认跑我们自己的文件系统。</p><p>rtems_filesystem_initialize() 函数的执行流程图如下：</p> <pre class="mermaid">flowchart TD
  A[开始初始化文件系统] --> B[获取根文件系统挂载配置信息]
  B --> C[挂载根文件系统]
  C --> D{挂载是否成功}
  D -- 否 --> E[触发致命错误停止系统]
  D -- 是 --> F[创建 /dev 目录]
  F --> G{目录创建是否成功}
  G -- 否 --> H[触发致命错误停止系统]
  G -- 是 --> I[根文件系统和 /dev 目录创建完成]
  I --> J[说明其他文件系统需手动挂载]
  J --> K[初始化完成]</pre> <h4 id="struct-rtems-filesystem-mount-configuration"><a href="#struct-rtems-filesystem-mount-configuration" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-rtems-filesystem-mount-configuration" class="headerlink" title="struct rtems_filesystem_mount_configuration"></a>struct rtems_filesystem_mount_configuration</h4><p>挂载根文件系统的挂载配置信息的结构体是 struct rtems_filesystem_mount_configuration。该结构体是 Rtems 中用于挂载文件系统时传递参数的配置结构。它的作用是将挂载一个文件系统所需的各种信息（如设备源、挂载点、文件系统类型等）集中在一起，作为参数传给 mount() 函数。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 描述挂载源，通常是设备路径，如 &quot;/dev/sd0&quot;；对 IMFS 等内存文件系统可为 NULL。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载目标目录，必须是系统中已存在的路径，如 &quot;/&quot; 或 &quot;/mnt/usb&quot;。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统类型的名称字符串，如 &quot;imfs&quot;、&quot;dosfs&quot;、&quot;devfs&quot; 等。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *filesystemtype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载选项，定义为 rtems_filesystem_options_t 类型，控制如只读、读写等行为。</span></span><br><span class="line">    <span class="type">rtems_filesystem_options_t</span> options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向文件系统特定的附加数据，一般为 NULL，某些文件系统可能使用此字段传递配置。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">void</span> *data;</span><br><span class="line">&#125; rtems_filesystem_mount_configuration;</span><br></pre></td></tr></table></div></figure><p>在 rtems_filesystem_initialize() 中，根文件系统的配置是预定义好的全局变量 rtems_filesystem_root_configuration。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> rtems_filesystem_mount_configuration rtems_filesystem_root_configuration = &#123;</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">&quot;/&quot;</span>,</span><br><span class="line">    RTEMS_FILESYSTEM_READ_WRITE,</span><br><span class="line">    &amp;IMFS_root_mount_data,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h3 id="rtems-filesystem-register"><a href="#rtems-filesystem-register" class="heading-link"><i class="fas fa-link"></i></a><a href="#rtems-filesystem-register" class="headerlink" title="rtems_filesystem_register()"></a>rtems_filesystem_register()</h3><p>rtems_filesystem_register() 用于在 Rtems 操作系统中注册一个新的文件系统类型。它接收文件系统的类型名称和对应的挂载函数指针，动态分配内存创建一个文件系统节点，将类型名称和挂载函数保存到该节点中，并检查该类型是否已被注册。如果未注册，则将该节点添加到全局文件系统链表完成注册；如果已注册，则释放内存并返回错误。通过这个注册机制，系统能够识别和管理多种文件系统类型，并在需要时调用对应的挂载函数进行挂载操作。</p><p>rtems_filesystem_register() 的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始 rtems_filesystem_register] --> B[计算 type_size 与 fsn_size 并 malloc 分配 fsn]
    B --> C{fsn 是否为 NULL?}
    C -- 是 --> D[设置 errno 等于 ENOMEM 并返回 -1]
    C -- 否 --> E[计算 type_storage 并 memcpy 复制类型字符串]
    E --> F[设置 fsn->entry.type 等于 type_storage]
    F --> G[设置 fsn->entry.mount_h 等于 mount_h]
    G --> H[rtems_libio_lock 进入临界区]
    H --> I{rtems_filesystem_get_mount_handler 判断 type 是否已注册}
    I -- 未注册 --> J[rtems_chain_initialize_node 初始化链表节点]
    J --> K[rtems_chain_append_unprotected 将 fsn 添加到全局链表]
    K --> L[rtems_libio_unlock 解锁]
    L --> M[返回 0 注册成功]
    I -- 已注册 --> N[rtems_libio_unlock 解锁]
    N --> O[free fsn 释放内存]
    O --> P[设置 errno 等于 EINVAL 并返回 -1]</pre> <p>在 rtems_filesystem_register() 的源码中，有几行比较细节的地方。在 Rtems 中，文件系统的注册全局表有两个，一个是静态表 rtems_filesystem_table，一个是动态表 filesystem_chain。静态表是 Rtems 预先定义好的常量，提供了 Rtems 内置的文件系统。动态表用于用户动态注册文件系统，在下面的函数实现中，如果发现全局表没有注册该文件系统，Rtems 会将该文件系统挂到 filesystem_chain 上。</p><p>好，问题来了，表里面除了 type 成员，更重要的是挂载函数 rtems_filesystem_fsmount_me_t。这个函数是需要我们自己写的，也就是说 Rtems 在注册文件系统的时候，除了记录到注册全局表以后，就没有其他架构上的操作了。后面的操作都需要我们自己做，Rtems 的文件系统虚拟层目前看起来几乎没有。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rtems_chain_control *chain = &amp;filesystem_chain;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rtems_filesystem_get_mount_handler(type) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    rtems_chain_initialize_node(&amp;fsn-&gt;node);</span><br><span class="line">    rtems_chain_append_unprotected(chain, &amp;fsn-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h4 id="struct-filesystem-node"><a href="#struct-filesystem-node" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-filesystem-node" class="headerlink" title="struct filesystem_node"></a>struct filesystem_node</h4><p>struct filesystem_node 结构体的作用是将一个文件系统的描述信息封装为链表中的一个节点，使得多个文件系统表项可以通过链表的形式组织和管理。它结合了 Rtems 的链表节点结构 rtems_chain_node 与文件系统表项 rtems_filesystem_table_t，方便在系统中动态维护、查找和操作支持的文件系统。该结构体通常用于构建一个文件系统注册表，实现对多个文件系统的统一管理和遍历。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体类型 filesystem_node，用于表示文件系统链表中的一个节点。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// RTEMS 提供的双向链表节点结构，用于将多个文件系统节点连接成链表。</span></span><br><span class="line">    rtems_chain_node node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统表项，包含该文件系统的初始化函数、挂载函数等描述信息。</span></span><br><span class="line">    <span class="type">rtems_filesystem_table_t</span> entry;</span><br><span class="line">&#125; filesystem_node;</span><br></pre></td></tr></table></div></figure><h4 id="struct-rtems-filesystem-table-t"><a href="#struct-rtems-filesystem-table-t" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-rtems-filesystem-table-t" class="headerlink" title="struct rtems_filesystem_table_t"></a>struct rtems_filesystem_table_t</h4><p>struct rtems_filesystem_table_t 结构体的作用是描述一个可挂载的文件系统类型，包括文件系统的类型名称和对应的挂载函数。它为 RTEMS 提供了一种统一的方式来表示和管理不同类型的文件系统，使系统能够在运行时根据类型名称选择合适的挂载函数进行文件系统初始化和挂载操作。这种设计有助于扩展文件系统支持，并实现灵活的文件系统管理机制。</p><p>在 rtems_filesystem_register() 函数中，成员 type 和 mount_h 通过函数参数传入，并在函数内赋值。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个结构体类型 rtems_filesystem_table_t，用于描述一个可挂载的文件系统类型。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">rtems_filesystem_table_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 文件系统的类型名称，通常为字符串形式，例如 &quot;imfs&quot; 或 &quot;dosfs&quot;。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统的挂载函数指针，用于挂载该类型的文件系统。</span></span><br><span class="line">    <span class="type">rtems_filesystem_fsmount_me_t</span> mount_h;</span><br><span class="line">&#125; <span class="type">rtems_filesystem_table_t</span>;</span><br></pre></td></tr></table></div></figure><h4 id="rtems-filesystem-fsmount-me-t"><a href="#rtems-filesystem-fsmount-me-t" class="heading-link"><i class="fas fa-link"></i></a><a href="#rtems-filesystem-fsmount-me-t" class="headerlink" title="rtems_filesystem_fsmount_me_t"></a>rtems_filesystem_fsmount_me_t</h4><p>rtems_filesystem_fsmount_me_t 是一个函数指针，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 初始化一个文件系统实例。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 该函数负责初始化挂载表项中的文件系统根节点。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[in] mt_entry 指向挂载表项的指针，表示要挂载的文件系统实例。</span></span><br><span class="line"><span class="comment"> * @param[in] data 用户提供的初始化数据，如设备路径或挂载选项。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @retval 0 操作成功，文件系统实例初始化完成。</span></span><br><span class="line"><span class="comment"> * @retval -1 操作失败，设置 errno 以指示具体错误。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数指针类型 rtems_filesystem_fsmount_me_t，表示挂载文件系统的函数。</span></span><br><span class="line"><span class="comment">// 该函数接受挂载表项指针和用户数据作为参数，返回挂载结果。</span></span><br><span class="line"><span class="comment">// 返回 0 表示挂载成功，返回 -1 表示挂载失败且设置 errno。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*<span class="type">rtems_filesystem_fsmount_me_t</span>)</span><span class="params">(</span></span><br><span class="line"><span class="params">    <span class="type">rtems_filesystem_mount_table_entry_t</span> *mt_entry, <span class="comment">// 指向挂载表项，表示要挂载的文件系统。</span></span></span><br><span class="line"><span class="params">    <span class="type">const</span> <span class="type">void</span> *data                                <span class="comment">// 用户传入的初始化数据。</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></div></figure><p>struct rtems_filesystem_mount_table_entry_t 结构体的作用是为每一个已挂载的文件系统提供一个集中式的描述，包含了文件系统的根节点信息、挂载点、类型、设备、访问控制状态等关键信息。Rtems 会维护一个这样的挂载表链表，每个表项都是这个结构体的一个实例。在挂载和卸载文件系统时，Rtems 会对这个结构体进行相应的初始化、操作或释放。文件系统的挂载、查找路径、访问权限、卸载等都依赖于这个结构体中记录的信息。</p><p>关于 struct rtems_filesystem_mount_table_entry_tt 和 struct _rtems_filesystem_operations_table，前面在 struct rtems_libio_t 的时候提到过，不再赘述。</p><h3 id="rtems-fsmount"><a href="#rtems-fsmount" class="heading-link"><i class="fas fa-link"></i></a><a href="#rtems-fsmount" class="headerlink" title="rtems_fsmount()"></a>rtems_fsmount()</h3><p>rtems_fsmount() 函数的作用是批量挂载多个文件系统，它按照用户提供的挂载表（fstab）顺序，依次创建每个挂载点目录并调用 mount() 执行挂载操作。该函数支持错误报告和失败控制机制，允许用户根据挂载结果决定是否继续处理后续项。通过这种方式，rtems_fsmount 提供了一种统一、高效的接口，适用于系统启动时自动挂载多个文件系统，简化了挂载流程并增强了可配置性。</p><p>rtems_fsmount() 的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始, 初始化 rc, fstab_idx, terminate] --> B[检查循环条件 fstab_idx 小于 fstab_count, 且 terminate 为 false]
    B -->|是| C[创建挂载点, 调用 rtems_mkdir]
    C --> D{创建成功}
    D -- 否 --> E[根据配置报告错误, 更新 terminate 和 rc]
    D -- 是 --> F[执行挂载, 调用 mount]
    F --> G{挂载成功}
    G -- 否 --> H[根据配置报告挂载失败, 更新 terminate 和 rc]
    G -- 是 --> I[根据配置报告挂载成功, 更新 terminate]
    E & H & I --> J{terminate}
    J -- 否 --> K[fstab_ptr 前移, fstab_idx 加一, 然后返回 B]
    J -- 是 --> L[退出循环]
    B -->|否| L
    L --> M{fail_idx 是否存在}
    M -- 是 --> N[写入失败索引]
    M -- 否 --> O
    N --> P[返回 rc]
    O --> P</pre> <h4 id="struct-rtems-fstab-entry"><a href="#struct-rtems-fstab-entry" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-rtems-fstab-entry" class="headerlink" title="struct rtems_fstab_entry"></a>struct rtems_fstab_entry</h4><p>struct rtems_fstab_entry 用于描述单个文件系统的挂载配置信息，包括挂载源设备或路径、挂载点目录、文件系统类型以及挂载时的选项和行为控制标志。它为系统批量挂载文件系统时提供了统一的数据格式，使挂载操作可以根据该结构体中的信息依次执行，支持对挂载过程中的错误报告和中止条件进行灵活管理。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件系统挂载表条目结构体。</span></span><br><span class="line"><span class="comment">// 用于描述一个文件系统的挂载信息，包括挂载源、挂载点、文件系统类型及挂载选项。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 挂载源，表示要挂载的设备、分区或路径。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *source;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂载目标，即挂载点路径，文件系统将挂载到该目录下。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统类型名称，如 &quot;imfs&quot;、&quot;dosfs&quot; 等。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件系统挂载选项，包含挂载时的参数配置。</span></span><br><span class="line">    <span class="comment">// // 文件系统挂载选项枚举类型，定义了文件系统挂载时支持的不同访问权限模式。</span></span><br><span class="line">    <span class="comment">// typedef enum</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     // 只读模式，文件系统以只读方式挂载。</span></span><br><span class="line">    <span class="comment">//     RTEMS_FILESYSTEM_READ_ONLY,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     // 读写模式，文件系统以读写方式挂载。</span></span><br><span class="line">    <span class="comment">//     RTEMS_FILESYSTEM_READ_WRITE,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     // 无效或错误的挂载选项。</span></span><br><span class="line">    <span class="comment">//     RTEMS_FILESYSTEM_BAD_OPTIONS</span></span><br><span class="line">    <span class="comment">// &#125; rtems_filesystem_options_t;</span></span><br><span class="line">    <span class="type">rtems_filesystem_options_t</span> options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 报告条件标志，用于指定哪些情况需要报告错误或信息。</span></span><br><span class="line">    <span class="type">uint16_t</span> report_reasons;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止条件标志，用于指定哪些情况会导致挂载流程终止。</span></span><br><span class="line">    <span class="type">uint16_t</span> abort_reasons;</span><br><span class="line">&#125; rtems_fstab_entry;</span><br></pre></td></tr></table></div></figure><h4 id="mount"><a href="#mount" class="heading-link"><i class="fas fa-link"></i></a><a href="#mount" class="headerlink" title="mount()"></a>mount()</h4><p>mount() 函数用于根据指定的源路径、目标挂载点、文件系统类型和挂载选项，完成文件系统的挂载操作。它首先根据文件系统类型获取对应的挂载处理函数，然后创建一个挂载表项来保存挂载信息，调用具体文件系统的挂载函数进行挂载，并将挂载点注册到系统的文件系统层次中。如果挂载或注册失败，会进行相应的资源释放和错误处理。函数最终返回挂载结果，成功返回 0，失败返回 -1 并设置相应的错误码。</p><p>mount() 函数的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始, 调用 mount] --> B[验证 options 是否为只读 或 读写]
    B -->|无效| C[设置 errno 为 EINVAL, 返回 -1]
    B -->|有效| D[调用 rtems_filesystem_get_mount_handler, 获取挂载函数]
    D -->|无 函数| E[设置 errno 为 EINVAL, 返回 -1]
    D -->|有 函数| F[调用 alloc_mount_table_entry, 分配挂载表项]
    F -->|分配 失败| G[设置 errno 为 ENOMEM, 返回 -1]
    F -->|分配 成功| H[根据 options 设置 writeable 标志]
    H --> I[调用挂载函数, 执行挂载]
    I -->|挂载 失败| J[释放挂载表项, 返回 -1]
    I -->|挂载 成功| K[注册 文件系统]
    K -->|注册 成功| L[返回 0]
    K -->|注册 失败| M[调用 fsunmount, 卸载, 释放挂载表项, 返回 -1]</pre> <h2 id="IMFS-文件系统"><a href="#IMFS-文件系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#IMFS-文件系统" class="headerlink" title="IMFS 文件系统"></a>IMFS 文件系统</h2><p>IMFS（In‐Memory File System）是 Rtems 提供的一个内存文件系统。它将文件和目录全部存储在 RAM 中，为嵌入式应用提供快速、轻量级的 POSIX 风格文件操作接口；其核心模块负责管理目录树结构、路径解析和文件读写逻辑，而底层的节点分配与销毁、元数据初始化等则通过回调函数（如 node_initialize、node_remove、node_destroy）由系统默认实现或用户自定义实现来完成，使得 IMFS 在不修改主体框架的情况下能够灵活适配不同内存布局或特殊需求，启动时通过 IMFS_initialize 自动注册并挂载为根文件系统，用户即可直接使用标准的 open&#x2F;read&#x2F;write&#x2F;close 等接口访问内存中存储的文件。</p><h3 id="rtems-filesystem-get-mount-handler"><a href="#rtems-filesystem-get-mount-handler" class="heading-link"><i class="fas fa-link"></i></a><a href="#rtems-filesystem-get-mount-handler" class="headerlink" title="rtems_filesystem_get_mount_handler()"></a>rtems_filesystem_get_mount_handler()</h3><p>在 rtems_filesystem_register() 中，有一步是调用 rtems_filesystem_get_mount_handler 函数判断节点类型是否注册。这不仅让我们联想到，可能 Rtems 内部维护了一张全局表，专门用于记录目前已挂载的文件系统的信息。</p><p>rtems_filesystem_get_mount_handler() 的执行流程如下。</p> <pre class="mermaid">flowchart TD
    A[开始 rtems_filesystem_get_mount_handler] --> B{type 为空?}
    B -- 是 --> C[返回 NULL]
    B -- 否 --> D[遍历表 rtems_filesystem_table]
    D --> E{表项匹配?}
    E -- 是 --> F[返回对应 mount_h]
    E -- 否 --> G[遍历表 filesystem_chain]
    G --> H{表项匹配?}
    H -- 是 --> I[返回对应 mount_h]
    H -- 否 --> J[返回 NULL]</pre> <p>在 rtems_filesystem_iterate 函数中，可以发现 Rtems 定义了全局的两个表 filesystem_chain 和 rtems_filesystem_table。源码中无法直接跳转 filesystem_chain，目前无法得知他的具体状况。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rtems_chain_control *chain = &amp;filesystem_chain;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">rtems_filesystem_table_t</span> *table_entry = &amp;rtems_filesystem_table[<span class="number">0</span>];</span><br></pre></td></tr></table></div></figure><h4 id="variable-rtems-filesystem-table"><a href="#variable-rtems-filesystem-table" class="heading-link"><i class="fas fa-link"></i></a><a href="#variable-rtems-filesystem-table" class="headerlink" title="variable rtems_filesystem_table"></a>variable rtems_filesystem_table</h4><p>关于 rtems_filesystem_table，它用于表示挂载的文件系统的信息，并且猜测大概率是预挂载的文件系统的信息。结构体 rtems_filesystem_table_t 前面提到过，两个成员分别代表文件系统的类型名称 type 和文件系统的挂载函数指针 mount_h。</p><p>rtems_filesystem_table 的定义如下。其中关于 IMFS 有两个地方提到，一个是文件系统名字叫 “&#x2F;“ 的文件系统，一个是下面的 IMFS 文件系统。他们对应的挂载函数分别叫 IMFS_initialize_support() 和 IMFS_initialize()。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">rtems_filesystem_table_t</span> rtems_filesystem_table[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;/&quot;</span>, IMFS_initialize_support&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIGURE_FILESYSTEM_DOSFS</span></span><br><span class="line">    &#123;RTEMS_FILESYSTEM_TYPE_DOSFS, rtems_dosfs_initialize&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIGURE_FILESYSTEM_FTPFS</span></span><br><span class="line">    &#123;RTEMS_FILESYSTEM_TYPE_FTPFS, rtems_ftpfs_initialize&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIGURE_FILESYSTEM_IMFS</span></span><br><span class="line">    &#123;RTEMS_FILESYSTEM_TYPE_IMFS, IMFS_initialize&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIGURE_FILESYSTEM_JFFS2</span></span><br><span class="line">    &#123;RTEMS_FILESYSTEM_TYPE_JFFS2, rtems_jffs2_initialize&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIGURE_FILESYSTEM_NFS</span></span><br><span class="line">    &#123;RTEMS_FILESYSTEM_TYPE_NFS, rtems_nfs_initialize&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIGURE_FILESYSTEM_RFS</span></span><br><span class="line">    &#123;RTEMS_FILESYSTEM_TYPE_RFS, rtems_rfs_rtems_initialise&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIGURE_FILESYSTEM_TFTPFS</span></span><br><span class="line">    &#123;RTEMS_FILESYSTEM_TYPE_TFTPFS, rtems_tftpfs_initialize&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;&#125;;</span><br></pre></td></tr></table></div></figure><h3 id="IMFS-initialize-和-IMFS-initialize-support"><a href="#IMFS-initialize-和-IMFS-initialize-support" class="heading-link"><i class="fas fa-link"></i></a><a href="#IMFS-initialize-和-IMFS-initialize-support" class="headerlink" title="IMFS_initialize() 和 IMFS_initialize_support()"></a>IMFS_initialize() 和 IMFS_initialize_support()</h3><p>IMFS_initialize() 的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始 IMFS_initialize] --> B[调用 calloc 分配并清零 fs_info 内存]
    B --> C{fs_info 是否为 NULL}
    C -- 是 --> D[设置 errno 为 ENOMEM] --> E[返回 -1, 初始化失败]
    C -- 否 --> F[构造 IMFS_mount_data 结构体]
    F --> G[填入 fs_info 指针<br>填入文件系统操作集 &IMFS_ops<br>填入默认节点创建控制表 &IMFS_default_mknod_controls]
    G --> H[调用 IMFS_initialize_support 进行实际初始化和挂载]
    H --> I[返回初始化结果]</pre> <p>其中填充 IMFS_mount_data 结构体的代码截取如下，可以看出 rtems_filesystem_operations_table 结构体的回调函数是在这里被注册进去的。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    IMFS_fs_info_t *fs_info;</span><br><span class="line">    <span class="type">const</span> rtems_filesystem_operations_table *ops;</span><br><span class="line">    <span class="type">const</span> IMFS_mknod_controls *mknod_controls;</span><br><span class="line">&#125; IMFS_mount_data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造挂载所需的初始化数据结构，包括操作集和创建节点控制表。</span></span><br><span class="line">IMFS_mount_data mount_data = &#123;</span><br><span class="line">    .fs_info = fs_info,                            <span class="comment">// 文件系统内部信息。</span></span><br><span class="line">    .ops = &amp;IMFS_ops,                              <span class="comment">// 文件系统操作函数集合。</span></span><br><span class="line">    .mknod_controls = &amp;IMFS_default_mknod_controls <span class="comment">// 创建节点控制信息。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>IMFS_initialize() 最后会调用 IMFS_initialize_support()，IMFS_initialize_support() 的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始 IMFS_initialize_support 函数] --> B[将 data 转为 IMFS_mount_data 指针]
    B --> C[提取 fs_info 和 mknod_controls]
    C --> D[获取 node_control 和 root_node 指针]
    D --> E[设置挂载点 mt_entry 的各项字段, 包括 fs_info, ops, pathconf, root 节点信息]
    E --> F[调用 IMFS_initialize_node 初始化根目录节点]
    F --> G[断言 root_node 不为 NULL]
    G --> H[返回 0, 表示初始化成功]</pre> <p>这其中也做了很多赋值操作，代码片段截取如下。其中 _rtems_filesystem_file_handlers_r 结构体的回调函数是在这里注册进去的。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换传入的 data 参数为具体类型。</span></span><br><span class="line">mount_data = data;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取文件系统信息和 mknod 控制器。</span></span><br><span class="line">fs_info = mount_data-&gt;fs_info;</span><br><span class="line">fs_info-&gt;mknod_controls = mount_data-&gt;mknod_controls;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根目录所用的节点控制器。</span></span><br><span class="line">node_control = &amp;mount_data-&gt;mknod_controls-&gt;directory-&gt;node_control;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取根节点结构体的地址。</span></span><br><span class="line">root_node = &amp;fs_info-&gt;Root_directory.Node;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置挂载点结构 mt_entry 的基本信息。</span></span><br><span class="line">mt_entry-&gt;fs_info = fs_info;                                      <span class="comment">// 文件系统私有数据。</span></span><br><span class="line">mt_entry-&gt;ops = mount_data-&gt;ops;                                  <span class="comment">// 文件系统操作集。</span></span><br><span class="line">mt_entry-&gt;pathconf_limits_and_options = &amp;IMFS_LIMITS_AND_OPTIONS; <span class="comment">// 路径相关限制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置挂载根目录的节点访问和操作处理函数。</span></span><br><span class="line">mt_entry-&gt;mt_fs_root-&gt;location.node_access = root_node;</span><br><span class="line">mt_entry-&gt;mt_fs_root-&gt;location.handlers = node_control-&gt;handlers;</span><br></pre></td></tr></table></div></figure><h4 id="IMFS-initialize-node"><a href="#IMFS-initialize-node" class="heading-link"><i class="fas fa-link"></i></a><a href="#IMFS-initialize-node" class="headerlink" title="IMFS_initialize_node()"></a>IMFS_initialize_node()</h4><p>IMFS_initialize_support() 最后会调用 IMFS_initialize_node() 函数。该函数用于初始化一个 IMFS 节点（内存文件系统中的目录或文件节点）。根据传入的信息填充节点结构体的基本字段，并调用节点类型控制器提供的初始化回调。成功返回已初始化的节点指针，失败返回 NULL 并设置 errno。</p><p>IMFS_initialize_node() 的执行流程图如下：</p> <pre class="mermaid">flowchart TD
    A[开始 IMFS_initialize_node 函数] --> B{namelen 是否超过 IMFS_NAME_MAX}
    B -- 是 --> C[设置 errno 为 ENAMETOOLONG<br>返回 NULL]
    B -- 否 --> D[填充节点基本字段 name, namelen, reference_count, st_nlink, control]
    D --> E[设置权限和属主信息 mode, uid, gid]
    E --> F[获取当前时间 now]
    F --> G[设置时间戳 atime, mtime, ctime]
    G --> H[调用 node_control 的 node_initialize 回调]
    H --> I[返回初始化后的节点指针]</pre> <p>该函数在设置了节点 node 的信息以后，会调用 node_control 结构体的 node_initialize 回调函数进行 node 初始化。代码片段如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用节点控制器中定义的初始化函数以执行具体类型的初始化。</span></span><br><span class="line"><span class="keyword">return</span> (*node_control-&gt;node_initialize)(node, arg);</span><br></pre></td></tr></table></div></figure><h3 id="struct-IMFS-jnode-tt"><a href="#struct-IMFS-jnode-tt" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-IMFS-jnode-tt" class="headerlink" title="struct IMFS_jnode_tt"></a>struct IMFS_jnode_tt</h3><p>IMFS_jnode_tt 是 IMFS 自己设计的 inode 结构，作用和 Linux 中文件系统自己的 inode 结构效果相同，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMFS_jnode_tt 是 IMFS 文件系统中用于表示一个文件或目录的节点结构体。这是内存文件系统（IMFS）中最核心的数据结构之一，包含名称、权限、所有者、时间戳等元数据，以及指向父节点和控制操作的指针。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IMFS_jnode_tt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 用于将该节点链接入链表中。</span></span><br><span class="line">    rtems_chain_node Node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向父节点的指针。</span></span><br><span class="line">    IMFS_jnode_t *Parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点名称，不以 \0 结尾（即不是 C 字符串）。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点名称的长度（对应上面的 name）。</span></span><br><span class="line">    <span class="type">uint16_t</span> namelen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件类型和权限信息（如目录、常规文件、权限位）。</span></span><br><span class="line">    <span class="type">mode_t</span> st_mode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的引用计数，用于资源管理。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> reference_count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 硬链接数量（链接计数）。</span></span><br><span class="line">    <span class="type">nlink_t</span> st_nlink;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拥有者的用户 ID。</span></span><br><span class="line">    <span class="type">uid_t</span> st_uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拥有者的组 ID。</span></span><br><span class="line">    <span class="type">gid_t</span> st_gid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次访问时间。</span></span><br><span class="line">    <span class="type">time_t</span> stat_atime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次修改内容的时间。</span></span><br><span class="line">    <span class="type">time_t</span> stat_mtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次属性更改（如权限、所有者等）的时间。</span></span><br><span class="line">    <span class="type">time_t</span> stat_ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点控制器，定义节点的行为和操作函数。</span></span><br><span class="line">    <span class="type">const</span> IMFS_node_control *control;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h4 id="struct-IMFS-node-control"><a href="#struct-IMFS-node-control" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-IMFS-node-control" class="headerlink" title="struct IMFS_node_control"></a>struct IMFS_node_control</h4><p>struct IMFS_jnode_tt 中除了 inode 的基本信息以外，需要关注的一点就是 struct IMFS_node_control。该结构体定义了 IMFS inode 节点的操作函数，并作统一控制管理。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief IMFS node control.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// IMFS_node_control：定义 IMFS 节点类型的操作控制器。</span></span><br><span class="line"><span class="comment">// 每种节点类型（如普通文件、目录、符号链接等）可以拥有自己的 handlers 和初始化、销毁等函数指针。</span></span><br><span class="line"><span class="comment">// 该结构体允许 IMFS 在操作不同类型节点时通过回调机制实现多态行为。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 文件操作处理器集合，包含 open、read、write、ioctl 等函数指针。</span></span><br><span class="line">    <span class="comment">// 每种节点类型可以定义不同的 handlers。</span></span><br><span class="line">    <span class="type">const</span> rtems_filesystem_file_handlers_r *handlers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点初始化函数，在创建该类型节点时调用。</span></span><br><span class="line">    <span class="comment">// 通常在 IMFS_initialize_node 中调用，用于执行类型特定的初始化逻辑。</span></span><br><span class="line">    IMFS_node_control_initialize node_initialize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点删除函数，在执行 unlink/remove 操作时调用。</span></span><br><span class="line">    <span class="comment">// 用于处理节点类型特定的清理逻辑，如从父结构中移除等。</span></span><br><span class="line">    IMFS_node_control_remove node_remove;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点销毁函数，在释放节点内存或引用计数归零时调用。</span></span><br><span class="line">    <span class="comment">// 通常用于释放节点中私有数据或执行资源回收。</span></span><br><span class="line">    IMFS_node_control_destroy node_destroy;</span><br><span class="line">&#125; IMFS_node_control;</span><br></pre></td></tr></table></div></figure><p>前面提到，_rtems_filesystem_file_handlers_r 结构体的回调函数是在 IMFS_initialize_support() 中注册的，最终就来源于 IMFS_node_control 中的 rtems_filesystem_file_handlers_r *handlers。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt_entry-&gt;mt_fs_root-&gt;location.handlers = node_control-&gt;handlers;</span><br></pre></td></tr></table></div></figure><p>下一步就是找到这些函数最开始是在哪里被注册的。最终在 cpukit&#x2F;libfs&#x2F;src&#x2F;imfs&#x2F;imfs_linfile.c 中找到了答案：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> rtems_filesystem_file_handlers_r IMFS_linfile_handlers = &#123;</span><br><span class="line">    .open_h = IMFS_linfile_open,</span><br><span class="line">    .close_h = rtems_filesystem_default_close,</span><br><span class="line">    .read_h = IMFS_linfile_read,</span><br><span class="line">    .write_h = rtems_filesystem_default_write,</span><br><span class="line">    .ioctl_h = rtems_filesystem_default_ioctl,</span><br><span class="line">    .lseek_h = rtems_filesystem_default_lseek_file,</span><br><span class="line">    .fstat_h = IMFS_stat_file,</span><br><span class="line">    .ftruncate_h = rtems_filesystem_default_ftruncate,</span><br><span class="line">    .fsync_h = rtems_filesystem_default_fsync_or_fdatasync_success,</span><br><span class="line">    .fdatasync_h = rtems_filesystem_default_fsync_or_fdatasync_success,</span><br><span class="line">    .fcntl_h = rtems_filesystem_default_fcntl,</span><br><span class="line">    .kqfilter_h = rtems_filesystem_default_kqfilter,</span><br><span class="line">    .mmap_h = rtems_filesystem_default_mmap,</span><br><span class="line">    .poll_h = rtems_filesystem_default_poll,</span><br><span class="line">    .readv_h = rtems_filesystem_default_readv,</span><br><span class="line">    .writev_h = rtems_filesystem_default_writev&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> IMFS_node_control IMFS_node_control_linfile = &#123;</span><br><span class="line">    .handlers = &amp;IMFS_linfile_handlers,</span><br><span class="line">    .node_initialize = IMFS_node_initialize_linfile,</span><br><span class="line">    .node_remove = IMFS_node_remove_default,</span><br><span class="line">    .node_destroy = IMFS_node_destroy_default&#125;;</span><br></pre></td></tr></table></div></figure><h1 id="参考文档"><a href="#参考文档" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ol><li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://docs.rtems.org/docs/6.1/filesystem/index.html">RTEMS Filesystem Design Guide (6.1). — RTEMS Filesystem Design Guide 6.1 (22nd January 2025) documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li><li><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://geekdaxue.co/read/linggs@qnf7q6/pnhxbw">rtems文件系统部分 - 《ext4文件系统移植》 - 极客文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></li></ol></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://blog.davidingplus.cn">DavidingPlus</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://blog.davidingplus.cn/posts/4936fe45.html">https://blog.davidingplus.cn/posts/4936fe45.html</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-reward reward"><div class="reward-button">大爷，赏个铜板呗~~~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/images/reward/alipay.webp"><div class="reward-qrcode-alipay__text">支付宝</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/images/reward/wechat-pay.webp"><div class="reward-qrcode-wechat__text">微信</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-next"><a class="paginator-next__link" href="/posts/69869e7f.html"><span class="paginator-prev__text">Block Device Drivers</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Rtems-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB"><span class="toc-number">1.</span> <span class="toc-text">Rtems 源码阅读</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#open"><span class="toc-number">2.1.1.</span> <span class="toc-text">open()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-rtems-libio-t"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">struct rtems_libio_t</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-rtems-filesystem-location-info-t"><span class="toc-number">2.1.1.1.1.</span> <span class="toc-text">struct rtems_filesystem_location_info_t</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-rtems-filesystem-file-handlers-r"><span class="toc-number">2.1.1.1.2.</span> <span class="toc-text">struct rtems_filesystem_file_handlers_r</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#struct-rtems-filesystem-mount-table-entry-tt"><span class="toc-number">2.1.1.1.3.</span> <span class="toc-text">struct rtems_filesystem_mount_table_entry_tt</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtems-libio-allocate"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">rtems_libio_allocate()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#rtems-libio-iop-free-head"><span class="toc-number">2.1.1.2.1.</span> <span class="toc-text">rtems_libio_iop_free_head</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#do-open"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">do_open()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">2.1.1.3.1.</span> <span class="toc-text">路径解析过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84-open-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.3.2.</span> <span class="toc-text">底层文件系统的 open 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close"><span class="toc-number">2.1.2.</span> <span class="toc-text">close()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read"><span class="toc-number">2.1.3.</span> <span class="toc-text">read()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#write"><span class="toc-number">2.1.4.</span> <span class="toc-text">write()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">文件系统启动流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rtems-filesystem-initialize"><span class="toc-number">2.2.1.</span> <span class="toc-text">rtems_filesystem_initialize()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-rtems-filesystem-mount-configuration"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">struct rtems_filesystem_mount_configuration</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rtems-filesystem-register"><span class="toc-number">2.2.2.</span> <span class="toc-text">rtems_filesystem_register()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-filesystem-node"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">struct filesystem_node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-rtems-filesystem-table-t"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">struct rtems_filesystem_table_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rtems-filesystem-fsmount-me-t"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">rtems_filesystem_fsmount_me_t</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rtems-fsmount"><span class="toc-number">2.2.3.</span> <span class="toc-text">rtems_fsmount()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-rtems-fstab-entry"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">struct rtems_fstab_entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mount"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">mount()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IMFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.3.</span> <span class="toc-text">IMFS 文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rtems-filesystem-get-mount-handler"><span class="toc-number">2.3.1.</span> <span class="toc-text">rtems_filesystem_get_mount_handler()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#variable-rtems-filesystem-table"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">variable rtems_filesystem_table</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IMFS-initialize-%E5%92%8C-IMFS-initialize-support"><span class="toc-number">2.3.2.</span> <span class="toc-text">IMFS_initialize() 和 IMFS_initialize_support()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IMFS-initialize-node"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">IMFS_initialize_node()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#struct-IMFS-jnode-tt"><span class="toc-number">2.3.3.</span> <span class="toc-text">struct IMFS_jnode_tt</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-IMFS-node-control"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">struct IMFS_node_control</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3"><span class="toc-number">3.</span> <span class="toc-text">参考文档</span></a></li></ol></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/android-chrome-512x512.webp" alt="avatar"></div><p class="sidebar-ov-author__text">Self-discipline is key in life.</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/DavidingPlus" target="_blank" rel="noopener" data-popover="GitHub" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/qq/" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="/wechat/" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="mailto:davidingplus@qq.com" target="_blank" rel="noopener" data-popover="davidingplus@qq.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">36</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">20</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">您已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023~2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>DavidingPlus</span><span class="footer__devider">|</span><span>蜀 ICP 备 2024088070 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.6</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("09/18/2023 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小破站已经安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒啦！"}setInterval("createtime()",250)</script></div><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;theme&quot;:&quot;default&quot;}" src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/mermaid.min.js"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></div></footer><div class="loading-animation" id="loading-animation"><div class="loading-animation__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-thumbs-up"></i></span></div><div class="back2bottom" id="back2bottom"><span class="back2bottom__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"><div class="search-btns">使用搜索：<span class="search-btns-item search-btns-item--bing"><i></i>必应</span><span class="search-btns-item search-btns-item--baidu"><i></i>百度</span></div></div><div class="search-results"></div></div><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/jquery.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity-ui.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/canvas-nest.js" color="255,255,255" opacity="1" count="99" zindex="-1"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/fancybox.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/masonry.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/lazyload.js"></script><script>function initSearch(){var e=!0,t="search.json";t?/json$/i.test(t)&&(e=!1):t="search.xml";var n="/"+t;$.ajax({url:n,dataType:e?"xml":"json",async:!0,success:function(t){var n=e?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,o=$(".search-input input"),i=$(".search-results"),c=100,r=1,a=function(){var e=o.val().toLowerCase().trim(),t=e.split(/[\s]+/),a=[];t.length>1&&t.push(e),e.length>0&&n.forEach(function(e){var n=!1,o=e.title&&e.title.trim()||"[ 文章无标题 ]",i=o&&o.toLowerCase(),s=e.content&&e.content.replace(/<[^>]+>/g,""),l=s&&s.toLowerCase(),u=e.url&&decodeURI(e.url).replace(/\/{2,}/g,"/"),h=[],d=[];t.forEach(function(e){function t(e,t,n,o){if(!e||!t)return[];var i=0,c=-1,r=[];for(n||(e=e.toLowerCase(),t=t.toLowerCase());-1!==(c=t.indexOf(e,i));){var a=!1;h.forEach(function(t){t.index===c&&t.word.length<e.length&&(t.word=e,a=!0)}),i=c+e.length,!a&&r.push({index:c,word:e,weight:o})}return r}h=h.concat(t(e,i,!1,c)),d=d.concat(t(e,l,!1,r))});var f=h.length,p=d.length;if((f>0||p>0)&&(n=!0),n){function w(e,t,n,o){if(e&&t&&t.length){var i="",c=n,r=o;return t.forEach(function(t){if(!(t.index<c)){var n=t.index+t.word.length;i+=e.slice(c,t.index),i+="<b>"+e.slice(t.index,n)+"</b>",c=n}}),i+=e.slice(c,r)}}[h,d].forEach(function(e){e.sort(function(e,t){return e.index-t.index})});var v,g={},x=h.length*c+d.length*r,y=w(o,h,0,o.length)||o;if(d.length>0){var S=d[0].index;v=w(s,d,S>20?S-20:0,S+180)}else v=s.slice(0,200);g.title=y,g.content=v,g.url=u,g.weight=x,a.push(g)}});var s="";a.length?(a.sort(function(e,t){return t.weight-e.weight}),s+="<ul>",a.forEach(function(e){s+='<li><a class="search-results-title" href="'+e.url+'">',s+=e.title,s+='</a><div class="search-results-content">',s+=e.content,s+="</div></li>"}),s+="</ul>"):s+='<div class="search-results-none"><i class="far fa-meh"></i></div>',i.html(s)};o.on("input",a),o.on("keyup",function(e){e.keyCode===Stun.utils.codeToKeyCode("Enter")&&a()})}})}function closeSearch(){$("body").css({overflow:"auto"}),$(".search-popup").css({display:"none"}),$(".search-mask").css({display:"none"})}function safeOpenUrl(e){var t=window.open();t.opener=null,t.location=e}function extSearch(e){var t=window.location.host,n=$(".search-input input").val().toLowerCase().trim();n?safeOpenUrl({google:"https://www.google.com/search?q=",bing:"https://cn.bing.com/search?q=",baidu:"https://www.baidu.com/s?ie=UTF-8&wd="}[e]+n+" site:"+t):Stun.utils.popAlert("warning","请输入字符")}window.addEventListener("DOMContentLoaded",function(){Stun.utils.pjaxReloadLocalSearch=function(){$(".header-nav-search").on("click",function(e){e.stopPropagation(),$("body").css("overflow","hidden"),$(".search-popup").velocity("stop").velocity("transition.expandIn",{duration:300,complete:function(){$(".search-popup input").focus()}}),$(".search-mask").velocity("stop").velocity("transition.fadeIn",{duration:300}),initSearch()}),$(".search-mask, .search-close").on("click",function(){closeSearch()}),$(document).on("keydown",function(e){e.keyCode===Stun.utils.codeToKeyCode("Escape")&&closeSearch()})},Stun.utils.pjaxReloadLocalSearch()},!1);var assistSearchList=window.CONFIG.assistSearch;Array.isArray(assistSearchList)&&assistSearchList.forEach(function(e){document.querySelector(".search-btns-item--"+e).addEventListener("click",function(){extSearch(e)},!1)})</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/pjax.js"></script><script>window.addEventListener("DOMContentLoaded",function(){new Pjax({selectors:["head title","#main",".pjax-reload",".header-banner"],history:!0,scrollTo:!1,scrollRestoration:!1,cacheBust:!1,debug:!1,currentUrlFullReload:!1,timeout:0});document.addEventListener("pjax:send",function(){$(".header-nav-menu").removeClass("show"),CONFIG.pjax&&CONFIG.pjax.avoidBanner&&$("html").velocity("scroll",{duration:500,offset:$("#header").height(),easing:"easeInOutCubic"}),$(".loading-animation").addClass("loading")},!1),window.addEventListener("pjax:complete",function(){if($(".loading-animation").removeClass("loading"),$("link[rel=prefetch], script[data-pjax-rm]").each(function(){$(this).remove()}),$("script[data-pjax], #pjax-reload script").each(function(){$(this).parent().append($(this).remove())}),Stun.utils.pjaxReloadBoot&&Stun.utils.pjaxReloadBoot(),Stun.utils.pjaxReloadScroll&&Stun.utils.pjaxReloadScroll(),Stun.utils.pjaxReloadSidebar&&Stun.utils.pjaxReloadSidebar(),"undefined"!=typeof mermaid){const e=Array.from(document.querySelectorAll(".mermaid")).filter(e=>!e.dataset.processed);mermaid.init(void 0,e)}},!1)},!1)</script><div id="pjax-reload"><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/quicklink.js"></script><script>function initQuicklink(){quicklink({timeout:"10000",priority:!0,ignores:[i=>i.includes("#"),i=>"https://blog.davidingplus.cn/posts/4936fe45.html"===i,/\/api\/?/,i=>i.includes(".xml"),i=>i.includes(".zip"),(i,t)=>t.hasAttribute("nofollow"),(i,t)=>t.hasAttribute("noprefetch")]})}initQuicklink()</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/busuanzi.js" async></script></div><script src="/js/utils.js?v=2.8.6"></script><script src="/js/stun-boot.js?v=2.8.6"></script><script src="/js/scroll.js?v=2.8.6"></script><script src="/js/header.js?v=2.8.6"></script><script src="/js/sidebar.js?v=2.8.6"></script><script type="application/json" src="/search.json"></script><script data-pjax="">function loadUtterances(){var t=document,e=t.createElement("script"),s=t.getElementById("utterances-container"),r=Stun.utils.getNightMode()?"photon-dark":"github-light";s&&(e.src="https://utteranc.es/client.js",e.setAttribute("repo","DavidingPlus/blog-comments"),e.setAttribute("issue-term","title"),e.setAttribute("label","utterances"),e.setAttribute("theme",r),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),e.setAttribute("data-pjax-rm",""),s.append(e))}loadUtterances()</script><script async src="/js/cursor/text.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="🤡快回来,粗大事了~~"+OriginTitile,clearTimeout(titleTime)):(document.title="😚欢迎回来!~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:160,height:290},mobile:{show:!0},log:!1})</script></body></html>