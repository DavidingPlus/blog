<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><script>window.MSInputMethodContext&&document.documentMode&&(window.location.href="https://support.dmeng.net/upgrade-your-browser.html")</script><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/favicon-16x16.webp?v=2.8.6" type="image/png" sizes="16x16"><link rel="icon" href="/assets/favicon-32x32.webp?v=2.8.6" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/assets/apple-touch-icon.webp?v=2.8.6" sizes="180x180"><meta name="description" content="笔记摘抄自 Linux 内核教学 — Linux 系统内核文档 的 VFS 部分，并总结记录。                     虚拟文件系统（VFS）       虚拟文件系统（VFS）是内核的组件，处理所有与文件和文件系统相关的系统调用。VFS 是用户与特定文件系统之间的通用接口。这种抽象简化了文件系统的实现，使得各种文件系统更容易集成。各种文件系统通过使用 VFS 提供的 API"><meta property="og:type" content="article"><meta property="og:title" content="Virtual Filesystem"><meta property="og:url" content="https://blog.davidingplus.cn/posts/68b0f3fd.html"><meta property="og:site_name" content="DavidingPlus&#39;s Blog"><meta property="og:description" content="笔记摘抄自 Linux 内核教学 — Linux 系统内核文档 的 VFS 部分，并总结记录。                     虚拟文件系统（VFS）       虚拟文件系统（VFS）是内核的组件，处理所有与文件和文件系统相关的系统调用。VFS 是用户与特定文件系统之间的通用接口。这种抽象简化了文件系统的实现，使得各种文件系统更容易集成。各种文件系统通过使用 VFS 提供的 API"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227142615377.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227143348812.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227120407496.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227141716401.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227145405084.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230094606623.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230101507978.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230102023524.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230104309655.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230103801350.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230102953331.png"><meta property="article:published_time" content="2024-12-24T16:05:00.000Z"><meta property="article:modified_time" content="2024-12-31T16:00:00.000Z"><meta property="article:author" content="DavidingPlus"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227142615377.png"><title>Virtual Filesystem | DavidingPlus's Blog</title><link ref="canonical" href="https://blog.davidingplus.cn/posts/68b0f3fd.html"><link rel="dns-prefetch" href="https://cdn.davidingplus.cn"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fontawesome.css" type="text/css"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fancybox.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.6"><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,assistSearch:["bing","baidu"],fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"55px",tocMaxDepth:6},header:{enable:!0,showOnPost:!0,scrollDownIcon:!0},postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},back2bottom:{enable:!0},codeblock:{style:"default",highlight:"light",wordWrap:!0},reward:!0,fancybox:!0,zoomImage:{gapAside:"20px"},galleryWaterfall:{colWidth:"255px",gapX:"65px"},lazyload:!0,pjax:{avoidBanner:!0},externalLink:{icon:{enable:!0,name:"fas fa-external-link-alt"}},shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"恭喜亲亲，复制成功咧",copyError:"哎呀，复制失败了"},sourcePath:{js:"js",css:"css",images:"images"},utterancesTheme:{light:"github-light",dark:"photon-dark"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-bars"></i></span><span class="header-nav-menu-item__text">其他</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/friends/"><span class="header-nav-submenu-item__icon"><i class="fas fa-users"></i></span><span class="header-nav-submenu-item__text">友链</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/gallery/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" target="_blank" rel="noopener" href="https://davidingplus.cn/"><span class="header-nav-menu-item__icon"><i class="fas fa-pager"></i></span><span class="header-nav-menu-item__text">站点主页</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">DavidingPlus's Blog</div><div class="header-banner-info__subtitle">🕊️ world peace</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">Virtual Filesystem</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2024-12-24</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2024-12-31</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">13.7k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">91分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><meta name="referrer" content="no-referrer"><p>笔记摘抄自 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://linux-kernel-labs-zh.xyz/">Linux 内核教学 — Linux 系统内核文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 的 VFS 部分，并总结记录。</p><h1 id="虚拟文件系统（VFS）"><a href="#虚拟文件系统（VFS）" class="heading-link"><i class="fas fa-link"></i></a><a href="#虚拟文件系统（VFS）" class="headerlink" title="虚拟文件系统（VFS）"></a>虚拟文件系统（VFS）</h1><p>虚拟文件系统（VFS）是内核的组件，处理所有与文件和文件系统相关的系统调用。VFS 是用户与特定文件系统之间的通用接口。这种抽象简化了文件系统的实现，使得各种文件系统更容易集成。各种文件系统通过使用 VFS 提供的 API 来实现文件系统，通用硬件以及 I&#x2F;O 子系统的通信部分由 VFS 处理。</p><p>文件系统按照功能可分为：</p><ol><li>磁盘文件系统（ext3、ext4、xfs、fat 以及 ntfs 等）。</li><li>网络文件系统（nfs、smbfs&#x2F;cifs、ncp 等）。</li><li>虚拟文件系统（procfs、sysfs、sockfs、pipefs 等）。</li></ol><span id="more"></span><p>Linux 内核使用 VFS 处理目录和文件的层次结构（其实是一棵树）。通过挂载操作，新的文件系统被添加为 VFS 子树。文件系统通常是从其所对应的环境中挂载的（从块类型设备、网络等）。<strong>然而 VFS 可以将普通文件作为虚拟块设备使用，可以将普通文件挂载为磁盘文件系统。</strong></p><p>VFS 的基本思想是提供可以表示任何文件系统文件的单一文件模型。文件系统驱动程序需要遵守公共的基准。这样，内核可以创建包含整个系统的单一目录结构。其中一个文件系统将作为根文件系统，其他文件系统将挂载在其各个目录下。</p><h1 id="存储栈整体结构"><a href="#存储栈整体结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#存储栈整体结构" class="headerlink" title="存储栈整体结构"></a>存储栈整体结构</h1><p>Linux 存储栈的整体结构图如下。从上到下分别是：<strong>VFS、通用块层、SCSI 层、块设备层</strong>。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227142615377.png" alt="image-20241227142615377" style="zoom:75%"><p>各个层次的作用如下。</p><ol><li><p>VFS：VFS 层是 Linux 最为津津乐道的设计，也就是所谓的一切皆文件。它通过统一的接口，底层封装了各种各样的文件系统。</p></li><li><p>通用块层：文件系统将读&#x2F;写请求转换成 bio 和 request，提交给通用块层，通用块层对 request 进行调度，发往下一层。</p></li></ol><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227143348812.png" alt="image-20241227143348812" style="zoom:80%"><ol start="3"><li><p>SCSI 层：SCSI（Small Computer Systems Interface）是一组标准集，定义了与大量设备（主要是与存储相关的设备）通信所需的接口和协议。Linux 提供了一种 SCSI 子系统，用于与这些设备通信。</p></li><li><p>块设备层：块设备层负责对某种具体的物理设备进行处理，完成相应的读写请求。</p></li></ol><h1 id="常见的文件系统模型"><a href="#常见的文件系统模型" class="heading-link"><i class="fas fa-link"></i></a><a href="#常见的文件系统模型" class="headerlink" title="常见的文件系统模型"></a>常见的文件系统模型</h1><p>任何实现的文件系统都需要包含这几种明确定义的类型：super_block、inode、file 和 dentry。这些也是文件系统的元数据。</p><p>模型实体间通过某些 VFS 子系统或内核子系统进行交互：dentry cache（目录项缓存）、inode cache（索引节点缓存）和 buffer cache（缓冲区缓存）。每个实体都被视为对象，具有关联的数据结构和指向方法表的指针。通过替换关联的方法来为每个组件引入特定的行为（类似于 C++ 的多态）。</p><h2 id="super-block"><a href="#super-block" class="heading-link"><i class="fas fa-link"></i></a><a href="#super-block" class="headerlink" title="super_block"></a>super_block</h2><p><strong>super_block 超级块存储挂载文件系统需要的信息。</strong>具体如下：</p><ol><li>inode 和块的位置。</li><li>文件系统块大小。</li><li>最大文件名长度。</li><li>最大文件大小。</li><li>根 inode 的位置。</li></ol><p>磁盘上的 super_block 通常存储在磁盘的第一个块中，即文件系统控制块。</p><p>在 VFS 中，super_block 实体都保留在类型为 <code>struct super_block</code> 的结构列表中，方法则保留在类型为 <code>struct super_operations</code> 的结构中。</p><h2 id="inode"><a href="#inode" class="heading-link"><i class="fas fa-link"></i></a><a href="#inode" class="headerlink" title="inode"></a>inode</h2><p><strong>inode 索引节点存储有关文件的信息。</strong>这里的文件泛指意义上的文件，常规文件、目录、特殊文件（如管道、fifo 等）、块设备、字符设备、链接或可以抽象为文件的任何内容都包括在内。</p><p>inode 存储了以下信息：</p><ol><li>文件类型。</li><li>文件大小。</li><li>访问权限。</li><li>访问或修改时间。</li><li>数据在磁盘上的位置（指向包含数据的磁盘块的指针）。</li></ol><blockquote><p>inode 通常不包含文件名。文件名由 dentry 存储。一个 inode 可以有多个名称（如多个硬链接文件指向同一个 inode）。</p></blockquote><p>磁盘上的 inode 通常分组存储在一个专用的 inode 区域中，与数据区域分开。</p><p>在 VFS 中，inode 实体由 <code>struct inode</code> 结构表示，由 <code>struct inode_operations</code> 结构定义与之相关的操作。</p><h2 id="file"><a href="#file" class="heading-link"><i class="fas fa-link"></i></a><a href="#file" class="headerlink" title="file"></a>file</h2><p>file 是文件系统模型中距离用户最近的组件。<strong>inode 抽象了磁盘上的文件，file 抽象了进程打开的文件。</strong>与其他结构不同的是，file 结构体在内存中作为 VFS 的实体存在，但没有在磁盘上的物理物对应。</p><p>file 存储了以下信息：</p><ol><li>文件游标位置。</li><li>文件打开权限。</li><li>指向关联 inode 的指针（inode 的索引）。</li></ol><p>在 VFS 中，file 实体由 <code>struct file</code> 结构表示，与之相关的操作由 <code>struct file_operations</code> 结构表示。</p><h2 id="dentry"><a href="#dentry" class="heading-link"><i class="fas fa-link"></i></a><a href="#dentry" class="headerlink" title="dentry"></a>dentry</h2><p><strong>dentry 将 inode 和 文件名关联起来。</strong>存储以下信息：</p><ol><li>用于标识 inode 的整数。</li><li>表示文件名的字符串。</li></ol><p>dentry 是目录或文件路径的特定部分。例如，对于路径 <code>/bin/vi</code>，为 <code>/</code>、<code>bin</code> 和 <code>vi</code> 创建共 3 个 dentry 对象。</p><p>dentry 在磁盘上有对应物，但对应关系不是直接的。每个文件系统都有特定的方式维护 dentry。</p><p>在 VFS 中，dentry 实体由 <code>struct dentry</code> 结构表示，与之相关的操作在 <code>struct dentry_operations</code> 结构中定义。</p><h2 id="其他数据结构"><a href="#其他数据结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#其他数据结构" class="headerlink" title="其他数据结构"></a>其他数据结构</h2><p>除了上述，VFS 中还有一些数据结构。</p><ol><li>address_space&#x2F;mapping：表示一个文件缓存，结构体的名字称为 address_space。但在其它结构体中被引用时，该指针的名字通常是 mapping。</li><li>mount：表示一个文件系统被挂载的信息。</li><li>file_system_type：表示一个文件系统类型，例如 ext4、proc、sys 等。</li></ol><h1 id="注册和注销文件系统"><a href="#注册和注销文件系统" class="heading-link"><i class="fas fa-link"></i></a><a href="#注册和注销文件系统" class="headerlink" title="注册和注销文件系统"></a>注册和注销文件系统</h1><h2 id="struct-file-system-type"><a href="#struct-file-system-type" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-file-system-type" class="headerlink" title="struct file_system_type"></a>struct file_system_type</h2><p>Linux 内核支持很多文件系统，包括 ext2&#x2F;ext4、reiserfs、xfs、fat、ntfs 等。但在单个系统上，不太可能超过 5&#x2F;6 个文件系统。文件系统在内核中被实现为内核模块，可以动态的加载和卸载。</p><p>描述特定文件系统的结构是 <code>struct file_system_type</code>，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// linux/fs.h</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 表示该文件系统的名称（传递给 mount -t 的参数）。</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定文件系统必须以哪些标志挂载。例如标志 FS_REQUIRES_DEV，指定 VFS 文件系统需要一个磁盘（而不是虚拟文件系统）</span></span><br><span class="line">    <span class="type">int</span> fs_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在加载文件系统时从磁盘中读取超级块到内存中。每种文件系统的函数都是独一无二的。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *(*<span class="title">mount</span>)(<span class="keyword">struct</span> <span class="title">file_system_type</span> *, <span class="title">int</span>, <span class="title">const</span> <span class="title">char</span> *, <span class="title">void</span> *);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存中的超级块。</span></span><br><span class="line">    <span class="type">void</span> (*kill_sb)(<span class="keyword">struct</span> super_block *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是内核模块实现，则为 THIS_MODULE。如果直接写在内核中，则为 NULL。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个列表，包含与该文件系统关联的所有超级块。由于同一文件系统可能会被多次挂载，因此每个挂载点都会有一个单独的超级块。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">fs_supers</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_lock_key</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> <span class="title">s_umount_key</span>;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>内核中的所有 file_system_type 都是通过一根单向链表组织起来的，register_filesystem() 函数负责将新的 file_system_type 加入到这个链表中。</p><p>每个文件系统类型下都挂载了多个文件系统，比如 sda、sdb 都是 ext4 文件系统，这些 super_block 以链表的形式连接到 <code>file_system_type-&gt;fs_supers</code> 字段中。系统中所有的 super_block 也是通过一根双向链表进行连接。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227120407496.png" alt="image-20241227120407496" style="zoom:75%"><p>在模块加载函数中，将文件系统注册到内核，需要做以下几步：</p><ol><li>初始化 <code>struct file_system_type</code> 结构体类型的实体，并填充相应的字段以及回调函数。</li><li>调用 register_filesystem() 函数。</li></ol><p>例如，ramfs 的部分代码如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> <span class="title">ramfs_fs_type</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;ramfs&quot;</span>,</span><br><span class="line">    .mount = ramfs_mount,</span><br><span class="line">    .kill_sb = ramfs_kill_sb,</span><br><span class="line">    .fs_flags = FS_USERNS_MOUNT,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_ramfs_fs</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (test_and_set_bit(<span class="number">0</span>, &amp;once)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> register_filesystem(&amp;ramfs_fs_type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="mount-和-kill-sb"><a href="#mount-和-kill-sb" class="heading-link"><i class="fas fa-link"></i></a><a href="#mount-和-kill-sb" class="headerlink" title="mount() 和 kill_sb()"></a>mount() 和 kill_sb()</h2><p>加载文件系统时，内核调用 <code>struct file_system_type</code> 结构定义的 mount() 函数。此函数对每个文件系统都是唯一的，进行初始化操作以后返回挂载点的目录 dentry 指针。mount() 函数一般会调用以下函数之一：</p><ol><li>mount_bdev()：挂载存储在块设备上的文件系统。</li><li>mount_single()：挂载一个在所有挂载操作之间是共享实例的文件系统。</li><li>mount_nodev()：挂载不在物理设备上的文件系统。</li><li>mount_pseudo()：用于伪文件系统的辅助函数（如 sockfs、pipefs 等无法被挂载的文件系统）。</li></ol><p>这些函数的其中一个参数是指向 fill_super() 函数的指针，该函数在超级块初始化后被调用，借助驱动程序完成超级块的初始化。</p><p>卸载文件系统时，内核调用 kill_sb() 函数，执行清理动作。kill_sb() 函数一般会调用以下函数之一：</p><ol><li>kill_block_super()：卸载块设备上的文件系统。</li><li>kill_anon_super()：卸载虚拟文件系统（当请求时生成信息）。</li><li>kill_litter_super()：卸载不在物理设备上的文件系统（信息保存在内存中）。</li></ol><p>对没有磁盘支持的文件系统，一个实例是 ramfs 文件系统的 ramfs_mount() 函数：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">ramfs_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> mount_nodev(fs_type, flags, data, ramfs_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>对来自磁盘的文件系统，一个实例是 minix 文件系统的 minix_mount() 函数：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dentry *<span class="title function_">minix_mount</span><span class="params">(<span class="keyword">struct</span> file_system_type *fs_type, <span class="type">int</span> flags, <span class="type">const</span> <span class="type">char</span> *dev_name, <span class="type">void</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> mount_bdev(fs_type, flags, dev_name, data, minix_fill_super);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="super-block-1"><a href="#super-block-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#super-block-1" class="headerlink" title="super_block"></a>super_block</h1><h2 id="struct-super-block"><a href="#struct-super-block" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-super-block" class="headerlink" title="struct super_block"></a>struct super_block</h2><p>超级块作为物理实体（磁盘上的实体）存在，也作为 VFS 实体（<code>struct super_block</code> 结构）存在。超级块仅包含元信息，并用于从磁盘中读取和写入元数据（如 inode、目录项）。超级块及 <code>struct super_block</code> 结构包含有关所使用的块设备、inode 列表、文件系统根目录的 inode 指针以及超级块操作的指针的信息。</p><p>struct super_block 定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> s_dev;                     <span class="comment">// 标识符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s_blocksize_bits;  <span class="comment">// 块大小（以位为单位）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s_blocksize;       <span class="comment">// 块大小（以字节为单位）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> s_dirt;            <span class="comment">// 脏标志</span></span><br><span class="line">    <span class="type">loff_t</span> s_maxbytes;               <span class="comment">// 最大文件大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_system_type</span> *<span class="title">s_type</span>;</span> <span class="comment">// 文件系统类型</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> *<span class="title">s_op</span>;</span>   <span class="comment">// 超级块方法</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s_flags; <span class="comment">// 挂载标志</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> s_magic; <span class="comment">// 文件系统的魔数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">s_root</span>;</span> <span class="comment">// 目录挂载点</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> s_id[<span class="number">32</span>];   <span class="comment">// 信息标识符</span></span><br><span class="line">    <span class="type">void</span> *s_fs_info; <span class="comment">// 文件系统私有信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>超级块存储了文件系统的全局信息：</p><ol><li>所使用的物理设备。</li><li>块大小。</li><li>文件的最大大小。</li><li>文件系统类型。</li><li>支持的操作。</li><li>魔数（用于标识文件系统）。</li><li>根目录的 dentry。</li></ol><p>另外，<code>void *s_fs_info</code> 可用于存储文件系统的私有数据，具体实现时候可加入自己的数据。类似于 <code>struct file</code> 的 <code>void *private_data</code>。</p><h2 id="super-block-操作"><a href="#super-block-操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#super-block-操作" class="headerlink" title="super_block 操作"></a>super_block 操作</h2><p>超级块操作由 super_block 描述，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入与 inode 相关的资源。</span></span><br><span class="line">    <span class="type">int</span> (*write_inode)(<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配与 inode 相关的资源。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">alloc_inode</span>)(<span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">sb</span>);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放与 inode 相关的资源。</span></span><br><span class="line">    <span class="type">void</span> (*destroy_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 卸载时调用，释放文件系统私有数据的任何资源（通常是内存）。</span></span><br><span class="line">    <span class="type">void</span> (*put_super)(<span class="keyword">struct</span> super_block *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在执行 statfs 系统调用时调用（尝试 stat - f 或 df）。此调用必须填充 struct kstatfs 结构的字段，就像在 ext4_statfs() 函数中所做的那样。</span></span><br><span class="line">    <span class="type">int</span> (*statfs)(<span class="keyword">struct</span> dentry *, <span class="keyword">struct</span> kstatfs *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在内核检测到重新挂载尝试（挂载标志 MS_REMOUNTM）时调用。大部分情况下，需要检测是否尝试从只读切换到读写或反之。这可以简单地通过访问旧标志（在 sb-&gt;s_flags 中）和新标志 (flags 参数) 来完成。data 是由 mount() 发送的表示文件系统特定选项的数据的指针。</span></span><br><span class="line">    <span class="type">int</span> (*remount_fs)(<span class="keyword">struct</span> super_block *, <span class="type">int</span> *, <span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h1 id="fill-super"><a href="#fill-super" class="heading-link"><i class="fas fa-link"></i></a><a href="#fill-super" class="headerlink" title="fill_super()"></a>fill_super()</h1><p>fill_super() 函数用于在文件系统加载时的 mount() 函数中调用，<strong>用于超级块初始化的最后一段，包括填充 struct super_block 字段和根目录的 inode 结构的初始化</strong>。</p><p>一个实例是 ramfs_fill_super() 函数：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/pagemap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RAMFS_MAGIC 0x858458f6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">super_operations</span> <span class="title">ramfs_ops</span> =</span> &#123;</span><br><span class="line">    .statfs = simple_statfs,</span><br><span class="line">    .drop_inode = generic_delete_inode,</span><br><span class="line">    .show_options = ramfs_show_options,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ramfs_fill_super</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">void</span> *data, <span class="type">int</span> silent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ramfs_fs_info</span> *<span class="title">fsi</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    save_mount_options(sb, data);</span><br><span class="line"></span><br><span class="line">    fsi = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ramfs_fs_info), GFP_KERNEL);</span><br><span class="line">    sb-&gt;s_fs_info = fsi;</span><br><span class="line">    <span class="keyword">if</span> (!fsi)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    err = ramfs_parse_options(data, &amp;fsi-&gt;mount_opts);</span><br><span class="line">    <span class="keyword">if</span> (err)</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span><br><span class="line">    sb-&gt;s_blocksize = PAGE_SIZE;</span><br><span class="line">    sb-&gt;s_blocksize_bits = PAGE_SHIFT;</span><br><span class="line">    sb-&gt;s_magic = RAMFS_MAGIC;</span><br><span class="line">    sb-&gt;s_op = &amp;ramfs_ops;</span><br><span class="line">    sb-&gt;s_time_gran = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    inode = ramfs_get_inode(sb, <span class="literal">NULL</span>, S_IFDIR | fsi-&gt;mount_opts.mode, <span class="number">0</span>);</span><br><span class="line">    sb-&gt;s_root = d_make_root(inode);</span><br><span class="line">    <span class="keyword">if</span> (!sb-&gt;s_root)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>内核提供了一些实现文件系统结构的通用函数，例如上面的 generic_delete_inode() 和 simple_statfs()。</p><p>上面的 ramfs_fill_super() 函数填充了超级块中的一些字段，然后读取根 inode 并分配根 dentry。读取根 inode 在 ramfs_get_inode() 函数中完成，包括使用 new_inode() 函数分配新的 inode 并进行初始化。为了释放 inode，使用了 iput()，并使用 d_make_root() 函数分配根 dentry。</p><p>VFS 函数通常以超级块、索引节点或包含指向超级块的指针的目录项作为实参，以便能够轻松访问这些私有数据。</p><h1 id="缓冲区缓存"><a href="#缓冲区缓存" class="heading-link"><i class="fas fa-link"></i></a><a href="#缓冲区缓存" class="headerlink" title="缓冲区缓存"></a>缓冲区缓存</h1><p><strong>缓冲区缓存是处理块设备读写缓存的内核子系统。</strong>磁盘文件系统的功能与虚拟文件系统类似，唯一区别是使用了缓冲区缓存。基本结构体是 <code>struct buffer_head</code>，定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> b_state;           <span class="comment">// 缓冲区的状态。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">b_this_page</span>;</span> <span class="comment">// circular list of page&#x27;s buffers</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">b_page</span>;</span>             <span class="comment">// the page this bh is mapped to</span></span><br><span class="line"></span><br><span class="line">    <span class="type">sector_t</span> b_blocknr; <span class="comment">// 已加载或需要保存在磁盘上的设备的块号。</span></span><br><span class="line">    <span class="type">size_t</span> b_size;      <span class="comment">// 缓冲区大小。</span></span><br><span class="line">    <span class="type">char</span> *b_data;       <span class="comment">// 指向读取数据或写入数据的内存区域的指针。</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">block_device</span> *<span class="title">b_bdev</span>;</span>       <span class="comment">// 块设备。</span></span><br><span class="line">    <span class="type">bh_end_io_t</span> *b_end_io;             <span class="comment">// I/O completion</span></span><br><span class="line">    <span class="type">void</span> *b_private;                   <span class="comment">// reserved for b_end_io</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">b_assoc_buffers</span>;</span>  <span class="comment">// associated with another mapping</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">b_assoc_map</span>;</span> <span class="comment">// mapping this buffer is associated with</span></span><br><span class="line">    <span class="type">atomic_t</span> b_count;                  <span class="comment">// users using this buffer_head</span></span><br><span class="line">    <span class="type">spinlock_t</span> b_uptodate_lock;        <span class="comment">// Used by the first bh in a page, to serialise IO completion of other buffers in the page</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>以下函数一般会与 <code>struct buffer_head</code> 一起使用：</p><ol><li><code>__bread()</code>：读取具有给定编号和给定大小的块到一个 <code>struct buffer_head</code> 中。如果成功，则返回指向 <code>struct buffer_head</code> 的指针，否则返回 NULL。</li><li>sb_bread()：与前一个函数相同，但读取的块的大小从超级块中获取，读取的设备也从超级块中获取。</li><li>mark_buffer_dirty()：将缓冲区标记为脏（设置 BH_Dirty 位）。缓冲区将在稍后的时间写入磁盘 (bdflush 内核线程会定期唤醒并将缓冲区写入磁盘)。</li><li>brelse()：在先前将缓冲区写入磁盘（如果需要）后，释放缓冲区使用的内存。</li><li>map_bh()：将 buffer-head 与相应的扇区关联。</li></ol><h1 id="函数和有用的宏"><a href="#函数和有用的宏" class="heading-link"><i class="fas fa-link"></i></a><a href="#函数和有用的宏" class="headerlink" title="函数和有用的宏"></a>函数和有用的宏</h1><p>超级块通常包含以位图（位向量）形式表示的占用块的映射（索引节点、目录条目、数据占用）。为处理这种映射，建议使用以下功能：</p><ol><li>find_first_zero_bit()：用于在内存区域中查找第一个为零的位。size 参数表示搜索区域中的位数。</li><li>test_and_set_bit()：设置位并获取旧值。</li><li>test_and_clear_bit()：删除位并获取旧值。</li><li>test_and_change_bit()：取反位的值并获取旧值。</li></ol><p>以下宏定义可用于验证索引节点的类型：</p><ol><li>S_ISDIR(inode-&gt;i_mode)：用于检查索引节点是否为目录。</li><li>S_ISREG(inode-&gt;i_mode)：用于检查索引节点是否为普通文件（非链接或设备文件）。</li></ol><h1 id="inode-1"><a href="#inode-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#inode-1" class="headerlink" title="inode"></a>inode</h1><p>inode 是文件系统的元数据（它包含信息的信息）。inode 是磁盘上文件的唯一标识，保存文件的信息（uid、gid、访问权限、访问时间以及指向数据块的指针等）。重要的一点是，inode 不保存文件名信息，文件名由相关的 <code>struct dentry</code> 结构保存。</p><p>inode 用于引用磁盘上的文件。对于进程打开的文件，使用 <code>struct file</code> 结构。一个 inode 可以关联一个或多个 <code>struct file</code> 结构。多个进程可以打开同一个文件，一个进程可以多次打开同一个文件。</p><p>inode 既存在于内存中的 VFS 结构，也存在于磁盘中（UNIX、HFS 以及 NTFS 等）。VFS 中的 inode 由 <code>struct inode</code> 结构表示。和 VFS 中的其他结构一样，<code>struct inode</code> 是通用结构，涵盖了所有支持的文件类型的选项，甚至包括那些没有关联磁盘实体的文件类型（例如 FAT 文件系统）。</p><h2 id="struct-inode"><a href="#struct-inode" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-inode" class="headerlink" title="struct inode"></a>struct inode</h2><p><code>struct inode</code> 定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">umode_t</span> i_mode; <span class="comment">// i_uid 以及 i_gid：访问权限、uid 以及 gid。</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> i_opflags;</span><br><span class="line">    <span class="type">kuid_t</span> i_uid;</span><br><span class="line">    <span class="type">kgid_t</span> i_gid;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> i_flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_POSIX_ACL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> *<span class="title">i_acl</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">posix_acl</span> *<span class="title">i_default_acl</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> *<span class="title">i_op</span>;</span> <span class="comment">// 指向结构 inode_operations 的指针。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">i_sb</span>;</span>            <span class="comment">// inode 所属的文件系统的超级块结构。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">i_mapping</span>;</span>     <span class="comment">// i_mapping-&gt;a_ops 包含指向 struct address_space_operations 的指针。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">    <span class="type">void</span> *i_security;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Stat data, not accessed from path walking */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i_ino; <span class="comment">// inode 的编号（在文件系统内唯一标识 inode）。</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Filesystems may only read i_nlink directly.  They shall use the</span></span><br><span class="line"><span class="comment">     * following functions for modification:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *    (set|clear|inc|drop)_nlink</span></span><br><span class="line"><span class="comment">     *    inode_(inc|dec)_link_count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用此 inode 的名称条目（dentry）的数量；对于没有链接（既没有硬链接也没有符号链接）的文件系统，这个值总是设置为 1。</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="type">unsigned</span> <span class="type">int</span> i_nlink;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> __i_nlink;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">dev_t</span> i_rdev;              <span class="comment">// 挂载的文件系统所在的设备。</span></span><br><span class="line">    <span class="type">loff_t</span> i_size;             <span class="comment">// 文件/目录等的大小（以字节为单位）。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">i_atime</span>;</span> <span class="comment">// 访问时间。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">i_mtime</span>;</span> <span class="comment">// 修改时间。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timespec64</span> <span class="title">i_ctime</span>;</span> <span class="comment">// 创建时间。</span></span><br><span class="line">    <span class="type">spinlock_t</span> i_lock;         <span class="comment">/* i_blocks, i_bytes, maybe i_size */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> i_bytes;</span><br><span class="line">    u8 i_blkbits; <span class="comment">// 块大小使用的比特数 == log2(块大小)。</span></span><br><span class="line">    u8 i_write_hint;</span><br><span class="line">    <span class="type">blkcnt_t</span> i_blocks; <span class="comment">// 文件使用的块数（所有块，不仅仅是数据块）。这仅由配额子系统使用。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NEED_I_SIZE_ORDERED</span></span><br><span class="line">    <span class="type">seqcount_t</span> i_size_seqcount;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Misc */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i_state;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">i_rwsem</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dirtied_when; <span class="comment">/* jiffies of first dirtying */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dirtied_time_when;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">i_hash</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_io_list</span>;</span> <span class="comment">/* backing dev IO list */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_CGROUP_WRITEBACK</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bdi_writeback</span> *<span class="title">i_wb</span>;</span> <span class="comment">/* the associated cgroup wb */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* foreign inode detection, see wbc_detach_inode() */</span></span><br><span class="line">    <span class="type">int</span> i_wb_frn_winner;</span><br><span class="line">    u16 i_wb_frn_avg_time;</span><br><span class="line">    u16 i_wb_frn_history;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_lru</span>;</span> <span class="comment">/* inode LRU list */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_sb_list</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_wb_list</span>;</span> <span class="comment">/* backing dev writeback list */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">i_dentry</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">i_rcu</span>;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">atomic64_t</span> i_version;</span><br><span class="line">    <span class="type">atomic64_t</span> i_sequence; <span class="comment">/* see futex */</span></span><br><span class="line">    <span class="type">atomic_t</span> i_count;      <span class="comment">// inode 计数器，指示有多少内核组件在使用它。</span></span><br><span class="line">    <span class="type">atomic_t</span> i_dio_count;</span><br><span class="line">    <span class="type">atomic_t</span> i_writecount;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)</span></span><br><span class="line">    <span class="type">atomic_t</span> i_readcount; <span class="comment">/* struct files open RO */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">i_fop</span>;</span> <span class="comment">// 指向结构 file_operations 的指针。former -&gt;i_op-&gt;default_file_ops</span></span><br><span class="line">        <span class="type">void</span> (*free_inode)(<span class="keyword">struct</span> inode *);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file_lock_context</span> *<span class="title">i_flctx</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> <span class="title">i_data</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">i_devices</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">i_pipe</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> *<span class="title">i_cdev</span>;</span></span><br><span class="line">        <span class="type">char</span> *i_link;</span><br><span class="line">        <span class="type">unsigned</span> i_dir_seq;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    __u32 i_generation;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">    __u32 i_fsnotify_mask; <span class="comment">/* all events this inode cares about */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span> *<span class="title">i_fsnotify_marks</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_ENCRYPTION</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fscrypt_info</span> *<span class="title">i_crypt_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FS_VERITY</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsverity_info</span> *<span class="title">i_verity_info</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *i_private; <span class="comment">/* fs or device private pointer */</span></span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></div></figure><p>每个文件系统都缓存了一定的 inode 数量到内存中。同一个文件系统的 inode 以双向链表连接起来，挂在 <code>super_block-&gt;s_inodes</code> 字段中。同时，内核中所有的 inode 被组织在了一个哈希表 inode_hashtable 上。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227141716401.png" alt="image-20241227141716401" style="zoom:75%"><p>一些可用于处理 inode 的函数如下：</p><ol><li>new_inode()：创建新的 inode，将 i_nlink 字段设置为 1，并初始化 i_blkbits, i_sb 和 i_dev。</li><li>insert_inode_hash()：将 inode 添加到 inode 哈希表中。这个调用的一个有趣的效果是，如果 inode 被标记为脏，它将被写入磁盘。</li><li>mark_inode_dirty()：将 inode 标记为脏，稍后它将被写入磁盘。</li><li>iget_locked()：从磁盘加载具有给定编号的 inode，如果它尚未加载。</li><li>unlock_new_inode()：与 iget_locked() 一起使用，释放对 inode 的锁定。</li><li>iput()：告诉内核对 inode 的操作已经完成。若没有其他进程在使用，它将被销毁（如果被标记为脏，则写入磁盘后再销毁）。</li><li>make_bad_inode()：告诉内核该 inode 无法使用；通常在从磁盘读取 inode 时发现无法读取的情况下使用，表示该 inode 无效。</li></ol><h2 id="inode-操作"><a href="#inode-操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#inode-操作" class="headerlink" title="inode 操作"></a>inode 操作</h2><h3 id="获取-inode"><a href="#获取-inode" class="heading-link"><i class="fas fa-link"></i></a><a href="#获取-inode" class="headerlink" title="获取 inode"></a>获取 inode</h3><p>获取 inode 是 inode 的主要操作之一。Linux 2.6 以前，存在 read_inode() 函数。Linux 2.6 以后，编程者必须自己定义 <code>&lt;fsname&gt;_get()</code> 函数，<code>fsname</code> 是文件系统的名称。此函数负责查找 VFS 中的 inode，如果存在则获取该 inode，否则创建一个新的 inode，并用磁盘中的信息填充它。</p><p>一般情况下，这个函数会调用 iget_locked() 从 VFS 中获取 inode 结构。如果 inode 是新创建的，则需要使用 sb_bread() 从磁盘中读取 inode，并填充有用的信息。</p><p>实例函数是 minix_iget()：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inode *<span class="title function_">V1_minix_iget</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buffer_head</span> *<span class="title">bh</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode</span> *<span class="title">raw_inode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">minix_inode_info</span> *<span class="title">minix_inode</span> =</span> minix_i(inode);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    raw_inode = minix_V1_raw_inode(inode-&gt;i_sb, inode-&gt;i_ino, &amp;bh);</span><br><span class="line">    <span class="keyword">if</span> (!raw_inode)</span><br><span class="line">    &#123;</span><br><span class="line">        iget_failed(inode);</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-EIO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此函数通过 iget_locked() 获取 inode。如果 inode 已经存在即不是新建的，则函数返回。否则使用 V1_minix_iget() 函数从磁盘读取 inode，然后使用读取的信息初始化 VFS inode。</span></span><br><span class="line"><span class="keyword">struct</span> inode *<span class="title function_">minix_iget</span><span class="params">(<span class="keyword">struct</span> super_block *sb, <span class="type">unsigned</span> <span class="type">long</span> ino)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span>;</span></span><br><span class="line"></span><br><span class="line">    inode = iget_locked(sb, ino);</span><br><span class="line">    <span class="keyword">if</span> (!inode)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM);</span><br><span class="line">    <span class="comment">// I_NEW 标志表示 inode 是否为新建的。</span></span><br><span class="line">    <span class="keyword">if</span> (!(inode-&gt;i_state &amp; I_NEW))</span><br><span class="line">        <span class="keyword">return</span> inode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (INODE_VERSION(inode) == MINIX_V1)</span><br><span class="line">        <span class="keyword">return</span> V1_minix_iget(inode);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h3 id="超级块操作"><a href="#超级块操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#超级块操作" class="headerlink" title="超级块操作"></a>超级块操作</h3><p>许多超级块操作在处理 inode 的时候使用，如下：</p><ol><li>alloc_inode()：分配 inode()。通常，此函数会分配一个 <code>struct &lt;fsname&gt;_inode_info</code> 结构，并使用 inode_init_once() 执行基本的 VFS inode 初始化。minix 文件系统使用 kmem_cache_alloc() 函数进行分配，该函数与 SLAB 子系统交互。对于每个分配，都会调用缓存构造函数，在 minix 下是 init_once() 函数。或者也可以使用 kmalloc()。在这种情况下，应调用 inode_init_once() 函数。alloc_inode() 函数将由 new_inode() 和 iget_locked() 函数调用。</li><li>write_inode()：将作为参数接收的 inode 保存或更新到磁盘。此函数要更新 inode，尽管效率不高。对初学者而言，建议使用以下操作：<ul><li>使用 sb_bread() 函数从磁盘加载 inode。</li><li>根据保存的 inode 修改缓冲区。</li><li>使用 mark_buffer_dirty() 将缓冲区标记为脏。内核将处理其在磁盘上的写入。</li></ul></li><li>evict_inode()：从磁盘和内存中移除通过 i_ino 字段接收的 inode 的任何信息，包括磁盘上的 inode 和相关的数据块。涉及以下操作：<ul><li>从磁盘中删除 inode。</li><li>更新磁盘位图（如果有）。</li><li>通过调用 truncate_inode_pages() 从 page cache 中删除 inode。</li><li>通过调用 clear_inode() 从内存中删除 inode。</li></ul></li><li>destroy_inode()：释放 inode 占用的内存。</li></ol><h3 id="inode-operations"><a href="#inode-operations" class="heading-link"><i class="fas fa-link"></i></a><a href="#inode-operations" class="headerlink" title="inode_operations"></a>inode_operations</h3><p>inode 索引节点的相关操作由 <code>struct inode_operations</code> 结构描述。</p><p>索引节点分为多种类型：文件、目录、特殊文件（管道、FIFO）、块设备、字符设备以及链接等。每种类型需要实现的操作都不同。</p><p>访问 <code>struct inode</code> 中的 i_op 字段可以对索引节点的操作进行初始化和访问。</p><h1 id="mount"><a href="#mount" class="heading-link"><i class="fas fa-link"></i></a><a href="#mount" class="headerlink" title="mount"></a>mount</h1><p><strong>mount 代表了一个文件系统被挂载到了某个地方。</strong>只有被挂载的文件系统，才能通过 VFS 的目录树进行访问。</p><p>一个文件系统可能被多次 mount 到不同的地方，这样一个 super_block 会对应多个不同的 mount 结构，这些 mount 以双向链表的形式组织起来，挂在 super_block-&gt;s_mounts 字段。</p><p>被 mount 的目录称为一个 mount 点。目录也是一个 dentry，mount 通过 mnt_mountpoint 字段指向该 dentry。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241227145405084.png" alt="image-20241227145405084" style="zoom:75%"><p>挂载点用 mountpoint 结构体表示。所有的挂载点被放到一个哈希表 mountpoint_hashtable 中，以 dentry 为键（Key），mountpoint 为值（T）。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230094606623.png" alt="image-20241230094606623" style="zoom:75%"><blockquote><p>注：这里的 mountpoint 是一个结构体。与上面的 mount-&gt;mnt_mountpoint 不一样，上面的是一个指针，指向 dentry。</p></blockquote><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mount</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">mnt_mountpoint</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vfsmount</span> <span class="title">mnt</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span> <span class="title">mnt_rcu</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">llist_node</span> <span class="title">mnt_llist</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SMP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_pcp</span> __<span class="title">percpu</span> *<span class="title">mnt_pcp</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="type">int</span> mnt_count;</span><br><span class="line">	<span class="type">int</span> mnt_writers;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_mounts</span>;</span>	<span class="comment">/* list of children, anchored here */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_child</span>;</span>	<span class="comment">/* and going through their mnt_child */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_instance</span>;</span>	<span class="comment">/* mount instance on sb-&gt;s_mounts */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *mnt_devname;	<span class="comment">/* Name of device e.g. /dev/dsk/hda1 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_list</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_expire</span>;</span>	<span class="comment">/* link in fs-specific expiry list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_share</span>;</span>	<span class="comment">/* circular list of shared mounts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave_list</span>;</span><span class="comment">/* list of slave mounts */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_slave</span>;</span>	<span class="comment">/* slave list entry */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mount</span> *<span class="title">mnt_master</span>;</span>	<span class="comment">/* slave is on master-&gt;mnt_slave_list */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mnt_namespace</span> *<span class="title">mnt_ns</span>;</span>	<span class="comment">/* containing namespace */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> *<span class="title">mnt_mp</span>;</span>	<span class="comment">/* where is it mounted */</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_mp_list</span>;</span>	<span class="comment">/* list mounts with the same mountpoint */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">mnt_umount</span>;</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mnt_umounting</span>;</span> <span class="comment">/* list entry for umount propagation */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_FSNOTIFY</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_mark_connector</span> __<span class="title">rcu</span> *<span class="title">mnt_fsnotify_marks</span>;</span></span><br><span class="line">	__u32 mnt_fsnotify_mask;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">int</span> mnt_id;			<span class="comment">/* mount identifier */</span></span><br><span class="line">	<span class="type">int</span> mnt_group_id;		<span class="comment">/* peer group identifier */</span></span><br><span class="line">	<span class="type">int</span> mnt_expiry_mark;		<span class="comment">/* true if marked for expiry */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_pins</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">mnt_stuck_children</span>;</span></span><br><span class="line">&#125; __randomize_layout;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mountpoint</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">m_hash</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">m_dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">m_list</span>;</span></span><br><span class="line">	<span class="type">int</span> m_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>同一个目录可被多个文件系统 mount。这些文件系统会相互覆盖，通过 VFS 只能看到最近那个被 mount 的文件系统。</p><p>为了处理这种情况，文件系统中所有的 mount 都被组织到同一个哈希表 mount_hashtable 中。哈希表以 <code>&lt;mount, dentry&gt;</code> 为键（Key），以新的 mount 作为值（Value），将其组织起来。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230101507978.png" alt="image-20241230101507978" style="zoom:70%"><p>将上述整理以后，能得到一个整体的架构图：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230102023524.png" alt="image-20241230102023524" style="zoom:70%"><h1 id="file-1"><a href="#file-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#file-1" class="headerlink" title="file"></a>file</h1><p><strong>file 结构对应于由进程打开的文件，仅存在于内存中，并与 inode 索引节点关联。</strong>它是最接近用户空间的 VFS 实体。结构字段包含用户空间文件的熟悉信息（访问模式、文件位置等），与之相关的操作由已知的系统调用（read, write 等）执行。</p><p>文件操作由 <code>struct file_operations</code> 结构描述。文件系统的文件操作使用 <code>struct inode</code> 结构中的 i_fop 字段进行初始化。在打开文件时，VFS 使用 inode-&gt;i_fop 的地址初始化 <code>struct file</code> 结构的 f_op 字段。后续的系统调用使用存储在 file-&gt;f_op 中的值。</p><p>file 与 inode 的区别在于，一个文件的 inode 在内核中是唯一的，但 file 可以有多个。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230104309655.png" alt="image-20241230104309655" style="zoom:70%"><h1 id="常规文件索引节点"><a href="#常规文件索引节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#常规文件索引节点" class="headerlink" title="常规文件索引节点"></a>常规文件索引节点</h1><p>使用索引节点必须要填充 inode 结构的 i_op 和 i_fop 字段。索引节点的类型决定了他要实现的操作。</p><p>一个例子是 minix 文件系统的对象实例 minix_file_operations 和 minix_file_inode_operations。</p><p>Linux 内核实现了 generic_file_llseek()、generic_file_read_iter()、generic_file_write_iter()、generic_file_mmap() 函数，定义了一些通用的 file 操作，具体做了哪些处理可参见源码。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minix_file_operations</span> =</span> &#123;</span><br><span class="line">    .llseek = generic_file_llseek,</span><br><span class="line">    .read_iter = generic_file_read_iter,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    .write_iter = generic_file_write_iter,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    .mmap = generic_file_mmap,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minix_file_inode_operations</span> =</span> &#123;</span><br><span class="line">    .setattr = minix_setattr,</span><br><span class="line">    .getattr = minix_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        inode-&gt;i_op = &amp;minix_file_inode_operations;</span><br><span class="line">        inode-&gt;i_fop = &amp;minix_file_operations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>对于简单的文件系统，只需实现截断 truncate() 系统调用。从 Linux 3.14 开始，该操作已嵌入到 setattr() 中。如果粘贴大小与索引节点的当前大小不同，则必须执行截断操作。</p><p>一个例子是 minix_setattr() 函数：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">minix_setattr</span><span class="params">(<span class="keyword">struct</span> dentry *dentry, <span class="keyword">struct</span> iattr *attr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> d_inode(dentry);</span><br><span class="line">    <span class="type">int</span> error;</span><br><span class="line"></span><br><span class="line">    error = setattr_prepare(dentry, attr);</span><br><span class="line">    <span class="keyword">if</span> (error)</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((attr-&gt;ia_valid &amp; ATTR_SIZE) &amp;&amp;</span><br><span class="line">        attr-&gt;ia_size != i_size_read(inode))</span><br><span class="line">    &#123;</span><br><span class="line">        error = inode_newsize_ok(inode, attr-&gt;ia_size);</span><br><span class="line">        <span class="keyword">if</span> (error)</span><br><span class="line">            <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">        truncate_setsize(inode, attr-&gt;ia_size);</span><br><span class="line">        minix_truncate(inode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setattr_copy(inode, attr);</span><br><span class="line">    mark_inode_dirty(inode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>截断操作涉及以下内容：</p><ol><li>释放磁盘上多余的数据块（如果新尺寸小于旧尺寸），或者分配新的数据块（当新尺寸较大时）。</li><li>更新磁盘位图（如果使用）。</li><li>更新索引节点。</li><li>使用 block_truncate_page() 函数，将上一个块中未使用的空间填充为零。</li></ol><h1 id="page-cache"><a href="#page-cache" class="heading-link"><i class="fas fa-link"></i></a><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h1><p>笔记摘抄自文章 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.ywang-wnlo.xyz/posts/9ba60726/">https://blog.ywang-wnlo.xyz/posts/9ba60726/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p>由于磁盘 HDD 以及现在广泛使用的固态硬盘 SSD 的读写速度都远小于内存 DRAM 的读写速度。为避免每次读取数据都要直接访问这些低速的底层存储设备，Linux 利用 DRAM 实现了一个缓存层，缓存的粒度是 page，也叫 page cache，也就是页（面）缓存。</p><p>经过这层 page cache 的作用，I&#x2F;O 的性能得到了显著的提升。不过由于 DRAM 具有易失性，在掉电后数据会丢失，因此内核中的 回写机制定时将 page cache 中的数据下刷到设备上，保证数据的持久化。此外内核还在 page cache 中实现了巧妙的预读机制，提升了顺序读性能。</p><p>写入到 page cache 的数据不会立刻写入后端设备，而是标记为“脏”，并被加入到脏页链表，后续由内核中的回写进程周期性的将脏页写回到底层存储设备。</p><p>在拥有 page cache 这一层后，写数据就有了三种不同的策略：</p><ol><li><p><strong>不经过缓存，直接写底层存储设备，但同时要使缓存中数据失效，也叫不缓存（nowrite）。</strong></p></li><li><p><strong>只写缓存，缓存中数据定期刷到底层存储设备上，也叫写回（write back）。</strong></p></li><li><p><strong>同时写缓存和底层存储设备，也叫写穿（write through）。</strong></p></li></ol><p>前两种就是直接 I&#x2F;O（direct_io）和缓存 I&#x2F;O（buffer_io）。</p><p>第三种策略虽然能非常简单保证缓存和底层设备的一致性，不过基于时间局部性原理，page cache 中的数据可能只是中间态，会被频繁修改，每次写穿会产生大量的开销。</p><p>关于 page cache 的写回机制（write back），参考 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.ywang-wnlo.xyz/posts/646202b9/">https://blog.ywang-wnlo.xyz/posts/646202b9/</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><h1 id="address-space"><a href="#address-space" class="heading-link"><i class="fas fa-link"></i></a><a href="#address-space" class="headerlink" title="address_space"></a>address_space</h1><p><strong>进程的地址空间与文件之间有着密切的联系：程序的执行几乎完全是通过将文件映射到进程的地址空间中进行的。</strong>这种方法非常有效且相当通用，也可以用于常规的系统调用，如 read() 和 write()。</p><p>描述地址空间的结构是 <code>struct address_space</code>，与之相关的操作由结构 <code>struct address_space_operations</code> 描述。初始化 <code>struct address_space_operations</code> 需填充文件类型索引节点的 <code>inode-&gt;i_mapping-&gt;a_ops</code>。</p><blockquote><p><code>struct address_space</code> 是 page cache 的核心结构体。每一个 address_space 与一个 inode 对应，同时 file 中的 f_mapping 字段通常由该文件的 inode 中 i_mapping 赋值。也就是说每个文件都会有独自的 file、inode 以及 address_space 结构体。</p><p><code>struct address_space</code> 中的 <code>struct xarray i_pages</code> 就是该文件的 page cache 中缓存的所有物理页。它是通过基数树结构进行管理的，而 xarray 只是在基数树上进行了一层封装。</p><p>通常 <code>struct address_space</code> 上会挂载一个 <code>struct address_space_operations</code>，自定义对 page cache 中的页面操作的函数。</p></blockquote><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inode</span>		*<span class="title">host</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">xarray</span>		<span class="title">i_pages</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">invalidate_lock</span>;</span></span><br><span class="line">	<span class="type">gfp_t</span>			gfp_mask;</span><br><span class="line">	<span class="type">atomic_t</span>		i_mmap_writable;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_READ_ONLY_THP_FOR_FS</span></span><br><span class="line">	<span class="comment">/* number of thp, only for non-shmem files */</span></span><br><span class="line">	<span class="type">atomic_t</span>		nr_thps;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root_cached</span>	<span class="title">i_mmap</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span>	<span class="title">i_mmap_rwsem</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nrpages;</span><br><span class="line">	<span class="type">pgoff_t</span>			writeback_index;</span><br><span class="line">	<span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> *<span class="title">a_ops</span>;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		flags;</span><br><span class="line">	<span class="type">errseq_t</span>		wb_err;</span><br><span class="line">	<span class="type">spinlock_t</span>		private_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">private_list</span>;</span></span><br><span class="line">	<span class="type">void</span>			*private_data;</span><br><span class="line">&#125; __attribute__((aligned(<span class="keyword">sizeof</span>(<span class="type">long</span>)))) __randomize_layout;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> (*writepage)(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> writeback_control *wbc);</span><br><span class="line">	<span class="type">int</span> (*readpage)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Write back some dirty pages from this mapping. */</span></span><br><span class="line">    <span class="comment">// writepage() 或 writepages() 负责对这些物理页的实际写入。</span></span><br><span class="line">	<span class="type">int</span> (*writepages)(<span class="keyword">struct</span> address_space *, <span class="keyword">struct</span> writeback_control *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Set a page dirty.  Return true if this dirtied it */</span></span><br><span class="line">	<span class="type">int</span> (*set_page_dirty)(<span class="keyword">struct</span> page *page);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Reads in the requested pages. Unlike -&gt;readpage(), this is</span></span><br><span class="line"><span class="comment">	 * PURELY used for read-ahead!.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*readpages)(<span class="keyword">struct</span> file *filp, <span class="keyword">struct</span> address_space *mapping,</span><br><span class="line">			<span class="keyword">struct</span> list_head *pages, <span class="type">unsigned</span> nr_pages);</span><br><span class="line">	<span class="type">void</span> (*readahead)(<span class="keyword">struct</span> readahead_control *);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要负责查找、或者分配新的物理页，并将其锁定，有时还需要先从底层读取最新的数据页。</span></span><br><span class="line">	<span class="type">int</span> (*write_begin)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> address_space *mapping,</span><br><span class="line">				<span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> flags,</span><br><span class="line">				<span class="keyword">struct</span> page **pagep, <span class="type">void</span> **fsdata);</span><br><span class="line">    <span class="comment">// 主要负责解锁这些物理页，并且更新 inode 中的元数据信息，例如 i_size。</span></span><br><span class="line">	<span class="type">int</span> (*write_end)(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> address_space *mapping,</span><br><span class="line">				<span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> copied,</span><br><span class="line">				<span class="keyword">struct</span> page *page, <span class="type">void</span> *fsdata);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Unfortunately this kludge is needed for FIBMAP. Don&#x27;t use it */</span></span><br><span class="line">	<span class="type">sector_t</span> (*bmap)(<span class="keyword">struct</span> address_space *, <span class="type">sector_t</span>);</span><br><span class="line">	<span class="type">void</span> (*invalidatepage) (<span class="keyword">struct</span> page *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">	<span class="type">int</span> (*releasepage) (<span class="keyword">struct</span> page *, <span class="type">gfp_t</span>);</span><br><span class="line">	<span class="type">void</span> (*freepage)(<span class="keyword">struct</span> page *);</span><br><span class="line">	<span class="type">ssize_t</span> (*direct_IO)(<span class="keyword">struct</span> kiocb *, <span class="keyword">struct</span> iov_iter *iter);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * migrate the contents of a page to the specified target. If</span></span><br><span class="line"><span class="comment">	 * migrate_mode is MIGRATE_ASYNC, it must not block.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="type">int</span> (*migratepage) (<span class="keyword">struct</span> address_space *,</span><br><span class="line">			<span class="keyword">struct</span> page *, <span class="keyword">struct</span> page *, <span class="keyword">enum</span> migrate_mode);</span><br><span class="line">	<span class="type">bool</span> (*isolate_page)(<span class="keyword">struct</span> page *, <span class="type">isolate_mode_t</span>);</span><br><span class="line">	<span class="type">void</span> (*putback_page)(<span class="keyword">struct</span> page *);</span><br><span class="line">	<span class="type">int</span> (*launder_page) (<span class="keyword">struct</span> page *);</span><br><span class="line">	<span class="type">int</span> (*is_partially_uptodate) (<span class="keyword">struct</span> page *, <span class="type">unsigned</span> <span class="type">long</span>,</span><br><span class="line">					<span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">	<span class="type">void</span> (*is_dirty_writeback) (<span class="keyword">struct</span> page *, <span class="type">bool</span> *, <span class="type">bool</span> *);</span><br><span class="line">	<span class="type">int</span> (*error_remove_page)(<span class="keyword">struct</span> address_space *, <span class="keyword">struct</span> page *);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* swapfile support */</span></span><br><span class="line">	<span class="type">int</span> (*swap_activate)(<span class="keyword">struct</span> swap_info_struct *sis, <span class="keyword">struct</span> file *file,</span><br><span class="line">				<span class="type">sector_t</span> *span);</span><br><span class="line">	<span class="type">void</span> (*swap_deactivate)(<span class="keyword">struct</span> file *file);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>address_space 是以基数树进行组织的文件 Cache。以页为单位，<code>page-&gt;index = 该页在文件中的逻辑偏移 / page_size</code>。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230103801350.png" alt="image-20241230103801350" style="zoom:30%"><p>例如 minix 文件系统的 minix_aops 结构如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_space_operations</span> <span class="title">minix_aops</span> =</span> &#123;</span><br><span class="line">    .readpage = minix_readpage,</span><br><span class="line">    .writepage = minix_writepage,</span><br><span class="line">    .write_begin = minix_write_begin,</span><br><span class="line">    .write_end = generic_write_end,</span><br><span class="line">    .bmap = minix_bmap&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISREG(inode-&gt;i_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        inode-&gt;i_mapping-&gt;a_ops = &amp;minix_aops;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>内核已实现 generic_write_end() 函数。并且上述的大多数函数的实现其实都非常简单：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">minix_writepage</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="keyword">struct</span> writeback_control *wbc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> block_write_full_page(page, minix_get_block, wbc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">minix_readpage</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> page *page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> block_read_full_page(page, minix_get_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">minix_write_failed</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="type">loff_t</span> to)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> =</span> mapping-&gt;host;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to &gt; inode-&gt;i_size)</span><br><span class="line">    &#123;</span><br><span class="line">        truncate_pagecache(inode, inode-&gt;i_size);</span><br><span class="line">        minix_truncate(inode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">minix_write_begin</span><span class="params">(<span class="keyword">struct</span> file *file, <span class="keyword">struct</span> address_space *mapping,</span></span><br><span class="line"><span class="params">                             <span class="type">loff_t</span> pos, <span class="type">unsigned</span> len, <span class="type">unsigned</span> flags,</span></span><br><span class="line"><span class="params">                             <span class="keyword">struct</span> page **pagep, <span class="type">void</span> **fsdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    ret = block_write_begin(mapping, pos, len, flags, pagep,</span><br><span class="line">                            minix_get_block);</span><br><span class="line">    <span class="keyword">if</span> (unlikely(ret))</span><br><span class="line">        minix_write_failed(mapping, pos + len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">sector_t</span> <span class="title function_">minix_bmap</span><span class="params">(<span class="keyword">struct</span> address_space *mapping, <span class="type">sector_t</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> generic_block_bmap(mapping, block, minix_get_block);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>上面函数中能经常见到 minix_get_block 这个东西。查看 block_write_full_page() 函数定义发现是一个函数指针。</p><p>在 minix 文件系统中，minix_get_block() 函数将文件的一个数据块转换为设备上的一个数据块。如果接收到的 create 标志被设置，那么必须分配一个新的数据块。在创建新的数据块时，必须相应地更新位图。为通知内核不要从磁盘中读取该数据块，必须使用 set_buffer_new() 函数标记 bh。通过 map_bh() 函数，将缓冲区与数据块关联起来。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">block_write_full_page</span><span class="params">(<span class="keyword">struct</span> page *page, <span class="type">get_block_t</span> *get_block, <span class="keyword">struct</span> writeback_control *wbc)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(<span class="type">get_block_t</span>)</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">sector_t</span> iblock, <span class="keyword">struct</span> buffer_head *bh_result, <span class="type">int</span> create)</span>;</span><br></pre></td></tr></table></div></figure><h1 id="dentry-1"><a href="#dentry-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#dentry-1" class="headerlink" title="dentry"></a>dentry</h1><h2 id="struct-dentry"><a href="#struct-dentry" class="heading-link"><i class="fas fa-link"></i></a><a href="#struct-dentry" class="headerlink" title="struct dentry"></a>struct dentry</h2><p>dentry 将 inode 和 文件名关联起来。VFS 中的 dentry 实体用 <code>struct dentry</code> 表示，相关操作用 <code>struct dentry_operations</code> 表示。</p><p><code>struct dentry</code> 重要字段定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dentry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">d_inode</span>;</span> <span class="comment">// 关联的索引节点。</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d_parent</span>;</span> <span class="comment">// 父目录的 dentry 对象。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qstr</span> <span class="title">d_name</span>;</span>      <span class="comment">// dentry 名称，struct qstr 类型，包含字段 name（名称）和 len（名称的长度）。</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dentry_operations</span> *<span class="title">d_op</span>;</span> <span class="comment">// 与 dentry 相关的操作。内核实现了默认操作，理论上无需重新实现它们。某些文件系统可以根据 dentry 的特定结构进行优化。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">super_block</span> *<span class="title">d_sb</span>;</span>       <span class="comment">// 文件的超级块。</span></span><br><span class="line">    <span class="type">void</span> *d_fsdata;                 <span class="comment">// 文件系统特定的数据。</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>dentry 也有一个全局哈希表进行组织，与它对应的 inode 互指。</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20241230102953331.png" alt="image-20241230102953331" style="zoom:75%"><h2 id="dentry-操作"><a href="#dentry-操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#dentry-操作" class="headerlink" title="dentry 操作"></a>dentry 操作</h2><p>dentry 最常见的操作包括：</p><ol><li>d_make_root()：分配根 dentry。通常在读取超级块的函数 fill_super() 中使用。此函数必须初始化根目录。一般从超级块获取根索引节点，并将其作为实参传递给此函数，以填充 struct super_block 结构的 s_root 字段。</li><li>d_add()：将 dentry 与索引节点关联起来。作为参数传递的 dentry 表示需要创建的条目（名称、长度）。在创建或加载尚未与任何 dentry 关联并尚未添加到索引节点哈希表中的新索引节点时，将使用此函数（在 lookup() 函数中）。</li><li>d_instantiate()：d_add() 的轻量级版本，其中 dentry 先前已添加到哈希表中。注意，d_instantiate() 必须用于实现创建调用 (mkdir, mknod, rename 以及 symlink)，而不是 d_add。</li></ol><h1 id="目录索引节点"><a href="#目录索引节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#目录索引节点" class="headerlink" title="目录索引节点"></a>目录索引节点</h1><h2 id="目录索引节点操作"><a href="#目录索引节点操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#目录索引节点操作" class="headerlink" title="目录索引节点操作"></a>目录索引节点操作</h2><p>目录索引节点的操作比常规文件索引节点的操作要复杂的多。在 minix 中，由对象实例 minix_dir_inode_operations 和 minix_dir_operations 定义。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_operations</span> <span class="title">minix_dir_inode_operations</span> =</span> &#123;</span><br><span class="line">    .create = minix_create,</span><br><span class="line">    .lookup = minix_lookup,</span><br><span class="line">    .link = minix_link,</span><br><span class="line">    .unlink = minix_unlink,</span><br><span class="line">    .symlink = minix_symlink,</span><br><span class="line">    .mkdir = minix_mkdir,</span><br><span class="line">    .rmdir = minix_rmdir,</span><br><span class="line">    .mknod = minix_mknod,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">minix_dir_operations</span> =</span> &#123;</span><br><span class="line">    .llseek = generic_file_llseek,</span><br><span class="line">    .read = generic_read_dir,</span><br><span class="line">    .iterate = minix_readdir,</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(inode-&gt;i_mode))</span><br><span class="line">    &#123;</span><br><span class="line">        inode-&gt;i_op = &amp;minix_dir_inode_operations;</span><br><span class="line">        inode-&gt;i_fop = &amp;minix_dir_operations;</span><br><span class="line">        inode-&gt;i_mapping-&gt;a_ops = &amp;minix_aops;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="相关函数"><a href="#相关函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h2><p>目录索引节点操作的相关函数如下所述。</p><h3 id="创建索引节点"><a href="#创建索引节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建索引节点" class="headerlink" title="创建索引节点"></a>创建索引节点</h3><p>由 inode_operations 的 create 字段（回调函数）表示。此函数由 open() 和 creat() 系统调用调用，执行以下操作：</p><ol><li>在磁盘上的物理结构中引入新条目。不要忘记更新磁盘上的位图。</li><li>使用传入函数的访问权限配置访问权限。</li><li>使用 mark_inode_dirty() 函数将索引节点标记为脏。</li><li>使用 d_instantiate() 函数实例化目录条目 (dentry)。</li></ol><h3 id="创建目录"><a href="#创建目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>由 mkdir 字段表示，由 mkdir() 系统调用调用，执行以下操作：</p><ol><li>调用 create 字段对应的回调函数。</li><li>为目录分配一个数据块。</li><li>创建 <code>&quot;.&quot;</code> 和 <code>&quot;..&quot;</code> 条目。</li></ol><h3 id="创建链接"><a href="#创建链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建链接" class="headerlink" title="创建链接"></a>创建链接</h3><p>由 link 字段表示，由 link() 系统调用调用，执行以下操作：</p><ol><li>将新的 dentry 绑定到索引节点。</li><li>递增索引节点的 i_nlink 字段。</li><li>使用 mark_inode_dirty() 函数将索引节点标记为脏。</li></ol><h3 id="创建符号链接"><a href="#创建符号链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h3><p>由 symlink 字段表示，由 symlink() 系统调用调用。执行操作与 link 的回调函数类似，区别在于此函数创建的是符号链接。</p><h3 id="删除链接"><a href="#删除链接" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除链接" class="headerlink" title="删除链接"></a>删除链接</h3><p>由 unlink 字段表示，由 unlink() 系统调用调用，执行以下操作：</p><ol><li>从物理磁盘结构中删除作为参数给出的 dentry。</li><li>将条目指向的索引节点的 i_nlink 计数器减一，否则该索引节点将永远不会被删除（引用计数无法减到 0）。</li></ol><h3 id="删除目录"><a href="#删除目录" class="heading-link"><i class="fas fa-link"></i></a><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p>由 rmdir 字段表示，由 rmdir() 系统调用调用，执行以下操作：</p><ol><li>执行 unlink 字段对应回调函数完成的操作。</li><li>确保目录为空，否则返回 ENOTEMPTY。</li><li>同时删除数据块。</li></ol><h3 id="在目录中搜索索引节点"><a href="#在目录中搜索索引节点" class="heading-link"><i class="fas fa-link"></i></a><a href="#在目录中搜索索引节点" class="headerlink" title="在目录中搜索索引节点"></a>在目录中搜索索引节点</h3><p>由 lookup 字段表示。当需要有关与目录中条目关联的索引节点的信息时，会间接调用此函数。此函数执行以下操作：</p><ol><li>在由 dir 指示的目录中搜索具有名称 <code>dentry-&gt;d_name.name</code> 的条目。</li><li>如果找到条目，则返回 NULL 并使用 d_add() 函数将索引节点与名称关联。</li><li>否则，返回 ERR_PTR。</li></ol><h3 id="遍历目录中的条目"><a href="#遍历目录中的条目" class="heading-link"><i class="fas fa-link"></i></a><a href="#遍历目录中的条目" class="headerlink" title="遍历目录中的条目"></a>遍历目录中的条目</h3><p>由 iterate 字段表示，由 readdir() 系统调用调用。</p><p>此函数返回目录中的所有条目，或者当为其分配的缓冲区不可用时，仅返回部分条目。可能的返回如下：</p><ol><li>如果对应的用户空间缓冲区有足够的空间，则返回与现有条目数相等的数字。</li><li>小于实际条目数的数字，对应的用户空间缓冲区中有多少空间，就返回多少。</li><li>0，表示没有更多条目可读取。</li></ol><p>此函数会连续调用，知道读取完所有可用的条目，并且至少会调用 2 次。</p><ol><li>在以下情况下仅调用两次：<ul><li>第一次调用读取所有条目并返回它们的数量。</li><li>第二次调用返回 0，表示没有其他条目可读取。</li></ul></li><li>如果第一次调用未返回总条目数，则会多次调用该函数。</li></ol><p>此函数执行以下操作：</p><ol><li>遍历当前目录中的条目（dentry）。</li><li>对于找到的每个 dentry，递增 <code>ctx-&gt;pos</code>。</li><li>对于每个有效的 dentry（例如，除了 0 之外的索引节点），调用 dir_emit() 函数。</li><li>如果 dir_emit() 函数返回非零值，表示用户空间的缓冲区已满，函数将返回。</li></ol><p>dir_emit() 定义如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ctx：目录遍历上下文，作为参数传递给 iterate 函数。</span></span><br><span class="line"><span class="comment">// name：条目的名称。</span></span><br><span class="line"><span class="comment">// namelen：条目名称的长度。</span></span><br><span class="line"><span class="comment">// ino：与条目关联的 inode 索引节点号。</span></span><br><span class="line"><span class="comment">// type：标志条目类型，DT_REG（文件）、DT_DIR（目录）、DT_UNKNOWN（未知）等。</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title function_">dir_emit</span><span class="params">(<span class="keyword">struct</span> dir_context *ctx, <span class="type">const</span> <span class="type">char</span> *name, <span class="type">int</span> namelen, u64 ino, <span class="type">unsigned</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> ctx-&gt;actor(ctx, name, namelen, ctx-&gt;pos, ino, type) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h1 id="位图操作"><a href="#位图操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#位图操作" class="headerlink" title="位图操作"></a>位图操作</h1><p>处理文件系统时，管理信息（哪个块是空闲的或忙碌的，哪个索引节点是空闲的或忙碌的）使用位图存储。因此需要使用位操作，包括：</p><ol><li>搜索第一个为 0 的位：表示一个空闲的块或索引节点。</li><li>将位标记为 1：标记忙碌的块或索引节点。</li></ol><p>位图操作常见的函数如下。这些函数定义在内核源码 include&#x2F;asm-generic&#x2F;bitops&#x2F; 目录下，特别是 find.h 和 atomic.h 中。</p><ol><li>find_first_zero_bit()</li><li>find_first_bit()</li><li>set_bit()</li><li>clear_bit()</li><li>test_and_set_bit()</li><li>test_and_clear_bit()</li></ol><p>这些函数通常接收位图的地址，可能还有其大小（以字节为单位）。如果需要，还要指定需要激活（设置）或停用（清除）的位的索引。</p><p>一个使用实例如下：</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> array_map[NUM_BYTES];</span><br><span class="line"><span class="type">size_t</span> idx;</span><br><span class="line"><span class="type">int</span> changed;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 32 位整数中找到第一个为 0 的位。 */</span></span><br><span class="line">idx = find_first_zero_bit(&amp;<span class="built_in">map</span>, <span class="number">32</span>);</span><br><span class="line">printk(KERN_ALERT <span class="string">&quot;第 %zu 位是第一个为 0 的位。\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在 NUM_BYTES 字节的数组中找到第一个为 1 的位。 */</span></span><br><span class="line">idx = find_first_bit(array_map, NUM_BYTES * <span class="number">8</span>);</span><br><span class="line">printk(KERN_ALERT <span class="string">&quot;第 %zu 位是第一个为 1 的位。\n&quot;</span>, idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 清除整数中的第 idx 位。</span></span><br><span class="line"><span class="comment"> * 假设 idx 小于整数的位数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">clear_bit(idx, &amp;<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试并设置数组中的第 idx 位。</span></span><br><span class="line"><span class="comment"> * 假设 idx 小于数组的位数。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">changed = __test_and_set_bit(idx, &amp;sbi-&gt;imap);</span><br><span class="line"><span class="keyword">if</span> (changed)</span><br><span class="line">    printk(KERN_ALERT <span class="string">&quot;%zu 位已更改\n&quot;</span>, idx);</span><br></pre></td></tr></table></div></figure><h1 id="流程分析"><a href="#流程分析" class="heading-link"><i class="fas fa-link"></i></a><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h1><h2 id="文件系统整体运行流程"><a href="#文件系统整体运行流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件系统整体运行流程" class="headerlink" title="文件系统整体运行流程"></a>文件系统整体运行流程</h2><ol><li><p>加载文件系统的内核模块，在 init 中，注册需要的 file_system_type。格式化过程在内核代码没有任何体现。</p></li><li><p>调用 mount()，挂载文件系统，通过 file_system_type 的 mount() 回调加载对应的 super_block。</p></li><li><p>通过 super_block 的 <code>s_op-&gt;alloc_inode()</code> 分配一个 inode。</p></li><li><p>分配 root 的 dentry，调用 <code>dentry-&gt;d_op</code> 初始化 dentry。inode_operation 和 dentry_operation 都被记录在 super_block 中，inode 和 dentry 各自在初始化时拷贝了该指针。</p></li><li><p>设置对应的挂载点，mount 过程完成。</p></li><li><p>应用程序 open 文件，从指定路径一级一级向下读取对应的 dentry，直到找到需要的文件的 dentry。查找时优先从 dentry 的全局唯一哈希表上查。如果哈希表没有数据，则调用 <code>inode-&gt;i_op-&gt;lookup()</code> 查找。如果最后发现没有这样的文件，则可能调用 <code>inode-&gt;i_op-&gt;atomic_open()</code> 和 <code>inode-&gt;i_op-&gt;create()</code>。在确保有文件的情况下，调用 <code>file-&gt;f_op-&gt;open()</code> 来打开文件。file 的 address_space 和 f_op 由 inode 赋予。</p></li><li><p>read 文件。如果文件加了范围锁，则需判断是否有冲突，然后调用 <code>file-&gt;f_op-&gt;read()</code> 或者 <code>file-&gt;f_op-&gt;read_iter()</code>。</p></li><li><p>write 文件。如果文件加了范围锁，则需判断是否有冲突，然后调用 <code>file-&gt;f_op-&gt;write()</code> 或者 <code>file-&gt;f_op-&gt;write_iter()</code>。</p></li><li><p>close 文件，先调用 <code>file-&gt;f_op-&gt;flush()</code> 刷数据，然后进行异步关闭操作。</p></li></ol><blockquote><p>如果当前进程不在中断上下文且不是 kthread 线程，将该文件的 close() 操作注册到 current-&gt;task_works 中。否则，将该文件的 close() 操作注册到全局的 delayed_fput_work 中。最终，两个异步线程会调到相同的回收代码中来。如果文件设置了 FASYNC 标志，调用 <code>file-&gt;f_op-&gt;fasync()</code> 函数，否则调用 <code>file-&gt;f_op-&gt;release()</code> 函数。</p></blockquote><ol start="10"><li>调用 umount()，卸载文件系统，触发 <code>super_block-&gt;s_op-&gt;kill_sb()</code> 回调。</li></ol><h2 id="path-lookup-过程"><a href="#path-lookup-过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#path-lookup-过程" class="headerlink" title="path lookup 过程"></a>path lookup 过程</h2><p>path lookup 是通过用户传递的一个绝对或相对路径，来找到对应文件的 inode 的过程。典型的应用如 open() 和 mount() 的查找。</p><p><strong>path lookup 总共可分为 ref-walk 和 rcu-walk 两种模式。</strong></p><p>RCU 模式对锁的争用更少，并发更好，但不适合所有场景（因为 RCU 可能会导致进程睡眠）。ref 模式是传统的 path lookup 方式，不容易失败。</p><p>RCU 模式为了检测 dentry 的修改（rename）带来的查询失败，每次查询都会记录 dentry-&gt;d_seq，在查询结束后会检测当前 dentry 和父目录 dentry 的 d_seq 是否改变。针对 ref 模式，每次都会锁住当前 dentry 的 d_lock，在成功查询到需要的 dentry 后，会将其引用计数加一。</p><p>当从当前目录跳转到下一层目录时，RCU 模式会丢弃掉原来的父目录的 d_seq 记录（因为不用关心祖父目录的引用计数），而 ref 模式则会丢弃对当前目录的引用。</p><h2 id="mount-过程"><a href="#mount-过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#mount-过程" class="headerlink" title="mount 过程"></a>mount 过程</h2><p>mount 系统调用定义如下。更多细节参考博客 <span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/bingyu880101/article/details/50481507">https://blog.csdn.net/bingyu880101/article/details/50481507</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mount.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// source：要挂上的文件系统的名字，通常是一个设备名。</span></span><br><span class="line"><span class="comment">// target：文件系统要挂在的目标目录。</span></span><br><span class="line"><span class="comment">// filesystemtype：挂载的文件系统类型，如 &quot;ext4&quot;、&quot;btrfs&quot;、&quot;msdos&quot;、&quot;proc&quot;、&quot;nfs&quot;、&quot;iso9660&quot;、&quot;vfat&quot; 等。</span></span><br><span class="line"><span class="comment">// mountflags：指定文件系统的读写访问标志。</span></span><br><span class="line"><span class="comment">// data：文件系统持有的参数。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">mount</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *source, <span class="type">const</span> <span class="type">char</span> *target, <span class="type">const</span> <span class="type">char</span> *filesystemtype, <span class="type">unsigned</span> <span class="type">long</span> mountflags, <span class="type">const</span> <span class="type">void</span> *_Nullable data)</span>;</span><br></pre></td></tr></table></div></figure><p>mount 的过程具体如下：</p><ol><li><p>根据 dir_name，进行 path lookup。</p></li><li><p>根据 type，查找对应的 file_system_type。</p></li><li><p>拿到 file_system_type，调 mount() 回调，将 dev_name 对应的块设备和 data 传递给它，mount() 回调将建立好对应的 root 的 dentry，super_block 和 root 的 inode。</p></li><li><p>新建 mount 结构体，将 dentry 与 mount 结构体绑定。</p></li><li><p>在 mount_hashtable 中不断查找。如果找到匹配的 mount 结构体，说明该挂载点已被使用，需要继续查找。直到找不到对应的 mount 结构体，说明当前挂载点尚未被占用，系统可以在此挂载新的文件系统。此时系统最后得到有效的 mount 结构体就作为当前 mount 结构体的父挂载点，得到的 dentry 作为当前 mount 结构体的 mountpoint。</p></li><li><p>建立父 mount 与当前 mount 的联系，建立 mountpoint 与当前 mount 的联系。</p></li></ol><h2 id="open-过程"><a href="#open-过程" class="heading-link"><i class="fas fa-link"></i></a><a href="#open-过程" class="headerlink" title="open 过程"></a>open 过程</h2><p>open 主要的流程如下：</p><ol><li><p>分析 open 传进来的 flags。</p></li><li><p>分配 fd。</p></li><li><p>对文件执行 open、create 等操作（视具体情况而定）。</p></li><li><p>通知监控文件打开的回调。</p></li><li><p>将打开得到的 file 结构体放到 fdtable 的 fd 数组中。</p></li></ol><p>open 具体查找文件 inode 的过程，即是 path lookup 的过程。</p><p><code>file-&gt;f_op</code> 有一个 atomic_open() 回调，允许文件系统以与原子的方式查找某个文件。如果该文件不存在，则文件系统尝试创建该文件（当设置了 O_CREAT 标志时）。故在尝试查找和创建文件时，VFS 优先使用 atomic_open()，当文件系统不支持该操作时，才回归到先 lookup，查找失败再 create 的模式。</p><h2 id="通用-read-流程"><a href="#通用-read-流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#通用-read-流程" class="headerlink" title="通用 read 流程"></a>通用 read 流程</h2><p>这里不考虑文件的异步读写，也就是 aio 系列的 read 和 write。</p><p>所谓通用，是指某些文件系统不单独写 read() 或 read_iter() 回调，而是调 VFS 实现的默认 read 函数 generic_file_read_iter()。</p><p>在读缓存的过程中，如果不允许进程阻塞，且需要的数据不在内存中，会立即返回失败。</p><p>读分为两种，一种是 direct_io，另一种是走 address_space。</p><p>如果走 direct_io：</p><ol><li><p>如果这个 read 操作不能陷入等待（NO_WAIT），且要读取的文件范围内有缓存，则返回 -EAGAIN。</p></li><li><p>否则，先通过 address_space 将缓存的数据刷下去。</p></li><li><p>再调用 <code>mapping-&gt;a_ops-&gt;direct_io()</code> 读取数据。</p></li></ol><p>如果走 address_space，用户需要的数据量可能很大，需要一页一页地处理。对于每一页：</p><ol><li><p>从 address_space 中查找对应 page。如果找不到，则以同步方式进行预读，如果这样也拿不到 page，跳转到步骤 6。</p></li><li><p>如果拿到的 page 带有 readahead 标记，说明我们需要自己预读一些页面。</p></li><li><p>如果 page 带有 uptodate 标志，则跳到下一步，否则：</p><ul><li>等待 page 的 lock 标志被清零（等待 page 被解锁）。</li><li>如果 page 带有 uptodate 标志，则跳转到步骤 4。</li><li>现在，文件可能被 truncate 了，需要进行检查。如果有 <code>mapping-&gt;a_ops-&gt;is_partially_uptodate()</code> 回调，且通过该回调发现我们需要读的范围内数据是 uptodate 的，则跳转到步骤 4，否则跳转到步骤 5。</li></ul></li><li><p>现在，数据是确保在内存中的，且是 uptodate 的。将 page 里面的数据拷贝到用户的 buffer 里面，然后进行下个 page 的处理或者退出循环。</p></li><li><p>到这一步，说明有 page，但数据没有 uptodate。</p><ul><li>如果 <code>page-&gt;mapping</code> 为空，则说明这整个页都被 truncate 了，即可以考虑下一块页面的处理（进入 continue）。</li><li>接下来需要调用 <code>mapping-&gt;a_ops-&gt;readpage()</code> 读取数据。</li><li>回到步骤 4，进行数据拷贝。</li></ul></li><li><p>到这一步，说明没有对应的 page，需要先分配一个 page，加入到 address_space 和 lru 结构中，然后回到步骤 5。</p></li></ol><h2 id="通用-write-流程"><a href="#通用-write-流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#通用-write-流程" class="headerlink" title="通用 write 流程"></a>通用 write 流程</h2><p>write 操作会更新 inode 的 mtime 和 ctime，以及 version。同理分为 direct_io 和 address_space 两种。</p><p>如果走 direct_io：</p><ol><li><p>如果 address_space 中缓存有要写入范围的数据，且当前进程不能阻塞，则立即返回错误。</p></li><li><p>否则，先通过 address_space 将缓存的数据刷下去。</p></li><li><p>现在处理缓存数据的其他问题。对于处于 write 范围内的每一个被缓存的 page 而言：</p><ul><li>首先，确保 page 的数据被刷到了磁盘上（上一步已经确保了这一步）。</li><li>如果这个 page 做了 mmap，取消这一页的 mmap。</li><li>接下来将这个 page 从 address_page 中取下，分为两步：<ul><li>如果这个页是 dirty 的话，先调用 <code>mapping-&gt;a_ops-&gt;launder_page()</code> 将脏数据刷下去。这一回调与 writepage() 回调的不同在于，它不允许文件系统通过 redirty 的方式跳过对这一页的 flush 操作。</li><li>接下来将 page 从 address_page 中取下，然后调用 <code>mapping-&gt;a_ops-&gt;freepage()</code> 释放掉这一 page。</li></ul></li></ul></li><li><p>接下来，调用 <code>mapping-&gt;a_ops-&gt;direct_io()</code> 写数据。</p></li><li><p>然后，继续调用步骤 3 来刷一次 page。这是因为可能有其他进程预读了这一部分的数据，或者因为 mmap 了，然后在访问时出现 page fault 导致这一部分的数据被拉进来了。</p></li><li><p>如果 direct_io 调用失败了，则通过写 Cache、刷 Cache、再无效化 Cache 的方式写数据。</p><ul><li>写 Cache。对于写入范围内的每一页：<ul><li>调用 <code>mapping-&gt;a_ops-&gt;write_begin()</code>，通知文件系统准备往 page 上数据了。</li><li>kmap page 后，将数据从用户空间拷贝到 page 上，然后 kunmap page，刷 tlb。</li><li>调用 <code>mapping-&gt;a_ops-&gt;write_end()</code>，通知文件系统往 page 上写数据的过程结束。</li><li>判断脏数据是否超过某一阈值，以决定是否需要后台刷数据下去。</li></ul></li><li>刷 Cache 和无效化 Cache 的过程与步骤 2、3 类似。</li></ul></li><li><p>至此，direct_io 的过程结束。</p></li></ol><p>如果是普通的写 Cache，而不是 direct_io，则与上述步骤 6 的写 Cache 步骤相同。</p><p>如果写入数据成功，且用户指定了需要 fsync，则通过 <code>file-&gt;f_op-&gt;fsync()</code> 回调将更新的数据刷下去。</p><h2 id="address-space-刷数据流程"><a href="#address-space-刷数据流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#address-space-刷数据流程" class="headerlink" title="address_space 刷数据流程"></a>address_space 刷数据流程</h2><ol><li><p>先调用 <code>mapping-&gt;a_ops-&gt;writepages</code> 刷数据。</p></li><li><p>如果 writepages 回调不存在，只能使用 write_page 回调。</p><ul><li>blk_start_plug()</li><li>对于范围内的每个 page：<ul><li>如果要等待所有 page 完成（<code>wbc-&gt;sync_mode == WB_SYNC_ALL</code>）或者标记了 <code>wbc-&gt;tagged_writepages</code>，则将 address_space 中标记为 PAGECACHE_TAG_DIRTY 的页面再标记为 PAGECACHE_TAG_TOWRITE。原来的 DIRTY 标记不去掉。</li><li>如果上一步设置了 TOWRITE 标记，则再次在 address_space 中搜索标记为 TOWRITE 的那些 page，否则搜索在 address_space 中标记为 DIRTY 的回调（仅在给定的范围内搜索）。对于搜索到的 page：<ul><li>如果 page 的（不是 address_space 的）DIRTY 标记被清掉了，说明其他进程先刷下去了，我们不需要对这个 page 做任何操作。</li><li>如果 page 有 WRITEBACK 标记，如果 <code>wbc-&gt;sync_mode != WB_SYNC_NONE</code>，我们需要等待这个 page 的 writeback 操作完成。</li><li>否则，由当前进程负责调用 <code>mapping-&gt;a_op-&gt;writepage()</code> 回调刷数据。</li></ul></li></ul></li><li>blk_finish_plug()</li></ul></li><li><p>如果回调函数返回了 -NOMEM，表示对应块设备繁忙。此时如果 <code>wbc-&gt;sync_mode == WB_SYNC_ALL</code>，代表可以在这里等待设备刷数据，因此调用 io_schedule() 稍微等待一段时间后回到第一步重试。</p></li><li><p>搜索 address_space，对于范围内的每个标记为 PAGECACHE_TAG_WRITEBACK 的 page，等待 page 的 writeback 标记被清空。</p></li></ol><blockquote><p>我们并没有设置 address_space 的 PAGECACHE_TAG_WRITEBACK 标志，但是在等待数据被刷下去时，却是搜索的该标志。其实 PAGECACHE_TAG_WRITEBACK 标志是被 <code>a_op-&gt;readpage()</code> 或 <code>a_op-&gt;readpages()</code> 回调函数设置的。</p></blockquote><h2 id="等待-page-标志流程"><a href="#等待-page-标志流程" class="heading-link"><i class="fas fa-link"></i></a><a href="#等待-page-标志流程" class="headerlink" title="等待 page 标志流程"></a>等待 page 标志流程</h2><p>等待 page 标志被清零，这是常见的操作。例如等待 page 的 writeback 标志被清零，表示 page 被写下去了。</p><p>page 的等待机制是用哈希表完成的，名字是 page_wait_table，共 256 根链表，以 page 的地址作为键（Key）。</p><ol><li><p>每次需要等待 page 的某个标志位被清零时，在栈上创建一个 wait_page_queue，作为 wait_queue 的一个 entry。</p></li><li><p>让该 entry 将入到对应的 wait_page_queue 的尾部，然后调用 io_schedule() 进行等待。</p></li><li><p>当有其他进程从哈希表的链表上唤醒某个 page 时，会判断当前 entry 等待的 page 是否与将要唤醒的 page 相同，等待标志是否相同。若相同，会先调用 wait_page_queue 的回调函数将该 entry 从链表上取下，然后再唤醒进程。</p></li><li><p>当从阻塞中被唤醒后，判断标志位是否被清零。如果是，则从等待中返回。如果是被信号打断的，也需要返回，否则回到步骤 2 重新等待。</p></li></ol><h2 id="plug-机制"><a href="#plug-机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#plug-机制" class="headerlink" title="plug 机制"></a>plug 机制</h2><h3 id="plug"><a href="#plug" class="heading-link"><i class="fas fa-link"></i></a><a href="#plug" class="headerlink" title="plug"></a>plug</h3><p><strong>plug 机制用于缓存刷向通用块层的数据。</strong>使用方法如下：</p><ol><li><p>调用 blk_start_plug() 初始化一个 plug。</p></li><li><p>处理各种往通用块层读写数据的请求。</p></li><li><p>调用 blk_finish_plug() 刷数据。</p></li></ol><p>plug 仅有三根链表：</p><ol><li><p>list：用于普通 request 的链表，上面串着单队列的 request。</p></li><li><p>mq_list：用于 multi-queue 的链表，上面串着多队列的 request。</p></li><li><p>cb_list：在 unplug 时需调用的回调函数链表。</p></li></ol><figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_plug</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mq_list</span>;</span> <span class="comment">/* blk-mq requests */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">cb_list</span>;</span> <span class="comment">/* md requires an unplug callback */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> rq_count;</span><br><span class="line">	<span class="type">bool</span> multiple_queues;</span><br><span class="line">	<span class="type">bool</span> nowait;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_plug_cb</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*blk_plug_cb_fn)</span><span class="params">(<span class="keyword">struct</span> blk_plug_cb *, <span class="type">bool</span>)</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">blk_plug_cb</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	blk_plug_cb_fn callback;</span><br><span class="line">	<span class="type">void</span> *data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><h3 id="blk-start-plug"><a href="#blk-start-plug" class="heading-link"><i class="fas fa-link"></i></a><a href="#blk-start-plug" class="headerlink" title="blk_start_plug"></a>blk_start_plug</h3><p>plug 总是与进程绑在一起的，一个进程只会有一个 plug，但 plug 机制可以递归进入。</p><ol><li><p>判断 <code>current-&gt;plug</code> 是否存在，如果存在，直接返回。</p></li><li><p>初始化 plug 的三根链表。</p></li><li><p>将外界传递进来的 plug 作为 <code>task-&gt;plug</code>。</p></li></ol><h3 id="blk-finish-plug"><a href="#blk-finish-plug" class="heading-link"><i class="fas fa-link"></i></a><a href="#blk-finish-plug" class="headerlink" title="blk_finish_plug"></a>blk_finish_plug</h3><ol><li><p>如果外界传递进来的 plug 不是 <code>current-&gt;plug</code>，则处于递归调用 plug 中，直接返回。</p></li><li><p>调用 <code>plug-&gt;cb_list</code> 中的所有回调函数。</p></li><li><p>将 mq_list 的 request 刷下去。</p><ul><li>对 mq_list 进行排序。这样属于同一个 blk_mq_ctx 的那些 request 就被放在一起了。</li><li>将属于同一个 blk_mq_ctx 的 request 搜集到一根链表上，统一提交到同一个 blk_mq_hw_ctx 中。</li></ul></li><li><p>将 list 的 request 刷下去。</p><ul><li>对 list 进行排序。这样属于同一个 request_queue 的那些 request 就被放在一起了。</li><li>将属于同一个 request_queue 的 request 搜集到一根链表上，统一提交到对应的 request_queue 中。</li></ul></li><li><p>设置 <code>current-&gt;plug</code> 为 NULL。</p></li></ol><h2 id="inode、super-block-和-dentry-的并发查找机制"><a href="#inode、super-block-和-dentry-的并发查找机制" class="heading-link"><i class="fas fa-link"></i></a><a href="#inode、super-block-和-dentry-的并发查找机制" class="headerlink" title="inode、super_block 和 dentry 的并发查找机制"></a>inode、super_block 和 dentry 的并发查找机制</h2><p>以 inode 为例，经常会遇到 malloc() 一个 inode 的情况。一般来说，内核中对于一个文件只对应一个 inode，但如果两个进程同时想针对硬盘上的同一个文件创建 inode，就会造成冲突。</p><p>内核为解决这个问题，将所有的 inode 放在了 inode_hashtable，被自旋锁保护。当需要一个文件对应的 inode 时：</p><ol><li><p>加锁，从该哈希表查找对应的 inode，解锁。</p></li><li><p>若没有，分配一个 inode。</p></li><li><p>加锁。</p></li><li><p>从该哈希表中再次查找对应的 inode。</p></li><li><p>若不存在对应的 inode，将新的 inode 加入到哈希表中。</p></li><li><p>解锁。</p></li><li><p>若存在对应的 inode，将刚才分配的 inode 释放掉。</p></li></ol><p>dentry 和 super_block 也有类似机制，设计内核的一系列函数 iget_locked()、sget()、d_alloc_parallel() 等。</p><p>dentry 比较特殊。它将要查找的 dentry 放到一个名为 in_lookup_hashtable 的哈希表中，而将所有的 dentry 放入到 dentry_hashtable 中。</p><h1 id="参考文章"><a href="#参考文章" class="heading-link"><i class="fas fa-link"></i></a><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ol><li><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://linux-kernel-labs.github.io/refs/heads/master/">Linux Kernel Teaching — The Linux Kernel documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li><li><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://linux-kernel-labs-zh.xyz/">Linux 内核教学 — Linux 系统内核文档</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p></li></ol></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://blog.davidingplus.cn">DavidingPlus</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://blog.davidingplus.cn/posts/68b0f3fd.html">https://blog.davidingplus.cn/posts/68b0f3fd.html</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-reward reward"><div class="reward-button">大爷，赏个铜板呗~~~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/images/reward/alipay.webp"><div class="reward-qrcode-alipay__text">支付宝</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/images/reward/wechat-pay.webp"><div class="reward-qrcode-wechat__text">微信</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/posts/69869e7f.html"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">Block Device Drivers</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/posts/2d325f6a.html"><span class="paginator-prev__text">TeRM：Extending RDMA-Attached Memory with SSD</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%EF%BC%88VFS%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">虚拟文件系统（VFS）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%A0%88%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">存储栈整体结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.</span> <span class="toc-text">常见的文件系统模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#super-block"><span class="toc-number">3.1.</span> <span class="toc-text">super_block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inode"><span class="toc-number">3.2.</span> <span class="toc-text">inode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#file"><span class="toc-number">3.3.</span> <span class="toc-text">file</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dentry"><span class="toc-number">3.4.</span> <span class="toc-text">dentry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.5.</span> <span class="toc-text">其他数据结构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E5%92%8C%E6%B3%A8%E9%94%80%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">注册和注销文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-file-system-type"><span class="toc-number">4.1.</span> <span class="toc-text">struct file_system_type</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mount-%E5%92%8C-kill-sb"><span class="toc-number">4.2.</span> <span class="toc-text">mount() 和 kill_sb()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#super-block-1"><span class="toc-number">5.</span> <span class="toc-text">super_block</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-super-block"><span class="toc-number">5.1.</span> <span class="toc-text">struct super_block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#super-block-%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.</span> <span class="toc-text">super_block 操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#fill-super"><span class="toc-number">6.</span> <span class="toc-text">fill_super()</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E7%BC%93%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">缓冲区缓存</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E5%AE%8F"><span class="toc-number">8.</span> <span class="toc-text">函数和有用的宏</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#inode-1"><span class="toc-number">9.</span> <span class="toc-text">inode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-inode"><span class="toc-number">9.1.</span> <span class="toc-text">struct inode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inode-%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.</span> <span class="toc-text">inode 操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-inode"><span class="toc-number">9.2.1.</span> <span class="toc-text">获取 inode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B6%85%E7%BA%A7%E5%9D%97%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.2.</span> <span class="toc-text">超级块操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#inode-operations"><span class="toc-number">9.2.3.</span> <span class="toc-text">inode_operations</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mount"><span class="toc-number">10.</span> <span class="toc-text">mount</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#file-1"><span class="toc-number">11.</span> <span class="toc-text">file</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">12.</span> <span class="toc-text">常规文件索引节点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#page-cache"><span class="toc-number">13.</span> <span class="toc-text">page cache</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#address-space"><span class="toc-number">14.</span> <span class="toc-text">address_space</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#dentry-1"><span class="toc-number">15.</span> <span class="toc-text">dentry</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-dentry"><span class="toc-number">15.1.</span> <span class="toc-text">struct dentry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dentry-%E6%93%8D%E4%BD%9C"><span class="toc-number">15.2.</span> <span class="toc-text">dentry 操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">16.</span> <span class="toc-text">目录索引节点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">16.1.</span> <span class="toc-text">目录索引节点操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">16.2.</span> <span class="toc-text">相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">16.2.1.</span> <span class="toc-text">创建索引节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">16.2.2.</span> <span class="toc-text">创建目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E9%93%BE%E6%8E%A5"><span class="toc-number">16.2.3.</span> <span class="toc-text">创建链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5"><span class="toc-number">16.2.4.</span> <span class="toc-text">创建符号链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E9%93%BE%E6%8E%A5"><span class="toc-number">16.2.5.</span> <span class="toc-text">删除链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95"><span class="toc-number">16.2.6.</span> <span class="toc-text">删除目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E7%9B%AE%E5%BD%95%E4%B8%AD%E6%90%9C%E7%B4%A2%E7%B4%A2%E5%BC%95%E8%8A%82%E7%82%B9"><span class="toc-number">16.2.7.</span> <span class="toc-text">在目录中搜索索引节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E7%9B%AE%E5%BD%95%E4%B8%AD%E7%9A%84%E6%9D%A1%E7%9B%AE"><span class="toc-number">16.2.8.</span> <span class="toc-text">遍历目录中的条目</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%8D%E5%9B%BE%E6%93%8D%E4%BD%9C"><span class="toc-number">17.</span> <span class="toc-text">位图操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">18.</span> <span class="toc-text">流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">18.1.</span> <span class="toc-text">文件系统整体运行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#path-lookup-%E8%BF%87%E7%A8%8B"><span class="toc-number">18.2.</span> <span class="toc-text">path lookup 过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mount-%E8%BF%87%E7%A8%8B"><span class="toc-number">18.3.</span> <span class="toc-text">mount 过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#open-%E8%BF%87%E7%A8%8B"><span class="toc-number">18.4.</span> <span class="toc-text">open 过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8-read-%E6%B5%81%E7%A8%8B"><span class="toc-number">18.5.</span> <span class="toc-text">通用 read 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8-write-%E6%B5%81%E7%A8%8B"><span class="toc-number">18.6.</span> <span class="toc-text">通用 write 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#address-space-%E5%88%B7%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B"><span class="toc-number">18.7.</span> <span class="toc-text">address_space 刷数据流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%89%E5%BE%85-page-%E6%A0%87%E5%BF%97%E6%B5%81%E7%A8%8B"><span class="toc-number">18.8.</span> <span class="toc-text">等待 page 标志流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#plug-%E6%9C%BA%E5%88%B6"><span class="toc-number">18.9.</span> <span class="toc-text">plug 机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#plug"><span class="toc-number">18.9.1.</span> <span class="toc-text">plug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blk-start-plug"><span class="toc-number">18.9.2.</span> <span class="toc-text">blk_start_plug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blk-finish-plug"><span class="toc-number">18.9.3.</span> <span class="toc-text">blk_finish_plug</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#inode%E3%80%81super-block-%E5%92%8C-dentry-%E7%9A%84%E5%B9%B6%E5%8F%91%E6%9F%A5%E6%89%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">18.10.</span> <span class="toc-text">inode、super_block 和 dentry 的并发查找机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">19.</span> <span class="toc-text">参考文章</span></a></li></ol></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/android-chrome-512x512.webp" alt="avatar"></div><p class="sidebar-ov-author__text">Self-discipline is key in life.</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/DavidingPlus" target="_blank" rel="noopener" data-popover="GitHub" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/qq/" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="/wechat/" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="mailto:davidingplus@qq.com" target="_blank" rel="noopener" data-popover="davidingplus@qq.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">36</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">20</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">您已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023~2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>DavidingPlus</span><span class="footer__devider">|</span><span>蜀 ICP 备 2024088070 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.6</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("09/18/2023 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小破站已经安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒啦！"}setInterval("createtime()",250)</script></div><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;theme&quot;:&quot;default&quot;}" src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/mermaid.min.js"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></div></footer><div class="loading-animation" id="loading-animation"><div class="loading-animation__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-thumbs-up"></i></span></div><div class="back2bottom" id="back2bottom"><span class="back2bottom__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"><div class="search-btns">使用搜索：<span class="search-btns-item search-btns-item--bing"><i></i>必应</span><span class="search-btns-item search-btns-item--baidu"><i></i>百度</span></div></div><div class="search-results"></div></div><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/jquery.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity-ui.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/canvas-nest.js" color="255,255,255" opacity="1" count="99" zindex="-1"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/fancybox.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/masonry.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/lazyload.js"></script><script>function initSearch(){var e=!0,t="search.json";t?/json$/i.test(t)&&(e=!1):t="search.xml";var n="/"+t;$.ajax({url:n,dataType:e?"xml":"json",async:!0,success:function(t){var n=e?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,o=$(".search-input input"),i=$(".search-results"),c=100,r=1,a=function(){var e=o.val().toLowerCase().trim(),t=e.split(/[\s]+/),a=[];t.length>1&&t.push(e),e.length>0&&n.forEach(function(e){var n=!1,o=e.title&&e.title.trim()||"[ 文章无标题 ]",i=o&&o.toLowerCase(),s=e.content&&e.content.replace(/<[^>]+>/g,""),l=s&&s.toLowerCase(),u=e.url&&decodeURI(e.url).replace(/\/{2,}/g,"/"),h=[],d=[];t.forEach(function(e){function t(e,t,n,o){if(!e||!t)return[];var i=0,c=-1,r=[];for(n||(e=e.toLowerCase(),t=t.toLowerCase());-1!==(c=t.indexOf(e,i));){var a=!1;h.forEach(function(t){t.index===c&&t.word.length<e.length&&(t.word=e,a=!0)}),i=c+e.length,!a&&r.push({index:c,word:e,weight:o})}return r}h=h.concat(t(e,i,!1,c)),d=d.concat(t(e,l,!1,r))});var f=h.length,p=d.length;if((f>0||p>0)&&(n=!0),n){function w(e,t,n,o){if(e&&t&&t.length){var i="",c=n,r=o;return t.forEach(function(t){if(!(t.index<c)){var n=t.index+t.word.length;i+=e.slice(c,t.index),i+="<b>"+e.slice(t.index,n)+"</b>",c=n}}),i+=e.slice(c,r)}}[h,d].forEach(function(e){e.sort(function(e,t){return e.index-t.index})});var v,g={},x=h.length*c+d.length*r,y=w(o,h,0,o.length)||o;if(d.length>0){var S=d[0].index;v=w(s,d,S>20?S-20:0,S+180)}else v=s.slice(0,200);g.title=y,g.content=v,g.url=u,g.weight=x,a.push(g)}});var s="";a.length?(a.sort(function(e,t){return t.weight-e.weight}),s+="<ul>",a.forEach(function(e){s+='<li><a class="search-results-title" href="'+e.url+'">',s+=e.title,s+='</a><div class="search-results-content">',s+=e.content,s+="</div></li>"}),s+="</ul>"):s+='<div class="search-results-none"><i class="far fa-meh"></i></div>',i.html(s)};o.on("input",a),o.on("keyup",function(e){e.keyCode===Stun.utils.codeToKeyCode("Enter")&&a()})}})}function closeSearch(){$("body").css({overflow:"auto"}),$(".search-popup").css({display:"none"}),$(".search-mask").css({display:"none"})}function safeOpenUrl(e){var t=window.open();t.opener=null,t.location=e}function extSearch(e){var t=window.location.host,n=$(".search-input input").val().toLowerCase().trim();n?safeOpenUrl({google:"https://www.google.com/search?q=",bing:"https://cn.bing.com/search?q=",baidu:"https://www.baidu.com/s?ie=UTF-8&wd="}[e]+n+" site:"+t):Stun.utils.popAlert("warning","请输入字符")}window.addEventListener("DOMContentLoaded",function(){Stun.utils.pjaxReloadLocalSearch=function(){$(".header-nav-search").on("click",function(e){e.stopPropagation(),$("body").css("overflow","hidden"),$(".search-popup").velocity("stop").velocity("transition.expandIn",{duration:300,complete:function(){$(".search-popup input").focus()}}),$(".search-mask").velocity("stop").velocity("transition.fadeIn",{duration:300}),initSearch()}),$(".search-mask, .search-close").on("click",function(){closeSearch()}),$(document).on("keydown",function(e){e.keyCode===Stun.utils.codeToKeyCode("Escape")&&closeSearch()})},Stun.utils.pjaxReloadLocalSearch()},!1);var assistSearchList=window.CONFIG.assistSearch;Array.isArray(assistSearchList)&&assistSearchList.forEach(function(e){document.querySelector(".search-btns-item--"+e).addEventListener("click",function(){extSearch(e)},!1)})</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/pjax.js"></script><script>window.addEventListener("DOMContentLoaded",function(){new Pjax({selectors:["head title","#main",".pjax-reload",".header-banner"],history:!0,scrollTo:!1,scrollRestoration:!1,cacheBust:!1,debug:!1,currentUrlFullReload:!1,timeout:0});document.addEventListener("pjax:send",function(){$(".header-nav-menu").removeClass("show"),CONFIG.pjax&&CONFIG.pjax.avoidBanner&&$("html").velocity("scroll",{duration:500,offset:$("#header").height(),easing:"easeInOutCubic"}),$(".loading-animation").addClass("loading")},!1),window.addEventListener("pjax:complete",function(){if($(".loading-animation").removeClass("loading"),$("link[rel=prefetch], script[data-pjax-rm]").each(function(){$(this).remove()}),$("script[data-pjax], #pjax-reload script").each(function(){$(this).parent().append($(this).remove())}),Stun.utils.pjaxReloadBoot&&Stun.utils.pjaxReloadBoot(),Stun.utils.pjaxReloadScroll&&Stun.utils.pjaxReloadScroll(),Stun.utils.pjaxReloadSidebar&&Stun.utils.pjaxReloadSidebar(),"undefined"!=typeof mermaid){const e=Array.from(document.querySelectorAll(".mermaid")).filter(e=>!e.dataset.processed);mermaid.init(void 0,e)}},!1)},!1)</script><div id="pjax-reload"><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/quicklink.js"></script><script>function initQuicklink(){quicklink({timeout:"10000",priority:!0,ignores:[i=>i.includes("#"),i=>"https://blog.davidingplus.cn/posts/68b0f3fd.html"===i,/\/api\/?/,i=>i.includes(".xml"),i=>i.includes(".zip"),(i,t)=>t.hasAttribute("nofollow"),(i,t)=>t.hasAttribute("noprefetch")]})}initQuicklink()</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/busuanzi.js" async></script></div><script src="/js/utils.js?v=2.8.6"></script><script src="/js/stun-boot.js?v=2.8.6"></script><script src="/js/scroll.js?v=2.8.6"></script><script src="/js/header.js?v=2.8.6"></script><script src="/js/sidebar.js?v=2.8.6"></script><script type="application/json" src="/search.json"></script><script data-pjax="">function loadUtterances(){var t=document,e=t.createElement("script"),s=t.getElementById("utterances-container"),r=Stun.utils.getNightMode()?"photon-dark":"github-light";s&&(e.src="https://utteranc.es/client.js",e.setAttribute("repo","DavidingPlus/blog-comments"),e.setAttribute("issue-term","title"),e.setAttribute("label","utterances"),e.setAttribute("theme",r),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),e.setAttribute("data-pjax-rm",""),s.append(e))}loadUtterances()</script><script async src="/js/cursor/text.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="🤡快回来,粗大事了~~"+OriginTitile,clearTimeout(titleTime)):(document.title="😚欢迎回来!~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:160,height:290},mobile:{show:!0},log:!1})</script></body></html>