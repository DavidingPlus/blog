<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><script>window.MSInputMethodContext&&document.documentMode&&(window.location.href="https://support.dmeng.net/upgrade-your-browser.html")</script><meta name="viewport" content="width=device-width,initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/assets/favicon-16x16.webp?v=2.8.6" type="image/png" sizes="16x16"><link rel="icon" href="/assets/favicon-32x32.webp?v=2.8.6" type="image/png" sizes="32x32"><link rel="apple-touch-icon" href="/assets/apple-touch-icon.webp?v=2.8.6" sizes="180x180"><meta name="description" content="前言       里面需要很多计算机网络的知识，我也懒得写了，在计算机网络复习当中有写到，这是文章的链接：计算机网络期末复习                     第一章 理解网络编程和套接字                           理解网络编程和套接字       网络编程的目的就是使两台联网的计算机相互交换数据。首先需要物理连接，这一点"><meta property="og:type" content="article"><meta property="og:title" content="TCP IP 网络编程"><meta property="og:url" content="https://blog.davidingplus.cn/posts/c5690fb7.html"><meta property="og:site_name" content="DavidingPlus&#39;s Blog"><meta property="og:description" content="前言       里面需要很多计算机网络的知识，我也懒得写了，在计算机网络复习当中有写到，这是文章的链接：计算机网络期末复习                     第一章 理解网络编程和套接字                           理解网络编程和套接字       网络编程的目的就是使两台联网的计算机相互交换数据。首先需要物理连接，这一点"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230818143501064.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230903173752565.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230903173820969.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904193622248.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904194133084.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904195220706.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904203131451.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905105657336.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230624203408369.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230624211609006.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905112425335.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905154922422.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904193622248.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905155342817.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905162539547.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905164245873.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905165356272.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909150644608.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909151100190.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909151937552.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909152233914.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909153956078.png"><meta property="og:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909154125497.png"><meta property="article:published_time" content="2024-06-20T23:00:00.000Z"><meta property="article:modified_time" content="2024-06-20T23:00:00.000Z"><meta property="article:author" content="DavidingPlus"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.davidingplus.cn/images/2025/02/01/image-20230818143501064.png"><title>TCP IP 网络编程 | DavidingPlus's Blog</title><link ref="canonical" href="https://blog.davidingplus.cn/posts/c5690fb7.html"><link rel="dns-prefetch" href="https://cdn.davidingplus.cn"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fontawesome.css" type="text/css"><link rel="stylesheet" href="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/css/fancybox.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.6"><script>var Stun=window.Stun||{},CONFIG={root:"/",algolia:void 0,assistSearch:["bing","baidu"],fontIcon:{prompt:{success:"fas fa-check-circle",info:"fas fa-arrow-circle-right",warning:"fas fa-exclamation-circle",error:"fas fa-times-circle"},copyBtn:"fas fa-copy"},sidebar:{offsetTop:"55px",tocMaxDepth:6},header:{enable:!0,showOnPost:!0,scrollDownIcon:!0},postWidget:{endText:!0},nightMode:{enable:!0},back2top:{enable:!0},back2bottom:{enable:!0},codeblock:{style:"default",highlight:"light",wordWrap:!0},reward:!0,fancybox:!0,zoomImage:{gapAside:"20px"},galleryWaterfall:{colWidth:"255px",gapX:"65px"},lazyload:!0,pjax:{avoidBanner:!0},externalLink:{icon:{enable:!0,name:"fas fa-external-link-alt"}},shortcuts:void 0,prompt:{copyButton:"复制",copySuccess:"恭喜亲亲，复制成功咧",copyError:"哎呀，复制失败了"},sourcePath:{js:"js",css:"css",images:"images"},utterancesTheme:{light:"github-light",dark:"photon-dark"}};window.CONFIG=CONFIG</script><meta name="generator" content="Hexo 7.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="javascript:;" onclick="return!1"><span class="header-nav-menu-item__icon"><i class="fas fa-bars"></i></span><span class="header-nav-menu-item__text">其他</span></a><div class="header-nav-submenu"><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/friends/"><span class="header-nav-submenu-item__icon"><i class="fas fa-users"></i></span><span class="header-nav-submenu-item__text">友链</span></a></div><div class="header-nav-submenu-item"><a class="header-nav-submenu-item__link" href="/gallery/"><span class="header-nav-submenu-item__icon"><i class="fas fa-images"></i></span><span class="header-nav-submenu-item__text">相册</span></a></div></div></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/about/"><span class="header-nav-menu-item__icon"><i class="fas fa-user"></i></span><span class="header-nav-menu-item__text">关于</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" target="_blank" rel="noopener" href="https://davidingplus.cn/"><span class="header-nav-menu-item__icon"><i class="fas fa-pager"></i></span><span class="header-nav-menu-item__text">站点主页</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">DavidingPlus's Blog</div><div class="header-banner-info__subtitle">🕊️ world peace</div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">TCP IP 网络编程</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2024-06-20</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2024-06-20</span></span><span class="post-meta-item post-meta-item--wordcount"><span class="post-meta-item__icon"><i class="far fa-file-word"></i></span><span class="post-meta-item__info">字数统计</span><span class="post-meta-item__value">7.8k</span></span><span class="post-meta-item post-meta-item--readtime"><span class="post-meta-item__icon"><i class="far fa-clock"></i></span><span class="post-meta-item__info">阅读时长</span><span class="post-meta-item__value">48分</span></span><span class="post-meta-item post-meta-item--visitors"><span class="post-meta-item__icon"><i class="fas fa-eye"></i></span><span class="post-meta-item__info">阅读次数</span><span class="post-meta-item__value" id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body"><meta name="referrer" content="no-referrer"><h1 id="前言"><a href="#前言" class="heading-link"><i class="fas fa-link"></i></a><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>里面需要很多计算机网络的知识，我也懒得写了，在计算机网络复习当中有写到，这是文章的链接：<a href="https://blog.davidingplus.cn/posts/b9598422.html">计算机网络期末复习</a></p><h1 id="第一章-理解网络编程和套接字"><a href="#第一章-理解网络编程和套接字" class="heading-link"><i class="fas fa-link"></i></a><a href="#第一章-理解网络编程和套接字" class="headerlink" title="第一章 理解网络编程和套接字"></a>第一章 理解网络编程和套接字</h1><h2 id="理解网络编程和套接字"><a href="#理解网络编程和套接字" class="heading-link"><i class="fas fa-link"></i></a><a href="#理解网络编程和套接字" class="headerlink" title="理解网络编程和套接字"></a>理解网络编程和套接字</h2><p>网络编程的目的就是使两台联网的计算机相互交换数据。首先需要物理连接，这一点已经达到了，基本上所有的电脑都是连通庞大的互联网的，所以这一点不需要担心；在此基础上我们只需要考虑如何使用程序来将两个主机建立连接即可，操作系统会给我们提供名为套接字(<code>socket</code>)的部件。</p><span id="more"></span><h3 id="TCP套接字"><a href="#TCP套接字" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP套接字" class="headerlink" title="TCP套接字"></a>TCP套接字</h3><p>我们先考虑比较重要的TCP套接字，他是建立连接的，可靠的运输层协议</p><p>这是TCP协议的通信过程，我们来看一下其中哪些地方比较重要：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230818143501064.png" alt="image-20230818143501064"></p><p>我们将通信过程总结如下：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP 通信的流程</span></span><br><span class="line"><span class="comment">// 服务器端 （被动接受连接的角色）</span></span><br><span class="line">    <span class="number">1.</span> 创建一个用于监听的套接字</span><br><span class="line">        - 监听：监听有客户端的连接</span><br><span class="line">        - 套接字：这个套接字其实就是一个文件描述符</span><br><span class="line">    <span class="number">2.</span> 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）</span><br><span class="line">    	- 客户端连接服务器的时候使用的就是这个IP和端口</span><br><span class="line">    <span class="number">3.</span> 设置监听，监听的fd开始工作</span><br><span class="line">    <span class="number">4.</span> 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字(fd)</span><br><span class="line">    <span class="number">5.</span> 通信</span><br><span class="line">        - 接收数据</span><br><span class="line">        - 发送数据</span><br><span class="line">    <span class="number">6.</span> 通信结束，断开连接</span><br></pre></td></tr></table></div></figure><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端</span></span><br><span class="line">    <span class="number">1.</span> 创建一个用于通信的套接字（fd）</span><br><span class="line">    <span class="number">2.</span> 连接服务器，需要指定连接的服务器的 IP 和 端口</span><br><span class="line">    <span class="number">3.</span> 连接成功了，客户端可以直接和服务器通信</span><br><span class="line">        - 接收数据</span><br><span class="line">        - 发送数据</span><br><span class="line">    <span class="number">4.</span> 通信结束，断开连接</span><br></pre></td></tr></table></div></figure><p><strong>客户端有两个套接字比较重要，一个是用于监听服务端的套接字<code>listen_fd</code>，这个套接字用于时刻监听客户端是否连接；另一个是和客户端进行通信的套接字<code>connect_fd</code>，这个套接字就是用来进行通信的。套接字就是伪文件描述符，使用方法和文件描述符一样</strong></p><h3 id="例子"><a href="#例子" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子" class="headerlink" title="例子"></a><span id="example">例子</span></h3><p>我们写一个程序来进行TCP本地双方的简单通信：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_IPV4_STRING_SIZE 16</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s  &lt;ip&gt;  &lt;port&gt;.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* server_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> server_port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建socket套接字</span></span><br><span class="line">    <span class="type">int</span> listen_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == listen_fd) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.由于客户端需要主动连接，服务端需要绑定一个固定端口</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    <span class="comment">// 地址族</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// ip</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// 端口</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(server_port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">bind</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;server has initalized.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.开始监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>(listen_fd, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.接受客户端连接</span></span><br><span class="line">    <span class="comment">// 我们就简单的让客户端发送数据，服务端不断接受，并且是p2p</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> client_addr;</span><br><span class="line">    <span class="type">socklen_t</span> client_addr_len = <span class="built_in">sizeof</span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> connect_fd = <span class="built_in">accept</span>(listen_fd, (<span class="keyword">struct</span> sockaddr*)&amp;client_addr, &amp;client_addr_len);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == connect_fd) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;accept&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取客户端信息</span></span><br><span class="line">    <span class="type">in_port_t</span> client_port = <span class="built_in">ntohs</span>(client_addr.sin_port);</span><br><span class="line">    <span class="type">char</span> client_ip[MAX_IPV4_STRING_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">inet_ntop</span>(AF_INET, &amp;client_addr.sin_addr.s_addr, client_ip, <span class="built_in">sizeof</span>(client_ip));</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> buf[MAX_BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 5.开始通信</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">recv</span>(connect_fd, buf, <span class="built_in">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">-1</span> == len) &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv client(ip: %s,port:%d) message: %s&quot;</span>, client_ip, client_port, buf);</span><br><span class="line">        <span class="keyword">else</span> &#123;  <span class="comment">// 写端关闭</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;client(ip: %s,port:%d) has closed...\n&quot;</span>, client_ip, client_port);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6.关闭socket</span></span><br><span class="line">    <span class="built_in">close</span>(connect_fd);</span><br><span class="line">    <span class="built_in">close</span>(listen_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* <span class="type">const</span> argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断命令行参数</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;usage: %s  &lt;ip&gt;  &lt;port&gt;.\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* server_ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">short</span> server_port = <span class="built_in">atoi</span>(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建socket套接字</span></span><br><span class="line">    <span class="type">int</span> connect_fd = <span class="built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == connect_fd) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;socket&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.开始连接</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> server_addr;</span><br><span class="line">    <span class="comment">// 地址族</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    <span class="comment">// ip</span></span><br><span class="line">    <span class="built_in">inet_pton</span>(AF_INET, server_ip, &amp;server_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="comment">// port</span></span><br><span class="line">    server_addr.sin_port = <span class="built_in">htons</span>(server_port);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = <span class="built_in">connect</span>(connect_fd, (<span class="keyword">struct</span> sockaddr*)&amp;server_addr, <span class="built_in">sizeof</span>(server_addr));</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">-1</span> == ret) &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.开始通信</span></span><br><span class="line">    <span class="type">char</span> buf[MAX_BUFFER_SIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 每隔一秒向服务端发送一次数据</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">bzero</span>(buf, <span class="built_in">sizeof</span>(buf));</span><br><span class="line">        <span class="built_in">sprintf</span>(buf, <span class="string">&quot;hello,this is client, count:%d\n&quot;</span>, count++);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send: %s&quot;</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">send</span>(connect_fd, buf, <span class="built_in">strlen</span>(buf), <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.关闭连接</span></span><br><span class="line">    <span class="built_in">close</span>(connect_fd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>执行结果：</p><p>客户端每隔一秒发送一次，服务端正确接收并且打印了出来</p><p>服务端</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230903173752565.png" alt="image-20230903173752565"></p><p>客户端</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230903173820969.png" alt="image-20230903173820969"></p><h2 id="基于Linux的文件操作"><a href="#基于Linux的文件操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#基于Linux的文件操作" class="headerlink" title="基于Linux的文件操作"></a>基于Linux的文件操作</h2><p>对Linux而言，socket套接字和文件操作没有区别，或者说socket套接字是一个伪文件，我们完全可以用操作文件的方式去操作它</p><p>但是在windows当中，是要区分socket和套接字文件的，在windows当中需要调用特殊的数据传输的相关函数</p><h3 id="文件描述符-文件句柄"><a href="#文件描述符-文件句柄" class="heading-link"><i class="fas fa-link"></i></a><a href="#文件描述符-文件句柄" class="headerlink" title="文件描述符(文件句柄)"></a>文件描述符(文件句柄)</h3><h4 id="open函数"><a href="#open函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h4><p>两种形式</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开一个已经存在的文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的文件</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></div></figure><h5 id="open函数打开文件"><a href="#open函数打开文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#open函数打开文件" class="headerlink" title="open函数打开文件"></a>open函数打开文件</h5><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* pathname, <span class="type">int</span> flags)</span></span>;</span><br></pre></td></tr></table></div></figure><p>参数解释</p><ul><li>pathname：文件路径</li><li>flags：对文件的操作权限设置，还有其他的设置，例如：O_RDONLY，O_WRONLY，O_RDWR 这三个设置是互斥的</li><li>返回值：返回一个新的文件描述符(int类型，类似于编号)，如果失败，返回-1</li></ul><h5 id="open函数创建新文件"><a href="#open函数创建新文件" class="heading-link"><i class="fas fa-link"></i></a><a href="#open函数创建新文件" class="headerlink" title="open函数创建新文件"></a>open函数创建新文件</h5><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></div></figure><p>参数解释：</p><ul><li><p>pathname：创建的文件路径</p></li><li><p>flags：对文件的操作权限和其他的设置<br><strong>必选项：O_RDONLY, O_WRONLY, or O_RDWR 这三个之间是互斥的</strong><br><strong>可选项：O_CREAT 文件不存在创建新文件；O_APPEND 可以进行文件的追加</strong><br><strong>flags参数是一个int类型的数据，占4个字节，32位，每一位就是一个标志位，1表示有，0表示没有，所以用按位或</strong></p></li><li><p>mode：八进制的数，表示用户对创建出的新的文件的操作权限，比如：0777<br><strong>3个7分别表示对不同的用户(所有者，组成员，其他用户的权限)的权限，每一个都是3位 ，第一位表示读R，第二位表示写W，第三位 表示可执行X，7对应就是111全有!!!</strong></p><p><strong>最终的权限是：mode &amp; ~umask</strong><br>umask可以通过shell命令 umask 查看<br>umask的作用是为了抹去某些权限，让我们创建的权限更加合理一些<br>例子：0777 &amp; ~0022</p></li></ul><p>关闭函数</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">close</span><span class="params">(<span class="type">int</span> fd)</span></span>;<span class="comment">//  fd：文件描述符 fd</span></span><br></pre></td></tr></table></div></figure><h4 id="read-write函数"><a href="#read-write函数" class="heading-link"><i class="fas fa-link"></i></a><a href="#read-write函数" class="headerlink" title="read,write函数"></a>read,write函数</h4><p>头文件：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></div></figure><p>两个函数：</p><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></div></figure><ul><li><p>参数：</p><ul><li>fd：文件描述符，通过open得到的，通过文件描述符操作某个文件</li><li>buf：缓冲区，需要读取数据存放的地方，数组的地方(传出参数)</li><li>count：指定的数组的大小</li></ul></li><li><p>返回值：</p><ul><li><p>成功 &gt;0 返回实际读取到的字节数</p><p>​ <strong>&#x3D;&#x3D;0 文件已经读取完了(注意是在调用read函数之前文件指针就在末尾了才会返回0，一次性从头读完是会返回读取的字节数的)</strong></p></li><li><p>失败 -1 并且修改errno</p></li></ul></li></ul><figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></div></figure><ul><li><p>参数：</p><ul><li>fd：文件描述符，通过open得到，通过文件描述符操作某个文件</li><li>buf：要往磁盘写入的数据</li><li>count：要写入的实际的大小</li></ul></li><li><p>返回值：</p><ul><li>成功 &gt;0 返回实际写入的字节数<br>&#x3D;&#x3D;0 文件已经写入完了</li><li>失败 -1 并且修改errno</li></ul></li></ul><p>程序我就不写了，之前学牛客 Linux的时候写了无数遍了，需要自查</p><h1 id="第二章-套接字类型与协议设置"><a href="#第二章-套接字类型与协议设置" class="heading-link"><i class="fas fa-link"></i></a><a href="#第二章-套接字类型与协议设置" class="headerlink" title="第二章 套接字类型与协议设置"></a>第二章 套接字类型与协议设置</h1><h2 id="套接字协议以及数据传输特性"><a href="#套接字协议以及数据传输特性" class="heading-link"><i class="fas fa-link"></i></a><a href="#套接字协议以及数据传输特性" class="headerlink" title="套接字协议以及数据传输特性"></a>套接字协议以及数据传输特性</h2><h3 id="关于协议"><a href="#关于协议" class="heading-link"><i class="fas fa-link"></i></a><a href="#关于协议" class="headerlink" title="关于协议"></a>关于协议</h3><p>两个人需要进行远距离通话，必须要先决定通话方式，如果一方使用电话，那么另一方也必须只能使用电话，否则就无法进行正常的通信。对于他们而言，电话就是两个人通话的协议。</p><p><strong>而对于<code>socket</code>而言，协议就是计算机之前对话需要具备的通信规则，它由语法，语义，同步三个要素组成；简单理解，协议就是为了完成数据交换而定好的约定</strong></p><h3 id="创建套接字socket"><a href="#创建套接字socket" class="heading-link"><i class="fas fa-link"></i></a><a href="#创建套接字socket" class="headerlink" title="创建套接字socket"></a>创建套接字socket</h3><p><code>Linux</code>给我们提供了系统调用<code>socket</code>函数来是我们可以创建套接字</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span> <span class="comment">// 包含了这个头文件，上面两个就可以省略</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">socket</span><span class="params">(<span class="type">int</span> domain, <span class="type">int</span> type, <span class="type">int</span> protocol)</span></span>;</span><br><span class="line">    - 功能：创建一个套接字</span><br><span class="line">    - 参数：</span><br><span class="line">    - domain: 协议族</span><br><span class="line">        AF_INET : ipv4</span><br><span class="line">        AF_INET6 : ipv6</span><br><span class="line">        AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）</span><br><span class="line">	<span class="comment">// 第二个参数type和第三个参数protocol一个是协议类型，一个是具体的某个协议，划分的还比较细和周到</span></span><br><span class="line">    - type: 通信过程中使用的协议类型</span><br><span class="line">        SOCK_STREAM : 流式协议(例如：字节流的TCP，当然不一定只有这一种，可以被第三个参数具体指定)</span><br><span class="line">        SOCK_DGRAM : 报式协议(例如：用户数据报的UDP，当然不一定只有这一种，可以被第三个参数具体指定)</span><br><span class="line">    - protocol : 具体的一个协议。一般写<span class="number">0</span>，可以表示默认的或者当协议类型中只有一个具体类型的时候就是用这个具体的类型</span><br><span class="line">        - SOCK_STREAM : 流式协议默认使用 TCP</span><br><span class="line">        - SOCK_DGRAM : 报式协议默认使用 UDP</span><br><span class="line">    - 返回值：</span><br><span class="line">        - 成功：返回文件描述符，操作的区域是内核缓冲区。</span><br><span class="line">        - 失败：<span class="number">-1</span>，并且设置errno</span><br></pre></td></tr></table></div></figure><h3 id="协议族"><a href="#协议族" class="heading-link"><i class="fas fa-link"></i></a><a href="#协议族" class="headerlink" title="协议族"></a>协议族</h3><p><code>socket</code>函数的协议族可分为如下几类：</p><p>我们用的最多的就是<code>PF_INET</code>和<code>PF_LOCAL</code>，也就是网络上通过<code>IPV4</code>，本地通过本地套接字，当然本地也可以用<code>IPV4</code></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904193622248.png" alt="image-20230904193622248"></p><h3 id="套接字类型-重要"><a href="#套接字类型-重要" class="heading-link"><i class="fas fa-link"></i></a><a href="#套接字类型-重要" class="headerlink" title="套接字类型(重要)"></a>套接字类型(重要)</h3><p>套接字类型就是表示套接字的数据传输方式，比如是类似于<code>TCP</code>的建立连接可靠的面向字节流的，还是类似<code>UDP</code>针对于用户数据报的无连接不可靠的，通过socket函数的第二个参数进行传输，下面我们将针对这两种进行阐述：</p><h4 id="面向连接的套接字-SOCK-STREAM-：TCP"><a href="#面向连接的套接字-SOCK-STREAM-：TCP" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向连接的套接字-SOCK-STREAM-：TCP" class="headerlink" title="面向连接的套接字(SOCK_STREAM)：TCP"></a>面向连接的套接字(SOCK_STREAM)：TCP</h4><p>面向连接，顾名思义，就是在进行正式数据传输之前需要建立连接，可以理解为在双方之间建立了一条逻辑通道，这种方式书上给出了一个类比的例子，同时图中也给出了他的特点：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904194133084.png" alt="image-20230904194133084"></p><p>在运输层当中这就对应者TCP协议，TCP协议是面向字节流的建立连接的可靠的传输服务，下面是一些理解：</p><ul><li><strong>收发双方之间存在缓冲，虽然<code>write</code>和<code>read</code>函数是不带缓冲的<code>I/O</code>函数，但是内核会提供缓冲区，带不带缓冲是针对在用户区有没有缓冲而言的。这个缓冲简而言之就是字节数组，套接字传输的数据并没有直接给到对方，而是在对方的内核的读缓冲区等待读取</strong></li><li><strong>关于不存在数据边界的理解：就是我每次传输的数据不一定就是一个完整的数据，可能我指定的写端的缓冲区比较小，我一次写的数据很少，但是我读端一次可以读取很多，写端写了三次，但是读端一次就读完了；这是合理的，读端也能够把数据正确接受，并不会因为数据被分开传输收到就会怎么样，因此我们称为不存在数据边界</strong></li><li><strong>数据不会丢失和按序传输数据：<code>TCP</code>套接字有累计确认<code>ACK</code>的机制，如果我前面的数据没有收到，那么到了一定时间会让发送方进行重传，然后进行累计确认，这就是协议内部具体的实现了，我们目前不需要过于了解，只需知道TCP可靠的机制保证了按序到达即可</strong></li></ul><h4 id="面向消息的套接字-SOCK-DGREAM-：UDP"><a href="#面向消息的套接字-SOCK-DGREAM-：UDP" class="heading-link"><i class="fas fa-link"></i></a><a href="#面向消息的套接字-SOCK-DGREAM-：UDP" class="headerlink" title="面向消息的套接字(SOCK_DGREAM)：UDP"></a>面向消息的套接字(SOCK_DGREAM)：UDP</h4><p>面向消息，顾名思义，就是强调传输的速度，强调消息传输的及时性，在运输层中对应UDP协议；TCP的传输虽然稳定，但是由于需要建立连接，还有其他的乱七八糟的，效率自然就没有UCP好，虽然面向消息的传输是无连接的面向数据报的不可靠的服务，但是在针对实时性的问题上我们还是选择这个会好一点，比如游戏和视频会议的通信；TCP就可以用在文件的传输上</p><p>书上给出了类比图和特点：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904195220706.png" alt="image-20230904195220706"></p><p>理解：</p><ul><li><strong>由于没有建立连接，所以发送方发给谁，其实是不知道的，接收方通过套接字收取数据，可能这个时候发送方已经发送了部分数据，接收方就丢失了一部分数据；另外，由于没有连接保证，传输的顺序也是没有保证的，有可能按序到达，也有可能不按序到达，我们本地测试的时候看不出来，但是一旦网络拓扑复杂起来就会出问题了因为数据并不一定是沿一条路径走的；</strong></li><li><strong>其次，由于没有连接保证，发送方可不会管接收方接受多少数据，或者是否接收到，发送方就自己发，一旦数据大了，接收方没办法及时接受完全，这部分数据就丢了，这就是坏处，虽然效率提高了，因此需要限制每次传输的数据大小；</strong></li><li><strong>关于<code>UDP</code>的缓冲区，<code>UDP</code>只有一个接收缓冲区，是没有发送缓冲区的，就是说发送方有数据就发出去，不会说接收方缓冲区满了怎么样，因此我们使用UDP通信的时候都不用<code>read</code>&#x2F;<code>write</code>函数，都用另一组系统调用<code>recvfrom</code>和<code>sendto</code>；所以UDP的发送方分批发送的数据，接收方没有办法缓存起来一起接受，因为我们不知道发送方什么时候会继续发送数据，<code>TCP</code>如果满了就会等待读完在发送，这也得益于<code>TCP</code>的写缓冲区，因此<code>UDP</code>具有传输的数据边界</strong></li></ul><h3 id="协议的最终选择"><a href="#协议的最终选择" class="heading-link"><i class="fas fa-link"></i></a><a href="#协议的最终选择" class="headerlink" title="协议的最终选择"></a>协议的最终选择</h3><p>第三个参数使用来决定最终使用什么协议，因为确认了协议族和套接字类型之后，仍有可能存在多个数据传输方式相同的协议，但是TCP和UDP这里是唯一的，他们表示如下：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP</span></span><br><span class="line"><span class="built_in">socket</span>(AF_INET, SOCK_STREAM, IPPROTO_TCP);  <span class="comment">// 第三个参数也可以传入0，表示默认用这个</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// UDP</span></span><br><span class="line"><span class="built_in">socket</span>(AF_INET, SOCK_DGREAM, IPPROTO_UDP);  <span class="comment">// 也可以传0</span></span><br></pre></td></tr></table></div></figure><h3 id="例子-1"><a href="#例子-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>为了证明TCP的套接字是没有数据边界的，我们可以修改上面程序的缓冲区大小，让recv函数和send函数调用次数不同，我们再来看读取结果，<a href="#example">程序点击这里</a>，下面只写改动的地方：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.cpp</span></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">recv</span>(connect_fd, buf, <span class="number">5</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> == len) &#123;</span><br><span class="line">    <span class="built_in">perror</span>(<span class="string">&quot;recv&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// printf(&quot;recv client(ip: %s,port:%d) message: %s&quot;, client_ip, client_port, buf);</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line"><span class="comment">// 这里我让每次读取的最大的长度为5个字节，显然一次没办法接受完数据</span></span><br><span class="line"><span class="comment">// 然后为了避免每次接受数据都有前缀打印，会有干扰，我把前缀删了</span></span><br></pre></td></tr></table></div></figure><p>结果：</p><p>服务端接收到的数据仍然没有任何问题，说明TCP的数据传输是没有边界的</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904203131451.png" alt="image-20230904203131451"></p><h1 id="第三章-地址族与数据序列"><a href="#第三章-地址族与数据序列" class="heading-link"><i class="fas fa-link"></i></a><a href="#第三章-地址族与数据序列" class="headerlink" title="第三章 地址族与数据序列"></a>第三章 地址族与数据序列</h1><h2 id="分配给套接字的IP地址与端口号"><a href="#分配给套接字的IP地址与端口号" class="heading-link"><i class="fas fa-link"></i></a><a href="#分配给套接字的IP地址与端口号" class="headerlink" title="分配给套接字的IP地址与端口号"></a>分配给套接字的IP地址与端口号</h2><p><strong><code>IP</code>是<code>Internet Protocol</code>(网络协议)的简写，是为了收发网络数据而分配给计算机的值，可以用于唯一标识一台在互联网中的计算机；</strong></p><p><strong>端口并非赋予计算机的值，而是为了区分不同主机之间的进程，这个和进程号有区别，端口号是为了让不同主机的进程都知道，这样才能正确的进行通信</strong></p><h3 id="网络地址"><a href="#网络地址" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h3><p><code>IP</code>地址分为<code>IPv4</code>和<code>IPv6</code>地址，分别由4个字节和16个字节组成，一个字节8个<code>bit</code>，所以<code>IPv4</code>有32位，<code>IPv6</code>有128位；</p><p><code>IPv6</code>是为了应对<code>IPv4</code>地址耗尽的问题提出的标准，但是目前尚未得到普及</p><p>网络地址是为了区分不同网络而设置的<code>IP</code>地址，是把<code>IP</code>地址的子网号部分设置为0得到的<code>IP</code>地址，全部设置为1就是广播地址，这些东西在计网已经学过了，详情请参考计网复习资料的部分</p><h3 id="网络地址分类与主机地址边界"><a href="#网络地址分类与主机地址边界" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络地址分类与主机地址边界" class="headerlink" title="网络地址分类与主机地址边界"></a>网络地址分类与主机地址边界</h3><p>书上写的很清楚，这里截图：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905105657336.png" alt="image-20230905105657336" style="zoom:80%"><p>当然更详细的分类如下：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230624203408369.png" alt="image-20230624203408369" style="zoom:50%"><p>当然还有一些特殊的IP使用：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230624211609006.png" alt="image-20230624211609006" style="zoom:80%"><h3 id="用于区分套接字的端口号"><a href="#用于区分套接字的端口号" class="heading-link"><i class="fas fa-link"></i></a><a href="#用于区分套接字的端口号" class="headerlink" title="用于区分套接字的端口号"></a>用于区分套接字的端口号</h3><p>我们已经有了IP用来区分不同的主机，这样可以使我们的数据从一个主机通过庞大的互联网找到另一个主机，但是虽然数据到了主机，但是仅凭这些没有办法传输给应用程序。</p><p><strong>这个时候我们就需要区分套接字的端口号了，端口号就是为了区分同一操作系统内不同套接字而设置的，所以没有办法将一个端口号分配给不同的套接字；</strong></p><p><strong>同时也是为了区分不同主机之间的应用进程，端口号在设置的时候是双方都知道的，因此可以定位到某一个用于通信的进程；</strong></p><p><strong>值得注意的是，虽然端口号不能重复，但是<code>TCP</code>和<code>UDP</code>的套接字不会公用端口号，所以允许重复</strong></p><p>用一个图可以如下形象的表示：</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905112425335.png" alt="image-20230905112425335" style="zoom:80%"><h2 id="地址信息的表示"><a href="#地址信息的表示" class="heading-link"><i class="fas fa-link"></i></a><a href="#地址信息的表示" class="headerlink" title="地址信息的表示"></a>地址信息的表示</h2><h3 id="表示IPv4的结构体"><a href="#表示IPv4的结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#表示IPv4的结构体" class="headerlink" title="表示IPv4的结构体"></a>表示IPv4的结构体</h3><p><code>Unix</code>对网络编程接口的<code>socket</code>地址提供了通用<code>socket</code>地址和专用<code>socket</code>地址</p><p><code>socket</code> 网络编程接口中表示 <code>socket</code> 地址的是结构体 <code>sockaddr</code>，这个在一般是通用的，其定义如下：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sa_family;</span><br><span class="line">    <span class="type">char</span> sa_data[<span class="number">14</span>]; <span class="comment">//存储数据，包括IP和端口号的信息</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> <span class="type">sa_family_t</span>;</span><br></pre></td></tr></table></div></figure><p>我们向内核提供的是这个通用的<code>socket</code>地址，但是<code>socket</code>地址实际上根据不同的用途可以分为很多种，比如<code>IPv4</code>，<code>IPv6</code>还有本地套接字，他们都有适用于自己的专用<code>socket</code>地址，下图就非常清晰的列出来了，我们在这里主要研究<code>IPv4</code>的<code>socket</code>地址</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905154922422.png" alt="image-20230905154922422"></p><h4 id="sockaddr-in结构体"><a href="#sockaddr-in结构体" class="heading-link"><i class="fas fa-link"></i></a><a href="#sockaddr-in结构体" class="headerlink" title="sockaddr_in结构体"></a>sockaddr_in结构体</h4><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">sockaddr_in</span> &#123;</span><br><span class="line">    <span class="type">sa_family_t</span> sin_family; <span class="comment">/* __SOCKADDR_COMMON(sin_) */</span> <span class="comment">// 地址族</span></span><br><span class="line">    <span class="type">in_port_t</span> sin_port; <span class="comment">/* Port number. */</span> <span class="comment">// 16位端口号</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">in_addr</span> sin_addr; <span class="comment">/* Internet address. */</span> <span class="comment">// 存储IPv4地址，是一个结构体，定义在下面</span></span><br><span class="line">    <span class="comment">/* Pad to size of `struct sockaddr&#x27;. */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> sin_zero[<span class="built_in">sizeof</span> (<span class="keyword">struct</span> sockaddr) - __SOCKADDR_COMMON_SIZE -</span><br><span class="line">    <span class="built_in">sizeof</span> (<span class="type">in_port_t</span>) - <span class="built_in">sizeof</span> (<span class="keyword">struct</span> in_addr)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">in_addr</span> &#123;</span><br><span class="line">	<span class="type">in_addr_t</span> s_addr; <span class="comment">// 32位IPv4地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure><p>我们来逐个分析一下这个结构体的成员：</p><ul><li><code>sin_family</code>：<strong>每种协议族对应了一个地址族，其实在实现的时候协议族和地址族宏对应的值是相同的</strong>，所以用哪个都无所谓，以下是对应的协议族和地址族：</li></ul><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230904193622248.png" alt="image-20230904193622248"></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905155342817.png" alt="image-20230905155342817"></p><ul><li><code>sin_port</code>：<strong>保存16位端口号，注意传入的时候记得转化为大端网络字节序</strong></li><li><code>sin_addr</code>：<strong>是一个结构体，保存32位IPv4地址信息，也是按照大端网络字节序保存的</strong>，但是我们不用自己动手，有系统调用(<code>inet_pton</code>)帮我们做了</li><li>sin_zero：<strong>没有特殊含义，因为系统接受的是通用的<code>sockaddr</code>结构体，我们的<code>sockaddr_in</code>结构体的成员大小不一定匹配，需要有一定的额外大小来让两个结构体的大小一致而适配，没有特殊含义</strong></li></ul><h4 id="思考"><a href="#思考" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考" class="headerlink" title="思考"></a>思考</h4><p>既然<code>sockaddr_in</code>是专门给<code>IPv4</code>使用的结构体，那么为什么里面还要有<code>sin_family</code>的地址族成员呢？</p><p><strong>这个问题非常好，我们前面说到，需要做到专用<code>socket</code>地址和通用<code>socket</code>地址的匹配，我通过指针强制类型转换的时候不会发生错误，而通过<code>socket</code>地址里面有地址族的成员，因为他不是为某一个协议而服务的，所以为了和它保持一致，专用<code>socket</code>地址这里也需要一个地址族成员</strong></p><h2 id="网络字节序与地址变换"><a href="#网络字节序与地址变换" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络字节序与地址变换" class="headerlink" title="网络字节序与地址变换"></a>网络字节序与地址变换</h2><p>对于单个字节的数据，在计算机中的保存倒无所谓，计算机是以字节存储数据的；但是如果是多个字节，比如双字节，就分为高字节和低字节，高字节就是高位嘛；那么我们的高字节是存储在内存地址的高处还是低处呢？这就是一个问题了，因此字节序分为了大端和小端字节序</p><p>我先给出定义：<strong>小端字节序是低位字节存储在内存的低地址处，高位字节存储在内存的高地址处；大端字节序则相反!!!</strong></p><h3 id="例子-2"><a href="#例子-2" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>我们可以写一个程序来看自己的电脑是大端还是小端字节序</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 给一个双字节的数据</span></span><br><span class="line">    <span class="type">short</span> num = <span class="number">0x1223</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* ch = (<span class="type">char</span>*)&amp;num;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ((*ch == <span class="number">0x23</span>) ? <span class="string">&quot;小端字节序&quot;</span> : <span class="string">&quot;大端字节序&quot;</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>结果：</p><p>在我的电脑上是以小端字节序存储的，也就是高位存在高地址的地方</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905162539547.png" alt="image-20230905162539547"></p><h3 id="思考-1"><a href="#思考-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#思考-1" class="headerlink" title="思考"></a>思考</h3><p>所以问题来了，不同的电脑存储的方式不同，难以得到统一，如果我们不加规范，那么在网络传输信息当中就很容易出现数据错误的问题，这将是致命的；</p><p>因此，<strong>在网络中，我们规定都用大端字节序传递数据，称为网络字节序</strong></p><h3 id="字节序转换"><a href="#字节序转换" class="heading-link"><i class="fas fa-link"></i></a><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h3><p><strong><code>Linux</code>系统给我们提供了系统<code>API</code>可以把主机字节序转化为网络字节序，可以转化<code>short</code>类型和<code>long</code>类型的值，也就是2个字节和8个字节的转化，为什么没有4个字节的<code>int</code>呢？因为2个字节对应16位的端口号，这是因为最初的时候<code>long</code>是4个字节，可以用来进行32位的转化，但是不同的系统的long不同，现在的long在大多数的机器上都是8个字节了，但是我们一般用不到，因为转化<code>IPv4</code>有其他的接口</strong></p><p>以下是转化字节序的<code>API</code>：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">h - host 主机，主机字节序</span><br><span class="line">to - 转换成什么</span><br><span class="line">n - network 网络字节序</span><br><span class="line">s - <span class="type">short</span> <span class="type">unsigned</span> <span class="type">short</span></span><br><span class="line">l - <span class="type">long</span> <span class="type">unsigned</span> <span class="type">int</span></span><br></pre></td></tr></table></div></figure><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 转换端口 端口号 0-65535，就是16位，因此是 uint16_t</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="type">uint16_t</span> hostshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="type">uint16_t</span> netshort)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="comment">// 转IP IP地址，IPV4是32位，因此是uint32_t</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="type">uint32_t</span> hostlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="type">uint32_t</span> netlong)</span></span>; <span class="comment">// 主机字节序 - 网络字节序</span></span><br></pre></td></tr></table></div></figure><p>所以以后在给<code>sockaddr_in</code>结构体初始化的时候，传入的端口号和<code>IPv4</code>地址记得转换字节序</p><h4 id="例子-3"><a href="#例子-3" class="heading-link"><i class="fas fa-link"></i></a><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p>我们写一个转化网络字节序的例子</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> host_port = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> host_addr = <span class="number">0x12345678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> net_port = <span class="built_in">htons</span>(host_port);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> net_addr = <span class="built_in">htonl</span>(host_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hex流可以让一个数以十六进制输出!!!</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Host ordered port: 0x&quot;</span> &lt;&lt; hex &lt;&lt; host_port &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Network ordered port: 0x&quot;</span> &lt;&lt; hex &lt;&lt; net_port &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Host ordered address: 0x&quot;</span> &lt;&lt; hex &lt;&lt; host_addr &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Network ordered address: 0x&quot;</span> &lt;&lt; hex &lt;&lt; net_addr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>结果：</p><p>我们看到了主机字节序和网络字节序的区别</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905164245873.png" alt="image-20230905164245873"></p><h4 id="补充"><a href="#补充" class="heading-link"><i class="fas fa-link"></i></a><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>让数据以二进制，八进制，十六进制输出(<code>c++</code>)</p><ul><li><strong>二进制：借助<code>bitset</code>库</strong></li><li><strong>八进制：借助<code>oct</code>流</strong></li><li><strong>十六进制：借助<code>hex</code>流</strong></li></ul><p>用法如下：</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="built_in">bitset</span>&lt;<span class="number">10</span>&gt;(num) &lt;&lt; endl; <span class="comment">// 0001100100，模板参数10是输出多少位</span></span><br><span class="line">    cout &lt;&lt; oct &lt;&lt; num &lt;&lt; endl; <span class="comment">// 144，oct流</span></span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; num &lt;&lt; endl; <span class="comment">// 64，hex流</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><h2 id="网络地址的初始化与分配"><a href="#网络地址的初始化与分配" class="heading-link"><i class="fas fa-link"></i></a><a href="#网络地址的初始化与分配" class="headerlink" title="网络地址的初始化与分配"></a>网络地址的初始化与分配</h2><p>通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用 十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录 日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字 符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：</p><p><strong>这个是旧的函数，只能适用于IPv4地址，可以使用但是不建议</strong></p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 这个数字转化过来之后是网络字节序，就是大端</span></span><br><span class="line"><span class="function"><span class="type">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span>; </span><br><span class="line"><span class="comment">// 第二个参数是传出参数，保存转换后的结果，返回值 1 成功，0 失败，字符串非法，不设置错误号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_aton</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp, <span class="keyword">struct</span> in_addr *inp)</span></span>; </span><br><span class="line"><span class="function"><span class="type">char</span> *<span class="title">inet_ntoa</span><span class="params">(<span class="keyword">struct</span> in_addr in)</span></span>;</span><br></pre></td></tr></table></div></figure><p><strong>下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：(推荐使用这里的新的api)</strong></p><p>我一般写代码只用新的API，就是p开头的</p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// p:点分十进制的IP字符串，n:表示network，网络字节序的整数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">inet_pton</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">void</span> *dst)</span></span>;</span><br><span class="line">    <span class="comment">// af:地址族： AF_INET AF_INET6</span></span><br><span class="line">    <span class="comment">// src:需要转换的点分十进制的IP字符串</span></span><br><span class="line">    <span class="comment">// dst:转换后的结果保存在这个里面，是一个传出参数</span></span><br><span class="line">    <span class="comment">// 将网络字节序的整数，转换成点分十进制的IP地址字符串</span></span><br><span class="line">    <span class="comment">// 返回值：1 成功 ；失败 0 或者 -1，0表示传入的点分制字符串不合理invalid，不设置errno；-1表示错误(比如地址族内容不合理)，并且设置errno</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="type">int</span> af, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">char</span> *dst, <span class="type">socklen_t</span> size)</span></span>;</span><br><span class="line">    <span class="comment">// af:地址族： AF_INET AF_INET6</span></span><br><span class="line">    <span class="comment">// src: 要转换的ip的整数的地址</span></span><br><span class="line">    <span class="comment">// dst: 转换成IP地址字符串保存的地方</span></span><br><span class="line">    <span class="comment">// size：第三个参数的大小（数组的大小）</span></span><br><span class="line">    <span class="comment">// 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的</span></span><br></pre></td></tr></table></div></figure><h3 id="INADDR-ANY"><a href="#INADDR-ANY" class="heading-link"><i class="fas fa-link"></i></a><a href="#INADDR-ANY" class="headerlink" title="INADDR_ANY"></a>INADDR_ANY</h3><p><strong>我们在创建服务端的时候可能有多个IP都可以分配给服务端，但是我们不知道用哪一个，这个时候我们可以传入<code>INADDR_ANY</code>参数，表示地址只要是我有的都能接受，可以省去一些麻烦</strong></p><p>以下是书上的例子：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230905165356272.png" alt="image-20230905165356272"></p><h1 id="第四章-基于TCP的服务端-x2F-客户端-1"><a href="#第四章-基于TCP的服务端-x2F-客户端-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#第四章-基于TCP的服务端-x2F-客户端-1" class="headerlink" title="第四章 基于TCP的服务端&#x2F;客户端(1)"></a>第四章 基于TCP的服务端&#x2F;客户端(1)</h1><h2 id="深入理解TCP，UDP"><a href="#深入理解TCP，UDP" class="heading-link"><i class="fas fa-link"></i></a><a href="#深入理解TCP，UDP" class="headerlink" title="深入理解TCP，UDP"></a>深入理解TCP，UDP</h2><p>基于网络协议的套接字可以分为<code>TCP</code>套接字和<code>UDP</code>套接字，<code>TCP</code>是面向连接的，又称为基于字节流的套接字</p><h3 id="TCP-x2F-IP协议栈"><a href="#TCP-x2F-IP协议栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-x2F-IP协议栈" class="headerlink" title="TCP&#x2F;IP协议栈"></a>TCP&#x2F;IP协议栈</h3><p>如图所示，我们的数据收发过程实际上经过了这四个层次的过程：</p><p>我们的计算机网络问题并不是仅凭软件就能够解决的，编写软件之前需要构建硬件系统，在此基础上通过软件实现各种算法；因此我们是把一个大问题划分为若干个小问题再逐个击破，这样可以大幅度的提高效率</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909150644608.png" alt="image-20230909150644608" style="zoom:80%"><h3 id="链路层"><a href="#链路层" class="heading-link"><i class="fas fa-link"></i></a><a href="#链路层" class="headerlink" title="链路层"></a>链路层</h3><p>链路层是将<code>IP</code>数据报封装成为帧并且传输的过程，又叫数据链路层(实际的<code>bit</code>传输在物理层)</p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909151100190.png" alt="image-20230909151100190" style="zoom:80%"><h3 id="IP层-网络层"><a href="#IP层-网络层" class="heading-link"><i class="fas fa-link"></i></a><a href="#IP层-网络层" class="headerlink" title="IP层(网络层)"></a>IP层(网络层)</h3><p><code>IP</code>层(网络层)帮我们解决了在巨大的互联网当中我们怎么如何选择路径还有如何进行传递</p><p><code>IP</code>本身是面向消息的，不可靠的协议，但是我们的传输层可以通过<code>TCP</code>协议来帮我们实现可靠数据的传输</p><h3 id="TCP-x2F-UDP层-运输层"><a href="#TCP-x2F-UDP层-运输层" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP-x2F-UDP层-运输层" class="headerlink" title="TCP&#x2F;UDP层(运输层)"></a>TCP&#x2F;UDP层(运输层)</h3><p>TCP&#x2F;UDP是在网络层之上的运输层，TCP协议是面向字节流的可靠的传输服务，它可以帮助不可靠的IP协议变得可靠，他有一系列机制帮助实现他的面向连接和可靠性；UDP协议是面向数据报的不可靠的协议</p><p>TCP具体来说是这么为IP的不可靠服务提供可靠性的：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909151937552.png" alt="image-20230909151937552"></p><h3 id="应用层"><a href="#应用层" class="heading-link"><i class="fas fa-link"></i></a><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>上面的功能都是不会暴露给用户的，因此我们用户在使用的过程中根本看不见下层的操作；我们需要做的就是使用下层封装出来给我们的<code>API</code>，在网络中就是<code>socket</code>套接字，我们根据规定的规则编写程序就可以进行通信，这就是一个简单的例子</p><h2 id="实现基于TCP的服务端-x2F-客户端"><a href="#实现基于TCP的服务端-x2F-客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现基于TCP的服务端-x2F-客户端" class="headerlink" title="实现基于TCP的服务端&#x2F;客户端"></a>实现基于TCP的服务端&#x2F;客户端</h2><h3 id="服务端的操作顺序"><a href="#服务端的操作顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#服务端的操作顺序" class="headerlink" title="服务端的操作顺序"></a>服务端的操作顺序</h3><p>如下图：</p><p>具体的操作在我的另一门课牛客<code>Linux</code>当中已经讲的很清楚了，这里给出对应文章的地址：</p><p><span class="exturl"><a class="exturl__link" target="_blank" rel="noopener" href="https://blog.csdn.net/m0_61588837/article/details/132432615">第四章：TCP套接字通信（这一篇就够了！）</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909152233914.png" alt="image-20230909152233914"></p><p>我们注意一点的<code>listen</code>函数，注意他的第二个参数<code>backlog</code></p><figure class="highlight cpp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">listen</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">int</span> backlog)</span></span>; <span class="comment">// /proc/sys/net/core/somaxconn</span></span><br><span class="line">    - 功能：监听这个socket上的连接</span><br><span class="line">    - 参数：</span><br><span class="line">        - sockfd : 通过<span class="built_in">socket</span>()函数得到的文件描述符</span><br><span class="line">        - backlog : 连接请求等待队列的长度，表示最多有多少个连接请求排队，并不是服务端最多可以连接通信的个数，因为出队列之后就可以进行通信，这个时候请求队列减一恢复了</span><br></pre></td></tr></table></div></figure><p>代码我就不放了，第一章写得非常清楚，<a href="#example">点击这里跳转过去</a></p><h3 id="客户端的操作顺序"><a href="#客户端的操作顺序" class="heading-link"><i class="fas fa-link"></i></a><a href="#客户端的操作顺序" class="headerlink" title="客户端的操作顺序"></a>客户端的操作顺序</h3><p>客户端一般不需要绑定<code>bind</code>，因为服务端绑定是因为客户端需要<code>IP</code>和端口号来进行请求连接，所以需要绑定而不是让系统自动给我分配，我们也可以看到在没有绑定的客户端的IP和端口都是系统分配的</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909153956078.png" alt="image-20230909153956078"></p><h3 id="TCP服务端和客户端的关系"><a href="#TCP服务端和客户端的关系" class="heading-link"><i class="fas fa-link"></i></a><a href="#TCP服务端和客户端的关系" class="headerlink" title="TCP服务端和客户端的关系"></a>TCP服务端和客户端的关系</h3><p>总体流程如下：</p><p><img class="lazyload lazyload-gif" src="/images/loading.svg" data-src="https://cdn.davidingplus.cn/images/2025/02/01/image-20230909154125497.png" alt="image-20230909154125497"></p><h2 id="实现迭代服务端和客户端"><a href="#实现迭代服务端和客户端" class="heading-link"><i class="fas fa-link"></i></a><a href="#实现迭代服务端和客户端" class="headerlink" title="实现迭代服务端和客户端"></a>实现迭代服务端和客户端</h2><p>TODO</p></div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="https://blog.davidingplus.cn">DavidingPlus</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="https://blog.davidingplus.cn/posts/c5690fb7.html">https://blog.davidingplus.cn/posts/c5690fb7.html</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-reward reward"><div class="reward-button">大爷，赏个铜板呗~~~</div><div class="reward-qrcode"><span class="reward-qrcode-alipay"><img class="reward-qrcode-alipay__img" src="/images/reward/alipay.webp"><div class="reward-qrcode-alipay__text">支付宝</div></span><span class="reward-qrcode-wechat"><img class="reward-qrcode-wechat__img" src="/images/reward/wechat-pay.webp"><div class="reward-qrcode-wechat__text">微信</div></span></div></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/posts/6fbfe9af.html"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">UNIX 环境高级编程</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/posts/13ca1b18.html"><span class="paginator-prev__text">使用 git</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div><div class="comments" id="comments"><div id="utterances-container"></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text">第一章 理解网络编程和套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%92%8C%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.1.</span> <span class="toc-text">理解网络编程和套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.1.1.</span> <span class="toc-text">TCP套接字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ELinux%E7%9A%84%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">基于Linux的文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6-%E6%96%87%E4%BB%B6%E5%8F%A5%E6%9F%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">文件描述符(文件句柄)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">open函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.1.1.1.</span> <span class="toc-text">open函数打开文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#open%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E4%BB%B6"><span class="toc-number">2.2.1.1.2.</span> <span class="toc-text">open函数创建新文件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#read-write%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">read,write函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE%E8%AE%BE%E7%BD%AE"><span class="toc-number">3.</span> <span class="toc-text">第二章 套接字类型与协议设置</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E5%8D%8F%E8%AE%AE%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%89%B9%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">套接字协议以及数据传输特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.1.1.</span> <span class="toc-text">关于协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%A5%97%E6%8E%A5%E5%AD%97socket"><span class="toc-number">3.1.2.</span> <span class="toc-text">创建套接字socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%97%8F"><span class="toc-number">3.1.3.</span> <span class="toc-text">协议族</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%97%E6%8E%A5%E5%AD%97%E7%B1%BB%E5%9E%8B-%E9%87%8D%E8%A6%81"><span class="toc-number">3.1.4.</span> <span class="toc-text">套接字类型(重要)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97-SOCK-STREAM-%EF%BC%9ATCP"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">面向连接的套接字(SOCK_STREAM)：TCP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E6%B6%88%E6%81%AF%E7%9A%84%E5%A5%97%E6%8E%A5%E5%AD%97-SOCK-DGREAM-%EF%BC%9AUDP"><span class="toc-number">3.1.4.2.</span> <span class="toc-text">面向消息的套接字(SOCK_DGREAM)：UDP</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9"><span class="toc-number">3.1.5.</span> <span class="toc-text">协议的最终选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-1"><span class="toc-number">3.1.6.</span> <span class="toc-text">例子</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9C%B0%E5%9D%80%E6%97%8F%E4%B8%8E%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">第三章 地址族与数据序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%BB%99%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">4.1.</span> <span class="toc-text">分配给套接字的IP地址与端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80"><span class="toc-number">4.1.1.</span> <span class="toc-text">网络地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB%E4%B8%8E%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%E8%BE%B9%E7%95%8C"><span class="toc-number">4.1.2.</span> <span class="toc-text">网络地址分类与主机地址边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E5%8C%BA%E5%88%86%E5%A5%97%E6%8E%A5%E5%AD%97%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">4.1.3.</span> <span class="toc-text">用于区分套接字的端口号</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">4.2.</span> <span class="toc-text">地址信息的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%A4%BAIPv4%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.2.1.</span> <span class="toc-text">表示IPv4的结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sockaddr-in%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">sockaddr_in结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">思考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2"><span class="toc-number">4.3.</span> <span class="toc-text">网络字节序与地址变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-2"><span class="toc-number">4.3.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83-1"><span class="toc-number">4.3.2.</span> <span class="toc-text">思考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.3.3.</span> <span class="toc-text">字节序转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90-3"><span class="toc-number">4.3.3.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">4.3.3.2.</span> <span class="toc-text">补充</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E5%88%86%E9%85%8D"><span class="toc-number">4.4.</span> <span class="toc-text">网络地址的初始化与分配</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#INADDR-ANY"><span class="toc-number">4.4.1.</span> <span class="toc-text">INADDR_ANY</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-x2F-%E5%AE%A2%E6%88%B7%E7%AB%AF-1"><span class="toc-number">5.</span> <span class="toc-text">第四章 基于TCP的服务端&#x2F;客户端(1)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TCP%EF%BC%8CUDP"><span class="toc-number">5.1.</span> <span class="toc-text">深入理解TCP，UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-IP%E5%8D%8F%E8%AE%AE%E6%A0%88"><span class="toc-number">5.1.1.</span> <span class="toc-text">TCP&#x2F;IP协议栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">5.1.2.</span> <span class="toc-text">链路层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP%E5%B1%82-%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">5.1.3.</span> <span class="toc-text">IP层(网络层)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-x2F-UDP%E5%B1%82-%E8%BF%90%E8%BE%93%E5%B1%82"><span class="toc-number">5.1.4.</span> <span class="toc-text">TCP&#x2F;UDP层(运输层)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">5.1.5.</span> <span class="toc-text">应用层</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8ETCP%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF-x2F-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.2.</span> <span class="toc-text">实现基于TCP的服务端&#x2F;客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">服务端的操作顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E6%93%8D%E4%BD%9C%E9%A1%BA%E5%BA%8F"><span class="toc-number">5.2.2.</span> <span class="toc-text">客户端的操作顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.2.3.</span> <span class="toc-text">TCP服务端和客户端的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%AD%E4%BB%A3%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.3.</span> <span class="toc-text">实现迭代服务端和客户端</span></a></li></ol></li></ol></section><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/android-chrome-512x512.webp" alt="avatar"></div><p class="sidebar-ov-author__text">Self-discipline is key in life.</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/DavidingPlus" target="_blank" rel="noopener" data-popover="GitHub" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="/qq/" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="/wechat/" target="_blank" rel="noopener" data-popover="微信" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-weixin"></i></span></a><a class="sidebar-ov-social-item" href="mailto:davidingplus@qq.com" target="_blank" rel="noopener" data-popover="davidingplus@qq.com" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fas fa-envelope"></i></span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">36</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">20</div><div class="sidebar-ov-state-item__name">分类</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">您已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023~2025</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>DavidingPlus</span><span class="footer__devider">|</span><span>蜀 ICP 备 2024088070 号</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v7.2.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.8.6</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div><div><span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span><script>var now=new Date;function createtime(){var n=new Date("09/18/2023 00:00:00");now.setTime(now.getTime()+250),days=(now-n)/1e3/60/60/24,dnum=Math.floor(days),hours=(now-n)/1e3/60/60-24*dnum,hnum=Math.floor(hours),1==String(hnum).length&&(hnum="0"+hnum),minutes=(now-n)/1e3/60-1440*dnum-60*hnum,mnum=Math.floor(minutes),1==String(mnum).length&&(mnum="0"+mnum),seconds=(now-n)/1e3-86400*dnum-3600*hnum-60*mnum,snum=Math.round(seconds),1==String(snum).length&&(snum="0"+snum),document.getElementById("timeDate").innerHTML="小破站已经安全运行 "+dnum+" 天 ",document.getElementById("times").innerHTML=hnum+" 小时 "+mnum+" 分 "+snum+" 秒啦！"}setInterval("createtime()",250)</script></div><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;theme&quot;:&quot;default&quot;}" src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/mermaid.min.js"></script><script>if(window.mermaid){var options=JSON.parse(document.getElementById("maid-script").getAttribute("mermaidoptioins"));mermaid.initialize(options)}</script></div></footer><div class="loading-animation" id="loading-animation"><div class="loading-animation__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-thumbs-up"></i></span></div><div class="back2bottom" id="back2bottom"><span class="back2bottom__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"><div class="search-btns">使用搜索：<span class="search-btns-item search-btns-item--bing"><i></i>必应</span><span class="search-btns-item search-btns-item--baidu"><i></i>百度</span></div></div><div class="search-results"></div></div><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/jquery.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/velocity-ui.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/canvas-nest.js" color="255,255,255" opacity="1" count="99" zindex="-1"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/fancybox.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/masonry.js"></script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/lazyload.js"></script><script>function initSearch(){var e=!0,t="search.json";t?/json$/i.test(t)&&(e=!1):t="search.xml";var n="/"+t;$.ajax({url:n,dataType:e?"xml":"json",async:!0,success:function(t){var n=e?$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():t,o=$(".search-input input"),i=$(".search-results"),c=100,r=1,a=function(){var e=o.val().toLowerCase().trim(),t=e.split(/[\s]+/),a=[];t.length>1&&t.push(e),e.length>0&&n.forEach(function(e){var n=!1,o=e.title&&e.title.trim()||"[ 文章无标题 ]",i=o&&o.toLowerCase(),s=e.content&&e.content.replace(/<[^>]+>/g,""),l=s&&s.toLowerCase(),u=e.url&&decodeURI(e.url).replace(/\/{2,}/g,"/"),h=[],d=[];t.forEach(function(e){function t(e,t,n,o){if(!e||!t)return[];var i=0,c=-1,r=[];for(n||(e=e.toLowerCase(),t=t.toLowerCase());-1!==(c=t.indexOf(e,i));){var a=!1;h.forEach(function(t){t.index===c&&t.word.length<e.length&&(t.word=e,a=!0)}),i=c+e.length,!a&&r.push({index:c,word:e,weight:o})}return r}h=h.concat(t(e,i,!1,c)),d=d.concat(t(e,l,!1,r))});var f=h.length,p=d.length;if((f>0||p>0)&&(n=!0),n){function w(e,t,n,o){if(e&&t&&t.length){var i="",c=n,r=o;return t.forEach(function(t){if(!(t.index<c)){var n=t.index+t.word.length;i+=e.slice(c,t.index),i+="<b>"+e.slice(t.index,n)+"</b>",c=n}}),i+=e.slice(c,r)}}[h,d].forEach(function(e){e.sort(function(e,t){return e.index-t.index})});var v,g={},x=h.length*c+d.length*r,y=w(o,h,0,o.length)||o;if(d.length>0){var S=d[0].index;v=w(s,d,S>20?S-20:0,S+180)}else v=s.slice(0,200);g.title=y,g.content=v,g.url=u,g.weight=x,a.push(g)}});var s="";a.length?(a.sort(function(e,t){return t.weight-e.weight}),s+="<ul>",a.forEach(function(e){s+='<li><a class="search-results-title" href="'+e.url+'">',s+=e.title,s+='</a><div class="search-results-content">',s+=e.content,s+="</div></li>"}),s+="</ul>"):s+='<div class="search-results-none"><i class="far fa-meh"></i></div>',i.html(s)};o.on("input",a),o.on("keyup",function(e){e.keyCode===Stun.utils.codeToKeyCode("Enter")&&a()})}})}function closeSearch(){$("body").css({overflow:"auto"}),$(".search-popup").css({display:"none"}),$(".search-mask").css({display:"none"})}function safeOpenUrl(e){var t=window.open();t.opener=null,t.location=e}function extSearch(e){var t=window.location.host,n=$(".search-input input").val().toLowerCase().trim();n?safeOpenUrl({google:"https://www.google.com/search?q=",bing:"https://cn.bing.com/search?q=",baidu:"https://www.baidu.com/s?ie=UTF-8&wd="}[e]+n+" site:"+t):Stun.utils.popAlert("warning","请输入字符")}window.addEventListener("DOMContentLoaded",function(){Stun.utils.pjaxReloadLocalSearch=function(){$(".header-nav-search").on("click",function(e){e.stopPropagation(),$("body").css("overflow","hidden"),$(".search-popup").velocity("stop").velocity("transition.expandIn",{duration:300,complete:function(){$(".search-popup input").focus()}}),$(".search-mask").velocity("stop").velocity("transition.fadeIn",{duration:300}),initSearch()}),$(".search-mask, .search-close").on("click",function(){closeSearch()}),$(document).on("keydown",function(e){e.keyCode===Stun.utils.codeToKeyCode("Escape")&&closeSearch()})},Stun.utils.pjaxReloadLocalSearch()},!1);var assistSearchList=window.CONFIG.assistSearch;Array.isArray(assistSearchList)&&assistSearchList.forEach(function(e){document.querySelector(".search-btns-item--"+e).addEventListener("click",function(){extSearch(e)},!1)})</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/pjax.js"></script><script>window.addEventListener("DOMContentLoaded",function(){new Pjax({selectors:["head title","#main",".pjax-reload",".header-banner"],history:!0,scrollTo:!1,scrollRestoration:!1,cacheBust:!1,debug:!1,currentUrlFullReload:!1,timeout:0});document.addEventListener("pjax:send",function(){$(".header-nav-menu").removeClass("show"),CONFIG.pjax&&CONFIG.pjax.avoidBanner&&$("html").velocity("scroll",{duration:500,offset:$("#header").height(),easing:"easeInOutCubic"}),$(".loading-animation").addClass("loading")},!1),window.addEventListener("pjax:complete",function(){if($(".loading-animation").removeClass("loading"),$("link[rel=prefetch], script[data-pjax-rm]").each(function(){$(this).remove()}),$("script[data-pjax], #pjax-reload script").each(function(){$(this).parent().append($(this).remove())}),Stun.utils.pjaxReloadBoot&&Stun.utils.pjaxReloadBoot(),Stun.utils.pjaxReloadScroll&&Stun.utils.pjaxReloadScroll(),Stun.utils.pjaxReloadSidebar&&Stun.utils.pjaxReloadSidebar(),"undefined"!=typeof mermaid){const e=Array.from(document.querySelectorAll(".mermaid")).filter(e=>!e.dataset.processed);mermaid.init(void 0,e)}},!1)},!1)</script><div id="pjax-reload"><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/quicklink.js"></script><script>function initQuicklink(){quicklink({timeout:"10000",priority:!0,ignores:[i=>i.includes("#"),i=>"https://blog.davidingplus.cn/posts/c5690fb7.html"===i,/\/api\/?/,i=>i.includes(".xml"),i=>i.includes(".zip"),(i,t)=>t.hasAttribute("nofollow"),(i,t)=>t.hasAttribute("noprefetch")]})}initQuicklink()</script><script src="//cdn.davidingplus.cn/files/hexo-theme-stun-third-party/js/busuanzi.js" async></script></div><script src="/js/utils.js?v=2.8.6"></script><script src="/js/stun-boot.js?v=2.8.6"></script><script src="/js/scroll.js?v=2.8.6"></script><script src="/js/header.js?v=2.8.6"></script><script src="/js/sidebar.js?v=2.8.6"></script><script type="application/json" src="/search.json"></script><script data-pjax="">function loadUtterances(){var t=document,e=t.createElement("script"),s=t.getElementById("utterances-container"),r=Stun.utils.getNightMode()?"photon-dark":"github-light";s&&(e.src="https://utteranc.es/client.js",e.setAttribute("repo","DavidingPlus/blog-comments"),e.setAttribute("issue-term","title"),e.setAttribute("label","utterances"),e.setAttribute("theme",r),e.setAttribute("crossorigin","anonymous"),e.setAttribute("async",""),e.setAttribute("data-pjax-rm",""),s.append(e))}loadUtterances()</script><script async src="/js/cursor/text.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!0,document.body.addEventListener("input",POWERMODE)</script><script>var titleTime,OriginTitile=document.title;document.addEventListener("visibilitychange",function(){document.hidden?(document.title="🤡快回来,粗大事了~~"+OriginTitile,clearTimeout(titleTime)):(document.title="😚欢迎回来!~"+OriginTitile,titleTime=setTimeout(function(){document.title=OriginTitile},2e3))})</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:160,height:290},mobile:{show:!0},log:!1})</script></body></html>