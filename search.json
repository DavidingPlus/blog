[{"title":"F2FS 文件系统","url":"/posts/257909f0.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 为什么需要 F2FS？\n\n传统的文件系统（如 FAT32, EXT4）是为“旋转的磁碟（HDD）”设计的，而 F2FS 是为“闪存（NAND Flash）”设计的。\n\n在存储领域，传统的文件系统如 FAT32 或 EXT4 最初都是为机械硬盘这种“旋转磁碟”设计的。这类设备拥有物理磁头，在磁道上移动时可以直接覆盖旧数据。然而，F2FS 则是专门为 NAND 闪存设计的，它深刻理解闪存与磁盘在物理特性上的巨大差异。闪存最核心的限制在于它无法像磁碟那样进行原地“覆盖写”。一旦一个存储位置写入了数据，必须先执行擦除操作才能再次写入。更棘手的是，闪存写入的最小单位通常很小，只有几 KB 左右的“页”，但擦除的最小单位却非常大，往往达到数 MB 级别的“块”。如果文件系统像处理磁盘那样频繁地在同一个逻辑地址修改数据，底层的闪存就不得不不断执行繁重的“读-改-写”循环，这会导致整体写入性能随时间推移而急剧下降。\n\n<!-- more -->\n\n为了掩盖闪存这些古怪的物理特性，所有的闪存设备，无论是你手中的 SD 卡还是高性能的 SSD，内部都内置了一个微控制器来运行闪存转换层，也就是 FTL。FTL 的本质是一个欺骗机制，它让操作系统觉得这块闪存依然是一个可以随意覆盖写的普通磁盘。然而，当传统文件系统进行大量的随机写入时，FTL 必须在后台疯狂地进行“垃圾回收”和“磨损均衡”，试图在不断变化的物理空间中寻找空白区域来安置这些新数据。由于 FTL 并不了解文件系统的上层布局，它的这种盲目搬运效率极低。这就是为什么很多嵌入式设备或智能手机在使用一段时间后会变得卡顿，其深层原因往往是文件系统的随机写入行为让底层的 FTL 陷入了几乎崩溃的处理链条中。\n\nF2FS 解决这一难题的核心武器是采用了**日志结构文件系统**，即 LFS 架构。我们可以做一个形象的比喻：传统文件系统就像一块黑板，哪里写错了就擦掉哪里，然后再原地重写；而 F2FS 则像是一个永远不使用橡皮擦的笔记本，无论你是新增文件还是修改旧文件，它永远不会去动之前写过的内容，而是不断在笔记本最后一页的空白处按顺序往后写。这种“追加式写入”的做法将所有的逻辑修改转换成了物理上的顺序写。对于底层闪存来说，顺序写入是最完美的运行模式，它极大地减轻了 FTL 的管理压力，让后台垃圾回收变得非常简单高效，同时也因为数据分布更加均匀而天然地实现了磨损均衡，从而显著延长了昂贵闪存硬件的寿命。\n\n虽然 LFS 架构的概念很早就有，但早期的实现一直被“漫游树（wandering tree）”这一难题所困扰，导致无法大规模商用。在传统的 LFS 中，如果你修改了一个数据块，由于它必须写到新位置，物理地址就变了。这意味着指向这个块的上一级索引节点也必须修改地址来指向它，而索引节点的地址改变又会触发上上级节点的修改，最终这种递归更新会一直蔓延到文件系统的根节点，造成巨大的额外开销。**F2FS 的绝活在于它引入了节点地址表，也就是 NAT。**NAT 像一个稳固的中转站，它给每个索引节点分配一个固定的 ID，并记录这个 ID 目前对应的物理地址。当一个数据块移动时，F2FS 只需要更新 NAT 表里对应的一个条目即可，彻底切断了向上递归的“漫游”效应。正是这个核心发明，让 F2FS 能够保持 LFS 的高性能，又避开了复杂的连锁更新，成为了现代闪存存储的基石。\n\n# 总体结构\n\n相对于传统的日志结构型文件系统，F2FS 在 wandering tree 和 gc 的高时间开销等问题，有一定的改进和优化。\n\n1. wandering tree 问题: 在传统的 LFS 中，由于采用异地更新（Out-of-place Update），当一个数据块被修改并写到新地址时，其父节点的指针也必须随之更新以指向新地址。这种更新会沿着文件系统的索引树一路向上递归，直到根节点。这种现象会导致极高的元数据（Metadata）写入开销，原本只改一个字节，最后可能导致整个树路径上的所有块都要重写。F2FS 通过引入 **NAT（Node Address Table）**层，成功切断了这种递归关联，实现了“不动声色”的地址转换。\n2. 高 gc 开销问题: LFS 随着时间推移会产生大量无效数据（旧版本的块）。当磁盘空间不足时，必须启动垃圾回收。传统的 LFS 往往在 GC 时面临不可预知的长延迟，严重影响实时性能。F2FS 通过 **Multi-head Logging（多头日志写入）**和多种 GC 策略（贪婪算法与成本收益算法），根据数据的冷热程度进行分类存储，极大地降低了 GC 时的有效数据搬迁量，减少了系统的波动性。\n\n## 系统特性\n\n### 基本数据单位\n\n分为四类：\n\n1. **Block（块）：**F2FS 读写操作的最小原子单位，大小固定为 **4KB**。这一设计与 Linux 的 Page Cache 以及大多数闪存设备的 Page 大小高度契合。所有的元数据结构和用户数据均以 Block 为单位组织。\n2. **Segment（段）：**管理 Block 的基本容器，大小为 **2MB**（包含 512 个 Block）。Segment 是 F2FS 进行空间管理和分配的基石。之所以选择 2MB，是为了适配主流闪存芯片的物理擦除块（Erase Block）大小，从而减少擦除时的干扰。\n3. **Section（节）：**由连续的若干个 Segment 组成，默认情况下 **1 Section = 1 Segment**。Section 是垃圾回收（GC）的物理操作单位。F2FS 会根据数据的冷热属性，将数据分配到不同的 Section 中，以便在 GC 时能以更高的效率释放整块空间。\n4. **Zone（区）：**由多个 Section 组成。在某些高级配置或特定硬件（如具有隔离特性的闪存阵列）上，Zone 用于进一步的物理隔离，以防止不同类型的数据在物理层面上产生写干扰。\n\n### LFS 异地更新特性\n\nF2FS 遵循“永远不要覆盖旧数据”的原则。这种**异地更新（Out-of-place Update）**策略是 F2FS 性能和可靠性的根源：\n\n- **传统就地更新（In-place）：**如 FAT/EXT4。当修改文件 A 的第 1 块时，直接在原物理位置重写。对于闪存，这会触发底层昂贵的“读取-擦除-修改-写回”过程。\n- **F2FS 异地更新：**当修改发生时，F2FS 直接在当前的 Log 尾部找一个干净的物理块写入新数据。旧块被标记为“Invalid（无效）”，留待未来的 GC 处理。\n\n**优点：**\n\n1. **写聚合：**将碎片化的随机写转换为大吞吐量的顺序写，极大提升 IOPS。\n2. **磨损均衡：**数据自动在全盘范围内散布，避免了因频繁更新特定元数据（如文件表）导致的局部闪存颗粒提前损坏。\n\n这样做的问题是：这种设计依赖 **Checkpoint（检查点）**机制来保证一致性。F2FS 不会像 JFS（日志文件系统）那样在每次操作时写日志，而是定期创建快照。这意味着如果突发断电且此时还没到 Checkpoint 时刻，可能会丢失极短时间内的数据。\n\n### Multi-head Logging（多头日志写入）特性\n\nF2FS 的核心精髓在于它能感知数据的“温度”。Log 区域指的是文件系统中用于分配 free block(空闲的且没有写入数据的 block)的区域，例如 F2FS 的一个文件需要写入新数据，它就要去 Log 区域请求 free block，然后再将数据写入这个 free block 中。传统的 LFS 往往会维护一个大的日志区域，一切数据的分配都从这个大的日志区域中进行处理。它同时维护了 6 个活动的 Log 区域（活跃段），将数据精准分类：\n\n- **节点类（Node）：存储文件的索引结构**\n  - **HOT NODE**：目录文件的直接索引块（Direct Node）。由于目录操作极其频繁且对用户感知影响大，将其单独存放以加快访问速度。\n  - **WARM NODE**：普通文件的直接索引块。\n  - **COLD NODE**：间接索引块（Indirect Node）。这些块通常属于超大文件，修改频率相对较低。\n- **数据类（Data）：存储用户实际内容**\n  - **HOT DATA**：目录项数据（Dentry）。目录下的文件名、inode 号等信息经常变动。\n  - **WARM DATA**：普通文件的内容。这是系统中最主要的数据流。\n  - **COLD DATA**：多媒体文件、只读文件或 GC 搬迁产生的数据。这类数据一旦写入，很难再次被修改。\n\n## 闪存设备物理布局\n\n![image-20251224164153966](https://cdn.davidingplus.cn/images/2025/12/29/image-20251224164153966.png)\n\n通过 mkfs.f2fs 格式化后，整个存储空间被划分为六大功能区。除了主数据区外，前五个区域统称为元数据区。\n\n1. Superblock（超级块，SB）\n\n位于分区的最开始，存储了文件系统的关键几何参数（块大小、段数量、区域边界）。为了保证安全性，F2FS 会保存两个 SB 备份。在挂载（Mount）时，驱动首先读取 SB 并初始化内存中的 f2fs_sb_info 结构。\n\n2. Checkpoint（检查点，CP）\n\n这是系统的“大脑”。CP 记录了当前文件系统的最新一致状态。它包含了两份备份（A/B 切换写入），以防在写 CP 过程中突然断电。CP 存储了 NAT 和 SIT 的位图快照、当前活跃段的列表以及 Orphan Inode（孤儿节点）等信息。在 RTEMS 重启后，挂载过程会根据 CP 来快速恢复整个文件系统的逻辑拓扑。\n\n3. Segment Information Table（段信息表，SIT）\n\nSIT 负责监控 **Main Area** 中每个 Segment 的使用情况。它包含一个位图，指示该段内 512 个块中哪些是有效的（Valid）。主要作用是 SIT 是 GC 决策的关键依据。系统通过查询 SIT 找到那些无效块最多的段进行回收。\n\n4. Node Address Table（节点地址表，NAT）\n\n建立了一张表保存了每一个 node 的物理地址信息。这是 F2FS 解决漫游树问题的秘密武器。\n\n- **机制：**每个 Node（索引节点）都有一个唯一的逻辑 ID（NID）。NAT 就像一个巨大的映射表，记录了 NID -> 物理地址 的转换。\n- **优势：**当文件数据更新导致 Node 本身位置发生移动时，只有 NAT 表中的物理地址需要更新，而指向该 NID 的父节点无需改动。这大大减少了元数据连锁更新的负担。\n\n5. Segment Summary Area（段摘要区，SSA）\n\n这个区域主要保存了 jounal(SIT/NAT 临时的修改信息)以及 summary(记录了逻辑地址和物理地址关系的结构，主要用于 GC)。SSA 区域在内存中没有专门的数据结构。SSA 存储了块的“身份证明”。\n\n- **反向查找：**SSA 记录了主数据区每个物理块对应的父 Node ID 及其在文件内部的偏移。\n- **主要用途：**在 GC 搬迁数据时，系统必须确定这个物理块到底是哪个文件的，SSA 提供了这种反向检索能力，确保搬迁后能正确更新对应的索引指针。\n\n6. Main Area（主数据区）\n\n这是文件系统最广阔的腹地，所有的用户数据、目录项、以及各种 Node 块（Inode 块、索引块）都存储在这里。所有的块分配都遵循前面提到的 6 个 Log 区域的冷热分类策略。\n\n# SuperBlock 区域\n\nSuperBlock 区域的结构如下：\n\n![image-20251224165214273](https://cdn.davidingplus.cn/images/2025/12/29/image-20251224165214273.png)\n\nSuperblock区域是由两个 `struct f2fs_super_block` 结构组成，互为备份。\n\n## f2fs_super_block 结构\n\n`struct f2fs_super_block` 定义了文件系统的几何参数和各功能区的物理偏移。我们可以观察到，F2FS 的许多设计都采用了 log2 的指数形式，例如 log_blocksize 和 log_blocks_per_seg。这种设计允许内核在计算物理地址时使用位移操作（Shift）代替昂贵的除法运算，这对于 CPU 资源有限的嵌入式设备（如运行 RTEMS 的环境）非常友好。此外，该结构体包含了一系列以 _blkaddr 结尾的字段，它们精确指向了 Checkpoint、SIT、NAT、SSA 以及 Main Area 的起始块地址。magic 字段（魔数）则用于标识这确实是一个 F2FS 卷，是驱动程序进行合法性检查的第一道关卡。定义如下：\n\n```c\nstruct f2fs_super_block {\n\t__le32 magic;\t\t\t/* Magic Number */\n\t__le16 major_ver;\t\t/* Major Version */\n\t__le16 minor_ver;\t\t/* Minor Version */\n\t__le32 log_sectorsize;\t\t/* log2 sector size in bytes */\n\t__le32 log_sectors_per_block;\t/* log2 # of sectors per block */\n\t__le32 log_blocksize;\t\t/* log2 block size in bytes */\n\t__le32 log_blocks_per_seg;\t/* log2 # of blocks per segment */\n\t__le32 segs_per_sec;\t\t/* # of segments per section */\n\t__le32 secs_per_zone;\t\t/* # of sections per zone */\n\t__le32 checksum_offset;\t\t/* checksum offset inside super block */\n\t__le64 block_count;\t\t/* total # of user blocks */\n\t__le32 section_count;\t\t/* total # of sections */\n\t__le32 segment_count;\t\t/* total # of segments */\n\t__le32 segment_count_ckpt;\t/* # of segments for checkpoint */\n\t__le32 segment_count_sit;\t/* # of segments for SIT */\n\t__le32 segment_count_nat;\t/* # of segments for NAT */\n\t__le32 segment_count_ssa;\t/* # of segments for SSA */\n\t__le32 segment_count_main;\t/* # of segments for main area */\n\t__le32 segment0_blkaddr;\t/* start block address of segment 0 */\n\t__le32 cp_blkaddr;\t\t/* start block address of checkpoint */\n\t__le32 sit_blkaddr;\t\t/* start block address of SIT */\n\t__le32 nat_blkaddr;\t\t/* start block address of NAT */\n\t__le32 ssa_blkaddr;\t\t/* start block address of SSA */\n\t__le32 main_blkaddr;\t\t/* start block address of main area */\n\t__le32 root_ino;\t\t/* root inode number */\n\t__le32 node_ino;\t\t/* node inode number */\n\t__le32 meta_ino;\t\t/* meta inode number */\n\t__u8 uuid[16];\t\t\t/* 128-bit uuid for volume */\n\t__le16 volume_name[MAX_VOLUME_NAME];\t/* volume name */\n\t__le32 extension_count;\t\t/* # of extensions below */\n\t__u8 extension_list[F2FS_MAX_EXTENSION][F2FS_EXTENSION_LEN];/* extension array */\n\t__le32 cp_payload;\n\t__u8 version[VERSION_LEN];\t/* the kernel version */\n\t__u8 init_version[VERSION_LEN];\t/* the initial kernel version */\n\t__le32 feature;\t\t\t/* defined features */\n\t__u8 encryption_level;\t\t/* versioning level for encryption */\n\t__u8 encrypt_pw_salt[16];\t/* Salt used for string2key algorithm */\n\tstruct f2fs_device devs[MAX_DEVICES];\t/* device list */\n\t__le32 qf_ino[F2FS_MAX_QUOTAS];\t/* quota inode numbers */\n\t__u8 hot_ext_count;\t\t/* # of hot file extension */\n\t__le16  s_encoding;\t\t/* Filename charset encoding */\n\t__le16  s_encoding_flags;\t/* Filename charset encoding flags */\n\t__u8 s_stop_reason[MAX_STOP_REASON];\t/* stop checkpoint reason */\n\t__u8 s_errors[MAX_F2FS_ERRORS];\t\t/* reason of image corrupts */\n\t__u8 reserved[258];\t\t/* valid reserved region */\n\t__le32 crc;\t\t\t/* checksum of superblock */\n} __packed;\n```\n\n## f2fs_sb_info 结构\n\n当 RTEMS 成功从磁盘读取了原始的超级块数据后，它并不会直接频繁操作磁盘上的那段字节流，而是会初始化一个内存管理结构体 `struct f2fs_sb_info`（简称 SBI）。SBI 是 F2FS 在运行时的“指挥部”，它不仅包含了原始超级块的指针 raw_super，还整合了节点管理器（NM）、段管理器（SM）以及用于保证线程安全的各类锁机制（如 sb_lock、gc_mutex）。对于移植工作而言，SBI 是最频繁被打交道的数据结构，它将静态的磁盘布局转换成了动态的内存对象，负责维护文件系统的实时挂载状态。`struct f2fs_super_block` 在内存中对应的结构是 `struct f2fs_sb_info`，它除了包含了`struct f2fs_super_block`的信息以外，还包含了一些额外的功能，如锁、SIT、NAT 对应的内存管理结构等。定义如下：\n\n```c\nstruct f2fs_sb_info {\n\tstruct super_block *sb;\t\t\t/* pointer to VFS super block */\n\tstruct proc_dir_entry *s_proc;\t\t/* proc entry */\n\tstruct f2fs_super_block *raw_super;\t/* raw super block pointer */\n\tstruct f2fs_rwsem sb_lock;\t\t/* lock for raw super block */\n\tint valid_super_block;\t\t\t/* valid super block no */\n\tunsigned long s_flag;\t\t\t\t/* flags for sbi */\n\tstruct mutex writepages;\t\t/* mutex for writepages() */\n\n#ifdef CONFIG_BLK_DEV_ZONED\n\tunsigned int blocks_per_blkz;\t\t/* F2FS blocks per zone */\n\tunsigned int max_open_zones;\t\t/* max open zone resources of the zoned device */\n\t/* For adjust the priority writing position of data in zone UFS */\n\tunsigned int blkzone_alloc_policy;\n#endif\n\n\t/* for node-related operations */\n\tstruct f2fs_nm_info *nm_info;\t\t/* node manager */\n\tstruct inode *node_inode;\t\t/* cache node blocks */\n\n\t/* for segment-related operations */\n\tstruct f2fs_sm_info *sm_info;\t\t/* segment manager */\n\n\t/* for bio operations */\n\tstruct f2fs_bio_info *write_io[NR_PAGE_TYPE];\t/* for write bios */\n\t/* keep migration IO order for LFS mode */\n\tstruct f2fs_rwsem io_order_lock;\n\tpgoff_t page_eio_ofs[NR_PAGE_TYPE];\t/* EIO page offset */\n\tint page_eio_cnt[NR_PAGE_TYPE];\t\t/* EIO count */\n\n\t/* for checkpoint */\n\tstruct f2fs_checkpoint *ckpt;\t\t/* raw checkpoint pointer */\n\tint cur_cp_pack;\t\t\t/* remain current cp pack */\n\tspinlock_t cp_lock;\t\t\t/* for flag in ckpt */\n\tstruct inode *meta_inode;\t\t/* cache meta blocks */\n\tstruct f2fs_rwsem cp_global_sem;\t/* checkpoint procedure lock */\n\tstruct f2fs_rwsem cp_rwsem;\t\t/* blocking FS operations */\n\tstruct f2fs_rwsem node_write;\t\t/* locking node writes */\n\tstruct f2fs_rwsem node_change;\t/* locking node change */\n\twait_queue_head_t cp_wait;\n\tunsigned long last_time[MAX_TIME];\t/* to store time in jiffies */\n\tlong interval_time[MAX_TIME];\t\t/* to store thresholds */\n\tstruct ckpt_req_control cprc_info;\t/* for checkpoint request control */\n\tstruct cp_stats cp_stats;\t\t/* for time stat of checkpoint */\n\n\tstruct inode_management im[MAX_INO_ENTRY];\t/* manage inode cache */\n\n\tspinlock_t fsync_node_lock;\t\t/* for node entry lock */\n\tstruct list_head fsync_node_list;\t/* node list head */\n\tunsigned int fsync_seg_id;\t\t/* sequence id */\n\tunsigned int fsync_node_num;\t\t/* number of node entries */\n\n\t/* for orphan inode, use 0'th array */\n\tunsigned int max_orphans;\t\t/* max orphan inodes */\n\n\t/* for inode management */\n\tstruct list_head inode_list[NR_INODE_TYPE];\t/* dirty inode list */\n\tspinlock_t inode_lock[NR_INODE_TYPE];\t/* for dirty inode list lock */\n\tstruct mutex flush_lock;\t\t/* for flush exclusion */\n\n\t/* for extent tree cache */\n\tstruct extent_tree_info extent_tree[NR_EXTENT_CACHES];\n\tatomic64_t allocated_data_blocks;\t/* for block age extent_cache */\n\tunsigned int max_read_extent_count;\t/* max read extent count per inode */\n\n\t/* The threshold used for hot and warm data seperation*/\n\tunsigned int hot_data_age_threshold;\n\tunsigned int warm_data_age_threshold;\n\tunsigned int last_age_weight;\n\n\t/* control donate caches */\n\tunsigned int donate_files;\n\n\t/* basic filesystem units */\n\tunsigned int log_sectors_per_block;\t/* log2 sectors per block */\n\tunsigned int log_blocksize;\t\t/* log2 block size */\n\tunsigned int blocksize;\t\t\t/* block size */\n\tunsigned int root_ino_num;\t\t/* root inode number*/\n\tunsigned int node_ino_num;\t\t/* node inode number*/\n\tunsigned int meta_ino_num;\t\t/* meta inode number*/\n\tunsigned int log_blocks_per_seg;\t/* log2 blocks per segment */\n\tunsigned int blocks_per_seg;\t\t/* blocks per segment */\n\tunsigned int unusable_blocks_per_sec;\t/* unusable blocks per section */\n\tunsigned int segs_per_sec;\t\t/* segments per section */\n\tunsigned int secs_per_zone;\t\t/* sections per zone */\n\tunsigned int total_sections;\t\t/* total section count */\n\tunsigned int total_node_count;\t\t/* total node block count */\n\tunsigned int total_valid_node_count;\t/* valid node block count */\n\tint dir_level;\t\t\t\t/* directory level */\n\tbool readdir_ra;\t\t\t/* readahead inode in readdir */\n\tu64 max_io_bytes;\t\t\t/* max io bytes to merge IOs */\n\n\tblock_t user_block_count;\t\t/* # of user blocks */\n\tblock_t total_valid_block_count;\t/* # of valid blocks */\n\tblock_t discard_blks;\t\t\t/* discard command candidats */\n\tblock_t last_valid_block_count;\t\t/* for recovery */\n\tblock_t reserved_blocks;\t\t/* configurable reserved blocks */\n\tblock_t current_reserved_blocks;\t/* current reserved blocks */\n\n\t/* Additional tracking for no checkpoint mode */\n\tblock_t unusable_block_count;\t\t/* # of blocks saved by last cp */\n\n\tunsigned int nquota_files;\t\t/* # of quota sysfile */\n\tstruct f2fs_rwsem quota_sem;\t\t/* blocking cp for flags */\n\tstruct task_struct *umount_lock_holder;\t/* s_umount lock holder */\n\n\t/* # of pages, see count_type */\n\tatomic_t nr_pages[NR_COUNT_TYPE];\n\t/* # of allocated blocks */\n\tstruct percpu_counter alloc_valid_block_count;\n\t/* # of node block writes as roll forward recovery */\n\tstruct percpu_counter rf_node_block_count;\n\n\t/* writeback control */\n\tatomic_t wb_sync_req[META];\t/* count # of WB_SYNC threads */\n\n\t/* valid inode count */\n\tstruct percpu_counter total_valid_inode_count;\n\n\tstruct f2fs_mount_info mount_opt;\t/* mount options */\n\n\t/* for cleaning operations */\n\tstruct f2fs_rwsem gc_lock;\t\t/*\n\t\t\t\t\t\t * semaphore for GC, avoid\n\t\t\t\t\t\t * race between GC and GC or CP\n\t\t\t\t\t\t */\n\tstruct f2fs_gc_kthread\t*gc_thread;\t/* GC thread */\n\tstruct atgc_management am;\t\t/* atgc management */\n\tunsigned int cur_victim_sec;\t\t/* current victim section num */\n\tunsigned int gc_mode;\t\t\t/* current GC state */\n\tunsigned int next_victim_seg[2];\t/* next segment in victim section */\n\tspinlock_t gc_remaining_trials_lock;\n\t/* remaining trial count for GC_URGENT_* and GC_IDLE_* */\n\tunsigned int gc_remaining_trials;\n\n\t/* for skip statistic */\n\tunsigned long long skipped_gc_rwsem;\t\t/* FG_GC only */\n\n\t/* free sections reserved for pinned file */\n\tunsigned int reserved_pin_section;\n\n\t/* threshold for gc trials on pinned files */\n\tunsigned short gc_pin_file_threshold;\n\tstruct f2fs_rwsem pin_sem;\n\n\t/* maximum # of trials to find a victim segment for SSR and GC */\n\tunsigned int max_victim_search;\n\t/* migration granularity of garbage collection, unit: segment */\n\tunsigned int migration_granularity;\n\t/* migration window granularity of garbage collection, unit: segment */\n\tunsigned int migration_window_granularity;\n\n\t/*\n\t * for stat information.\n\t * one is for the LFS mode, and the other is for the SSR mode.\n\t */\n#ifdef CONFIG_F2FS_STAT_FS\n\tstruct f2fs_stat_info *stat_info;\t/* FS status information */\n\tatomic_t meta_count[META_MAX];\t\t/* # of meta blocks */\n\tunsigned int segment_count[2];\t\t/* # of allocated segments */\n\tunsigned int block_count[2];\t\t/* # of allocated blocks */\n\tatomic_t inplace_count;\t\t/* # of inplace update */\n\t/* # of lookup extent cache */\n\tatomic64_t total_hit_ext[NR_EXTENT_CACHES];\n\t/* # of hit rbtree extent node */\n\tatomic64_t read_hit_rbtree[NR_EXTENT_CACHES];\n\t/* # of hit cached extent node */\n\tatomic64_t read_hit_cached[NR_EXTENT_CACHES];\n\t/* # of hit largest extent node in read extent cache */\n\tatomic64_t read_hit_largest;\n\tatomic_t inline_xattr;\t\t\t/* # of inline_xattr inodes */\n\tatomic_t inline_inode;\t\t\t/* # of inline_data inodes */\n\tatomic_t inline_dir;\t\t\t/* # of inline_dentry inodes */\n\tatomic_t compr_inode;\t\t\t/* # of compressed inodes */\n\tatomic64_t compr_blocks;\t\t/* # of compressed blocks */\n\tatomic_t swapfile_inode;\t\t/* # of swapfile inodes */\n\tatomic_t atomic_files;\t\t\t/* # of opened atomic file */\n\tatomic_t max_aw_cnt;\t\t\t/* max # of atomic writes */\n\tunsigned int io_skip_bggc;\t\t/* skip background gc for in-flight IO */\n\tunsigned int other_skip_bggc;\t\t/* skip background gc for other reasons */\n\tunsigned int ndirty_inode[NR_INODE_TYPE];\t/* # of dirty inodes */\n\tatomic_t cp_call_count[MAX_CALL_TYPE];\t/* # of cp call */\n#endif\n\tspinlock_t stat_lock;\t\t\t/* lock for stat operations */\n\n\t/* to attach REQ_META|REQ_FUA flags */\n\tunsigned int data_io_flag;\n\tunsigned int node_io_flag;\n\n\t/* For sysfs support */\n\tstruct kobject s_kobj;\t\t\t/* /sys/fs/f2fs/<devname> */\n\tstruct completion s_kobj_unregister;\n\n\tstruct kobject s_stat_kobj;\t\t/* /sys/fs/f2fs/<devname>/stat */\n\tstruct completion s_stat_kobj_unregister;\n\n\tstruct kobject s_feature_list_kobj;\t\t/* /sys/fs/f2fs/<devname>/feature_list */\n\tstruct completion s_feature_list_kobj_unregister;\n\n\t/* For shrinker support */\n\tstruct list_head s_list;\n\tstruct mutex umount_mutex;\n\tunsigned int shrinker_run_no;\n\n\t/* For multi devices */\n\tint s_ndevs;\t\t\t\t/* number of devices */\n\tstruct f2fs_dev_info *devs;\t\t/* for device list */\n\tunsigned int dirty_device;\t\t/* for checkpoint data flush */\n\tspinlock_t dev_lock;\t\t\t/* protect dirty_device */\n\tbool aligned_blksize;\t\t\t/* all devices has the same logical blksize */\n\tunsigned int first_seq_zone_segno;\t/* first segno in sequential zone */\n\tunsigned int bggc_io_aware;\t\t/* For adjust the BG_GC priority when pending IO */\n\tunsigned int allocate_section_hint;\t/* the boundary position between devices */\n\tunsigned int allocate_section_policy;\t/* determine the section writing priority */\n\n\t/* For write statistics */\n\tu64 sectors_written_start;\n\tu64 kbytes_written;\n\n\t/* Precomputed FS UUID checksum for seeding other checksums */\n\t__u32 s_chksum_seed;\n\n\tstruct workqueue_struct *post_read_wq;\t/* post read workqueue */\n\n\t/*\n\t * If we are in irq context, let's update error information into\n\t * on-disk superblock in the work.\n\t */\n\tstruct work_struct s_error_work;\n\tunsigned char errors[MAX_F2FS_ERRORS];\t\t/* error flags */\n\tunsigned char stop_reason[MAX_STOP_REASON];\t/* stop reason */\n\tspinlock_t error_lock;\t\t\t/* protect errors/stop_reason array */\n\tbool error_dirty;\t\t\t/* errors of sb is dirty */\n\n\tstruct kmem_cache *inline_xattr_slab;\t/* inline xattr entry */\n\tunsigned int inline_xattr_slab_size;\t/* default inline xattr slab size */\n\n\t/* For reclaimed segs statistics per each GC mode */\n\tunsigned int gc_segment_mode;\t\t/* GC state for reclaimed segments */\n\tunsigned int gc_reclaimed_segs[MAX_GC_MODE];\t/* Reclaimed segs for each mode */\n\n\tunsigned long seq_file_ra_mul;\t\t/* multiplier for ra_pages of seq. files in fadvise */\n\n\tint max_fragment_chunk;\t\t\t/* max chunk size for block fragmentation mode */\n\tint max_fragment_hole;\t\t\t/* max hole size for block fragmentation mode */\n\n\t/* For atomic write statistics */\n\tatomic64_t current_atomic_write;\n\ts64 peak_atomic_write;\n\tu64 committed_atomic_block;\n\tu64 revoked_atomic_block;\n\n\t/* carve out reserved_blocks from total blocks */\n\tbool carve_out;\n\n#ifdef CONFIG_F2FS_FS_COMPRESSION\n\tstruct kmem_cache *page_array_slab;\t/* page array entry */\n\tunsigned int page_array_slab_size;\t/* default page array slab size */\n\n\t/* For runtime compression statistics */\n\tu64 compr_written_block;\n\tu64 compr_saved_block;\n\tu32 compr_new_inode;\n\n\t/* For compressed block cache */\n\tstruct inode *compress_inode;\t\t/* cache compressed blocks */\n\tunsigned int compress_percent;\t\t/* cache page percentage */\n\tunsigned int compress_watermark;\t/* cache page watermark */\n\tatomic_t compress_page_hit;\t\t/* cache hit count */\n#endif\n\n#ifdef CONFIG_F2FS_IOSTAT\n\t/* For app/fs IO statistics */\n\tspinlock_t iostat_lock;\n\tunsigned long long iostat_count[NR_IO_TYPE];\n\tunsigned long long iostat_bytes[NR_IO_TYPE];\n\tunsigned long long prev_iostat_bytes[NR_IO_TYPE];\n\tbool iostat_enable;\n\tunsigned long iostat_next_period;\n\tunsigned int iostat_period_ms;\n\n\t/* For io latency related statistics info in one iostat period */\n\tspinlock_t iostat_lat_lock;\n\tstruct iostat_lat_info *iostat_io_lat;\n#endif\n};\n```\n\n## init_sb_info()\n\ninit_sb_info() 函数承担了从“原始字节”到“逻辑对象”的转换任务。首先，它会执行大量的字节序转换（如 le32_to_cpu），确保无论磁盘是在大端还是小端机器上格式化的，在当前 CPU 内存中都能正确解析。接着，它会计算出一些关键的导出参数，如总节点数量、根目录索引号（root_ino）等。除此之外，该函数还会初始化文件系统的同步原语，包括各种读写信号量、互斥锁和自旋锁。在 RTEMS 移植过程中，你需要将这些 Linux 特有的锁接口（如 mutex_init 或 init_rwsem）映射到 RTEMS 的信号量或互斥量 API 上。只有正确完成了这一步，F2FS 才能在多线程任务环境下安全地操作元数据。定义如下：\n\n```c\nstatic void init_sb_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = sbi->raw_super;\n\tint i;\n\n\tsbi->log_sectors_per_block =\n\t\tle32_to_cpu(raw_super->log_sectors_per_block);\n\tsbi->log_blocksize = le32_to_cpu(raw_super->log_blocksize);\n\tsbi->blocksize = BIT(sbi->log_blocksize);\n\tsbi->log_blocks_per_seg = le32_to_cpu(raw_super->log_blocks_per_seg);\n\tsbi->blocks_per_seg = BIT(sbi->log_blocks_per_seg);\n\tsbi->segs_per_sec = le32_to_cpu(raw_super->segs_per_sec);\n\tsbi->secs_per_zone = le32_to_cpu(raw_super->secs_per_zone);\n\tsbi->total_sections = le32_to_cpu(raw_super->section_count);\n\tsbi->total_node_count = SEGS_TO_BLKS(sbi,\n\t\t\t((le32_to_cpu(raw_super->segment_count_nat) / 2) *\n\t\t\tNAT_ENTRY_PER_BLOCK));\n\tsbi->allocate_section_hint = le32_to_cpu(raw_super->section_count);\n\tsbi->allocate_section_policy = ALLOCATE_FORWARD_NOHINT;\n\tF2FS_ROOT_INO(sbi) = le32_to_cpu(raw_super->root_ino);\n\tF2FS_NODE_INO(sbi) = le32_to_cpu(raw_super->node_ino);\n\tF2FS_META_INO(sbi) = le32_to_cpu(raw_super->meta_ino);\n\tsbi->cur_victim_sec = NULL_SECNO;\n\tsbi->gc_mode = GC_NORMAL;\n\tsbi->next_victim_seg[BG_GC] = NULL_SEGNO;\n\tsbi->next_victim_seg[FG_GC] = NULL_SEGNO;\n\tsbi->max_victim_search = DEF_MAX_VICTIM_SEARCH;\n\tsbi->migration_granularity = SEGS_PER_SEC(sbi);\n\tsbi->migration_window_granularity = f2fs_sb_has_blkzoned(sbi) ?\n\t\tDEF_MIGRATION_WINDOW_GRANULARITY_ZONED : SEGS_PER_SEC(sbi);\n\tsbi->seq_file_ra_mul = MIN_RA_MUL;\n\tsbi->max_fragment_chunk = DEF_FRAGMENT_SIZE;\n\tsbi->max_fragment_hole = DEF_FRAGMENT_SIZE;\n\tspin_lock_init(&sbi->gc_remaining_trials_lock);\n\tatomic64_set(&sbi->current_atomic_write, 0);\n\n\tsbi->dir_level = DEF_DIR_LEVEL;\n\tsbi->interval_time[CP_TIME] = DEF_CP_INTERVAL;\n\tsbi->interval_time[REQ_TIME] = DEF_IDLE_INTERVAL;\n\tsbi->interval_time[DISCARD_TIME] = DEF_IDLE_INTERVAL;\n\tsbi->interval_time[GC_TIME] = DEF_IDLE_INTERVAL;\n\tsbi->interval_time[DISABLE_TIME] = DEF_DISABLE_INTERVAL;\n\tsbi->interval_time[ENABLE_TIME] = DEF_ENABLE_INTERVAL;\n\tsbi->interval_time[UMOUNT_DISCARD_TIMEOUT] =\n\t\t\t\tDEF_UMOUNT_DISCARD_TIMEOUT;\n\tclear_sbi_flag(sbi, SBI_NEED_FSCK);\n\n\tfor (i = 0; i < NR_COUNT_TYPE; i++)\n\t\tatomic_set(&sbi->nr_pages[i], 0);\n\n\tfor (i = 0; i < META; i++)\n\t\tatomic_set(&sbi->wb_sync_req[i], 0);\n\n\tINIT_LIST_HEAD(&sbi->s_list);\n\tmutex_init(&sbi->umount_mutex);\n\tinit_f2fs_rwsem(&sbi->io_order_lock);\n\tspin_lock_init(&sbi->cp_lock);\n\n\tsbi->dirty_device = 0;\n\tspin_lock_init(&sbi->dev_lock);\n\n\tinit_f2fs_rwsem(&sbi->sb_lock);\n\tinit_f2fs_rwsem(&sbi->pin_sem);\n}\n```\n\n# CheckPoint 区域\n\nCheckpoint（检查点，简称 CP）是 F2FS 维护数据一致性的灵魂结构，它记录了文件系统在某一时刻的完整“快照”状态。由于 F2FS 采用日志结构（LFS）不断进行异地更新，系统的元数据（如 NAT、SIT）和数据位置总是在动态变化。为了保证在系统突然断电或崩溃后能够恢复，F2FS 会定期或在特定条件下（如 Umount、Sync）将当前活跃的段信息、节点分配情况以及位图快照写入 Checkpoint 区域。为了极致的可靠性，F2FS 维护了两份互为备份的 CP 结构（通常称为 CP #0 和 CP #1）。**系统始终保持一个为“稳定版本”，另一个为“正在写入版本”。**如果在更新 CP 时发生故障，系统可以安全地回退到上一个稳定的 CP，确保文件系统不会因为元数据损坏而无法挂载。\n\nCheckPoint 区域的结构如下。从图中看出分别是 checkpoint 元数据区域(f2fs_checkpoint)、orphan node 区域、active segments 区域。同时 active segments 区域在不同的情况下，会有不同的形式，目的是减少 IO 的写入。\n\n![image-20251224170347186](https://cdn.davidingplus.cn/images/2025/12/29/image-20251224170347186.png)\n\n## f2fs_checkpoint 结构\n\n`struct f2fs_checkpoint` 定义了恢复系统所需的最少信息量。其中最重要的字段是 checkpoint_ver（版本号），系统通过比较两个 CP 备份的版本号来确定哪一个是最新的。此外，cur_node_segno 和 cur_node_blkoff（以及对应的 Data 字段）记录了上次 CP 时系统 6 个写入头的精确坐标。如果没有这些坐标，挂载后文件系统将不知道该从哪个物理块开始继续追加数据。同时，结构体末尾的 sit_nat_version_bitmap 记录了 SIT 和 NAT 区域的版本位图，帮助系统快速定位元数据表的最前沿更新。F2FS 必须定时执行 Checkpoint 去记录当前系统的 log 分配到哪个位置，否则在系统宕机的时候，会出现数据丢失等一致性问题，因此 cur_xxx_segno 以及 cur_xxx_blkoff 记录了上次 Checkpoint 时，系统正在使用的 log 的 segment number，以及分配到这个 segment 的哪个位置。定义如下：\n\n```c\nstruct f2fs_checkpoint {\n\t__le64 checkpoint_ver;\t\t/* checkpoint block version number */\n\t__le64 user_block_count;\t/* # of user blocks */\n\t__le64 valid_block_count;\t/* # of valid blocks in main area */\n\t__le32 rsvd_segment_count;\t/* # of reserved segments for gc */\n\t__le32 overprov_segment_count;\t/* # of overprovision segments */\n\t__le32 free_segment_count;\t/* # of free segments in main area */\n\n\t/* information of current node segments */\n\t__le32 cur_node_segno[MAX_ACTIVE_NODE_LOGS];\n\t__le16 cur_node_blkoff[MAX_ACTIVE_NODE_LOGS];\n\t/* information of current data segments */\n\t__le32 cur_data_segno[MAX_ACTIVE_DATA_LOGS];\n\t__le16 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS];\n\t__le32 ckpt_flags;\t\t/* Flags : umount and journal_present */\n\t__le32 cp_pack_total_block_count;\t/* total # of one cp pack */\n\t__le32 cp_pack_start_sum;\t/* start block number of data summary */\n\t__le32 valid_node_count;\t/* Total number of valid nodes */\n\t__le32 valid_inode_count;\t/* Total number of valid inodes */\n\t__le32 next_free_nid;\t\t/* Next free node number */\n\t__le32 sit_ver_bitmap_bytesize;\t/* Default value 64 */\n\t__le32 nat_ver_bitmap_bytesize; /* Default value 256 */\n\t__le32 checksum_offset;\t\t/* checksum offset inside cp block */\n\t__le64 elapsed_time;\t\t/* mounted time */\n\t/* allocation type of current segment */\n\tunsigned char alloc_type[MAX_ACTIVE_LOGS];\n\n\t/* SIT and NAT version bitmap */\n\tunsigned char sit_nat_version_bitmap[];\n} __packed;\n```\n\n## Orphan Node\n\n这是一个动态的区域，如果没有 orphan node list 则不会占用空间。\n\n## Active Segments\n\nActive Segments 又被称为 **CURSEG**，是 F2FS 实施 Multi-head Logging 策略的直接体现。为了提高效率，F2FS 并非每次分配一个块就去更新一次磁盘上的 SIT（段信息表）或 NAT（节点地址表），因为这样会带来巨大的写压力。相反，它利用 CP 区域中的 **Journal（日志）**和 **Summary（摘要）**结构作为临时缓存。Journal 记录了活跃段中元数据的频繁修改，而 Summary 记录了逻辑地址与物理地址的映射。只有当触发 Checkpoint 操作时，这些暂存在内存和 CP 区域的信息才会被批量持久化。这种设计极大地平衡了闪存的寿命与系统的实时性能。\n\nCP 的主要任务是维护数据一致性，因此 CP 的 active segment 区域的主要任务是维护 Active Segment 的分配状态，使系统宕机时候可以恢复正常。维护 active segment 需要维护三种信息，分别是 f2fs_checkpoint 的信息，以及该 segment 对应的 journal 和 summary 的信息。\n\n- **f2fs_checkpoint 中 Active Segment 信息**：从上面给出的 f2fs_checkpoint 定义，cur_node_segno[MAX_ACTIVE_NODE_LOGS] 和 cur_data_segno[MAX_ACTIVE_DATA_LOGS] 表示 node 和 data 当前的 Active Segment 的编号(segment number, segno)，系统可以通过这个编号找到对应的 segment。MAX_ACTIVE_NODE_LOGS 以及 MAX_ACTIVE_NODE_LOGS 分别表示 data 和 node 有多少种类型，F2FS 默认情况下都等于 3，表示 HOT、WARM、COLD 类型数据。cur_node_blkoff[MAX_ACTIVE_NODE_LOGS] 以及 cur_data_blkoff[MAX_ACTIVE_DATA_LOGS] 则分别表示当前 active segment 分配到哪一个 block(一个 segment 包含了 512 个 block)。\n- **Segment 对应的 Journal 信息**：Journal 在两处地方都有出现，分别是 CP 区域以及 SSA 区域。CP 区域的 journal 主要用来保存 **active segment** 的修改信息，而 SSA 区域的则是持久化保存的**所有的 segment** 的 journal 信息。如系统分配出一个 block 给用户，那么就要将这个 block 所在的 segment 的 bitmap 中标记为已分配，防止其他写请求使用。分两个区域存放 journal 是为了减轻频繁更新导致的系统性能下降。例如，当系统写压力很大的时候，bitmap 就会频繁被更新，如果这个时候频繁将 bitmap 写入 SSA，就会加重写压力。因此 CP 区域的 Journal 的作用就是维护这些经常修改的数据，等待 CP 被触发的时候才回写到闪存设备，从而减少写压力，提高闪存寿命。\n- **Segment 对应的 Summary 信息**：summary 同样在 CP 区域和 SSA 区域有出现，它表示的是逻辑地址和物理地址的映射关系，这个映射关系会使用到 GC 流程中。summary 与 segment 是一对一的关系，一个 summary 保存了一个 segment 所有的 block 的物理地址和逻辑地址的映射关系。summary 保存在 CP 区域中同样是出于减少 IO 的写入。\n\n## 内存管理结构\n\nCheckpoint 的内存管理结构是 `struct f2fs_checkpoint` 本身，因为 Checkpoint 一般只在 F2FS 启动的时候被读取数据，用于数据恢复，而在运行过程中大部分情况都是被写，用于记录恢复信息。因此，Checkpoint 不需要过于复杂的内存管理结构，因此使用 `struct f2fs_checkpoint` 本身即可以满足需求。\n\nF2FS 的 log，即 active segments，主要用于系统 free block 的分配，因此需要特定的管理结构 `struct curseg_info` 进行管理。定义如下：\n\n```c\n/* for active log information */\nstruct curseg_info {\n\tstruct mutex curseg_mutex;\t\t/* lock for consistency */\n\tstruct f2fs_summary_block *sum_blk;\t/* cached summary block */\n\tstruct rw_semaphore journal_rwsem;\t/* protect journal area */\n\tstruct f2fs_journal *journal;\t\t/* cached journal info */\n\tunsigned char alloc_type;\t\t/* current allocation type */\n\tunsigned short seg_type;\t\t/* segment type like CURSEG_XXX_TYPE */\n\tunsigned int segno;\t\t\t/* current segment number */\n\tunsigned short next_blkoff;\t\t/* next block offset to write */\n\tunsigned int zone;\t\t\t/* current zone number */\n\tunsigned int next_segno;\t\t/* preallocated segment */\n\tint fragment_remained_chunk;\t\t/* remained block size in a chunk for block fragmentation mode */\n\tbool inited;\t\t\t\t/* indicate inmem log is inited */\n};\n```\n\n从结构分析可以直到，`curseg_info` 记录当前的 segment 的分配信息，当系统出现宕机的时候，可以从 CP 记录的 `curseg_info` 恢复当上一次 CP 点的状态。每一种类型的 active segment 就对应一个 `struct curseg_info` 结构。在 F2FS 中，使用一个数组来表示:\n\n```c\nstruct f2fs_sm_info {\n\t...\n\tstruct curseg_info *curseg_array; // 默认是分配6个curseg_info，分别对应不同类型\n\t...\n}\n```\n\n`struct f2fs_sm_info`是 SIT 的管理结构，它也管理了 CP 最终的 active segment 的信息，是一个跨区域的管理结构。\n\n`struct f2fs_checkpoint` 通过 get_checkpoint_version() 函数从磁盘读取出来：\n\n```c\nstatic int get_checkpoint_version(struct f2fs_sb_info *sbi, block_t cp_addr,\n\t\tstruct f2fs_checkpoint **cp_block, struct page **cp_page,\n\t\tunsigned long long *version)\n{\n\tunsigned long blk_size = sbi->blocksize;\n\tsize_t crc_offset = 0;\n\t__u32 crc = 0;\n\n\t*cp_page = f2fs_get_meta_page(sbi, cp_addr); // 根据CP所在的地址cp_addr从磁盘读取一个block\n\t*cp_block = (struct f2fs_checkpoint *)page_address(*cp_page); // 直接转换为数据结构\n\n\tcrc_offset = le32_to_cpu((*cp_block)->checksum_offset);\n\tif (crc_offset > (blk_size - sizeof(__le32))) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"invalid crc_offset: %zu\", crc_offset);\n\t\treturn -EINVAL;\n\t}\n\n\tcrc = cur_cp_crc(*cp_block);\n\tif (!f2fs_crc_valid(sbi, crc, *cp_block, crc_offset)) { // 比较CRC的值，进而知道是否成功读取出来\n\t\tf2fs_msg(sbi->sb, KERN_WARNING, \"invalid crc value\");\n\t\treturn -EINVAL;\n\t}\n\n\t*version = cur_cp_version(*cp_block);\n\treturn 0;\n}\n```\n\n`struct curseg_info` 则是通过 build_curseg() 函数进行初始化:\n\n```c\nstatic int build_curseg(struct f2fs_sb_info *sbi)\n{\n\tstruct curseg_info *array;\n\tint i;\n\n\tarray = f2fs_kzalloc(sbi, array_size(NR_CURSEG_TYPE, sizeof(*array)),\n\t\t\t     GFP_KERNEL); // 根据active segment类型的数目分配空间\n\tif (!array)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->curseg_array = array; // 赋值到f2fs_sm_info->curseg_array\n\n\tfor (i = 0; i < NR_CURSEG_TYPE; i++) { // 为curseg的其他信息分配空间\n\t\tmutex_init(&array[i].curseg_mutex);\n\t\tarray[i].sum_blk = f2fs_kzalloc(sbi, PAGE_SIZE, GFP_KERNEL);\n\t\tif (!array[i].sum_blk)\n\t\t\treturn -ENOMEM;\n\t\tinit_rwsem(&array[i].journal_rwsem);\n\t\tarray[i].journal = f2fs_kzalloc(sbi,\n\t\t\t\tsizeof(struct f2fs_journal), GFP_KERNEL);\n\t\tif (!array[i].journal)\n\t\t\treturn -ENOMEM;\n\t\tarray[i].segno = NULL_SEGNO;\n\t\tarray[i].next_blkoff = 0;\n\t}\n\treturn restore_curseg_summaries(sbi); // 从f2fs_checkpoint恢复上一个CP点CURSEG的状态\n}\n\nstatic int restore_curseg_summaries(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_journal *sit_j = CURSEG_I(sbi, CURSEG_COLD_DATA)->journal;\n\tstruct f2fs_journal *nat_j = CURSEG_I(sbi, CURSEG_HOT_DATA)->journal;\n\tint type = CURSEG_HOT_DATA;\n\tint err;\n\n\t...\n\tfor (; type <= CURSEG_COLD_NODE; type++) { // 按类型逐个恢复active segment的信息\n\t\terr = read_normal_summaries(sbi, type);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t...\n\n\treturn 0;\n}\n\nstatic int read_normal_summaries(struct f2fs_sb_info *sbi, int type)\n{\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_summary_block *sum;\n\tstruct curseg_info *curseg;\n\tstruct page *new;\n\tunsigned short blk_off;\n\tunsigned int segno = 0;\n\tblock_t blk_addr = 0;\n\n\t...\n\tsegno = le32_to_cpu(ckpt->cur_data_segno[type]); // 从CP读取segno\n\tblk_off = le16_to_cpu(ckpt->cur_data_blkoff[type - CURSEG_HOT_DATA]); // 从CP读取blk_off\n\tblk_addr = sum_blk_addr(sbi, NR_CURSEG_DATA_TYPE, type); // 获取summary block地址\t\n\n\t// 读取&转换结构\n\tnew = f2fs_get_meta_page(sbi, blk_addr);\n\tsum = (struct f2fs_summary_block *)page_address(new);\n\n\tcurseg = CURSEG_I(sbi, type); // 根据type找到对应的curseg\n\tmutex_lock(&curseg->curseg_mutex);\n\n\t/* 复制&恢复数据 */\n\tdown_write(&curseg->journal_rwsem);\n\tmemcpy(curseg->journal, &sum->journal, SUM_JOURNAL_SIZE);\n\tup_write(&curseg->journal_rwsem);\n\n\tmemcpy(curseg->sum_blk->entries, sum->entries, SUM_ENTRY_SIZE);\n\tmemcpy(&curseg->sum_blk->footer, &sum->footer, SUM_FOOTER_SIZE);\n\tcurseg->next_segno = segno;\n\treset_curseg(sbi, type, 0);\n\tcurseg->alloc_type = ckpt->alloc_type[type];\n\tcurseg->next_blkoff = blk_off; // 恢复上次的分配状态\n\tmutex_unlock(&curseg->curseg_mutex);\n\tf2fs_put_page(new, 1);\n\treturn 0;\n}\n```\n\n# Segment Infomation Table 区域\n\nSegment Infomation Table，简称 SIT，是 F2FS 用于集中管理 segment 状态的结构。它的主要作用是维护的 segment 的分配信息，它的作用可以使用两个常见例子进行描述:\n\n- 用户进行写操作，那么 segment 会根据用户写入的数据量分配特定数目的 block 给用户进行数据写入，SIT 会将这些已经被分配的 block 标记为\"已经使用(valid 状态)\"，那么之后的写操作就不会再使用这些 block。\n- 用户进行了**覆盖写**操作以后，由于 F2FS **异地更新**的特性，F2FS 会分配新 block 给用户写入，同时会将旧 block 置为\"无效状态(invalid 状态)\"，这样 gc 的时候可以根据 segment 无效的 block 的数目，采取某种策略进行回收。\n\n综上所述，SIT 的作用是维护每一个 segment 的 block 的使用状态以及有效无效状态。\n\n## 元数据的物理结构\n\nSIT 区域的结构如下。SIT 区域由 N 个 `struct f2fs_sit_block` 组成，每一个 `struct f2fs_sit_block` 包含了 55 个 `struct f2fs_sit_entry`，每一个 entry 对应了一个 segment 的管理状态。每一个 entry 包含了三个变量: vblocks(记录这个 segment 有多少个 block 已经被使用了)，valid_map(记录这个 segment 里面的哪一些 block 是无效的)，mtime(表示修改时间)。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/12/29/image-20251225152548700.png\" alt=\"image-20251225152548700\" style=\"zoom:67%;\" />\n\nSIT 的基本存放单元是 `struct f2fs_sit_block`，定义如下:\n\n```c\nstruct f2fs_sit_block {\n\tstruct f2fs_sit_entry entries[SIT_ENTRY_PER_BLOCK];\n} __packed;\n```\n\n由于一个 block 的尺寸是 4 KB，因此跟根据 `sizeof(struct f2fs_sit_entry entries)` 的值，得到 `SIT_ENTRY_PER_BLOCK` 的值为 55。`struct f2fs_sit_entry entries `用来表示每一个 segment 的状态信息，定义如下：\n\n```c\nstruct f2fs_sit_entry {\n\t__le16 vblocks;\t\t\t\t/* reference above */\n\t__u8 valid_map[SIT_VBLOCK_MAP_SIZE];\t/* bitmap for valid blocks */\n\t__le64 mtime;\t\t\t\t/* segment age for cleaning */\n} __packed;\n```\n\n第一个参数 `vblocks` 表示当前 segment 有多少个 block 已经被使用，第二个参数 `valid_map` 表示 segment 内的每一个 block 的有效无效信息; 由于一个 segment 包含了 512 个 block，因此需要用 512 个 bit 去表示每一个 block 的有效无效状态，因此 `SIT_VBLOCK_MAP_SIZE` 的值是 64(8*64=512)。最后一个参数 `mtime` 表示这个 entry 被修改的时间，用于挑选 GC 时需要使用的 segment。\n\n## 内存管理结构\n\nSIT 在内存中对应的管理结构是 `struct f2fs_sm_info`，它在 build_segment_manager() 函数进行初始化：\n\n```c\nstruct f2fs_sm_info {\n\tstruct sit_info *sit_info;\t\t/* whole segment information */\n\tstruct free_segmap_info *free_info;\t/* free segment information */\n\tstruct dirty_seglist_info *dirty_info;\t/* dirty segment information */\n\tstruct curseg_info *curseg_array;\t/* active segment information */\n\n\tstruct f2fs_rwsem curseg_lock;\t/* for preventing curseg change */\n\n\tblock_t seg0_blkaddr;\t\t/* block address of 0'th segment */\n\tblock_t main_blkaddr;\t\t/* start block address of main area */\n\tblock_t ssa_blkaddr;\t\t/* start block address of SSA area */\n\n\tunsigned int segment_count;\t/* total # of segments */\n\tunsigned int main_segments;\t/* # of segments in main area */\n\tunsigned int reserved_segments;\t/* # of reserved segments */\n\tunsigned int ovp_segments;\t/* # of overprovision segments */\n\n\t/* a threshold to reclaim prefree segments */\n\tunsigned int rec_prefree_segments;\n\n\tstruct list_head sit_entry_set;\t/* sit entry set list */\n\n\tunsigned int ipu_policy;\t/* in-place-update policy */\n\tunsigned int min_ipu_util;\t/* in-place-update threshold */\n\tunsigned int min_fsync_blocks;\t/* threshold for fsync */\n\tunsigned int min_seq_blocks;\t/* threshold for sequential blocks */\n\tunsigned int min_hot_blocks;\t/* threshold for hot block allocation */\n\tunsigned int min_ssr_sections;\t/* threshold to trigger SSR allocation */\n\n\t/* for flush command control */\n\tstruct flush_cmd_control *fcc_info;\n\n\t/* for discard command control */\n\tstruct discard_cmd_control *dcc_info;\n};\n\nint build_segment_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);\n\tstruct f2fs_sm_info *sm_info;\n\tint err;\n\n    /* 分配空间 */\n\tsm_info = kzalloc(sizeof(struct f2fs_sm_info), GFP_KERNEL);\n\n\t/* 初始化一些地址信息，基础信息 */\n\tsbi->sm_info = sm_info;\n\tINIT_LIST_HEAD(&sm_info->wblist_head);\n\tspin_lock_init(&sm_info->wblist_lock);\n\tsm_info->seg0_blkaddr = le32_to_cpu(raw_super->segment0_blkaddr);\n\tsm_info->main_blkaddr = le32_to_cpu(raw_super->main_blkaddr);\n\tsm_info->segment_count = le32_to_cpu(raw_super->segment_count);\n\tsm_info->reserved_segments = le32_to_cpu(ckpt->rsvd_segment_count);\n\tsm_info->ovp_segments = le32_to_cpu(ckpt->overprov_segment_count);\n\tsm_info->main_segments = le32_to_cpu(raw_super->segment_count_main);\n\tsm_info->ssa_blkaddr = le32_to_cpu(raw_super->ssa_blkaddr);\n\n    /* 初始化内存中的entry数据结构 */\n\terr = build_sit_info(sbi);\n    \n    /* 初始化可用segment的数据结构 */\n\terr = build_free_segmap(sbi);\n\n    /* 恢复checkpoint active segment区域的信息，参考checkpoint结构那一节 */\n\terr = build_curseg(sbi);\n\n\t/* 从磁盘中将SIT物理区域记录的 物理区域sit_entry与只存在于内存的sit_entry建立联系 */\n\tbuild_sit_entries(sbi);\n\n    /* 根据checkpoint记录的恢复信息，恢复可用segment的映射关系 */\n\tinit_free_segmap(sbi);\n    \n    /* 恢复脏segment的映射关系 */\n\terr = build_dirty_segmap(sbi);\n\n    /* 初始化最大最小的修改时间 */\n\tinit_min_max_mtime(sbi);\n\treturn 0;\n}\n```\n\nbuild_sit_info() 用于初始化内存区域的 entry，这里需要注意的是注意区分内存 entry 以及物理区域的 entry：\n\n```c\nstatic int build_sit_info(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);\n\tstruct sit_info *sit_i;\n\tunsigned int sit_segs, start;\n\tchar *src_bitmap, *bitmap;\n\tunsigned int bitmap_size, main_bitmap_size, sit_bitmap_size;\n\tunsigned int discard_map = f2fs_block_unit_discard(sbi) ? 1 : 0;\n\n\t/* allocate memory for SIT information */\n\tsit_i = f2fs_kzalloc(sbi, sizeof(struct sit_info), GFP_KERNEL);\n\tif (!sit_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->sit_info = sit_i;\n\n\tsit_i->sentries =\n\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct seg_entry),\n\t\t\t\t\t      MAIN_SEGS(sbi)),\n\t\t\t      GFP_KERNEL);\n\tif (!sit_i->sentries)\n\t\treturn -ENOMEM;\n\n\tmain_bitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tsit_i->dirty_sentries_bitmap = f2fs_kvzalloc(sbi, main_bitmap_size,\n\t\t\t\t\t\t\t\tGFP_KERNEL);\n\tif (!sit_i->dirty_sentries_bitmap)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * (3 + discard_map);\n#else\n\tbitmap_size = MAIN_SEGS(sbi) * SIT_VBLOCK_MAP_SIZE * (2 + discard_map);\n#endif\n\tsit_i->bitmap = f2fs_kvzalloc(sbi, bitmap_size, GFP_KERNEL);\n\tif (!sit_i->bitmap)\n\t\treturn -ENOMEM;\n\n\tbitmap = sit_i->bitmap;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tsit_i->sentries[start].cur_valid_map = bitmap;\n\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n\n\t\tsit_i->sentries[start].ckpt_valid_map = bitmap;\n\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\t\tsit_i->sentries[start].cur_valid_map_mir = bitmap;\n\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n#endif\n\n\t\tif (discard_map) {\n\t\t\tsit_i->sentries[start].discard_map = bitmap;\n\t\t\tbitmap += SIT_VBLOCK_MAP_SIZE;\n\t\t}\n\t}\n\n\tsit_i->tmp_map = f2fs_kzalloc(sbi, SIT_VBLOCK_MAP_SIZE, GFP_KERNEL);\n\tif (!sit_i->tmp_map)\n\t\treturn -ENOMEM;\n\n\tif (__is_large_section(sbi)) {\n\t\tsit_i->sec_entries =\n\t\t\tf2fs_kvzalloc(sbi, array_size(sizeof(struct sec_entry),\n\t\t\t\t\t\t      MAIN_SECS(sbi)),\n\t\t\t\t      GFP_KERNEL);\n\t\tif (!sit_i->sec_entries)\n\t\t\treturn -ENOMEM;\n\t}\n\n\t/* get information related with SIT */\n\tsit_segs = le32_to_cpu(raw_super->segment_count_sit) >> 1;\n\n\t/* setup SIT bitmap from ckeckpoint pack */\n\tsit_bitmap_size = __bitmap_size(sbi, SIT_BITMAP);\n\tsrc_bitmap = __bitmap_ptr(sbi, SIT_BITMAP);\n\n\tsit_i->sit_bitmap = kmemdup(src_bitmap, sit_bitmap_size, GFP_KERNEL);\n\tif (!sit_i->sit_bitmap)\n\t\treturn -ENOMEM;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tsit_i->sit_bitmap_mir = kmemdup(src_bitmap,\n\t\t\t\t\tsit_bitmap_size, GFP_KERNEL);\n\tif (!sit_i->sit_bitmap_mir)\n\t\treturn -ENOMEM;\n\n\tsit_i->invalid_segmap = f2fs_kvzalloc(sbi,\n\t\t\t\t\tmain_bitmap_size, GFP_KERNEL);\n\tif (!sit_i->invalid_segmap)\n\t\treturn -ENOMEM;\n#endif\n\n\tsit_i->sit_base_addr = le32_to_cpu(raw_super->sit_blkaddr);\n\tsit_i->sit_blocks = SEGS_TO_BLKS(sbi, sit_segs);\n\tsit_i->written_valid_blocks = 0;\n\tsit_i->bitmap_size = sit_bitmap_size;\n\tsit_i->dirty_sentries = 0;\n\tsit_i->sents_per_block = SIT_ENTRY_PER_BLOCK;\n\tsit_i->elapsed_time = le64_to_cpu(sbi->ckpt->elapsed_time);\n\tsit_i->mounted_time = ktime_get_boottime_seconds();\n\tinit_rwsem(&sit_i->sentry_lock);\n\treturn 0;\n}\n```\n\nbuild_free_segmap() 用于初始化 segment 的分配状态：\n\n```c\nstatic int build_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct free_segmap_info *free_i;\n\tunsigned int bitmap_size, sec_bitmap_size;\n\n\t/* allocate memory for free segmap information */\n\tfree_i = f2fs_kzalloc(sbi, sizeof(struct free_segmap_info), GFP_KERNEL);\n\tif (!free_i)\n\t\treturn -ENOMEM;\n\n\tSM_I(sbi)->free_info = free_i;\n\n\tbitmap_size = f2fs_bitmap_size(MAIN_SEGS(sbi));\n\tfree_i->free_segmap = f2fs_kvmalloc(sbi, bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_segmap)\n\t\treturn -ENOMEM;\n\n\tsec_bitmap_size = f2fs_bitmap_size(MAIN_SECS(sbi));\n\tfree_i->free_secmap = f2fs_kvmalloc(sbi, sec_bitmap_size, GFP_KERNEL);\n\tif (!free_i->free_secmap)\n\t\treturn -ENOMEM;\n\n\t/* set all segments as dirty temporarily */\n\tmemset(free_i->free_segmap, 0xff, bitmap_size);\n\tmemset(free_i->free_secmap, 0xff, sec_bitmap_size);\n\n\t/* init free segmap information */\n\tfree_i->start_segno = GET_SEGNO_FROM_SEG0(sbi, MAIN_BLKADDR(sbi));\n\tfree_i->free_segments = 0;\n\tfree_i->free_sections = 0;\n\tspin_lock_init(&free_i->segmap_lock);\n\treturn 0;\n}\n```\n\nbuild_sit_entries() 的作用是从 SIT 的物理区域存放的物理 entry 与内存的 entry 建立联系，首先看看物理 entry 和内存 entry 的差异在哪里。\n\n```c\nstatic int build_sit_entries(struct f2fs_sb_info *sbi)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_COLD_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tstruct seg_entry *se;\n\tstruct f2fs_sit_entry sit;\n\tint sit_blk_cnt = SIT_BLK_CNT(sbi);\n\tunsigned int i, start, end;\n\tunsigned int readed, start_blk = 0;\n\tint err = 0;\n\tblock_t sit_valid_blocks[2] = {0, 0};\n\n\tdo {\n\t\treaded = f2fs_ra_meta_pages(sbi, start_blk, BIO_MAX_VECS,\n\t\t\t\t\t\t\tMETA_SIT, true);\n\n\t\tstart = start_blk * sit_i->sents_per_block;\n\t\tend = (start_blk + readed) * sit_i->sents_per_block;\n\n\t\tfor (; start < end && start < MAIN_SEGS(sbi); start++) {\n\t\t\tstruct f2fs_sit_block *sit_blk;\n\t\t\tstruct folio *folio;\n\n\t\t\tse = &sit_i->sentries[start];\n\t\t\tfolio = get_current_sit_folio(sbi, start);\n\t\t\tif (IS_ERR(folio))\n\t\t\t\treturn PTR_ERR(folio);\n\t\t\tsit_blk = folio_address(folio);\n\t\t\tsit = sit_blk->entries[SIT_ENTRY_OFFSET(sit_i, start)];\n\t\t\tf2fs_folio_put(folio, true);\n\n\t\t\terr = check_block_count(sbi, start, &sit);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tseg_info_from_raw_sit(se, &sit);\n\n\t\t\tif (se->type >= NR_PERSISTENT_LOG) {\n\t\t\t\tf2fs_err(sbi, \"Invalid segment type: %u, segno: %u\",\n\t\t\t\t\t\t\tse->type, start);\n\t\t\t\tf2fs_handle_error(sbi,\n\t\t\t\t\t\tERROR_INCONSISTENT_SUM_TYPE);\n\t\t\t\treturn -EFSCORRUPTED;\n\t\t\t}\n\n\t\t\tsit_valid_blocks[SE_PAGETYPE(se)] += se->valid_blocks;\n\n\t\t\tif (!f2fs_block_unit_discard(sbi))\n\t\t\t\tgoto init_discard_map_done;\n\n\t\t\t/* build discard map only one time */\n\t\t\tif (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {\n\t\t\t\tmemset(se->discard_map, 0xff,\n\t\t\t\t\t\tSIT_VBLOCK_MAP_SIZE);\n\t\t\t\tgoto init_discard_map_done;\n\t\t\t}\n\t\t\tmemcpy(se->discard_map, se->cur_valid_map,\n\t\t\t\t\t\tSIT_VBLOCK_MAP_SIZE);\n\t\t\tsbi->discard_blks += BLKS_PER_SEG(sbi) -\n\t\t\t\t\t\tse->valid_blocks;\ninit_discard_map_done:\n\t\t\tif (__is_large_section(sbi))\n\t\t\t\tget_sec_entry(sbi, start)->valid_blocks +=\n\t\t\t\t\t\t\tse->valid_blocks;\n\t\t}\n\t\tstart_blk += readed;\n\t} while (start_blk < sit_blk_cnt);\n\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < sits_in_cursum(journal); i++) {\n\t\tunsigned int old_valid_blocks;\n\n\t\tstart = le32_to_cpu(segno_in_journal(journal, i));\n\t\tif (start >= MAIN_SEGS(sbi)) {\n\t\t\tf2fs_err(sbi, \"Wrong journal entry on segno %u\",\n\t\t\t\t start);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tf2fs_handle_error(sbi, ERROR_CORRUPTED_JOURNAL);\n\t\t\tbreak;\n\t\t}\n\n\t\tse = &sit_i->sentries[start];\n\t\tsit = sit_in_journal(journal, i);\n\n\t\told_valid_blocks = se->valid_blocks;\n\n\t\tsit_valid_blocks[SE_PAGETYPE(se)] -= old_valid_blocks;\n\n\t\terr = check_block_count(sbi, start, &sit);\n\t\tif (err)\n\t\t\tbreak;\n\t\tseg_info_from_raw_sit(se, &sit);\n\n\t\tif (se->type >= NR_PERSISTENT_LOG) {\n\t\t\tf2fs_err(sbi, \"Invalid segment type: %u, segno: %u\",\n\t\t\t\t\t\t\tse->type, start);\n\t\t\terr = -EFSCORRUPTED;\n\t\t\tf2fs_handle_error(sbi, ERROR_INCONSISTENT_SUM_TYPE);\n\t\t\tbreak;\n\t\t}\n\n\t\tsit_valid_blocks[SE_PAGETYPE(se)] += se->valid_blocks;\n\n\t\tif (f2fs_block_unit_discard(sbi)) {\n\t\t\tif (is_set_ckpt_flags(sbi, CP_TRIMMED_FLAG)) {\n\t\t\t\tmemset(se->discard_map, 0xff, SIT_VBLOCK_MAP_SIZE);\n\t\t\t} else {\n\t\t\t\tmemcpy(se->discard_map, se->cur_valid_map,\n\t\t\t\t\t\t\tSIT_VBLOCK_MAP_SIZE);\n\t\t\t\tsbi->discard_blks += old_valid_blocks;\n\t\t\t\tsbi->discard_blks -= se->valid_blocks;\n\t\t\t}\n\t\t}\n\n\t\tif (__is_large_section(sbi)) {\n\t\t\tget_sec_entry(sbi, start)->valid_blocks +=\n\t\t\t\t\t\t\tse->valid_blocks;\n\t\t\tget_sec_entry(sbi, start)->valid_blocks -=\n\t\t\t\t\t\t\told_valid_blocks;\n\t\t}\n\t}\n\tup_read(&curseg->journal_rwsem);\n\n\t/* update ckpt_valid_block */\n\tif (__is_large_section(sbi)) {\n\t\tunsigned int segno;\n\n\t\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += SEGS_PER_SEC(sbi)) {\n\t\t\tset_ckpt_valid_blocks(sbi, segno);\n\t\t\tsanity_check_valid_blocks(sbi, segno);\n\t\t}\n\t}\n\n\tif (err)\n\t\treturn err;\n\n\tif (sit_valid_blocks[NODE] != valid_node_count(sbi)) {\n\t\tf2fs_err(sbi, \"SIT is corrupted node# %u vs %u\",\n\t\t\t sit_valid_blocks[NODE], valid_node_count(sbi));\n\t\tf2fs_handle_error(sbi, ERROR_INCONSISTENT_NODE_COUNT);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\tif (sit_valid_blocks[DATA] + sit_valid_blocks[NODE] >\n\t\t\t\tvalid_user_blocks(sbi)) {\n\t\tf2fs_err(sbi, \"SIT is corrupted data# %u %u vs %u\",\n\t\t\t sit_valid_blocks[DATA], sit_valid_blocks[NODE],\n\t\t\t valid_user_blocks(sbi));\n\t\tf2fs_handle_error(sbi, ERROR_INCONSISTENT_BLOCK_COUNT);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\treturn 0;\n}\n\n// 物理entry\nstruct f2fs_sit_entry {\n\t__le16 vblocks;\t\t\t\t/* reference above */\n\t__u8 valid_map[SIT_VBLOCK_MAP_SIZE];\t/* bitmap for valid blocks */\n\t__le64 mtime;\t\t\t\t/* segment age for cleaning */\n} __packed;\n\n// 内存entry\nstruct seg_entry {\n\tunsigned short valid_blocks;\t/* # of valid blocks */\n\tunsigned char *cur_valid_map;\t/* validity bitmap of blocks */\n\tunsigned short ckpt_valid_blocks;\n\tunsigned char *ckpt_valid_map;\n\tunsigned char type;\t\t/* segment type like CURSEG_XXX_TYPE */\n\tunsigned long long mtime;\t/* modification time of the segment */\n};\n```\n\n两者之间的差异主要是多了表示 segment 类型的 type 变量，以及多了两个与 checkpoint 相关的内容。\n\n其实物理 entry 也包含了 segment type 的信息，但是为了节省空间，将 segment type 于 vblocks 存放在了一起，及 vblocks 的前 10 位表示数目，后 6 位表示 segment type，关系如下：\n\n```c\n#define SIT_VBLOCKS_SHIFT\t10\n#define SIT_VBLOCKS_MASK\t((1 << SIT_VBLOCKS_SHIFT) - 1)\n#define GET_SIT_VBLOCKS(raw_sit)\t\t\t\t\\\n\t(le16_to_cpu((raw_sit)->vblocks) & SIT_VBLOCKS_MASK)\n#define GET_SIT_TYPE(raw_sit)\t\t\t\t\t\\\n\t((le16_to_cpu((raw_sit)->vblocks) & ~SIT_VBLOCKS_MASK)\t\\\n\t >> SIT_VBLOCKS_SHIFT)\n```\n\n因此，内存 entry 实际上仅仅多了 2 个与 checkpoint 相关的信息，即 `ckpt_valid_blocks` 与 `ckpt_valid_map` 。在系统执行 checkpoint 的时候，会将 `valid_blocks` 以及 `cur_valid_map` 的值分别写入 `ckpt_valid_blocks` 与 `ckpt_valid_map`，当系统出现宕机的时候根据这个值恢复映射信息。\n\ninit_free_segmap() 从内存 entry 以及 checkpoint 中恢复 free segment 的信息。\n\n```c\nstatic void init_free_segmap(struct f2fs_sb_info *sbi)\n{\n\tunsigned int start;\n\tint type;\n\tstruct seg_entry *sentry;\n\n\tfor (start = 0; start < MAIN_SEGS(sbi); start++) {\n\t\tif (f2fs_usable_blks_in_seg(sbi, start) == 0)\n\t\t\tcontinue;\n\t\tsentry = get_seg_entry(sbi, start);\n\t\tif (!sentry->valid_blocks)\n\t\t\t__set_free(sbi, start);\n\t\telse\n\t\t\tSIT_I(sbi)->written_valid_blocks +=\n\t\t\t\t\t\tsentry->valid_blocks;\n\t}\n\n\t/* set use the current segments */\n\tfor (type = CURSEG_HOT_DATA; type <= CURSEG_COLD_NODE; type++) {\n\t\tstruct curseg_info *curseg_t = CURSEG_I(sbi, type);\n\n\t\t__set_test_and_inuse(sbi, curseg_t->segno);\n\t}\n}\n```\n\ninit_dirty_segmap() 函数恢复脏 segment 的信息。\n\n```c\nstatic void init_dirty_segmap(struct f2fs_sb_info *sbi)\n{\n\tstruct dirty_seglist_info *dirty_i = DIRTY_I(sbi);\n\tstruct free_segmap_info *free_i = FREE_I(sbi);\n\tunsigned int segno = 0, offset = 0, secno;\n\tblock_t valid_blocks, usable_blks_in_seg;\n\n\twhile (1) {\n\t\t/* find dirty segment based on free segmap */\n\t\tsegno = find_next_inuse(free_i, MAIN_SEGS(sbi), offset);\n\t\tif (segno >= MAIN_SEGS(sbi))\n\t\t\tbreak;\n\t\toffset = segno + 1;\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, false);\n\t\tusable_blks_in_seg = f2fs_usable_blks_in_seg(sbi, segno);\n\t\tif (valid_blocks == usable_blks_in_seg || !valid_blocks)\n\t\t\tcontinue;\n\t\tif (valid_blocks > usable_blks_in_seg) {\n\t\t\tf2fs_bug_on(sbi, 1);\n\t\t\tcontinue;\n\t\t}\n\t\tmutex_lock(&dirty_i->seglist_lock);\n\t\t__locate_dirty_segment(sbi, segno, DIRTY);\n\t\tmutex_unlock(&dirty_i->seglist_lock);\n\t}\n\n\tif (!__is_large_section(sbi))\n\t\treturn;\n\n\tmutex_lock(&dirty_i->seglist_lock);\n\tfor (segno = 0; segno < MAIN_SEGS(sbi); segno += SEGS_PER_SEC(sbi)) {\n\t\tvalid_blocks = get_valid_blocks(sbi, segno, true);\n\t\tsecno = GET_SEC_FROM_SEG(sbi, segno);\n\n\t\tif (!valid_blocks || valid_blocks == CAP_BLKS_PER_SEC(sbi))\n\t\t\tcontinue;\n\t\tif (is_cursec(sbi, secno))\n\t\t\tcontinue;\n\t\tset_bit(secno, dirty_i->dirty_secmap);\n\t}\n\tmutex_unlock(&dirty_i->seglist_lock);\n}\n```\n\n# Node Address Table 区域\n\nNode Address Table，简称 NAT，是 F2FS 用于集中管理 node 的结构。**它的主要维护了一张表(如下图)，记录了每一个 node 在 flash 设备的物理地址。**F2FS 给每一个 node 分配了一个 node ID(nid)，系统可以根据 nid 从 NAT 查找到该 node 在 flash 设备上的物理地址，然后从 flash 设备读取出来。表的结构如下：\n\n![image-20251225153846231](https://cdn.davidingplus.cn/images/2025/12/29/image-20251225153846231.png)\n\n## 元数据的物理结构\n\nNAT 区域由 N 个 `struct f2fs_nat_block` 组成，每一个 `struct f2fs_nat_block` 包含了 455 个 `struct f2fs_nat_entry`。每一个 nid 对应了一个 entry，每一个 entry 记录了这个 node 的在 flash 设备上的物理地址 block_addr。同时 entry 也记录了一个 ino 的值，这个值用于找到这个 node 的 parent node，如果 nid == ino 则表示这个 node 是 inode，如果 nid != ino，则表示这是一个 direct_node 或者 indrect_node。version 变量用于系统恢复。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/12/29/image-20251225153933456.png\" alt=\"image-20251225153933456\" style=\"zoom:65%;\" />\n\n## 内存管理结构\n\nNAT 在内存中对应的管理结构是 `struct f2fs_nm_info`，它在 build_node_manager() 函数进行初始化。`struct f2fs_nm_info` 不会将所有的 NAT 的数据都读取出来，而是读取 NAT 的一部分，然后构建 free nid 表，用于给新的 node 分配 nid。\n\n```c\nstruct f2fs_nm_info {\n\tblock_t nat_blkaddr;\t\t/* base disk address of NAT */\n\tnid_t max_nid;\t\t\t/* maximum possible node ids */\n\tnid_t available_nids;\t\t/* # of available node ids */\n\tnid_t next_scan_nid;\t\t/* the next nid to be scanned */\n\tnid_t max_rf_node_blocks;\t/* max # of nodes for recovery */\n\tunsigned int ram_thresh;\t/* control the memory footprint */\n\tunsigned int ra_nid_pages;\t/* # of nid pages to be readaheaded */\n\tunsigned int dirty_nats_ratio;\t/* control dirty nats ratio threshold */\n\n\t/* NAT cache management */\n\tstruct radix_tree_root nat_root;/* root of the nat entry cache */\n\tstruct radix_tree_root nat_set_root;/* root of the nat set cache */\n\tstruct f2fs_rwsem nat_tree_lock;\t/* protect nat entry tree */\n\tstruct list_head nat_entries;\t/* cached nat entry list (clean) */\n\tspinlock_t nat_list_lock;\t/* protect clean nat entry list */\n\tunsigned int nat_cnt[MAX_NAT_STATE]; /* the # of cached nat entries */\n\tunsigned int nat_blocks;\t/* # of nat blocks */\n\n\t/* free node ids management */\n\tstruct radix_tree_root free_nid_root;/* root of the free_nid cache */\n\tstruct list_head free_nid_list;\t\t/* list for free nids excluding preallocated nids */\n\tunsigned int nid_cnt[MAX_NID_STATE];\t/* the number of free node id */\n\tspinlock_t nid_list_lock;\t/* protect nid lists ops */\n\tstruct mutex build_lock;\t/* lock for build free nids */\n\tunsigned char **free_nid_bitmap;\n\tunsigned char *nat_block_bitmap;\n\tunsigned short *free_nid_count;\t/* free nid count of NAT block */\n\n\t/* for checkpoint */\n\tchar *nat_bitmap;\t\t/* NAT bitmap pointer */\n\n\tunsigned int nat_bits_blocks;\t/* # of nat bits blocks */\n\tunsigned char *nat_bits;\t/* NAT bits blocks */\n\tunsigned char *full_nat_bits;\t/* full NAT pages */\n\tunsigned char *empty_nat_bits;\t/* empty NAT pages */\n#ifdef CONFIG_F2FS_CHECK_FS\n\tchar *nat_bitmap_mir;\t\t/* NAT bitmap mirror */\n#endif\n\tint bitmap_size;\t\t/* bitmap size */\n};\n\nint build_node_manager(struct f2fs_sb_info *sbi)\n{\n\tint err;\n\n    /* 分配空间 */\n\tsbi->nm_info = kzalloc(sizeof(struct f2fs_nm_info), GFP_KERNEL);\n\tif (!sbi->nm_info)\n\t\treturn -ENOMEM;\n\n    /* 初始化sbi->nm_info的信息 */\n\terr = init_node_manager(sbi);\n\tif (err)\n\t\treturn err;\n\n    /* 构建free nids表，用于给新的node分配nid */\n\tbuild_free_nids(sbi);\n\treturn 0;\n}\n```\n\ninit_node_manager() 函数主要用于初始化 `sbi->nm_info` 内的变量信息。\n\n```c\nstatic int init_node_manager(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_super_block *sb_raw = F2FS_RAW_SUPER(sbi);\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tunsigned char *version_bitmap;\n\tunsigned int nat_segs;\n\tint err;\n\n\tnm_i->nat_blkaddr = le32_to_cpu(sb_raw->nat_blkaddr);\n\n\t/* segment_count_nat includes pair segment so divide to 2. */\n\tnat_segs = le32_to_cpu(sb_raw->segment_count_nat) >> 1;\n\tnm_i->nat_blocks = nat_segs << le32_to_cpu(sb_raw->log_blocks_per_seg);\n\tnm_i->max_nid = NAT_ENTRY_PER_BLOCK * nm_i->nat_blocks;\n\n\t/* not used nids: 0, node, meta, (and root counted as valid node) */\n\tnm_i->available_nids = nm_i->max_nid - sbi->total_valid_node_count -\n\t\t\t\t\t\tF2FS_RESERVED_NODE_NUM;\n\tnm_i->nid_cnt[FREE_NID] = 0;\n\tnm_i->nid_cnt[PREALLOC_NID] = 0;\n\tnm_i->ram_thresh = DEF_RAM_THRESHOLD;\n\tnm_i->ra_nid_pages = DEF_RA_NID_PAGES;\n\tnm_i->dirty_nats_ratio = DEF_DIRTY_NAT_RATIO_THRESHOLD;\n\tnm_i->max_rf_node_blocks = DEF_RF_NODE_BLOCKS;\n\n\tINIT_RADIX_TREE(&nm_i->free_nid_root, GFP_ATOMIC);\n\tINIT_LIST_HEAD(&nm_i->free_nid_list);\n\tINIT_RADIX_TREE(&nm_i->nat_root, GFP_NOIO);\n\tINIT_RADIX_TREE(&nm_i->nat_set_root, GFP_NOIO);\n\tINIT_LIST_HEAD(&nm_i->nat_entries);\n\tspin_lock_init(&nm_i->nat_list_lock);\n\n\tmutex_init(&nm_i->build_lock);\n\tspin_lock_init(&nm_i->nid_list_lock);\n\tinit_f2fs_rwsem(&nm_i->nat_tree_lock);\n\n\tnm_i->next_scan_nid = le32_to_cpu(sbi->ckpt->next_free_nid);\n\tnm_i->bitmap_size = __bitmap_size(sbi, NAT_BITMAP);\n\tversion_bitmap = __bitmap_ptr(sbi, NAT_BITMAP);\n\tnm_i->nat_bitmap = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap)\n\t\treturn -ENOMEM;\n\n\tif (!test_opt(sbi, NAT_BITS))\n\t\tdisable_nat_bits(sbi, true);\n\n\terr = __get_nat_bitmaps(sbi);\n\tif (err)\n\t\treturn err;\n\n#ifdef CONFIG_F2FS_CHECK_FS\n\tnm_i->nat_bitmap_mir = kmemdup(version_bitmap, nm_i->bitmap_size,\n\t\t\t\t\tGFP_KERNEL);\n\tif (!nm_i->nat_bitmap_mir)\n\t\treturn -ENOMEM;\n#endif\n\n\treturn 0;\n}\n```\n\nbuild_free_nids() 主要用于构建 free nid 表，用于给新的 node 分配 nid。 为了节省内存，F2FS 不会将 NAT 中所有的 free nid 读取出来，只会读取一部分，因此使用 `nm_i->fcnt` 表示缓存了多少个 free nid。然后会读取一定的数目的 `f2fs_nat_block` 出来，并遍历其中的每一个 `f2fs_nat_entry`，加入到 free nid 的管理结构中。最后还会搜索一下 log 区域的 free nid 信息，也加入到 free nid 管理结构中。\n\n```c\nvoid build_free_nids(struct f2fs_sb_info *sbi)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tint i = 0;\n\tnid_t nid = nm_i->next_scan_nid; // next_scan_nid的含义上面有介绍，从这里开始搜索free nid\n\n\t/* *\n\t * 为了节省内存，F2FS不会将NAT中所有的free nid读取出来，只会读取一部分\n\t * fcnt表示目前缓存了多少个free nid，如果大于NAT_ENTRY_PER_BLOCK，则不再缓存了\n\t */\n\tif (nm_i->fcnt >= NAT_ENTRY_PER_BLOCK)\n\t\treturn;\n\n\t/* \n\t * 因为准备开始读取NAT的page(block)，因此根据nid(next_scan_nid)的所在的block开始，\n\t * 读取FREE_NID_PAGES(=8)个page进入内存 \n\t */\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nid), FREE_NID_PAGES,\n\t\t\t\t\t\t\tMETA_NAT, true);\n\n\tdown_read(&nm_i->nat_tree_lock);\n\n\twhile (1) {\n\t\tstruct page *page = get_current_nat_page(sbi, nid);\n\n        /* \n         * 读取当前nid所在的f2fs_nat_block(page)，\n         * 然后将free nid加入到nm_i->free_nid_list/root中 \n         */\n\t\tscan_nat_page(sbi, page, nid);\n        \n        /* 释放当前的f2fs_nat_block对应的page */\n\t\tf2fs_put_page(page, 1);\n\n        /* 已经读取了一个f2fs_nat_block，自然要跳到下一个f2fs_nat_block的第一个nid */\n\t\tnid += (NAT_ENTRY_PER_BLOCK - (nid % NAT_ENTRY_PER_BLOCK));\n\t\tif (unlikely(nid >= nm_i->max_nid))\n\t\t\tnid = 0;\n\n        /* 所有block读完之后就跳出循环 */\n\t\tif (++i >= FREE_NID_PAGES)\n\t\t\tbreak;\n\t}\n\n\t/* 更新next_scan_nid，前面的已经扫描过了，下一次从这个nid开始扫描 */\n\tnm_i->next_scan_nid = nid;\n\n\t/* 遍历log的nat_journal记录的nat_entry信息，从中寻找free nid */\n\tdown_read(&curseg->journal_rwsem);\n\tfor (i = 0; i < nats_in_cursum(journal); i++) {\n\t\tblock_t addr;\n\t\t/* 从journal中获取nid信息 */\n        nid = le32_to_cpu(nid_in_journal(journal, i));\n        /* 从journal中获取该nid对应的物理地址 */\n\t\taddr = le32_to_cpu(nat_in_journal(journal, i).block_addr);\n        \n        /* addr==NULL_ADDR 表示这个nid没有被文件使用，因此加入free nid，否则去除free nid */\n\t\tif (addr == NULL_ADDR) \n\t\t\tadd_free_nid(sbi, nid, true);\n\t\telse\n\t\t\tremove_free_nid(nm_i, nid);\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tup_read(&nm_i->nat_tree_lock);\n\n\tra_meta_pages(sbi, NAT_BLOCK_OFFSET(nm_i->next_scan_nid),\n\t\t\t\t\tnm_i->ra_nid_pages, META_NAT, false);\n}\n```\n\nscan_nat_page() 函数的作用是扫描当前的 `f2fs_nat_block` 的每一个 entry，并找到其中的 free nid，加入到 `nm_i` 的 free nid 管理结构中。\n\n```c\nstatic int scan_nat_page(struct f2fs_sb_info *sbi,\n\t\t\tstruct f2fs_nat_block *nat_blk, nid_t start_nid)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tblock_t blk_addr;\n\tunsigned int nat_ofs = NAT_BLOCK_OFFSET(start_nid);\n\tint i;\n\n\t__set_bit_le(nat_ofs, nm_i->nat_block_bitmap);\n\n\ti = start_nid % NAT_ENTRY_PER_BLOCK;\n\n\tfor (; i < NAT_ENTRY_PER_BLOCK; i++, start_nid++) {\n\t\tif (unlikely(start_nid >= nm_i->max_nid))\n\t\t\tbreak;\n\n\t\tblk_addr = le32_to_cpu(nat_blk->entries[i].block_addr);\n\n\t\tif (blk_addr == NEW_ADDR)\n\t\t\treturn -EFSCORRUPTED;\n\n\t\tif (blk_addr == NULL_ADDR) {\n\t\t\tadd_free_nid(sbi, start_nid, true, true);\n\t\t} else {\n\t\t\tspin_lock(&NM_I(sbi)->nid_list_lock);\n\t\t\tupdate_free_nid_bitmap(sbi, start_nid, false, true);\n\t\t\tspin_unlock(&NM_I(sbi)->nid_list_lock);\n\t\t}\n\t}\n\n\treturn 0;\n}\n```\n\n# Segment Summary Area 区域\n\nSegment Summary Area，简称 SSA，是 F2FS 用于集中管理物理地址到逻辑地址的映射关系的结构，同时它也具有通过 journal 缓存 sit 或者 nat 的操作用于数据恢复的作用。映射关系的主要作用是当给出一个物理地址的时候，可以通过 SSA 索引得到对应的逻辑地址，主要应用在 GC 流程中; SSA 所包含的 journal 可以缓存一些 sit 或者 nat 的操作，用于避免频繁的元数据更新，以及宕机时候的数据恢复。\n\n## 元数据的物理结构\n\n从结构图可以知道，SSA 区域由 N 个 `struct f2fs_summary_block` 组成，每一个 `struct f2fs_summary_block` 包含了 512 个 `struct f2fs_summary_entry`，刚好对应一个 segment。segment 里面的每一个 block(物理地址)对应一个的 `struct f2fs_summary_entry`，它记录了物理地址到逻辑地址的映射信息。它包含了三个变量: nid(该物理地址是属于哪一个 node 的)，version(用于数据恢复)，ofs_in_node(该物理地址属于该 nid 对应的 node 的第 ofs_in_node 个 block)。\n\n`f2fs_journal` 属于 journal 的信息，它的作用是减少频繁地对 NAT 区域以及 SIT 区域的更新。例如，当系统写压力很大的时候，segment bitmap 更新就会很频繁，就会对 `struct f2fs_sit_entry` 结构进行频繁地改动。如果这个时候频繁将新的映射关系写入 SIT，就会加重写压力。此时可以将数据先写入到 journal 中，因此 **journal 的作用就是维护这些经常修改的数据，等待 CP 被触发的时候才写入磁盘，从而减少写压力**。也许这里会有疑问，为什么将 journal 放在 SSA 区域而不是 NAT 区域以及 SIT 区域呢？这是因为这种存放方式可以减少元数据区域空间的占用。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/12/29/image-20251225154609242.png\" alt=\"image-20251225154609242\" style=\"zoom:67%;\" />\n\nSSA 的基本存放单元是 `struct f2fs_summary_block`，定义如下：\n\n```c\n/* Block-sized summary block structure */\nstruct f2fs_summary_block {\n\tstruct f2fs_summary entries[ENTRIES_IN_SUM];\n\tstruct f2fs_journal journal;\n\tstruct summary_footer footer;\n} __packed;\n```\n\n与 summary 直接相关的是 `struct f2fs_summary` 以及 `struct summary_footer`。`ENTRIES_IN_SUM` 的值 512，因此每一个 entry 对应一个 block，记录了从物理地址到逻辑地址的映射关系，entry 的结构如下：\n\n```c\n/* a summary entry for a block in a segment */\nstruct f2fs_summary {\n\t__le32 nid;\t\t/* parent node id */\n\tunion {\n\t\t__u8 reserved[3];\n\t\tstruct {\n\t\t\t__u8 version;\t\t/* node version number */\n\t\t\t__le16 ofs_in_node;\t/* block index in parent node */\n\t\t} __packed;\n\t};\n} __packed;\n\nstruct summary_footer {\n\tunsigned char entry_type;\t/* SUM_TYPE_XXX */\n\t__le32 check_sum;\t\t/* summary checksum */\n} __packed;\n```\n\n`struct f2fs_summary` 用了一个 union 结构进行表示，但是核心信息是 `nid`、`version` 以及 `ofs_in_node`。数据的索引是通过 node 来进行。文件访问某一个页的数据时，需要首先根据页的索引，找到对应的 nid 以及 offset(两者构成逻辑地址)，从而根据 nid 得到 node page，再根据 offset 得到了该页的物理地址，然后从磁盘中读取出来。`f2fs_summary` 则是**记录物理地址到逻辑地址的映射**，即根据物理地址找到对应的 nid 以及 offset。例如，现在需要根据物理地址为 624 的 block，找到对应的 nid 以及 offset。那么物理地址为 624，可以得到该地址位于第二个 segment，然后属于第二个 segment 的第 113 个 block(block 的编址从 0 开始)。因此根据属于第二个 segment 的信息，找到第二个 `struct f2fs_summary_block`，然后根据偏移量为 113 的信息，找到对应的 `struct f2fs_summary` 结构，从而得到 `nid` 以及 `ofs_in_node`。\n\n`struct summary_footer` 结构记录了校验信息，以及这个 summary 对应的 segment 是属于保存 data 数据的 segment 还是 node 数据的segment。\n\nSSA 在内存没有单独的管理结构，summary 以及 journal 在内存中主要存在于 CURSEG 中。\n\n# 文件数据组织方式\n\n文件数据的组织方式一般时被设计为 inode-data 模式，即每一个文件都具有一个 inode，这个 inode 记录 data 的组织关系，这个关系称为**文件结构**。例如用户需要访问 A 文件的第 1000 个字节，系统就会先根据 A 文件的路径找到的 A 的 inode，然后从 inode 找到第 1000 个字节所在的物理地址，然后从磁盘读取出来。那么 F2FS 的文件结构是怎么样的呢？\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/12/29/image-20251225155522809.png\" alt=\"image-20251225155522809\" style=\"zoom:80%;\" />\n\nF2FS 中的一个 inode，包含两个主要部分: metadata 部分，和数据块寻址部分。我们重点观察数据块寻址部分，分析 inode 时如何将数据块索引出来。在图中，数据块寻址部分包含 direct pointers，single-indirect，double-indirect，以及 triple-indirect。它们的含义分别是：\n\n- **direct pointer:** inode 内直接指向数据块(图右上角 Data)的地址数组，即 **inode->data模式**。\n- **single-indirect pointer:** inode 记录了两个 single-indirect pointer(图右上角 Direct node)，每一个 single-indirect pointer 存储了多个数据块的地址，即 **inode->direct_node->data 模式**。\n- **double-indirect:** inode 记录了两个 double-indirect pointer(图右上角 indirect node)，每一个 double-indirect pointer 记录了许多 single-indirect pointer，每一个 single-indirect pointer 指向了数据块，即 **inode->indirect_node->direct_node->data 模式**。\n- **triple-indirect:** inode 记录了一个 triple-indirect pointer(图右上角 indirect node)，每一个 triple-indirect pointer 记录了许多 double-indirect pointer，每一个 double-indirect pointer 记录了许多 single-indirect pointer，最后每一个 single-indirect pointer 指向了数据块。即 **inode->indirect_node->indirect_node->direct_node->data 模式**。\n\n可以发现，F2FS 的 inode 结构采取 indirect_node，首先在 inode 内部寻找物理地址，如果找不到再去 direct_node 找，层层深入。\n\n## f2fs_node 结构及其作用\n\n对于一个较大的文件，它可能包含 inode 以外的 node，去保存一些间接寻址的信息。single-indirect pointer 记录的是数据块的地址，而 double-indirect pointer 记录的是 single-indirect pointer 的地址，triple-indirect pointer 记录的 double-indirect pointer 地址。在F2FS中：\n\n- inode 对应的是 `f2fs_inode` 结构，包含了多个 direct pointer 指向数据块物理地址；\n- single-indirect pointer 对应的是 `direct_node` 结构，包含了多个 direct pointer 指向物理地址；\n- double-indirect pointer 对应的是 `indirect_node` 结构，包含了多个指向 `direct_node` 的地址；\n- triple-indirect pointer 对应的也是 `indirect_node` 结构，包含了多个指向 `indirect_node` 的地址。\n\n### 基本 node 结构\n\n为了方便 F2FS 的对 node 的区分和管理，`f2fs_inode` 和 `direct_node` 以及 `indirect_node` 都使用了同一个数据结构 `f2fs_node` 进行描述，并通过 union 的方式，将 `f2fs_node` 初始化成不同的 node 形式。定义如下：\n\n```c\nstruct f2fs_node {\n\t/* can be one of three types: inode, direct, and indirect types */\n\tunion {\n\t\tstruct f2fs_inode i;\n\t\tstruct direct_node dn;\n\t\tstruct indirect_node in;\n\t};\n\tstruct node_footer footer;\n} __packed;\n\nstruct node_footer {\n\t__le32 nid;\t\t/* node id */\n\t__le32 ino;\t\t/* inode number */\n\t__le32 flag;\t\t/* include cold/fsync/dentry marks and offset */\n\t__le64 cp_ver;\t\t/* checkpoint version */\n\t__le32 next_blkaddr;\t/* next node page block address */\n} __packed;\n```\n\n其中起到区分是哪一种 node 的关键数据结构是 `node_footer`。如果 `node_footer` 的 `nid` 和 `ino` 相等，则表示这是一个 `f2fs_inode` 结构，如果不相等，则表示这是一个 `direct_node` 或者 `indirect_node`。\n\n### f2fs_inode 结构\n\n考虑 `f2fs_inode` 的结构，省略其他元数据的信息，重点关注文件如何索引的，结构如下：\n\n```c\nstruct f2fs_inode {\n\t...\n\t__le32 i_addr[DEF_ADDRS_PER_INODE]; // DEF_ADDRS_PER_INODE=923\n\t__le32 i_nid[DEF_NIDS_PER_INODE];\t// DEF_NIDS_PER_INODE=5\n\t...\n} __packed;\n```\n\n`i_addr` 数组就是前面提及的 direct pointer，数组的下标是文件的逻辑位置，数组的值就是 flash 设备的物理地址。例如文件的第一个页就对应 `i_addr[0]`，第二个页就对应 `i_addr[1]`，而 `i_addr[0]` 和 `i_addr[1]` 所记录的物理地址，就是文件第一个页(page)和第二个页的数据的物理地址，系统可以将两个物理地址提交到 flash 设备，将数据读取出来。\n\n我们可以发现 `i_addr` 的数组长度只有 923，即一个 `f2fs_inode` 只能直接索引到 923 个页/块的地址(约 3.6 MB)，对于大于 3.6 MB的文件，就需要使用**间接寻址**。`f2fs_inode` 的 `i_nid` 数组就是为了间接寻址而设计，`i_nid` 数组是一个长度为 5 的数组，可以记录 5 个 node 的地址。其中：\n\n- `i_nid[0]` 和 `i_nid[1]` 记录的是 `direct_node` 的地址，即对应前述的 single-indirect pointer。\n- `i_nid[2]` 和 `i_nid[3]` 记录的是 `indirect_node` 的地址，这两个 `indirect_node` 记录的是 `direct_node` 的地址，即对应前述的 double-indirect pointer。\n- `i_nid[4]` 记录的是 `indirect_node` 的地址，但是这个 `indirect_node` 记录的是 `indirect_node` 的地址，即前述的 triple-indirect pointer。\n\n### direct_node 和 indirect_node 结构\n\n`direct_node` 记录的是数据块的地址，`indirect_inode` 记录的是 node 的 id，系统可以通过 nid 找到对应的 node 的地址。\n\n```c\nstruct direct_node {\n\t__le32 addr[ADDRS_PER_BLOCK]; // ADDRS_PER_BLOCK=1018\n} __packed;\n\nstruct indirect_node {\n\t__le32 nid[NIDS_PER_BLOCK]; // NIDS_PER_BLOCK=1018\n} __packed;\n```\n\n### Wandering Tree 问题\n\nF2FS 的设计是为了解决 wandering tree 的问题，那么现在的设计是如何解决这个问题的呢。假设一个文件发生更改，修改了 `direct_node` 里面的某一个 block 的数据，根据 LFS 的异地更新特性，我们需要给更改后的数据一个新的 block。传统的 LFS 需要将这个新的 block 的地址一层层网上传递，直到 inode 结构。**而 F2FS 的设计是只需要将 `direct_node` 对应位置的 `addr` 的值更新为新 block 的地址，从而没必要往上传递，因此解决了 wandering tree 的问题。**\n\n## 普通文件数据的保存\n\n一个文件由一个 `f2fs_inode` 和多个 `direct_inode` 或者 `indirect_inode` 所组成。当系统创建一个文件的时候，它会首先创建一个 `f2fs_inode` 写入到 flash 设备，然后用户往该文件写入第一个 page 的时候，会将数据写入到 main area 的一个 block 中，然后将该 block 的物理地址赋值到 `f2fs_inode->i_addr[0]` 中，这样就完成了 Node-Data 的管理关系。随着对同一文件写入的数据的增多，会逐渐使用到其他类型的 node 去保存文件的数据。\n\n## 内联数据文件的保存\n\n文件的实际数据是保存在 `f2fs_inode->i_addr` 对应的物理块当中，因此即使一个很小的文件，如 1 个字节的小文件，也需要一个 node 和 data block 才能实现正常的保存和读写，也就是需要 8 KB 的磁盘空间去保存一个尺寸为 1 字节的小文件。而且 `f2fs_inode->i_addr[923]` 里面除了 `f2fs_inode->i_addr[0]` 保存了一个物理地址，其余的 922 个 i_addr 都被闲置，造成了空间的浪费。\n\nF2FS 为了减少空间的使用量，使用内联(inline)文件减少这些空间的浪费。它的核心思想是当文件足够小的时候，使用 `f2fs_inode->i_addr` 数组直接保存数据本身，而不单独写入一个 block 中，再进行寻址。因此，如上面的例子，只有 1 个字节大小的文件，只需要一个 `f2fs_inode` 结构，即 4 KB，就可以同时将 node 信息和 data 信息同时保存，减少了一半的空间使用量。\n\n根据上述定义，可以计算得到多大的文件可以使用内联的方式进行保存，`f2fs_inode` 有尺寸为 923 的用于保存数据物理地址的数组 i_addr，它的数据类型是 __le32，即 4 个字节。保留一个数组成员另做它用，因此内联文件最大尺寸为: 922 * 4 = 3688 字节。\n\n## 文件访问的实际例子\n\nLinux 的文件是通过 page 进行组织起来的，默认 page 的 size 是 4 KB，使用 index 作为编号。\n\n一个小文件访问例子：例如一个 size = 10 KB 的文件，需要 3 个 page 去保存数据，这 3 个 page 的编号是 0，1，2。当用户访问这个文件的第 2~6kb 的数据的时候，系统就会计算出数据保存在 page index = 0 和 1 的 page 中，然后根据文件的路径找到对应的 `f2fs_inode` 结构，page index = 0 和 1 即对应 `f2fs_inode` 的 `i_addr[0]` 和 `i_addr[1]`。系统进而从这两个 `i_addr` 读取物理地址，提交到 flash 设备将数据读取出来。\n\n一个大文件访问例子：假设用户需要读取文件第 4000 个页(page index = 3999)的数据，第一步: 那么首先系统会根据文件路径找到对应的 f2fs_inode 结构。第二步：由于 4000 >（923 + 1018 + 1018），`f2fs_inode->i_addr `和 `f2fs_inode->nid[0]和nid[1]` 都无法满足需求，因此系统根据 `f2fs_inode->nid[2]` 找到对应的 `indirect_node` 的地址。第三步：`indirect_node` 保存的是 `direct_node` 的nid数组，由于 4000 - 923 - 1018 - 1018 = 1041，而一个 `direct_node` 只能保存 1018 个 block，因此可以知道数据位于 `indirect_node->nid[1]` 对应的 `direct_node` 中。第四步：计算剩下的的偏移(4000-923-1018-1018-1018=23)找到数据的物理地址位于该 `direct_node` 的 `direct_node->addr[23]` 中。\n\n# 读流程\n\nF2FS 的读流程包含了以下几个子流程:\n1. vfs_read 函数。\n2. generic_file_read_iter 函数: 根据访问类型执行不同的处理。\n3. generic_file_buffered_read 函数: 根据用户传入的文件偏移，读取尺寸等信息，计算起始位置和页数，然后遍历每一个 page，通过预读或者单个读取的方式从磁盘中读取出来。\n4. f2fs_read_data_page&f2fs_read_data_pages 函数: 从磁盘读取 1 个 page 或者多个 page。\n5. f2fs_mpage_readpages 函数: f2fs 读取数据的主流程。\n\n第一步的 vfs_read 函数是 VFS 层面的流程，下面仅针对涉及 F2FS 的读流程，且经过简化的主要流程进行分析。\n\n## generic_file_read_iter 函数\n这个函数的作用是处理普通方式访问以及 direct 方式访问的读行为，这里仅针对普通方式的读访问进行分析:\n```c\nssize_t generic_file_read_iter(struct kiocb *iocb, struct iov_iter *iter)\n{\n\tsize_t count = iov_iter_count(iter); // 获取需要读取的字节数\n\tssize_t retval = 0;\n\n\tif (!count)\n\t\tgoto out;\n\n\tif (iocb->ki_flags & IOCB_DIRECT) { // 处理direct方式的访问，这里不做介绍\n\t\t...\n\t}\n\n\tretval = generic_file_buffered_read(iocb, iter, retval); // 进行普通的读访问\nout:\n\treturn retval;\n}\n```\n\n## generic_file_buffered_read 函数\n在介绍这两个之前，需要先介绍一种 VFS 提高读取速度的机制: 预读(readahead)机制。它的核心原理是，当用户访问 page 1，系统就会将 page 1 后续的 page 2，page 3，page 4 一起读取到 page cache(减少与磁盘这种速度慢设备的交互次数，提高读性能)。之后用户再连续读取 page 2，page 3，page 4 时，由于已经读取到内存中，因此可以快速地返回给用户。\n\ngeneric_file_buffered_read() 函数的主要作用是循环地从磁盘或者内存读取用户需要的 page，同时也会在某些情况调用 page_cache_sync_readahead() 函数进行预读，由于函数比较复杂，且很多 goto 语句，简化后的步骤如下：\n\n**情况 1：预读(readahead)机制成功预读到用户需要接下来访问的 page**\n\n1. ind_get_page: 系统无法在 cache 中找到用户需要的 page。\n2. page_cache_sync_readahead: 系统执行该函数进行预读，一次性读取多个 page。\n3. find_get_page: 再重新在 cache 获取一次 page，获取成功后跳转到 page ok 区域。\n4. page_ok: 复制 page 的数据去用户传入的 buffer 中，然后判读是否为最后一个 page，如果是则退出读流程。\n\n**情况 2：预读(readahead)机制错误预读到用户需要接下来访问的 page**\n\n1. find_get_page: 系统无法在 cache 中找到用户需要的 page。\n2. page_cache_sync_readahead: 系统执行该函数进行预读，一次性读取多个 page。\n3. find_get_page: 再重新在 cache 获取一次 page，获取失败，跳转到 no_cached_page 区域。\n4. no_cached_page: 创建一个 page cache 结构，加入到 LRU 后，跳转到 readpage 区域。\n5. readpage: 执行 `mapping->a_ops->readpage` 函数从磁盘读取数据，成功后跳转到 page ok 区域。\n6. page_ok: 复制 page 的数据去用户传入的 buffer 中，然后判读是否为最后一个 page，如果是则退出读流程。\n\n\n```c\nstatic ssize_t generic_file_buffered_read(struct kiocb *iocb,\n\t\tstruct iov_iter *iter, ssize_t written)\n{\n\n\tindex = *ppos >> PAGE_SHIFT; // 文件指针偏移*ppos除以page的大小就是页偏移index\n\tprev_index = ra->prev_pos >> PAGE_SHIFT;\n\tprev_offset = ra->prev_pos & (PAGE_SIZE-1);\n\tlast_index = (*ppos + iter->count + PAGE_SIZE-1) >> PAGE_SHIFT;\n\toffset = *ppos & ~PAGE_MASK;\n\n\tfor (;;) {\nfind_page:\n\t\tpage = find_get_page(mapping, index); // 根据页偏移index从cache获取page\n\t\tif (!page) { // 获取失败进行一次预读\n\t\t\tpage_cache_sync_readahead(mapping, ra, filp,\n\t\t\t\t\tindex, last_index - index);\n\t\t\tpage = find_get_page(mapping, index); // 预读后再从cache获取page\n\t\t\tif (unlikely(page == NULL)) // 如果仍然失败则跳转到no_cached_page，成功则直接去page ok区域\n\t\t\t\tgoto no_cached_page;\n\t\t}\npage_ok: \n\t\t// page数据读取成功后都进入这个区域，用于将数据复制到用户传入的buffer中\n\t\tisize = i_size_read(inode);\n\t\tend_index = (isize - 1) >> PAGE_SHIFT;\n\n\t\tnr = PAGE_SIZE;\n\t\tif (index == end_index) { // 如果到了最后一个index就退出循环\n\t\t\tnr = ((isize - 1) & ~PAGE_MASK) + 1;\n\t\t\tif (nr <= offset) {\n\t\t\t\tput_page(page);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tnr = nr - offset;\n\t\tret = copy_page_to_iter(page, offset, nr, iter); // 复制用户数据到buffer中\n\t\toffset += ret;\n\t\tindex += offset >> PAGE_SHIFT;\n\t\toffset &= ~PAGE_MASK;\n\t\tprev_offset = offset;\n\n\t\tput_page(page);\n\t\twritten += ret;\n\t\tif (!iov_iter_count(iter))  // 如果将所有数据读取完毕后退出循环\n\t\t\tgoto out;\n\t\tif (ret < nr) {\n\t\t\terror = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tcontinue;\nreadpage:\n\t\tClearPageError(page);\n\t\terror = mapping->a_ops->readpage(filp, page); // 去磁盘进行读取\n\t\tgoto page_ok;\nno_cached_page:\n\t\tpage = page_cache_alloc(mapping); // 创建page cache\n\t\terror = add_to_page_cache_lru(page, mapping, index,\n\t\t\t\tmapping_gfp_constraint(mapping, GFP_KERNEL)); // 加入lru\n\t\tgoto readpage;\n\t}\nout:\n\tra->prev_pos = prev_index;\n\tra->prev_pos <<= PAGE_SHIFT;\n\tra->prev_pos |= prev_offset;\n\n\t*ppos = ((loff_t)index << PAGE_SHIFT) + offset;\n\tfile_accessed(filp);\n\treturn written ? written : error;\n}\n```\n预读函数 page_cache_sync_readahead() 的分析由于篇幅有限无法全部展示，这里仅分析它的核心调用函数 __do_page_cache_readahead():\n```c\nunsigned int __do_page_cache_readahead(struct address_space *mapping,\n\t\tstruct file *filp, pgoff_t offset, unsigned long nr_to_read,\n\t\tunsigned long lookahead_size)\n{\n\tend_index = ((isize - 1) >> PAGE_SHIFT); // 得到文件的最后一个页的页偏移index\n\n\tfor (page_idx = 0; page_idx < nr_to_read; page_idx++) { // nr_to_read是需要预读的page的数目\n\t\tpgoff_t page_offset = offset + page_idx; // offset表示从第几个page开始预读\n\n\t\tif (page_offset > end_index) // 预读超过了文件大小就退出\n\t\t\tbreak;\n\t\t\t\n\t\tpage = __page_cache_alloc(gfp_mask); // 创建page cache\n\t\tpage->index = page_offset; // 设置page index\n\t\tlist_add(&page->lru, &page_pool); // 将所有预读的page加入到一个list中\n\t\tnr_pages++;\n\t}\n\n\tif (nr_pages)\n\t\tread_pages(mapping, filp, &page_pool, nr_pages, gfp_mask); // 执行预读\n\tBUG_ON(!list_empty(&page_pool));\nout:\n\treturn nr_pages;\n}\n\nstatic int read_pages(struct address_space *mapping, struct file *filp,\n\t\tstruct list_head *pages, unsigned int nr_pages, gfp_t gfp)\n{\n\tstruct blk_plug plug;\n\tunsigned page_idx;\n\tint ret;\n\n\tblk_start_plug(&plug);\n\n\tif (mapping->a_ops->readpages) {\n\t\tret = mapping->a_ops->readpages(filp, mapping, pages, nr_pages); // 执行readpages函数进行预读\n\t\tput_pages_list(pages);\n\t\tgoto out;\n\t}\n\tret = 0;\n\nout:\n\tblk_finish_plug(&plug);\n\n\treturn ret;\n}\n```\n\n## f2fs_read_data_page & f2fs_read_data_pages 函数\n当预读机制会调用 `mapping->a_ops->readpages` 函数一次性读取多个 page。而当预读失败时，也会调用 `mapping->a_ops->readpage` 读取单个 page。这两个函数在 f2fs 中对应的就是 `f2fs_read_page` 和 `f2fs_read_pages`，如下所示:\n```c\nstatic int f2fs_read_data_page(struct file *file, struct page *page)\n{\n\tstruct inode *inode = page->mapping->host;\n\tint ret = -EAGAIN;\n\n\ttrace_f2fs_readpage(page, DATA);\n\n\tif (f2fs_has_inline_data(inode)) // inline文件使用特定的读取方法，这里暂不分析\n\t\tret = f2fs_read_inline_data(inode, page);\n\tret = f2fs_mpage_readpages(page->mapping, NULL, page, 1); // 读取1个page\n\treturn ret;\n}\n\nstatic int f2fs_read_data_pages(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct page *page = list_last_entry(pages, struct page, lru);\n\n\ttrace_f2fs_readpages(inode, page, nr_pages);\n\n\tif (f2fs_has_inline_data(inode)) // inline文件是size小于1个page的文件，因此不需要进行预读，直接return 0\n\t\treturn 0;\n\n\treturn f2fs_mpage_readpages(mapping, pages, NULL, nr_pages); // 读取nr_pages个page\n}\n```\n\n## f2fs_mpage_readpages函数\n无论是 `f2fs_read_page` 函数还是 `f2fs_read_pages` 函数，都是调用 `f2fs_mpage_readpages` 函数进行读取，区别仅在于传入参数。`f2fs_mpage_readpages` 的定义为:\n```c\nstatic int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page, unsigned nr_pages);\n```\n1. 第二个参数表示一个链表头，这个链表保存了多个 page，因此需要写入多个 page 的时候，就要传入一个 List。\n2. 第三个参数表示单个 page，在写入单个 page 的时候，通过这个函数写入。\n3. 第四个参数表示需要写入 page 的数目。\n\n因此：\n\n1. 在写入多个 page 的时候，需要设定第二个参数，和第四个参数，然后设定第三个参数为 NULL。\n2. 在写入单个 page 的时候，需要设定第三个参数，和第四个参数，然后设定第二个参数为 NULL。\n\n然后分析这个函数的执行流程:\n\n1. 遍历传入的 page，得到每一个 page 的 index 以及 inode。\n2. 将 page 的 inode 以及 index 传入 f2fs_map_blocks() 函数获取到该 page 的物理地址。\n3. 将物理地址通过 submit_bio() 读取该 page 在磁盘中的数据。\n\n```c\nstatic int f2fs_mpage_readpages(struct address_space *mapping,\n\t\t\tstruct list_head *pages, struct page *page,\n\t\t\tunsigned nr_pages)\n{\n\t// 主流程第一步 初始化map结构，这个步骤非常重要，用于获取page在磁盘的物理地址\n\tstruct f2fs_map_blocks map;\n\tmap.m_pblk = 0;\n\tmap.m_lblk = 0;\n\tmap.m_len = 0;\n\tmap.m_flags = 0;\n\tmap.m_next_pgofs = NULL;\n\n\t// 主流程第二步 开始进行遍历，结束条件为 nr_pages 不为空\n\tfor (page_idx = 0; nr_pages; page_idx++, nr_pages--) {\n\n\t\t// 循环第一步，如果是读取多个page，则pages不为空，从list里面读取每一次的page结构\n\t\tif (pages) {\n\t\t\tpage = list_entry(pages->prev, struct page, lru);\n\t\t\tlist_del(&page->lru);\n\t\t\tif (add_to_page_cache_lru(page, mapping,\n\t\t\t\t\t\t  page->index, GFP_KERNEL))\n\t\t\t\tgoto next_page;\n\t\t}\n\n\t\t/**\n \t\t * map.m_lblk是上一个block_in_file\n \t\t * map.m_lblk + map.m_len是需要读取长度的最后一个blokaddr\n \t\t * 因此这里的意思是，如果是在这个 map.m_lblk < block_in_file < map.m_lblk + map.m_len \n \t\t * 这个范围里面，不需要map，直接将上次的blkaddr+1就是需要的地址\n \t\t * \n\t\t */\n\t\t// 循环第二步，如果上一次找到了page，则跳到 got_it 通过bio获取page的具体数据\n\t\tif ((map.m_flags & F2FS_MAP_MAPPED) && block_in_file > map.m_lblk &&\n\t\t\tblock_in_file < (map.m_lblk + map.m_len))\n\t\t\tgoto got_it;\n\t\n\t\t// 循环第三步，使用page offset和length，通过f2fs_map_blocks获得物理地址\n\t\tmap.m_flags = 0;\n\t\tif (block_in_file < last_block) {\n\t\t\tmap.m_lblk = block_in_file; // 文件的第几个block\n\t\t\tmap.m_len = last_block - block_in_file; // 读取的block的长度\n\n\t\t\tif (f2fs_map_blocks(inode, &map, 0,\n\t\t\t\t\t\tF2FS_GET_BLOCK_READ))\n\t\t\t\tgoto set_error_page;\n\t\t}\n\ngot_it:\n\t\t// 循环第四步，通过map的结果执行不一样的处理方式\n\t\tif ((map.m_flags & F2FS_MAP_MAPPED)) { // 如果找到了地址，则计算block_nr得到磁盘的地址\n\t\t\tblock_nr = map.m_pblk + block_in_file - map.m_lblk;\n\t\t\tSetPageMappedToDisk(page);\n\n\t\t\tif (!PageUptodate(page) && !cleancache_get_page(page)) {\n\t\t\t\tSetPageUptodate(page);\n\t\t\t\tgoto confused;\n\t\t\t}\n\t\t} else { // 获取失败了，则跳过这个page\n\t\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\t\tSetPageUptodate(page);\n\t\t\tunlock_page(page);\n\t\t\tgoto next_page;\n\t\t}\n\n\t\t/**\n\t\t * 这部分开始用于将物理地址通过submit_bio提交到磁盘读取数据\n\t\t * 由于从磁盘读取数据是一个相对耗时的操作，\n\t\t * 因此显然每读取一个页就访问一次磁盘一次的方式是低效的且影响读性能的，\n\t\t * 所以F2FS会尽量一次性提交多个页到磁盘读取数据，以提高性能。\n\t\t * \n\t\t * 这部分开始就是具体实现:\n\t\t * 1. 创建一个bio(最大一次性提交256个页)\n\t\t * 2. 将需要读取的页添加到这个bio中，\n\t\t *     ------如果bio未满则将page添加到bio中\n\t\t *     ------如果bio满了立即访问磁盘读取\n\t\t *     ------如果循环结束以后，bio还是未满，则通过本函数末尾的操作提交未满的bio。\n\t\t *     \n         */\n\n\t\t// 循环第五步，判断bio装的page是否到了设定的最大数量，如果到了最大值则先发送到磁盘\n\t\tif (bio && (last_block_in_bio != block_nr - 1)) {\nsubmit_and_realloc:\n\t\t\tsubmit_bio(READ, bio);\n\t\t\tbio = NULL;\n\t\t}\n\n\t\t// 循环第六步，如果bio是空，则创建一个bio，然后指定的f2fs_read_end_io进行读取\n\t\tif (bio == NULL) {\n\t\t\tstruct fscrypt_ctx *ctx = NULL;\n\n\t\t\tif (f2fs_encrypted_inode(inode) &&\n\t\t\t\t\tS_ISREG(inode->i_mode)) {\n\n\t\t\t\tctx = fscrypt_get_ctx(inode, GFP_NOFS);\n\t\t\t\tif (IS_ERR(ctx))\n\t\t\t\t\tgoto set_error_page;\n\n\t\t\t\t/* wait the page to be moved by cleaning */\n\t\t\t\tf2fs_wait_on_encrypted_page_writeback(\n\t\t\t\t\t\tF2FS_I_SB(inode), block_nr);\n\t\t\t}\n\n\t\t\tbio = bio_alloc(GFP_KERNEL,\n\t\t\t\tmin_t(int, nr_pages, BIO_MAX_PAGES)); // 创建bio\n\t\t\tif (!bio) {\n\t\t\t\tif (ctx)\n\t\t\t\t\tfscrypt_release_ctx(ctx);\n\t\t\t\tgoto set_error_page;\n\t\t\t}\n\t\t\tbio->bi_bdev = bdev;\n\t\t\tbio->bi_iter.bi_sector = SECTOR_FROM_BLOCK(block_nr); // 设定bio的sector地址\n\t\t\tbio->bi_end_io = f2fs_read_end_io;\n\t\t\tbio->bi_private = ctx;\n\t\t}\n\n\t\t// 循环第七步，将page加入到bio中，等待第五步满了之后发送到磁盘\n\t\tif (bio_add_page(bio, page, blocksize, 0) < blocksize)\n\t\t\tgoto submit_and_realloc;\n\nset_error_page:\n\t\tSetPageError(page);\n\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\tunlock_page(page);\n\t\tgoto next_page;\nconfused: // 特殊情况进行submit bio\n\t\tif (bio) {\n\t\t\tsubmit_bio(READ, bio);\n\t\t\tbio = NULL;\n\t\t}\n\t\tunlock_page(page);\nnext_page:\n\t\tif (pages)\n\t\t\tput_page(page);\n\t\t\n\t}\n\n\t\n\tBUG_ON(pages && !list_empty(pages));\n\n\t// 如果还有bio没有处理，例如读取的页遍历完以后，还没有达到第五步要求的bio的最大保存页数，就会在这里提交bio到磁盘读取\n\tif (bio)\n\t\tsubmit_bio(READ, bio);\n\treturn 0;\n}\n```\n\n# 写流程\n\nF2FS 的写流程主要包含了以下几个子流程:\n1. 调用 vfs_write 函数。\n2. 调用 f2fs_file_write_iter 函数: 初始化 f2fs_node 的信息。\n3. 调用 f2fs_write_begin 函数: 创建 page cache，并填充数据。\n4. 写入到 page cache: 等待系统触发 writeback 回写到磁盘。\n5. 调用 f2fs_write_end 函数: 将 page 设置为最新状态。\n6. 调用 f2fs_write_data_pages 函数: 系统 writeback 或者 fsync 触发的时候执行这个函数写入到磁盘。\n\n第一步的 vfs_write 函数是 VFS 层面的流程，下面仅针对涉及 F2FS 的写流程，且经过简化的主要流程进行分析。\n\n## f2fs_file_write_iter函数\n这个函数的主要作用是在数据写入文件之前进行预处理，核心流程就是将该文件对应 `f2fs_inode` 或者 `direct_node` 对应写入位置的 `i_addr` 或者 `addr `的值进行初始化。例如用户需要在第 4 个 page 的位置写入数据，那么 `f2fs_file_write_iter` 函数会首先找到该文件对应的 `f2fs_inode`，然后找到第 4 个 page 对应的数据块地址记录，即 `f2fs_inode->i_addr[3]`。如果该位置的值是 `NULL_ADDR` 则表示当前是**添加写(Append Write)**，因此将值初始化为 `NEW_ADDR`。如果是该位置的值是一个具体的 block 号，那么表示为**覆盖写(Overwrite)**，不需要做处理。\n```c\nstatic ssize_t f2fs_file_write_iter(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file_inode(file);\n\tssize_t ret;\n\n\t...\n\terr = f2fs_preallocate_blocks(iocb, from); // 进行预处理\n\t...\n\tret = __generic_file_write_iter(iocb, from); // 预处理完成后继续执行下一步写流程\n\t...\n\n\treturn ret;\n}\n```\n下面继续分析 f2fs_preallocate_blocks()。\n```c\nint f2fs_preallocate_blocks(struct kiocb *iocb, struct iov_iter *from)\n{\n\tstruct inode *inode = file_inode(iocb->ki_filp); // 获取inode\n\tstruct f2fs_map_blocks map;\n\n\tmap.m_lblk = F2FS_BLK_ALIGN(iocb->ki_pos); // 根据文件指针偏移计算需要从第几个block开始写入\n\tmap.m_len = F2FS_BYTES_TO_BLK(iocb->ki_pos + iov_iter_count(from)); // 计算要写入block的个数\n\n\t// 初始化一些信息\n\tmap.m_next_pgofs = NULL;\n\tmap.m_next_extent = NULL;\n\tmap.m_seg_type = NO_CHECK_TYPE;\n\n\tflag = F2FS_GET_BLOCK_PRE_AIO;\n\nmap_blocks:\n\terr = f2fs_map_blocks(inode, &map, 1, flag); // 进行初始化\n\treturn err;\n}\n```\nf2fs_map_blocks() 函数的作用非常广泛，主要作用是通过逻辑地址(文件偏移指针)找到对应的物理地址(block 号)。因此在读写流程中都有作用。在写流程中，该函数的主要作用是初始化地址信息。\n```c\nint f2fs_map_blocks(struct inode *inode, struct f2fs_map_blocks *map,\n\t\t\t\t\t\tint create, int flag)\n{\n\tunsigned int maxblocks = map->m_len;\n\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE;\n\n\tmap->m_len = 0;\n\tmap->m_flags = 0;\n\n\tpgofs =\t(pgoff_t)map->m_lblk; // 获得文件访问偏移量\n\tend = pgofs + maxblocks; // 获得需要读取的block的长度\n\nnext_dnode:\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0); // 初始化dnode，dnode的作用是根据逻辑地址找到物理地址\n\t\n\t// 根据inode找到对应的f2fs_inode或者direct_node结构，然后通过pgofs(文件页偏移)获得物理地址，记录在dn中\n\terr = f2fs_get_dnode_of_data(&dn, pgofs, mode); \n\n\tstart_pgofs = pgofs;\n\tprealloc = 0;\n\tlast_ofs_in_node = ofs_in_node = dn.ofs_in_node;\n\tend_offset = ADDRS_PER_PAGE(dn.node_page, inode);\n\nnext_block:\n\t// 根据dn获得物理地址，ofs_in_node表示这个物理地址位于当前node的第几个数据块\n\t// 如 f2fs_inode->i_addr[3]，那么dn.ofs_in_node=3\n\tblkaddr = datablock_addr(dn.inode, dn.node_page, dn.ofs_in_node); \n\t...\n\tif (!is_valid_blkaddr(blkaddr)) { // is_valid_blkaddr函数用于判断是否存在旧数据\n\t\t// 如果不存在旧数据\n\t\tif (create) {\n\t\t\tif (flag == F2FS_GET_BLOCK_PRE_AIO) {\n\t\t\t\tif (blkaddr == NULL_ADDR) {\n\t\t\t\t\tprealloc++; // 记录有多少个添加写的block\n\t\t\t\t\tlast_ofs_in_node = dn.ofs_in_node;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmap->m_flags |= F2FS_MAP_NEW; // F2FS_MAP_NEW表示正在处理一个从未使用的数据\n\t\t\tblkaddr = dn.data_blkaddr; // 记录当前的物理地址\n\t\t}\n\t}\n\t...\n\t// 记录处理了多少个block\n\tdn.ofs_in_node++; \n\tpgofs++;\n\t...\n\t// 这里表示已经处理到最后一个block了\n\tif (flag == F2FS_GET_BLOCK_PRE_AIO &&\n\t\t\t(pgofs == end || dn.ofs_in_node == end_offset)) {\n\n\t\tdn.ofs_in_node = ofs_in_node; // 回到第一个block\n\t\terr = f2fs_reserve_new_blocks(&dn, prealloc); // 通过这个函数将其地址设置为NEW_ADDR\n\t\tmap->m_len += dn.ofs_in_node - ofs_in_node;\n\t\tdn.ofs_in_node = end_offset;\n\t}\n\t...\n\tif (pgofs >= end)\n\t\tgoto sync_out; // 表示已经全部处理完，可以退出这个函数了\n\telse if (dn.ofs_in_node < end_offset)\n\t\tgoto next_block; // 每执行上面的流程就处理一个block，如果没有处理所有用户写入的block，那么回去继续处理\n\t...\nsync_out:\n\t...\nout:\n\treturn err;\n}\n```\n然后分析 f2fs_reserve_new_blocks()。\n```c\nint f2fs_reserve_new_blocks(struct dnode_of_data *dn, blkcnt_t count)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tint err;\n\n\t...\n\tfor (; count > 0; dn->ofs_in_node++) {\n\t\tblock_t blkaddr = datablock_addr(dn->inode,\n\t\t\t\t\tdn->node_page, dn->ofs_in_node);\n\t\tif (blkaddr == NULL_ADDR) { // 首先判断是不是NULL_ADDR，如果是则初始化为NEW_ADDR\n\t\t\tdn->data_blkaddr = NEW_ADDR;\n\t\t\t__set_data_blkaddr(dn);\n\t\t\tcount--;\n\t\t}\n\t}\n\t...\n\n\treturn 0;\n}\n```\n## f2fs_write_begin 和 f2fs_write_end 函数\nVFS 中 `write_begin` 和 `write_end` 函数分别是数据写入 page cache 前以及写入后的处理。写入 page cache 后，系统会维护一段时间，直到满足一定条件后(如 fsync 和 writeback 会写)，VFS 会调用 writepages 函数，将这些缓存在内存中的 page 一次性写入到磁盘中。`write_begin` 和 `write_end` 函数的调用可以参考 VFS 的 `generic_perform_write` 函数。\n```c\nssize_t generic_perform_write(struct file *file,\n\t\t\t\tstruct iov_iter *i, loff_t pos)\n{\n\tstruct address_space *mapping = file->f_mapping;\n\tconst struct address_space_operations *a_ops = mapping->a_ops;\n\tlong status = 0;\n\tssize_t written = 0;\n\tunsigned int flags = 0;\n\n\tdo {\n\t\tstruct page *page;\n\t\tunsigned long offset;\n\t\tunsigned long bytes;\n\t\tsize_t copied;\n\t\tvoid *fsdata;\n\n\t\toffset = (pos & (PAGE_SIZE - 1)); // 计算文件偏移，按page计算\n\t\tbytes = min_t(unsigned long, PAGE_SIZE - offset, iov_iter_count(i)); // 计算需要写多少个字节\nagain:\n\t\tstatus = a_ops->write_begin(file, mapping, pos, bytes, flags, &page, &fsdata); // 调用write_begin，对page进行初始化\n\n\t\tcopied = iov_iter_copy_from_user_atomic(page, i, offset, bytes); //  将处理后的数据拷贝到page当中\n\t\tflush_dcache_page(page); // 将包含用户数据的page加入到page cache中，等待系统触发writeback的时候回写\n\n\t\tstatus = a_ops->write_end(file, mapping, pos, bytes, copied, page, fsdata); // 调用write_end函数进行后续处理\n\t\t\n\t\tcopied = status;\n\n\t\tiov_iter_advance(i, copied);\n\n\t\tpos += copied;\n\t\twritten += copied;\n\n\t\tbalance_dirty_pages_ratelimited(mapping);\n\t} while (iov_iter_count(i)); // 直到处理完所有的数据\n\n\treturn written ? written : status;\n}\n```\n然后分析 VFS 的 `write_begin` 和 `write_end` 对应的功能，`write_begin` 在 F2FS 中对应的是 `f2fs_write_begin`，它的作用是将根据用户需要写入的数据类型，对 page 进行初始化，如下所示：\n```c\nstatic int f2fs_write_begin(struct file *file, struct address_space *mapping,\n\t\tloff_t pos, unsigned len, unsigned flags,\n\t\tstruct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct page *page = NULL;\n\tpgoff_t index = ((unsigned long long) pos) >> PAGE_SHIFT;\n\tbool need_balance = false, drop_atomic = false;\n\tblock_t blkaddr = NULL_ADDR;\n\tint err = 0;\n\nrepeat:\n\tpage = f2fs_pagecache_get_page(mapping, index,\n\t\t\t\tFGP_LOCK | FGP_WRITE | FGP_CREAT, GFP_NOFS); // 第一步创建或者获取page cache\n\n\t*pagep = page;\n\n\terr = prepare_write_begin(sbi, page, pos, len,\n\t\t\t\t\t&blkaddr, &need_balance); // 第二步根据页偏移信息获取到对应的物理地址blkaddr\n\n\t// 第三步，根据写类型对新创建的page进行初始化处理\n\tif (blkaddr == NEW_ADDR) { //如果是添加写，则将该page直接使用0填充\n\t\tzero_user_segment(page, 0, PAGE_SIZE);\n\t\tSetPageUptodate(page);\n\t} else {  //如果是覆盖写，则将该page直接使用0填充\n\t\terr = f2fs_submit_page_read(inode, page, blkaddr); // 从磁盘中将旧数据读取出来\n\n\t\tlock_page(page);\n\t\tif (unlikely(page->mapping != mapping)) {\n\t\t\tf2fs_put_page(page, 1);\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (unlikely(!PageUptodate(page))) {\n\t\t\terr = -EIO;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\treturn 0;\n}\n```\n通过 flush_dcache_page() 函数将用户数据写入到 page cache 之后，进行 `write_end` 处理，在 F2FS 中它对应的是 f2fs_write_end() 函数，它的作用是，如下所述:\n```c\nstatic int f2fs_write_end(struct file *file,\n\t\t\tstruct address_space *mapping,\n\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\tstruct page *page, void *fsdata)\n{\n\tstruct inode *inode = page->mapping->host;\n\n\tif (!PageUptodate(page)) { // 判断是否已经将page cache在写入是否到达了最新的状态\n\t\tif (unlikely(copied != len))\n\t\t\tcopied = 0;\n\t\telse\n\t\t\tSetPageUptodate(page); // 如果不是就处理后设置为最新\n\t}\n\tif (!copied)\n\t\tgoto unlock_out;\n\n\tset_page_dirty(page); // 将page设置为dirty，就会加入到inode->mapping的radix tree中，等待系统回写\n\n\tif (pos + copied > i_size_read(inode))\n\t\tf2fs_i_size_write(inode, pos + copied); // 更新文件尺寸\nunlock_out:\n\tf2fs_put_page(page, 1);\n\tf2fs_update_time(F2FS_I_SB(inode), REQ_TIME); // 更新文件修改日期\n\treturn copied;\n}\n```\n\n## f2fs_write_data_pages 函数\n系统会将用户写入的数据先写入到 page cache，然后等待时机回写到磁盘中。page cache 的回写是通过 f2fs_write_data_pages() 函数进行。系统会将 page cache 中 dirty 的 pages 加入到一个 list 当中，然后传入到 f2fs_write_data_pages() 进行处理。它包含如下步骤:\n1. f2fs_write_data_pages & __f2fs_write_data_pages 函数: 做一些不那么重要的预处理。\n2. f2fs_write_cache_pages 函数: 从 inode->mapping 的 radix tree 中取出 page。\n3. __write_data_page 函数: 判断文件类型(内联文件，目录文件，普通文件)进行不同的写入。\n4. f2fs_do_write_data_page: 根据 F2FS 的状态选择进行就地回写(在原物理地址更新)还是异地回写(在其他物理地址更新)。\n5. f2fs_outplace_write_data: 执行回写，更新 f2fs_inode 的状态。\n6. do_write_page: 从 CURSEG 分配物理地址，然后写入到磁盘。\n\n### f2fs_write_data_pages & __f2fs_write_data_pages 函数\n这两个函数只是包含了一些不太重要的预处理。\n```c\nstatic int f2fs_write_data_pages(struct address_space *mapping,\n\t\t\t    struct writeback_control *wbc)\n{\n\tstruct inode *inode = mapping->host;\n\n\treturn __f2fs_write_data_pages(mapping, wbc,\n\t\t\tF2FS_I(inode)->cp_task == current ?\n\t\t\tFS_CP_DATA_IO : FS_DATA_IO); // 这个函数可以知道当前是普通的写入，还是Checkpoint数据的写入\n}\n\nstatic int __f2fs_write_data_pages(struct address_space *mapping,\n\t\t\t\t\t\tstruct writeback_control *wbc,\n\t\t\t\t\t\tenum iostat_type io_type)\n{\n\tstruct inode *inode = mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tstruct blk_plug plug;\n\tint ret;\n\n\n\tblk_start_plug(&plug);\n\n\tret = f2fs_write_cache_pages(mapping, wbc, io_type); // 取出需要回写的page，然后写入\n\n\tblk_finish_plug(&plug);\n\n\tf2fs_remove_dirty_inode(inode); // 写入后将inode从dirty标志清除，即不需要再回写\n\treturn ret;\nskip_write:\n\twbc->pages_skipped += get_dirty_pages(inode);\n\ttrace_f2fs_writepages(mapping->host, wbc, DATA);\n\treturn 0;\n}\n```\n\n### f2fs_write_cache_pages 函数\n这个函数的主要作用是从 inode 对应的 mapping(radix tree 的 root)中，取出所有需要回写的 page，然后通过一个循环，逐个写入到磁盘。\n```c\nstatic int f2fs_write_cache_pages(struct address_space *mapping,\n\t\t\t\t\tstruct writeback_control *wbc,\n\t\t\t\t\tenum iostat_type io_type)\n{\n\tstruct pagevec pvec;\n\t\n\tpagevec_init(&pvec); // 这是一个用于装载page的数组，数组大小是15个page\n\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE; // tag是mapping给每一个pae的标志，用于标志这些page的属性\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\t\t\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, index, end); // SYNC模式下，将所有的tag=PAGECACHE_TAG_DIRTY的page重新标志为PAGECACHE_TAG_TOWRITE，作用是SYNC模式下必须全部回写到磁盘\n\tdone_index = index;\n\t\n\twhile (!done && (index <= end)) {\n\t\tint i;\n\t\t\n\t\t// 从mapping中取出tag类型的15个page，装载到pvec中\n\t\tnr_pages = pagevec_lookup_range_tag(&pvec, mapping, &index, end, tag); \n\t\t\n\t\t// 循环将pvec中的page取出，回写到磁盘\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tbool submitted = false;\n\t\t\t\n\t\t\tret = __write_data_page(page, &submitted, wbc, io_type); // 写入磁盘的核心函数\n\n\t\t\tif (--wbc->nr_to_write <= 0 &&\n\t\t\t\t\twbc->sync_mode == WB_SYNC_NONE) {\n\t\t\t\tdone = 1; // 如果本次writeback的所有page写完就退出\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tpagevec_release(&pvec); // 释放掉pvec\n\t\tcond_resched();\n\t}\n\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\tmapping->writeback_index = done_index;\n\n\tif (last_idx != ULONG_MAX)\n\t\t// page通过一些函数后，会放入到bio中，然后提交到磁盘。\n\t\t// f2fs的机制是不会马上提交bio，需要等到bio包含了一定数目的page之后才会提交\n\t\t// 因此这个函数作用是，即使数目不够，但是仍要强制提交bio，需要与磁盘同步\n\t\tf2fs_submit_merged_write_cond(F2FS_M_SB(mapping), mapping->host,\n\t\t\t\t\t\t0, last_idx, DATA);\n\n\treturn ret;\n}\n```\n\n### __write_data_page 函数\n这个函数的作用是判断文件类型(目录文件，内联文件，普通文件)进行不同的写入。F2FS 针对普通文件，有两种保存方式，分别是内联方式(inline)和普通方式。这里主要介绍普通文件的写流程。\n```c\nstatic int __write_data_page(struct page *page, bool *submitted,\n\t\t\t\tstruct writeback_control *wbc,\n\t\t\t\tenum iostat_type io_type)\n{\n\tstruct inode *inode = page->mapping->host;\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n\tloff_t i_size = i_size_read(inode);\n\tconst pgoff_t end_index = ((unsigned long long) i_size) >> PAGE_SHIFT;\n\t// 这个数据结构在整个写流程非常重要，记录了写入的信息\n\t// 关键变量是 fio->old_blkaddr 以及 fio->new_blkaddr记录旧地址和新地址\n\tstruct f2fs_io_info fio = { \n\t\t.sbi = sbi,\n\t\t.ino = inode->i_ino,\n\t\t.type = DATA,\n\t\t.op = REQ_OP_WRITE,\n\t\t.op_flags = wbc_to_write_flags(wbc),\n\t\t.old_blkaddr = NULL_ADDR,\n\t\t.page = page, // 即将写入的page\n\t\t.encrypted_page = NULL,\n\t\t.submitted = false,\n\t\t.need_lock = LOCK_RETRY,\n\t\t.io_type = io_type,\n\t\t.io_wbc = wbc,\n\t};\n\n\tif (page->index < end_index)\n\t\tgoto write;\n\t\t\nwrite:\n\tif (S_ISDIR(inode->i_mode)) { // 如果是目录文件，直接写入不需要修改\n\t\terr = f2fs_do_write_data_page(&fio);\n\t\tgoto done;\n\t}\n\n\terr = -EAGAIN;\n\tif (f2fs_has_inline_data(inode)) { // 内联文件使用内联的写入方式\n\t\terr = f2fs_write_inline_data(inode, page);\n\t\tif (!err)\n\t\t\tgoto out;\n\t}\n\n\tif (err == -EAGAIN) { // 普通文件则使用普通的方式\n\t\terr = f2fs_do_write_data_page(&fio);\n\t}\n\ndone:\n\tif (err && err != -ENOENT)\n\t\tgoto redirty_out;\n\nout:\n\tinode_dec_dirty_pages(inode); // 每写入一个page，就清除了inode一个dirty pages，因此数目减去1\n\tif (err)\n\t\tClearPageUptodate(page);\n\n\tunlock_page(page);\n\n\tif (submitted)\n\t\t*submitted = fio.submitted;\n\n\treturn 0;\n\nredirty_out:\n\tredirty_page_for_writepage(wbc, page);\n\tif (!err || wbc->for_reclaim)\n\t\treturn AOP_WRITEPAGE_ACTIVATE;\n\tunlock_page(page);\n\treturn err;\n}\n```\n### f2fs_do_write_data_page 函数\n这个函数的作用是根据系统的状态选择就地更新数据(inplace update)还是异地更新数据(outplace update)。一般情况下，系统只会在磁盘空间比较满的时候选择就地更新策略，避免触发过多的 gc 影响性能。因此，这里主要介绍异地更新的写流程:\n```c\nint f2fs_do_write_data_page(struct f2fs_io_info *fio) // 前面提到fio是写流程最重要的数据结构\n{\n\tstruct page *page = fio->page;\n\tstruct inode *inode = page->mapping->host;\n\tstruct dnode_of_data dn;\n\tstruct extent_info ei = {0,0,0};\n\tbool ipu_force = false;\n\tint err = 0;\n\n\tset_new_dnode(&dn, inode, NULL, NULL, 0); // 初始化dnode\n\terr = f2fs_get_dnode_of_data(&dn, page->index, LOOKUP_NODE); // 根据文件偏移page->index获取物理地址\n\n\tfio->old_blkaddr = dn.data_blkaddr; // 将旧的物理地址赋值给fio->old_blkaddr\n\n\tif (fio->old_blkaddr == NULL_ADDR) { // 前面提及到f2fs_file_write_iter已经将物理地址设置为NEW_ADDR或者具体的block号，因此这里表示在写入磁盘之前，用户又将这部分数据删除了，所以没必要写入了\n\t\tClearPageUptodate(page);\n\t\tgoto out_writepage;\n\t}\ngot_it:\n\tif (ipu_force || (is_valid_blkaddr(fio->old_blkaddr) &&\n\t\t\t\t\tneed_inplace_update(fio))) { // 判断是否需要就地更新\n\t\terr = encrypt_one_page(fio);\n\t\tif (err)\n\t\t\tgoto out_writepage;\n\n\t\tset_page_writeback(page);\n\t\tClearPageError(page);\n\t\tf2fs_put_dnode(&dn);\n\t\tif (fio->need_lock == LOCK_REQ)\n\t\t\tf2fs_unlock_op(fio->sbi);\n\t\terr = f2fs_inplace_write_data(fio); // 使用就地更新的方式写入\n\t\ttrace_f2fs_do_write_data_page(fio->page, IPU);\n\t\tset_inode_flag(inode, FI_UPDATE_WRITE);\n\t\treturn err;\n\t}\n\n\terr = encrypt_one_page(fio); // 如果开启系统加密，会将这个fio->page先加密\n\n\tset_page_writeback(page);\n\tClearPageError(page);\n\n\tf2fs_outplace_write_data(&dn, fio); // 执行异地更新函数\n\n\tset_inode_flag(inode, FI_APPEND_WRITE);\n\tif (page->index == 0)\n\t\tset_inode_flag(inode, FI_FIRST_BLOCK_WRITTEN);\nout_writepage:\n\tf2fs_put_dnode(&dn);\nout:\n\tif (fio->need_lock == LOCK_REQ)\n\t\tf2fs_unlock_op(fio->sbi);\n\treturn err;\n}\n```\n\n### f2fs_outplace_write_data 函数\n这个函数主要用作异地更新，所谓异地更新即不在原先的物理地址更新数据，因此包含了如下四个步骤:\n1. 分配一个新的物理地址。\n2. 将数据写入新的物理地址。\n3. 将旧的物理地址无效掉，然后等 GC 回收。\n4. 更新逻辑地址和物理地址的映射关系。\n\n本函数即完成以上四个步骤:\n```c\nvoid f2fs_outplace_write_data(struct dnode_of_data *dn,\n\t\t\t\t\tstruct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\tstruct f2fs_summary sum;\n\tstruct node_info ni;\n\n\tf2fs_get_node_info(sbi, dn->nid, &ni);\n\tset_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n\t\n\tdo_write_page(&sum, fio); // 这里完成第1,2,3步骤\n\tf2fs_update_data_blkaddr(dn, fio->new_blkaddr); // 这里完成第四个步骤，重新建立映射\n}\n```\n`struct dnode_of_data dn` 的作用是根据文件 inode，找到 `f2fs_inode` 或者 `direct_node`，然后再通过文件偏移得到物理地址，因此 f2fs_update_data_blkaddr() 也是通过 `dnode_of_data` 将新的物理地址更新到 `f2fs_inode` 或者 `direct_node` 对应的位置中。\n\n```c\nvoid f2fs_update_data_blkaddr(struct dnode_of_data *dn, block_t blkaddr)\n{\n\tdn->data_blkaddr = blkaddr; // 获得新的物理地址\n\tf2fs_set_data_blkaddr(dn); // 更新地址到f2fs_inode或者direct_node\n\tf2fs_update_extent_cache(dn); // 更新cache\n}\n\nvoid f2fs_set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tf2fs_wait_on_page_writeback(dn->node_page, NODE, true); // 因为要更新node，所以要保证当前的node是最新状态\n\t__set_data_blkaddr(dn);\n\tif (set_page_dirty(dn->node_page)) // 设置dirty，因为更新后的地址要回写到磁盘记录\n\t\tdn->node_changed = true;\n}\n\nstatic void __set_data_blkaddr(struct dnode_of_data *dn)\n{\n\tstruct f2fs_node *rn = F2FS_NODE(dn->node_page); // 根据node page转换到对应的f2fs_node\n\t__le32 *addr_array;\n\tint base = 0;\n\n\taddr_array = blkaddr_in_node(rn); // 这个用于获得f2fs_inode->i_addr地址或者direct_node->addr地址\n\taddr_array[base + dn->ofs_in_node] = cpu_to_le32(dn->data_blkaddr); // 根据偏移赋值更新\n}\n\nstatic inline __le32 *blkaddr_in_node(struct f2fs_node *node)\n{\n\t// RAW_IS_INODE判断当前node是属于f2fs_inode还是f2fs_node，然后返回物理地址数组指针\n\treturn RAW_IS_INODE(node) ? node->i.i_addr : node->dn.addr;\n}\n```\n\n### do_write_page 函数\n上一节提及到异地更新的 1,2,3 步骤都是在这里完成，分别是 f2fs_allocate_data_block() 函数完成新物理地址的分配，以及旧物理地址的回收; f2fs_submit_page_write() 函数完成最后一步，将数据提交到磁盘。下面进行分析:\n\n```c\nstatic void do_write_page(struct f2fs_summary *sum, struct f2fs_io_info *fio)\n{\n\tint type = __get_segment_type(fio); // 获取数据类型，这个类型指HOT/WARM/COLD X NODE/DATA的六种类型\n\n\tf2fs_allocate_data_block(fio->sbi, fio->page, fio->old_blkaddr,\n\t\t\t&fio->new_blkaddr, sum, type, fio, true); // 完成异地更新的1,2步\n\n\tf2fs_submit_page_write(fio); //完成异地更新的第3步\n\n}\n```\nf2fs_allocate_data_block() 函数首先会根据 type 获得 CURSEG。然后在 CURSEG 分配一个新的物理块，然后将旧的物理块无效掉。\n```c\nvoid f2fs_allocate_data_block(struct f2fs_sb_info *sbi, struct page *page,\n\t\tblock_t old_blkaddr, block_t *new_blkaddr,\n\t\tstruct f2fs_summary *sum, int type,\n\t\tstruct f2fs_io_info *fio, bool add_list)\n{\n\tstruct sit_info *sit_i = SIT_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, type);\n\n\t*new_blkaddr = NEXT_FREE_BLKADDR(sbi, curseg); // 获取新的物理地址\n\n\t__add_sum_entry(sbi, type, sum); // 将当前summary更新到CURSEG中\n\n\t__refresh_next_blkoff(sbi, curseg); // 更新下一次可以用的物理地址\n\n\t// 下面更新主要是更新SIT区域的segment信息\n\t\n\t// 根据new_blkaddr找到对应的sit_entry，然后更新状态为valid(值为1)，表示被用户使用，不可被其他人所使用\n\tupdate_sit_entry(sbi, *new_blkaddr, 1);\n\t\n\t// 根据old_blkaddr找到对应的sit_entry，然后更新状态为invalid(值为-1)，表示被覆盖了，等待GC回收后重新投入使用\n\tif (GET_SEGNO(sbi, old_blkaddr) != NULL_SEGNO)\n\t\tupdate_sit_entry(sbi, old_blkaddr, -1);\n\n\t// 如果当前segment没有空间进行下一次分配了，就分配一个新的segment给CURSEG\n\tif (!__has_curseg_space(sbi, type))\n\t\tsit_i->s_ops->allocate_segment(sbi, type, false);\n\n\t// 将segment设置为脏，等CP写回磁盘\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, old_blkaddr));\n\tlocate_dirty_segment(sbi, GET_SEGNO(sbi, *new_blkaddr));\n\n}\n```\nf2fs_submit_page_write() 完成最后的提交到磁盘的任务，先创建一个 bio，然后将 page 加入到 bio 中，如果 bio 满了就提交到磁盘。\n```c\nvoid f2fs_submit_page_write(struct f2fs_io_info *fio)\n{\n\tstruct f2fs_sb_info *sbi = fio->sbi;\n\tenum page_type btype = PAGE_TYPE_OF_BIO(fio->type);\n\tstruct f2fs_bio_info *io = sbi->write_io[btype] + fio->temp; // 这个是F2FS用于临时存放bio的变量\n\tstruct page *bio_page;\n\n\tdown_write(&io->io_rwsem);\nnext:\n\t// 第一步根据是否有加密，将bio_page设置为对应的page\n\tif (fio->encrypted_page)\n\t\tbio_page = fio->encrypted_page;\n\telse\n\t\tbio_page = fio->page;\n\n\tfio->submitted = true;\n\nalloc_new:\n\t// 如果bio是null，就创建一个新的bio\n\tif (io->bio == NULL) {\n\t\tio->bio = __bio_alloc(sbi, fio->new_blkaddr, fio->io_wbc,\n\t\t\t\t\t\tBIO_MAX_PAGES, false,\n\t\t\t\t\t\tfio->type, fio->temp); // BIO_MAX_PAGES一般等于256\n\t\tio->fio = *fio;\n\t}\n\n\t// 将page加入到bio中，如果  < PAGE_SIZE 表示bio已经满了，因此就先将这个bio提交，然后重新分配一个新的bio\n\tif (bio_add_page(io->bio, bio_page, PAGE_SIZE, 0) < PAGE_SIZE) {\n\t\t__submit_merged_bio(io); // 提交bio，最终会执行submit_bio函数\n\t\tgoto alloc_new;\n\t}\nout:\n\tup_write(&io->io_rwsem);\n}\n```\n需要注意的是，在这个函数，当 bio 还没有填满 page 的时候是不会被提交到磁盘的，这是因为 F2FS 通过增大 bio 的 size 提高了写性能。因此，在用户 fsync 或者系统 writeback 的时候，为了保证这些 page 都可以刷写到磁盘，会如 f2fs_write_cache_pages() 函数所介绍一样，通过 f2fs_submit_merged_write_cond() 函数或者其他函数强行提交这个 page 未满的 bio。\n\n# 文件创建流程\n\nlinux 的文件的创建可以抽象为两个流程。\n\n1. 创建一个 inode，使得包含文件的元数据信息;\n2. 将这个新创建的 inode 加入父目录的管理当中，可以理解建立父目录与这个新 inode 的关系。\n\n到具体代码，上述两个抽象流程在 F2FS 中主要包含了以下几个子流程：\n\n1. 调用 vfs_open 函数。\n2. 调用 f2fs_create 函数: 创建文件 inode，并链接到父目录。\n   - f2fs_new_inode 函数创建 inode。\n   - f2fs_add_link 函数链接到父目录。\n\n第一步的 vfs_open 函数是 VFS 层面的流程，下面仅针对涉及 F2FS 的文件创建流程，且经过简化的主要流程进行分析。\n\n## inode 和 f2fs_inode_info\n\n`inode` 结构是 linux 的 vfs 层最核心的结构之一，反应了文件的应该具有的基础信息，但是对于一些文件系统，原生的 `inode` 结构的信息并不够，还需要增加一些额外的变量去支持文件系统的某些功能，同时为了保证 vfs 层对所有文件系统的兼容性，我们直接修改 `inode` 结构不是一个明智的方法。针对这种场景，f2fs 使用了一种叫 `f2fs_inode_info` 的结构去扩展原有的 `inode` 的功能。\n\n### 相互转换\n\n从 `inode` 到 `f2fs_inode_info`:\n\n```c\nstatic inline struct f2fs_inode_info *F2FS_I(struct inode *inode)\n{\n\treturn container_of(inode, struct f2fs_inode_info, vfs_inode);\n}\n```\n\n从 `f2fs_inode_info` 到 `inode`:\n\n```c\n// vfs的inode其实是f2fs_inode_info结构体的一个内部变量\nstruct f2fs_inode_info {\n\tstruct inode vfs_inode;\t\t/* serve a vfs inode */\n\t...\n};\n\n// 因此访问可以直接指向\nstruct f2fs_inode_info *fi = F2FS_I(inode);\nfi->vfs_inode // 这里 fi->vfs_inode == inode\n```\n\n从上面代码我们可以看出，f2fs 中的 `inode` 是 `f2fs_inode_info` 当中的一个内部变量，因此可以用 container_of 这个函数直接获得，也可以通过指针获得。\n\n### VFS inode 的创建和销毁\n\n我们一般使用 VFS 提供的 `new_inode` 函数创建一个新 inode。这个 `new_inode` 函数内部会调用 new_inode_pseudo 函数，然后再调用 alloc_inode 函数，最后调用 `f2fs_alloc_inode` 函数，我们从这里开始分析:\n\n如下代码，显然就是通过内存分配函数先创建一个 `f2fs_inode_info` 然后返回给上层：\n\n```c\nstatic struct inode *f2fs_alloc_inode(struct super_block *sb)\n{\n\tstruct f2fs_inode_info *fi;\n\n\tfi = kmem_cache_alloc(f2fs_inode_cachep, GFP_F2FS_ZERO); //简单直接创建f2fs_inode_info\n\tif (!fi)\n\t\treturn NULL;\n\n\tinit_once((void *) fi); // 这个函数初始化vfs inode部分的原始信息\n\n    // 下面开始初始化f2fs_inode_info部分的原始信息\n\tatomic_set(&fi->dirty_pages, 0);\n\tinit_rwsem(&fi->i_sem);\n\t...\n\treturn &fi->vfs_inode; // 返回的vfs_inode给上层\n}\n```\n\n当 vfs inode 的 link 是 0 的时候，它应当被销毁。由于 vfs inode 是 f2fs_inode_info 的内部变量：\n\n```c\n// 用户传入一个inode销毁\nstatic void f2fs_destroy_inode(struct inode *inode)\n{\n\tcall_rcu(&inode->i_rcu, f2fs_i_callback);\n}\n\n```\n\n同样简单直接，free 掉这块内存就行。\n\n```c\nstatic void f2fs_i_callback(struct rcu_head *head)\n{\n\tstruct inode *inode = container_of(head, struct inode, i_rcu);\n\tkmem_cache_free(f2fs_inode_cachep, F2FS_I(inode));\n}\n```\n\n## f2fs_create 函数\n这个函数的主要作用是创建 vfs_inode，并链接到对应的目录下，核心流程就是先创建该文件的基于 f2fs 的 inode 结构，以及对应的 f2fs 的 inode page，即 `f2fs_inode`。然后设置函数指针，最后将 f2fs 的 inode page 链接到对应的目录下。\n```c\nstatic int f2fs_create(struct inode *dir, struct dentry *dentry, umode_t mode,\n\t\t\t\t\t\tbool excl)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tstruct inode *inode;\n\tnid_t ino = 0;\n\tint err;\n\n\tinode = f2fs_new_inode(dir, mode); // 创建f2fs特定的inode结构\n\n\tinode->i_op = &f2fs_file_inode_operations; // 然后赋值对应的函数指针\n\tinode->i_fop = &f2fs_file_operations;\n\tinode->i_mapping->a_ops = &f2fs_dblock_aops;\n\tino = inode->i_ino; // 记录该inode的ino\n\n\terr = f2fs_add_link(dentry, inode); // 将该inode链接到用户传入的父目录dir中\n\tif (err)\n\t\tgoto out;\n\n\tf2fs_alloc_nid_done(sbi, ino); // 在f2fs_new_inode函数内分配了ino，在这里完成最后一步\n\n\treturn 0;\n}\n\n```\n### f2fs_new_inode 函数\n\n下面继续分析 `f2fs_new_inode` 函数(只显示主干部分)，这个函数创建 inode 结构，**还没**创建对应的 f2fs inode page。\n\n```c\nstatic struct inode *f2fs_new_inode(struct inode *dir, umode_t mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dir);\n\tnid_t ino;\n\tstruct inode *inode;\n\tbool nid_free = false;\n\tint xattr_size = 0;\n\tint err;\n\n\tinode = new_inode(dir->i_sb); // 先创建出来一个没有ino的inode结构，参考前面提及的创建流程\n\n\tif (!f2fs_alloc_nid(sbi, &ino)) { // 然后给这个inode分配一个nid，即ino\n\t\tgoto fail;\n\t}\n    \n\tnid_free = true;\n\n\tinode_init_owner(inode, dir, mode); // 初始化从属信息: 访问模式、父目录等\n\n\tinode->i_ino = ino; // 初始化一些元数据信息，例如ino\n\tinode->i_blocks = 0;\n\tinode->i_mtime = inode->i_atime = inode->i_ctime = current_time(inode);\n\tF2FS_I(inode)->i_crtime = inode->i_mtime;\n\tinode->i_generation = sbi->s_next_generation++;\n\n\terr = insert_inode_locked(inode); // 将这个inode插入到全局的inode table(VFS行为)\n\n    set_inode_flag(inode, FI_NEW_INODE); // 注意这个标志位后面会用到\n    \n\t......\n\t// 上面省略代码都在设置法f2fs_inode_info的flag，并在这个函数将部分flag设置到vfs inode中\n\tf2fs_set_inode_flags(inode); \n\treturn inode;\n}\n```\n### f2fs_add_link 函数\n\n经过上面的函数，我们已经创建了一个 f2fs 使用的 vfs inode，接下来我们要将这个 inode 链接到父目录的 inode 当中，建立联系，`f2fs_add_link` 函数直接会调用 `f2fs_do_add_link` 函数，因此我们直接分析这个函数。其中 `f2fs_dir_entry` 代表是目录项，可以理解为**父目录包含了多个子文件/目录项，每一个目录项对应一个子文件/子目录的关联信息。我们将新创建的 inode 加入到父目录的管理，也就是在父目录中为这个新 inode 下创建一个目录项。**\n\n```c\nstatic inline int f2fs_add_link(struct dentry *dentry, struct inode *inode)\n{\n    // 这里的dentry就是新inode的dentry\n\treturn f2fs_do_add_link(d_inode(dentry->d_parent), &dentry->d_name,\n\t\t\t\tinode, inode->i_ino, inode->i_mode);\n}\n\n// dir是父目录\nint f2fs_do_add_link(struct inode *dir, const struct qstr *name,\n\t\t\t\tstruct inode *inode, nid_t ino, umode_t mode)\n{\n\tstruct f2fs_dir_entry *de = NULL; // 父目录dir的目录项，初始化为NULL\n\tint err;\n    // 如果文件已经加密，则获得解密后的名字fname\n\terr = fscrypt_setup_filename(dir, name, 0, &fname); \n\tif (de) { // 如果找到目录项\n\t\tf2fs_put_page(page, 0);\n\t\terr = -EEXIST;\n\t} else if (IS_ERR(page)) {\n\t\terr = PTR_ERR(page);\n\t} else { // 对于一个新inode，它对应的父目录的目录项f2fs_dir_entry应该是不存在的\n\t\terr = f2fs_add_dentry(dir, &fname, inode, ino, mode);\n\t}\n\treturn err;\n}\n```\n\n`f2fs_add_dentry` 函数提取了文件名字的字符串以及字符串长度：\n\n```c\nint f2fs_add_dentry(struct inode *dir, struct fscrypt_name *fname,\n\t\t\t\tstruct inode *inode, nid_t ino, umode_t mode)\n{\n\tstruct qstr new_name;\n\tint err = -EAGAIN;\n\n\tnew_name.name = fname_name(fname); // 将文件名的字符串格式保存在这里\n\tnew_name.len = fname_len(fname);   // 将文件名的长度保存在这里\n\n    // 在这个函数实现新inode和父inode的链接\n\terr = f2fs_add_regular_entry(dir, &new_name, fname->usr_fname,\n\t\t\t\t\t\tinode, ino, mode);\n\n\tf2fs_update_time(F2FS_I_SB(dir), REQ_TIME); // 更新修改时间\n\treturn err;\n}\n```\n\n新 inode 的 `f2fs_dir_entry` 应该是不存在的，注意 `FI_NEW_INODE` 的 flag。\n\n```c\nint f2fs_add_regular_entry(struct inode *dir, const struct qstr *new_name,\n\t\t\t\tconst struct qstr *orig_name,\n\t\t\t\tstruct inode *inode, nid_t ino, umode_t mode)\n{\n\t...\n\n\t// 上面的机制比较复杂，在这里不提，在目录项的作用相关章节再提\n    // 上面做了一大堆事情可以理解为，根据[文件名的长度]创建一个新的f2fs_dir_entry，然后加入到父目录当中\n    // 需要注意的是这个f2fs_dir_entry还没有包含新inode的信息\n       \n    //  接下来就是要做的就是\n    // \t1. 为新的vfs inode创建inode page，初始化与父目录有关的信息\n    // \t2. 基于新inode的信息(名字，ino等)更新f2fs_dir_entry\n        \n\tif (inode) {\n        // 这个函数就是创建inode page，初始化与父目录有关的信息\n\t\tpage = f2fs_init_inode_metadata(inode, dir, new_name,\n\t\t\t\t\t\torig_name, NULL);\n\t}\n\n\n    // 基于新inode的信息(名字，ino等)更新f2fs_dir_entry\n\tf2fs_update_dentry(ino, mode, &d, new_name, dentry_hash, bit_pos);\n\n\tset_page_dirty(dentry_page);\n\tf2fs_update_parent_metadata(dir, inode, current_depth); // 清除FI_NEW_INODE的flag\n\treturn err;\n}\n```\n\n由于新 inode 设置了 `FI_NEW_INODE`，因此 `f2fs_init_inode_metadata` 函数就是完成了两个功能:\n\n1. 创建一个新的 inode page，然后初始化 acl、security 等信息。\n2. 然后初始化新创建的 inode page 的名字。\n3. 再增加 inode 的引入链接。\n\n```c\nstruct page *f2fs_init_inode_metadata(struct inode *inode, struct inode *dir,\n\t\t\tconst struct qstr *new_name, const struct qstr *orig_name,\n\t\t\tstruct page *dpage)\n{\n\tstruct page *page;\n\tint err;\n\n    // 由于新inode设置了FI_NEW_INODE\n\tif (is_inode_flag_set(inode, FI_NEW_INODE)) {\n        // 创建一个新的inode page，然后初始化acl、security等信息。\n\t\tpage = f2fs_new_inode_page(inode);\n\n\t\terr = f2fs_init_acl(inode, dir, page, dpage);\n\t\tif (err)\n\t\t\tgoto put_error;\n\n\t\terr = f2fs_init_security(inode, dir, orig_name, page);\n\t\tif (err)\n\t\t\tgoto put_error;\n\t\t}\n\t} else {\n\t\tpage = f2fs_get_node_page(F2FS_I_SB(dir), inode->i_ino);\n\t\tif (IS_ERR(page))\n\t\t\treturn page;\n\t}\n\n\tif (new_name) { // 然后初始化新创建的inode page的名字\n\t\tinit_dent_inode(new_name, page);\n\t\tif (f2fs_encrypted_inode(dir))\n\t\t\tfile_set_enc_name(inode);\n\t}\n\t// 再增加inode的引入链接。\n\tif (is_inode_flag_set(inode, FI_INC_LINK))\n\t\tf2fs_i_links_write(inode, true);\n\treturn page;\n}\n```\n将新的 inode 链接到父目录后，后续用户访问时，可以通过父目录找到新创建的文件的 inode，即完成了整个文件的创建流程。\n\n# 重要数据结构和函数分析\n\n## f2fs_summary 和 f2fs_summary_block\n\n### 介绍\n因为每一个 segment 需要管理 512 个 Block 的地址，而且很多场合需要通过 block 地址找到这个 block 是属于哪一个 node，以及属于这个 node 的第几个 block。`f2fs_summary` 主要保存了 block->node 的映射信息：\n\n```c\nstruct f2fs_summary {\n\t__le32 nid;\t\t/* parent node id */\n\tunion {\n\t\t__u8 reserved[3];\n\t\tstruct {\n\t\t\t__u8 version;\t\t/* node version number */\n\t\t\t__le16 ofs_in_node;\t/* block index in parent node */\n\t\t} __packed;\n\t};\n} __packed;\n```\n一个 segment 对应的 512 个 `f2fs_summary` 是通过一个 4 KB 的 block 保存，`f2fs_summary_block` 保存在元数据区域的 **SSA**  区域: \n\n```c\nstruct f2fs_summary_block {\n\tstruct f2fs_summary entries[ENTRIES_IN_SUM];\n\tstruct f2fs_journal journal;\n\tstruct summary_footer footer;\n} __packed;\n\nstruct summary_footer {\n\tunsigned char entry_type;\t/* SUM_TYPE_XXX */\n\t__le32 check_sum;\t\t/* summary checksum */\n} __packed;\n```\n\n其中 `summary_footer` 记录了这个 `f2fs_summary_block` 的一些属性，如校验信息，以及这个 `f2fs_summary_block` 对应的 segment 所管理的 block 是属于 node 还是 data。\n\n### 应用场景\n\n1. **GC 基本流程:** 选一个无效 block 最多的当选择出需要 gc 的 victim segment，然后将这个 victim segment 的 block 迁移插入到其他 segment 中，这样就可以制造出一个全部 block 都可以用的 segment。\n2. **f2fs_summary 在 GC 的作用:** 当选择出需要 gc 的 victim segment 之后，可以通过这个 victim segment 的 segno，在 SSA 区域找到 `f2fs_summary_block`。对 victim segment 的每一个 block 进行迁移的时候，会根据 block 的地址在 `f2fs_summary_block` 找到 它所对应的 `f2fs_summary` 然后根据它所记录的 `f2fs_summary->nid` 以及 `f2fs_summary->ofs_in_node` 找到对应的具体的 block 的数据，然后将这些数据设置为 dirty，然后等待 vfs 的 writeback 机制完成页迁移。\n\n## seg_entry 和 sit_info\n\n### seg_entry 结构\n#### 介绍\n因为每一个 segment 需要管理 512 个 Block 的地址，因此需要通过某种方式去标记一个 segment 下的 block，哪些是已经使用的，哪些 block 是处于无效状态等待回收。在 F2FS 中，通过结构体 `seg_entry` 去管理一个 segment 下的所有 block 的使用信息:\n\n```c\nstruct seg_entry {\n\tunsigned int type:6;\t\t/* 这个segment的类型 */\n\tunsigned int valid_blocks:10;\t/* 已经使用的块的数目 */\n\tunsigned int ckpt_valid_blocks:10;\t/* 上一次执行CP时，使用的块的数目 */\n\tunsigned int padding:6;\t\t/* padding */\n\tunsigned char *cur_valid_map;\t/* 通过bitmap(512位)表示这个segment哪些被使用，哪些没使用 */\n#ifdef CONFIG_F2FS_CHECK_FS\n\tunsigned char *cur_valid_map_mir;\t/* mirror of current valid bitmap */\n#endif\n\t/*\n\t * # of valid blocks and the validity bitmap stored in the the last\n\t * checkpoint pack. This information is used by the SSR mode.\n\t */\n\tunsigned char *ckpt_valid_map;\t/* 上次CP时的bitmap状态 */\n\tunsigned char *discard_map; /* 标记哪些block需要discard的bitmap */\n\tunsigned long long mtime;\t/* 修改时间 */\n};\n```\n\n`seg_entry` 由于跟磁盘空间大小有关，因此初始化时以动态分配的方式，保存在元数据区域的 **SIT** 区域当中，代码的具体实现为 `sbi->sit_info->sentries` 中。\n\n#### 应用场景\n\n**写流程:** 当文件的修改某一个 block 的数据时，需要经过的流程是：\n\n1) 分配一个新的 block; \n2) 将数据写入到新分配的 block 中; \n3) 将旧 block 置为无效，等待回收; \n4) 将新 block 写入到磁盘中。\n\n这一个流程需要更新的 segment 的管理信息，因为新 block 和旧 block 可能来自不同的 segment，因此需要更新 segment 的统计信息，具体流程是: 根据新 block 的地址，找到对应 segment number 和 seg_entry，然后在 `seg_entry` 的根据新 block 在 segment 的 bitmap 对应位置设为 1，然后给 `seg_entry->valid_blocks` 加一，表示这个 segment 新增加了一个被使用 block；对于旧 block，一样是根据 block 地址找到 segment number 和 seg_entry，然后执行相反操作对 bitmap 设为 0，然后 `seg_entry->valid_blocks` 减一。\n\n### curseg_info 结构\n#### 介绍\n`curseg_info` 在 F2FS 中表示的是当前使用的 segment 的信息。一般情况下，F2FS 同时运行着 6 个 `curseg_info` ，分别表示 **(NODE,DATA) X (HOT,WARM,COLD)** 这些不同类型的 segment。它的基本结构和关联数据结构是：\n\n```c\nstruct curseg_info {\n\tstruct mutex curseg_mutex;\t\t/* lock for consistency */\n\tstruct f2fs_summary_block *sum_blk;\t/* cached summary block */\n\tstruct rw_semaphore journal_rwsem;\t/* protect journal area */\n\tstruct f2fs_journal *journal;\t\t/* cached journal info */\n\tunsigned char alloc_type;\t\t/* current allocation type */\n\tunsigned int segno;\t\t\t/* current segment number */\n\tunsigned short next_blkoff;\t\t/* next block offset to write */\n\tunsigned int zone;\t\t\t/* current zone number */\n\tunsigned int next_segno;\t\t/* preallocated segment */\n};\n```\n**f2fs_summary_block:** `curseg_info` 表示一个 segment，因此通过 `f2fs_summary_block` 管理这个 segment 下的所有 block。 `f2fs_summary_block` 包含 512 个 `f2fs_summary`，每个 summary 代表一个这个 segment 里面的一个 block，它的结构是:\n\n```c\nstruct f2fs_summary_block {\n\tstruct f2fs_summary entries[ENTRIES_IN_SUM]; /* ENTRIES_IN_SUM = 512 表示被管理的512个块 */\n\tstruct f2fs_journal journal;\n\tstruct summary_footer footer; /* 指示这个segment的类型 */\n} __packed;\n\nstruct f2fs_summary {\n\t__le32 nid;\t\t/* 属主node id */\n\tunion {\n\t\t__u8 reserved[3];\n\t\tstruct {\n\t\t\t__u8 version;\t\t/* node version number */\n\t\t\t__le16 ofs_in_node;\t/* 属主node里面的第几个block */\n\t\t} __packed;\n\t};\n} __packed;\n\n```\n可以看到每一个 `f2fs_summary` 用来描述这个 segment 里面的 block 是属于哪一个 node，而且是这个 node 里面的第几个 block。\n\n**f2fs_journal:** `curseg_info` 管理着 512 个 block，需要一种机制去记录每一个它所管理的 block 是否已经被分配出去。因此 `f2fs_journal` 的作用就是记录每一个 block 是否是有效。它的结构如下:\n\n```c\nstruct f2fs_journal {\n\tunion {\n\t\t__le16 n_nats;\n\t\t__le16 n_sits; /* 这个journal里面包含多少个sit_journal对象 */\n\t};\n\t/* spare area is used by NAT or SIT journals or extra info */\n\tunion {\n\t\tstruct nat_journal nat_j;\n\t\tstruct sit_journal sit_j;\n\t\tstruct f2fs_extra_info info;\n\t};\n} __packed;\n\nstruct sit_journal {\n\tstruct sit_journal_entry entries[SIT_JOURNAL_ENTRIES];\n\t__u8 reserved[SIT_JOURNAL_RESERVED];\n} __packed;\n\nstruct sit_journal_entry {\n\t__le32 segno;\n\tstruct f2fs_sit_entry se;\n} __packed;\n\nstruct f2fs_sit_entry {\n\t__le16 vblocks;\t\t\t\t/* reference above */\n\t__u8 valid_map[SIT_VBLOCK_MAP_SIZE];\t/* SIT_VBLOCK_MAP_SIZE = 64，64 * 8 = 512 可以表示每一个块的valid状态 */\n\t__le64 mtime;\t\t\t\t/* segment age for cleaning */\n} __packed;\n```\n`f2fs_journal` 可以记录 NAT 和 SIT 的 journal。通过 `f2fs_sit_entry` 可以发现，`f2fs_journal` 保存的是有效 block 的数目 `vblocks` 以及它的 bitmap `valid_map`。 \n\n#### curseg_info 的作用\n`curseg_info` 的作用主要是当一个 Node 或者 Data 需要分配一个新的 block 的时候，就会根据这个 block 的类型，在 `curseg_info` 取出一个 segment，然后在这个 segment 分配出一个新的 block，然后将新的 block 的映射信息，写入 `curseg_info` 的 `f2fs_summary_block` 和 `f2fs_journal` 中。这样设计的原因是，将大部分更新元数据的操作都放在 `curseg_info` 完成，避免了频繁读写磁盘。\n\n## F2FS Journal 机制\n### 介绍\n当 F2FS 进行文件读写的时候，根据 `f2fs_node` 的设计以及闪存设备异地更新的特性，每修改一个数据块，都需要改动 `f2fs_node` 的地址映射，以及 NAT，SIT 等信息。但是如果仅仅因为一个小改动，例如修改一个块，就需要改动这么多数据，然后再写入磁盘，这样既会导致性能下降，也会导致 SSD 寿命的下降。故 F2FS 设计了 journal 机制，用于将这些对数据的修改会暂存在 `f2fs_journal`，等系统进行 checkpoint 的时候，再写入磁盘当中。\n\n部分内容参考: [https://blog.csdn.net/sunwukong54/article/details/45669017](https://blog.csdn.net/sunwukong54/article/details/45669017)\n\n### 涉及到的数据结构\n```c\nstruct f2fs_journal {\n\tunion {\n\t\t__le16 n_nats; /* 这个journal里面包含多少个nat_journal对象 */\n\t\t__le16 n_sits; /* 这个journal里面包含多少个sit_journal对象 */\n\t};\n\t/* spare area is used by NAT or SIT journals or extra info */\n\tunion {\n\t\tstruct nat_journal nat_j;\n\t\tstruct sit_journal sit_j;\n\t\tstruct f2fs_extra_info info;\n\t};\n} __packed;\n```\n`f2fs_journal` 可以保存 NAT 的 journal 也可以保存 SIT 的 journal，以下分别分析:\n\n**NAT Journal**\nNAT 类型的 journal 主要保存的每一个 node 是属于哪一个 inode，以及它的地址是什么，这样设计的原始访问某一个 node 的时候，只要根据 nid 找到对应的 `nat_journal_entry`，然后就可以找到 `f2fs_nat_entry`，最后找到 blkaddr。\n\n```c\nstruct nat_journal {\n\tstruct nat_journal_entry entries[NAT_JOURNAL_ENTRIES];\n\t__u8 reserved[NAT_JOURNAL_RESERVED];\n} __packed;\n\nstruct nat_journal_entry {\n\t__le32 nid;\n\tstruct f2fs_nat_entry ne;\n} __packed;\n\nstruct f2fs_nat_entry {\n\t__u8 version;\t\t/* latest version of cached nat entry */\n\t__le32 ino;\t\t/* inode number */\n\t__le32 block_addr;\t/* block address */\n} __packed;\n```\n**SIT Journal**\nSIT 类型的 Journal 和 segment 一一对应。segment 管理着 512 个 block，需要一种机制去记录每一个它所管理的 block 是否已经被分配出去。通过 `f2fs_sit_entry` 可以发现，`f2fs_journal` 保存的是有效 block 的数目 `vblocks` 以及它的 bitmap `valid_map`。 \n\n```c\nstruct sit_journal {\n\tstruct sit_journal_entry entries[SIT_JOURNAL_ENTRIES];\n\t__u8 reserved[SIT_JOURNAL_RESERVED];\n} __packed;\n\nstruct sit_journal_entry {\n\t__le32 segno;\n\tstruct f2fs_sit_entry se;\n} __packed;\n\nstruct f2fs_sit_entry {\n\t__le16 vblocks;\t\t\t\t/* reference above */\n\t__u8 valid_map[SIT_VBLOCK_MAP_SIZE];\t/* SIT_VBLOCK_MAP_SIZE = 64，64 * 8 = 512 可以表示每一个块的valid状态 */\n\t__le64 mtime;\t\t\t\t/* segment age for cleaning */\n} __packed;\n```\n\n### 一些机制的具体实现\n\n#### 通过 Journal 获取 Node 的地址\n```c\nvoid f2fs_get_node_info(struct f2fs_sb_info *sbi, nid_t nid,\n\t\t\t\t\t\tstruct node_info *ni)\n{\n\tstruct f2fs_nm_info *nm_i = NM_I(sbi);\n\tstruct curseg_info *curseg = CURSEG_I(sbi, CURSEG_HOT_DATA);\n\tstruct f2fs_journal *journal = curseg->journal;\n\tnid_t start_nid = START_NID(nid);\n\tstruct f2fs_nat_block *nat_blk;\n\tstruct page *page = NULL;\n\tstruct f2fs_nat_entry ne;\n\tstruct nat_entry *e;\n\tpgoff_t index;\n\tint i;\n\n\tni->nid = nid;\n\n\t/* Check nat cache */\n\tdown_read(&nm_i->nat_tree_lock);\n\te = __lookup_nat_cache(nm_i, nid); // 从cache里面找nid\n\tif (e) { // 如果有就返回\n\t\tni->ino = nat_get_ino(e);\n\t\tni->blk_addr = nat_get_blkaddr(e);\n\t\tni->version = nat_get_version(e);\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\treturn;\n\t}\n\n\tmemset(&ne, 0, sizeof(struct f2fs_nat_entry)); // 初始化为0\n\n\t/* Check current segment summary */\n\tdown_read(&curseg->journal_rwsem);\n\ti = f2fs_lookup_journal_in_cursum(journal, NAT_JOURNAL, nid, 0); // 从NAT_JOURNAL里面找这个nid在journal中的offset\n\tif (i >= 0) {\n\t\tne = nat_in_journal(journal, i); // 将nat_entry返回出来\n\t\tnode_info_from_raw_nat(ni, &ne); // 读到node_info中\n\t}\n\tup_read(&curseg->journal_rwsem);\n\tif (i >= 0) {\n\t\tup_read(&nm_i->nat_tree_lock);\n\t\tgoto cache;\n\t}\n\n\t/*\n\t * Fill node_info from nat page\n\t * start_nid是根据nid找到管理这个nid的nat block偏移\n\t * */\n\tindex = current_nat_addr(sbi, nid);\n\tup_read(&nm_i->nat_tree_lock);\n\n\tpage = f2fs_get_meta_page(sbi, index); // 从磁盘读取出f2fs_nat_block\n\tnat_blk = (struct f2fs_nat_block *)page_address(page);\n\tne = nat_blk->entries[nid - start_nid];\n\tnode_info_from_raw_nat(ni, &ne);\n\tf2fs_put_page(page, 1);\ncache:\n\t/* cache nat entry */\n\tcache_nat_entry(sbi, nid, &ne); // 缓存这个node_entry\n}\n```\n\n#### 通过 Checkpoint 将 journal 的信息写入到磁盘中\n简略的流程如下: \n1. `f2fs_flush_nat_entries` 和 `f2fs_flush_sit_entries` 函数将 entry 都写入到 `curseg_info->f2fs_summary->journal` 的变量中。\n2. do_checkpoint() 函数读取 `curseg_info->f2fs_summary`，然后通过函数 `f2fs_write_node_summaries` 或 `f2fs_write_data_summaries` 刷写到磁盘中。\n\n## f2fs_map_blocks 的作用与源码分析\n函数 f2fs_map_blocks() 启到了地址映射的作用，主要作用是通过逻辑地址找到可以访问磁盘的物理地址。\n\n### 读写流程的作用\n1. 对读的作用: 通过该函数根据逻辑地址找到物理地址，然后从磁盘读取出数据。\n2. 对写的作用: 文件在写入数据之前，会执行一个 preallocate 的过程，这个过程会调用 `f2fs_map_blocks` 函数对即将要写入数据的逻辑块进行预处理，如果是 append 的方式写入数据，则将物理地址初始化为 NEW_ADDR; 如果是 rewrite 的方式写入数据，则不作改变。\n\n### 核心数据结构\nf2fs_map_blocks() 函数的核心是 `f2fs_map_blocks` 数据结构，保存了一系列映射信息。\n\n```c\nstruct f2fs_map_blocks {\n\tblock_t m_pblk; // 保存的是物理地址，可以通过这个物理地址访问磁盘读取信息\n\tblock_t m_lblk; // 保存的逻辑地址，即文件的page->index\n\tunsigned int m_len; // 需要读取的长度\n\tunsigned int m_flags; // flags表示获取数据状态，如F2FS_MAP_MAPPED\n\tpgoff_t *m_next_pgofs; // 指向下一个offset\n};\n```\n\n### 读流程的核心逻辑\n\n一般的读流程，会进行如下的数据结构初始化:\n```c\nmap.m_lblk = block_in_file; // 设置逻辑地址page->index\nmap.m_len = len; // 设置需要读取的长度\nf2fs_map_blocks(inode, &map, 0, F2FS_GET_BLOCK_READ); // 0设定非创建模式，F2FS_GET_BLOCK_READ设定搜索模式\n```\n即通过逻辑地址和读取长度找到对应的物理地址，与**读流程相关的核心逻辑**如下所示:\n```c\nint f2fs_map_blocks(struct inode *inode, struct f2fs_map_blocks *map, int create, int flag)\n{\n\tunsigned int maxblocks = map->m_len; // 设定最大搜索长度\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE_RA; // LOOKUP_NODE_RA模式\n\n\tmap->m_len = 0; // 将len重新设置为0\n\tmap->m_flags = 0;\n\tpgofs =\t(pgoff_t)map->m_lblk; // page->index\n\n\t// 第一步：先从extent找，如果在extent找到，就可以马上返回\n\tif (!create && f2fs_lookup_extent_cache(inode, pgofs, &ei)) {\n\t\tmap->m_pblk = ei.blk + pgofs - ei.fofs;\n\t\tmap->m_len = min((pgoff_t)maxblocks, ei.fofs + ei.len - pgofs);\n\t\tmap->m_flags = F2FS_MAP_MAPPED;\n\t\tgoto out;\n\t}\n\n\t// 第二步：根据page->index找到对应的dn，dn是一个包含了物理地址的数据结构\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = get_dnode_of_data(&dn, pgofs, mode);\n\n\t// 第三步：从dn获取物理地址\n\tblkaddr = datablock_addr(dn.node_page, dn.ofs_in_node);\n\t...\n\tmap->m_pblk = blkaddr;\n\t...\n\treturn err;\n}\n```\n\n### 写流程的核心逻辑\n一般的读流程，会进行如下的数据结构初始化:\n```c\nmap.m_lblk = F2FS_BLK_ALIGN(iocb->ki_pos); // 计算得到页偏移\nmap.m_len = F2FS_BYTES_TO_BLK(iocb->ki_pos + iov_iter_count(from)); // 计算得到需要读取的页数\nf2fs_map_blocks(inode, &map, 1, F2FS_GET_BLOCK_PRE_AIO); // 1设定创建模式，F2FS_GET_BLOCK_PRE_AIO表示用于预分配物理页\n```\n写流程下的 f2fs_map_blocks() 函数作用是先根据逻辑地址读取物理地址出来，如果这个物理地址没有被分配过(NULL_ADDR)，则初始化为新地址(NEW_ADDR)，用于下一步的写入磁盘的操作，与**写流程相关的核心逻辑**如下所示:\n```c\n\nint f2fs_map_blocks(struct inode *inode, struct f2fs_map_blocks *map,\n\t\t\t\t\t\tint create, int flag)\n{\n\tunsigned int maxblocks = map->m_len;\n\tint mode = create ? ALLOC_NODE : LOOKUP_NODE;\n\n\tmap->m_len = 0;\n\tmap->m_flags = 0;\n\n\tpgofs =\t(pgoff_t)map->m_lblk;\n\tend = pgofs + maxblocks;\n\n\t// 第一步：根据page->index找到对应的dn，dn是一个包含了物理地址的数据结构\n\tset_new_dnode(&dn, inode, NULL, NULL, 0);\n\terr = f2fs_get_dnode_of_data(&dn, pgofs, mode);\n\n\t// 第二步：从dn获取物理地址\n\tblkaddr = datablock_addr(dn.inode, dn.node_page, dn.ofs_in_node);\n\n\t// 第三步：如果blkaddr == NULL_ADDR表示这个是从来未使用过的物理页，即目前运行的是append写，\n\t//  因此将其记录下来。\n\tif (flag == F2FS_GET_BLOCK_PRE_AIO) {\n\t\tif (blkaddr == NULL_ADDR) {\n\t\t\tprealloc++; // 记录需要与分配的物理页的数目\n\t\t\tlast_ofs_in_node = dn.ofs_in_node;\n\t\t}\n\t} \n\n\tif (flag == F2FS_GET_BLOCK_PRE_AIO &&\n\t\t\t(pgofs == end || dn.ofs_in_node == end_offset)) {\n\n\t\tdn.ofs_in_node = ofs_in_node;\n\t\t// 第四步：根据prealloc记录的从未被使用过的块的数目，\n\t\t//  通过函数f2fs_reserve_new_blocks，将他们的值由NULL_ADDR转换为NEW_ADDR，用于下一步写入磁盘\n\t\terr = f2fs_reserve_new_blocks(&dn, prealloc);\n\t\tif (err)\n\t\t\tgoto sync_out;\n\n\t\tmap->m_len += dn.ofs_in_node - ofs_in_node;\n\t\tif (prealloc && dn.ofs_in_node != last_ofs_in_node + 1) {\n\t\t\terr = -ENOSPC;\n\t\t\tgoto sync_out;\n\t\t}\n\t\tdn.ofs_in_node = end_offset;\n\t}\n\n\t...\n\treturn err;\n}\n```\n\n## 物理地址寻址的实现\nVFS 的读写都依赖于物理地址的寻址。经典的读流程，VFS 会传入 inode 以及 page index 信息给文件系统，然后文件系统需要根据以上信息，找到物理地址，然后访问磁盘将其读取出来。F2FS 的物理地址寻址，是通过 f2fs_get_dnode_of_data() 函数实现。\n\n在执行这个 f2fs_get_dnode_of_data() 函数之前，需要通过 set_new_dnode() 函数进行对数据结构 `struct dnode_of_data` 进行初始化:\n```c\nstruct dnode_of_data {\n\tstruct inode *inode;\t\t/* VFS inode结构 */\n\tstruct page *inode_page;\t/* f2fs_inode对应的node page */\n\tstruct page *node_page;\t\t/* 用户需要访问的物理地址所在的node page，有可能跟inode_page一样*/\n\tnid_t nid;\t\t\t/* 用户需要访问的物理地址所在的node的nid，与上面的node_page对应*/\n\tunsigned int ofs_in_node;\t/* 用户需要访问的物理地址位于上面的node_page对应的addr数组第几个位置 */\n\tbool inode_page_locked;\t\t/* inode page is locked or not */\n\tbool node_changed;\t\t/* is node block changed */\n\tchar cur_level;\t\t\t/* 当前node_page的层次，按直接访问或者简介访问的深度区分 */\n\tchar max_level;\t\t\t/* level of current page located */\n\tblock_t\tdata_blkaddr;\t\t/* 用户需要访问的物理地址 */\n};\n\nstatic inline void set_new_dnode(struct dnode_of_data *dn, struct inode *inode,\n\t\tstruct page *ipage, struct page *npage, nid_t nid)\n{\n\tmemset(dn, 0, sizeof(*dn));\n\tdn->inode = inode;\n\tdn->inode_page = ipage;\n\tdn->node_page = npage;\n\tdn->nid = nid;\n}\n```\n大部分情况下，仅需要传入 inode 进行初始化: \n```c\nset_new_dnode(&dn, inode, NULL, NULL, 0); // 0表示不清楚nid\n```\n然后根据需要访问的 page index，执行 f2fs_get_dnode_of_data() 函数寻找:\n```c\nerr = f2fs_get_dnode_of_data(&dn, page->index, type); // type类型影响了寻址的行为\nblockt blkaddr = dn.data_blkaddr; // 获得对应位置的物理地址信息\n```\n接下来分析，函数是如何寻址，由于函数比较长和复杂，先分析一个比较重要的函数 get_node_path() 函数的作用，它的用法是:\n### 概念\n在分析之前，我们要明确几个概念。f2fs 有三种 node 的类型，`f2fs_inode`、`direct_node` 和 `indirect node`。其中 `f2fs_inode` 和 `direct_node` 都是直接保存数据的地址指针，因此一般统称为 direct node，若有下横线，例如 `direct_node`，则表示数据结构 `struct direct_node`，如果没有下横线，则表示直接保存数据的地址指针的 node，即 `f2fs_inode` 和 `direct_node`。另外 `indirect node` 保存的是间接寻址的 node 的 nid，因此一般直接称为 indirect node。\n### 函数用法\n```c\nint level;\nint offset[4];\nunsigned int noffset[4];\nlevel = get_node_path(inode, page->index, offset, noffset);\n```\n这里 offset 和 noffset 分别表示 block offset 和 node offset，返回的 level 表示寻址的深度，一共有 4 个深度，使用 0~3 表示:\n\n- level=0: 表示可以直接在 `f2fs_inode` 找到物理地址。\n- level=1: 表示可以在 `f2fs_inode->i_nid[0~1]` 对应的 `direct_node `能够找到物理地址。\n- level=2: 表示可以在 `f2fs_inode->i_nid[2~3] `对应的 `indirect_node` 下的 nid 对应的 `direct_node `能够找到物理地址。\n- level=3: 表示只能在 `f2fs_inode->i_nid[4]` 对应 `indirect_node `的 nid 对应的 `indirect_node` 的 nid 对应的 `direct_node` 才能找到地址。\n\n由于 offset 和 noffset，表示的是物理地址寻址信息，分别表示 block 偏移和 direct node 偏移来表示，它们是长度为 4 的数组，代表不同 level 0~3 的寻址信息。之后的函数可以通过 offset 和 noffset 将数据块计算出来。\n### 寻址原理\n给定 page->index，计算出 level 之后，offset[level] 表示该 page 在所对应的 direct node 里面的 block 的偏移，noffset[level] 表示当前的 node 是属于这个文件的第几个 node(包括 f2fs_node, direct_node, indirect_node)，下面用几个例子展示一下(注意下面计算的是不使用 xattr 的 f2fs 版本，如果使用了 xattr 结果会不同，但是表示的含义是一样的):\n\n#### 例子 1: 物理地址位于 f2fs_inode\n\n例如我们要寻找 page->index = 665 的数据块所在的位置，显然 655 是位于 `f2fs_inode` 内，因此 level=0，因此我们只需要看 offset[0] 以及 noffset[0] 的信息。offset[0] = 665 表示这个数据块在当前 direct node(注意: f2fs_inode 也是 direct node 的一种)的位置；noffset[0] 表示当前 direct node 是属于这个文件的第几个 node，由于 f2fs_inode 是第一个 node，所以 noffset[0] = 0。\n\n```c\nlevel = 0 // 可以直接在f2fs_inode找到物理地址\noffset[0] = 665 // 由于level=0，因此我们只需要看offset[level]=offset[0]的信息，这里offset[0] = 665表示地址位于f2fs_inode->i_addr[665]\nnoffset[0] = 0 // 对于level=0的情况，即看noffset[0]，因为level=0表示数据在唯一一个的f2fs_inode中，因此这里表示inode。\n```\n\n#### 例子 2: 物理地址位于 direct_node\n\n例如我们要寻找 page->index = 2113 的数据块所在的位置，它位于第二个 direct_node，所以 level=1。我们只需要看 offset[1] 以及 noffset[1] 的信息。offset[1] = 172 表示这个数据块在当前 direct node 的位置，即 direct_node->addr[172]；noffset[1] 表示当前 direct node 是属于这个文件的第几个 node，由于它位于第二个 direct_node，前面还有一个 f2fs_inode 以及一个 direct node，所以这是第三个 node，因此 noffset[1] = 2。\n\n```c\nlevel = 1 // 表示可以在f2fs_inode->i_nid[0~1]对应的direct_node能够找到物理地址\noffset[1] = 172 // 表示物理地址位于对应的node page的i_addr的第172个位置中，即direct_node->addr[172]\nnoffset[1] = 2 // 数据保存在总共第三个node中 (1个f2fs_inode，2个direct_node)\n```\n\n#### 例子 3: 物理地址位于 indirect_node\n\n例如我们要寻找 page->index = 4000 的数据块所在的位置，它位于第 1 个 indirect_node 的第 2 个 direct_node中，所以 level=2。我们只需要看 offset[2] 以及 noffset[2] 的信息。offset[2] = 23 表示这个数据块在当前 direct node 的位置；noffset[2] 表示当前 direct node 是属于这个文件的第几个 direct node，即这是第 6 个 node。(1 * f2fs_inode + 2 * direct_node + 1 * indirect_node + 2 * direct node)。\n\n```c\noffset[2] = 23\nnoffset[2] = 5\n```\n\n#### 例子 4: 物理地址位于 indirect_node 再 indiret_node 中 (double indirect node)\n\n例如我们要寻找 page->index = 2075624 的数据块所在的位置，它位于第一个 double indirect_node 的第一个 indirect_node 的第一个 direct_node 中，所以 level=3。同理我们只需要看 offset[3] 以及 noffset[3] 的信息，如下，可以自己计算一下：\n\n```c\noffset[3] = 17\nnoffset[3] = 2043\n```\n\n从上面可以知道 get_node_path() 函数以后，执行可以根据 offset 和 noffset 直接知道 page->index 对应的物理地址，位于第几个 node page 的第几个 offset 对应的物理地址中。下面分析 f2fs_get_dnode_of_data() 的原理：\n\n```c\nint f2fs_get_dnode_of_data(struct dnode_of_data *dn, pgoff_t index, int mode)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n\tstruct page *npage[4];\n\tstruct page *parent = NULL;\n\tint offset[4];\n\tunsigned int noffset[4];\n\tnid_t nids[4];\n\tint level, i = 0;\n\tint err = 0;\n\t\n\t// 通过计算得到offset, noffset，从而知道位于第几个node page的第几个offset对应的物理地址中\n\tlevel = get_node_path(dn->inode, index, offset, noffset);\n\tif (level < 0)\n\t\treturn level;\n\n\tnids[0] = dn->inode->i_ino;\n\tnpage[0] = dn->inode_page;\n\n\tif (!npage[0]) {\n\t\tnpage[0] = f2fs_get_node_page(sbi, nids[0]); // 获取inode对应的f2fs_inode的node page\n\t}\n\n\tparent = npage[0];\n\tif (level != 0)\n\t\tnids[1] = get_nid(parent, offset[0], true); // 获取f2fs_inode->i_nid\n\t\t\n\tdn->inode_page = npage[0];\n\tdn->inode_page_locked = true;\n\n\tfor (i = 1; i <= level; i++) {\n\t\tbool done = false;\n\n\t\tif (!nids[i] && mode == ALLOC_NODE) { \n\t\t\t// 创建模式，常用，写入文件时，需要node page再写入数据，因此对于较大文件，在这里创建node page\n\t\t\tif (!f2fs_alloc_nid(sbi, &(nids[i]))) { // 分配nid\n\t\t\t\terr = -ENOSPC;\n\t\t\t\tgoto release_pages;\n\t\t\t}\n\n\t\t\tdn->nid = nids[i];\n\t\t\tnpage[i] = f2fs_new_node_page(dn, noffset[i]); // 分配node page\n\t\t\t//  如果i == 1，表示f2fs_inode->nid[0~1]，即direct node，直接赋值到f2fs_inode->i_nid中\n\t\t\t//  如果i != 1，表示parent是indirect node类型的，要赋值到indirect_node->nid中\n\t\t\tset_nid(parent, offset[i - 1], nids[i], i == 1); \n\t\t\tf2fs_alloc_nid_done(sbi, nids[i]);\n\t\t\tdone = true;\n\t\t} else if (mode == LOOKUP_NODE_RA && i == level && level > 1) {\n\t\t\t// 预读模式，少用，将node page全部预读出来\n\t\t\tnpage[i] = f2fs_get_node_page_ra(parent, offset[i - 1]);\n\t\t\tdone = true;\n\t\t}\n\t\tif (i == 1) {\n\t\t\tdn->inode_page_locked = false;\n\t\t\tunlock_page(parent);\n\t\t} else {\n\t\t\tf2fs_put_page(parent, 1);\n\t\t}\n\n\t\tif (!done) {\n\t\t\tnpage[i] = f2fs_get_node_page(sbi, nids[i]); // 根据nid获取node page\n\t\t}\n\t\tif (i < level) {\n\t\t\tparent = npage[i]; // 注意这里parent被递归地赋值，目的是处理direct node和indrect node的赋值问题\n\t\t\tnids[i + 1] = get_nid(parent, offset[i], false); // 计算下一个nid\n\t\t}\n\t}\n\t// 全部完成后，将结果赋值到dn，然后退出函数\n\tdn->nid = nids[level];\n\tdn->ofs_in_node = offset[level];\n\tdn->node_page = npage[level];\n\tdn->data_blkaddr = datablock_addr(dn->inode, dn->node_page, dn->ofs_in_node); // 这个就是根据page index所得到的物理地址\n\treturn 0;\n}\n```\n\n## Node Footer 的作用\n\n`footer` 是 F2FS 中记录 node 的属性的一个数据，定义如下：\n\n```c\nstruct f2fs_node {\n\tunion {\n\t\tstruct f2fs_inode i;\n\t\tstruct direct_node dn;\n\t\tstruct indirect_node in;\n\t};\n\tstruct node_footer footer;\n} __packed;\n\nstruct node_footer {\n\t__le32 nid;\t\t/* node id */\n\t__le32 ino;\t\t/* inode nunmber */\n\t__le32 flag;\t\t/* include cold/fsync/dentry marks and offset */\n\t__le64 cp_ver;\t\t/* checkpoint version */\n\t__le32 next_blkaddr;\t/* next node page block address */\n} __packed;\n```\n\nF2FS 有三种类型的 node，分别是 `f2fs_inode`、`direct_node`、`indirect_node`，每一种类型的 node 都有对应的 footer。\n\n### footer->nid 和 footer->ino\n\n每一个 node 都有一个独特的 `nid`，它被记录在 `footer` 中，如果是 `direct_node` 或者 `indirect_node`，它们都有一个对应的 `f2fs_inode`，因此为了记录从属关系，还需要 `footer` 记录它所属于的 `f2fs_inode` 的 `nid`，即 `ino`。因此，如果 `footer->nid == footer->ino`，那么这个 node 就是 inode，反正这个 `node` 是 `direct_node` 或者 `indirect_node`。\n\n### footer->flag\n\n`footer->flag` 的作用是标记当前的 node 的属性。目前 F2FS 给 node 定义了三种属性: \n\n```c\nenum {\n\tCOLD_BIT_SHIFT = 0,\n\tFSYNC_BIT_SHIFT,\n\tDENT_BIT_SHIFT,\n\tOFFSET_BIT_SHIFT\n};\n\n#define OFFSET_BIT_MASK\t\t(0x07)\t/* (0x01 << OFFSET_BIT_SHIFT) - 1 */\n```\n\n其中 `footer->flag`：\n\n- 第 0 位表示这个 node 是否是 cold node。\n- 第 1 位表示这个 node 是否执行了完整的 fsync。F2FS 为了 `fsync` 的效率做了一些改进，F2FS 不会在 `fsync` 刷写所有脏的 node page 进去磁盘，只会刷写一些根据 data 直接相关的 node page 进入磁盘，例如 `f2fs_inode` 和 `direct_node`。因此这个标志位是用来记录这个 node 是否执行了完整的 fsync，以便系统在 crash 中恢复。\n- 第 3 位表示这个 node 是是用来保存文件数据，还是目录数据的，也是用于数据恢复。\n\n### footer->cp_ver 和 footer->next_blkaddr\n\n`footer->cp_ver` 分别用来记录当前的 checkpoint 的 version，恢复的时候比较 version 版本确定如何进行数据恢复。\n\n`footer->next_blkaddr` 则是用来记录这个 node 对应下一个 node page 的地址，也是用来恢复数据。\n\n## rename 流程\n\n### 流程介绍\n\n1. sys_rename 函数。\n2. do_renameat2 函数。\n3. vfs_rename 函数。\n4. f2fs_rename 函数。\n\n### sys_rename 函数\n\nsys_rename 函数是一个系统调用，是 rename 函数进入内核层的第一个函数:\n\n```c\nSYSCALL_DEFINE2(rename, const char __user *, oldname, const char __user *, newname)\n{\n    // AT_FDCWD表示以相对路径的方法找oldname和newname这个文件，flags=0\n\treturn do_renameat2(AT_FDCWD, oldname, AT_FDCWD, newname, 0);\n}\n```\n\n### do_renameat2 函数\n\ndo_renameat2 函数比较长，考虑多个输入 flag 的作用，这里只考虑 sys_rename 函数 rename 一个文件的情形，即 flag=0，并以此精简函数。\n\n```c\nstatic int do_renameat2(int olddfd, const char __user *oldname, int newdfd,\n\t\t\tconst char __user *newname, unsigned int flags)\n{\n\tstruct dentry *old_dentry, *new_dentry;\n\tstruct dentry *trap;\n\tstruct path old_path, new_path;\n\tstruct qstr old_last, new_last;\n\tint old_type, new_type;\n\tstruct inode *delegated_inode = NULL;\n\tstruct filename *from;\n\tstruct filename *to;\n\tunsigned int lookup_flags = 0, target_flags = LOOKUP_RENAME_TARGET;\n\tbool should_retry = false;\n\tint error;\n\nretry:\n    // 接下来两个函数最重要的作用是根据oldname和newname找到父目录的dentry结构\n    // 这两个dentry结构保存在old_path和new_path中(注意是父目录的dentry)\n\tfrom = filename_parentat(olddfd, getname(oldname), lookup_flags,\n\t\t\t\t&old_path, &old_last, &old_type);\n\n\tto = filename_parentat(newdfd, getname(newname), lookup_flags,\n\t\t\t\t&new_path, &new_last, &new_type);\n    \nretry_deleg:\n    // 这个函数会触发一个全局的rename的互斥锁，然后锁两个父目录inode结构\n\ttrap = lock_rename(new_path.dentry, old_path.dentry);\n\t// 根据old path的父目录找到需要被rename的文件的dentry\n\told_dentry = __lookup_hash(&old_last, old_path.dentry, lookup_flags);\n\t// 根据new path的父目录找到或创建新的dentry\n\tnew_dentry = __lookup_hash(&new_last, new_path.dentry, lookup_flags | target_flags);\n\t// 调用vfs_rename函数进行重命名\n    // 传入的是新旧两个目录的inode，以及需要重命名的两个dentry， flags = 0\n\terror = vfs_rename(old_path.dentry->d_inode, old_dentry,\n\t\t\t   new_path.dentry->d_inode, new_dentry,\n\t\t\t   &delegated_inode, flags);\n\n\tdput(new_dentry);\n\n\tdput(old_dentry);\n    // 解锁全局rename互斥锁，释放两个inode锁\n\tunlock_rename(new_path.dentry, old_path.dentry);\n\n\tpath_put(&new_path);\n\tputname(to);\n\n\tpath_put(&old_path);\n\tputname(from);\nexit:\n\treturn error;\n}\n```\n\n### vfs_rename 函数\n\nvfs_rename 函数也会做简化，简化的情形是将文件 A 重命名到文件 B(B 可能已经存在，或者不存在)，flags=0。\n\n```c\nint vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tstruct inode *source = old_dentry->d_inode; // 旧文件inode\n\tstruct inode *target = new_dentry->d_inode; // 新文件inode\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\tstruct name_snapshot old_name;\n\n\tdget(new_dentry); // 对新文件的引用计数+1\n\tif (target)\n\t\tinode_lock(target); // 如果新文件已经存在，则上锁\n\n\n\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t       new_dir, new_dentry, flags);\n\n\nout:\n\tif (target)\n\t\tinode_unlock(target); // 如果新文件已经存在，则解锁\n\tdput(new_dentry); // 对新文件的引用计数-1\n\treturn error;\n}\n```\n\n### f2fs_rename函数\n\nf2fs_rename 函数也会做简化，简化的情形是将文件A 重命名到文件 B(B 可能已经存在，或者不存在)，flags=0。\n\n```c\nstatic int f2fs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t\t\tstruct inode *new_dir, struct dentry *new_dentry,\n\t\t\tunsigned int flags)\n{\n\tstruct f2fs_sb_info *sbi = F2FS_I_SB(old_dir);\n\tstruct inode *old_inode = d_inode(old_dentry);\n\tstruct inode *new_inode = d_inode(new_dentry);\n\tstruct inode *whiteout = NULL;\n\tstruct page *old_dir_page;\n\tstruct page *old_page, *new_page = NULL;\n\tstruct f2fs_dir_entry *old_dir_entry = NULL;\n\tstruct f2fs_dir_entry *old_entry;\n\tstruct f2fs_dir_entry *new_entry;\n\tbool is_old_inline = f2fs_has_inline_dentry(old_dir);\n\tint err;\n\t\n\t// 输入显然是\n    // 旧的父目录old_dir，旧的文件old_dentry\n    // 新的父目录new_dir，新的文件new_dentry\n    \n    // 根据旧文件的名字找到对应的f2fs_dir_entry，old_page保存的是磁盘上的dir_entry数据\n\told_entry = f2fs_find_entry(old_dir, &old_dentry->d_name, &old_page);\n\n\tif (new_inode) { // 如果新文件已经存在\n\n        // 根据新文件的名字找到对应的f2fs_dir_entry，new_page保存的是磁盘上的数据\n\t\tnew_entry = f2fs_find_entry(new_dir, &new_dentry->d_name,\n\t\t\t\t\t\t&new_page);\n\n        // F2FS获取一个全局读信号量\n\t\tf2fs_lock_op(sbi);\n\n        // 在管理orphan inode的全局结构中，将orphan inode的数目+1。\n\t\terr = f2fs_acquire_orphan_inode(sbi);\n\n        // 这里进行新旧inode的link的变化:\n        // 将new_dentry所属的inode指向old_inode\n        // 因为rename的时候新inode是已经存在了，因此rename的操作就是将\n        // 新路径原来的inode无效掉，然后替换为旧路径的inode\n\t\tf2fs_set_link(new_dir, new_entry, new_page, old_inode);\n\n\t\tnew_inode->i_ctime = current_time(new_inode);\n        \n        \n\t\tdown_write(&F2FS_I(new_inode)->i_sem); // 拿写信号量\n\t\t// 减少新inode一个引用计数，因为被rename了\n\t\tf2fs_i_links_write(new_inode, false);\n\t\tup_write(&F2FS_I(new_inode)->i_sem); // 释放写信号量\n\n        // 如果引用计数下降到0，则添加到orphan inode中，在checkpoint管理\n\t\tif (!new_inode->i_nlink)\n\t\t\tf2fs_add_orphan_inode(new_inode);\n\t\telse\n\t\t\tf2fs_release_orphan_inode(sbi); // 否则管理结构将orphan inode的数目-1。\n\t} else {\n        \n        // 这个情况是新路径的Inode不存在\n\n\t\t// F2FS获取一个全局读信号量\n\t\tf2fs_lock_op(sbi);\n\n        // 由于新inode是不存在的，因此直接将旧inode添加到新的f2fs_dir_entry中\n\t\terr = f2fs_add_link(new_dentry, old_inode);\n\n\t}\n\n    \n\tdown_write(&F2FS_I(old_inode)->i_sem);\n\tif (!old_dir_entry || whiteout)\n\t\tfile_lost_pino(old_inode);  // 这个操作要保留着用于数据恢复\n\telse\n\t\tF2FS_I(old_inode)->i_pino = new_dir->i_ino;\n\tup_write(&F2FS_I(old_inode)->i_sem);\n\n\told_inode->i_ctime = current_time(old_inode);\n\tf2fs_mark_inode_dirty_sync(old_inode, false);\n\n    // 新的数据已经加入到新的f2fs_dir_entry，因此旧entry就去去除掉\n\tf2fs_delete_entry(old_entry, old_page, old_dir, NULL);\n\n\t// F2FS释放全局读信号量\n\tf2fs_unlock_op(sbi);\n\n\tf2fs_update_time(sbi, REQ_TIME);\n\treturn 0;\n}\n```\n\n# 参考文档\n\n1. [RiweiPan/F2FS-NOTES: F2FS的学习笔记以及源码分析](https://github.com/RiweiPan/F2FS-NOTES)\n\n","categories":["Linux 学习","内核层"]},{"title":"计算机高级图形学 期末复习","url":"/posts/1b712153.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 第一章 绪论\n\n## 本章复习重点\n\n- 图形学和图像学的区别。\n- 走样的原因和反走样的概念。\n- 选择题（直线算法）。\n- 光栅显示系统。\n\n<!-- more -->\n\n## 计算机图形学概述\n\n|          | 图形处理                                                     | 图像处理                                                     |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 数据来源 | **多来源于主观世界，人为地由计算机产生，由数据描述而生成图形。** | **多来源于客观世界，来自对实物的拍摄、捡取。**               |\n| 处理方法 | 图形处理技术包括：几何变换，拟合，图形操作，图形模型产生，图形处理，隐藏线，面的消除，浓淡处理，色彩纹理处理，图案生成等。 | 图像处理技术包括：图像几何修正（校正），图像采集、存储、编码、滤波、增强、压缩、复原、重建、图形理解识别等。 |\n| 理论基础 | 多利用数学矩阵代数、计算几何、分形几何等。                   | 多利用二维数字信号滤波，各种信号正交变换等。                 |\n| 应用领域 | 多应用 CAD/CAM/CAE/CAI 等领域，以及计算机艺术、计算机模拟、计算机动画、多媒体系统应用等。 | 多应用于多媒体系统，医学，遥感遥测，工业控制，监测监视，天文气象，军事侦察等。 |\n\n## 图形学研究内容\n\n1. **建模**：创建用计算机表示的三维物体模型，主要是形状表述与定义。\n2. **渲染**：通过各种矩阵变换从模型产生物体的二维图像，主要考虑光照、透视变换。\n3. **动画**：描述物体运动变化。\n\n## 光栅扫描系统\n\n### 随机扫描与光栅扫描\n\n随机扫描技术的本质是**按照显示命令的任意顺序，将电子束从一个端点偏转到另一个端点**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/04/image-20251104203112346.png\" alt=\"image-20251104203112346\" style=\"zoom:50%;\" />\n\n光栅图形具有对显示区域填充颜色或图案的能力，存储的图像更加易于操作。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/04/image-20251104203145253.png\" alt=\"image-20251104203145253\" style=\"zoom:60%;\" />\n\n光栅显示器上的图形由光栅（raster）形成。\n\n**光栅是一组互相平行的水平扫描线。每行扫描线是由大小一致的显示单元组成的显示序列，每一显示单元称为一个像素，可显示给定的颜色和灰度。**\n\n光栅显示器将显示图元（primitive）如线、文字、填充颜色或图案区域等，以像素的形式存储到一个刷新缓冲器中。\n\n### 光栅扫描系统\n\n构成：\n\n1. 帧缓冲区（Frame Buffer）。\n2. 视频控制器（Video Controller）。\n3. 显示处理器（Display Processor / GPU）。\n\n视频控制器如何实现基本刷新：\n\n1. 有两个寄存器用来存放屏幕像素的坐标。\n2. 存储在帧缓冲区中该像素对应位置的值被取出，并用来设置 CRT 电子束的强度值。\n\n显示处理器的主要任务是**将应用程序给出的图形定义数字化为一组像素强度值，并存放在帧缓冲区中**。这个数字化过程称为**扫描转换（Scan Conversion）**。\n\n### 直线段的扫描转换算法\n\n当我们对直线进行光栅化时，需要在显示器有限个像素中，确定最佳逼近该直线的一组像素，并且按扫描线顺序，对这些像素进行写操作，这个过程称为用显示器绘制直线或直线的扫描转换。\n\n三种算法：\n\n1. 基本增量算法（DDA）数值微分算法。\n2. 中点画线算法。\n3. **Bresenham 算法（使用最广泛）。**\n\n#### DDA 算法\n\n在一个坐标轴上以单位间隔对线段取样，则另一个坐标轴以常数 m 或 1/m 变化，从而获得线段上各像素点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/04/image-20251104205009793.png\" alt=\"image-20251104205009793\" style=\"zoom:50%;\" />\n\n算法迭代公式（**存在浮点数，计算慢**）：\n$$\n\\text{若 } |m| \\le 1:\n\\begin{cases}\nx_{k+1} = x_k + 1, \\quad y_{k+1} = y_k + m, & (x_a < x_b) \\\\\nx_{k+1} = x_k - 1, \\quad y_{k+1} = y_k - m, & (x_a > x_b)\n\\end{cases}\n\n\\\\\n\n\\text{若 } |m| \\ge 1:\n\\begin{cases}\ny_{k+1} = y_k + 1, \\quad x_{k+1} = x_k + \\dfrac{1}{m}, & (y_a < y_b) \\\\\ny_{k+1} = y_k - 1, \\quad x_{k+1} = x_k - \\dfrac{1}{m}, & (y_a > y_b)\n\\end{cases}\n$$\n\n#### Bresenham 算法\n\n**只用整数计算寻找最接近实际直线的整数坐标。即从 Yk 和 Yk + 1 中取出最贴近 y 坐标的点作为拟合点，但只通过整数计算（优势，快）。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/04/image-20251104211634765.png\" alt=\"image-20251104211634765\" style=\"zoom:50%;\" />\n\n推导过程如下：\n$$\n\\\\\n\\textbf{假定：} \\quad 0 < m < 1\n\\\\\n\n已知点 (x_k, y_k)，求下一点 (x_{k+1}, y_{k+1})。(x_{k+1}, y_{k+1}) 的两种可能为：(x_{k+1}, y_k) \\quad \\text{或} \\quad (x_{k+1}, y_k + 1)。其中：x_{k+1} = x_k + 1\n\\\\\n\n\\textbf{推导：}\n\\\\\n设两点与理想直线的距离分别为 d_1、d_2：\n\n\\\\\n\\begin{aligned}\nd_1 &= y - y_k = m x_{k+1} + b - y_k, \\\\\nd_2 &= y_{k+1} - y = y_{k+1} - (m x_{k+1} + b).\n\\end{aligned}\n\\\\\n因此：d_1 - d_2 = 2m x_{k+1} - 2y_k + 2b - 1\n\\\\\n令：m = \\frac{\\Delta y}{\\Delta x}\n\\\\\n代入上式，引入决策参数 P_k 表示相对距离：\n\\\\\nP_k = \\Delta x (d_1 - d_2) = 2\\Delta y x_k - 2\\Delta x y_k + C\n\\\\\n其中：C = 2\\Delta y + \\Delta x (2b - 1)\n\\\\\n\n\\textbf{推论：}\n\\\\\n\\begin{cases}\nP_k < 0, & \\text{则选择 } y_{k+1} = y_k \\\\\nP_k \\ge 0, & \\text{则选择 } y_{k+1} = y_k + 1\n\\end{cases}\n\\\\\n\nP_k 的递推公式：\n\\\\\n\n由\n\\\\\n\\begin{aligned}\nP_{k+1} &= 2\\Delta y x_{k+1} - 2\\Delta x y_{k+1} + C, \\\\\nP_k &= 2\\Delta y x_k - 2\\Delta x y_k + C,\n\\end{aligned}\n\\\\\n\n两式相减得：\n\\\\\nP_{k+1} - P_k = 2\\Delta y (x_{k+1} - x_k) - 2\\Delta x (y_{k+1} - y_k)\n\\\\ = 2\\Delta y - 2\\Delta x (y_{k+1} - y_k)\n\n\\\\\n\\therefore \\; {P_{k+1}} \\text{ 的递推公式：}\n\\\\\n\nP_{k+1} =\n\\begin{cases}\nP_k + 2\\Delta y, & (P_k < 0) \\\\[6pt]\nP_k + 2\\Delta y - 2\\Delta x, & (P_k \\ge 0)\n\\end{cases}\n\\\\\n\n初始值为：\\\\\n\nP_0 = 2\\Delta y - \\Delta x\n$$\n\n#### 中点画线算法\n\n用判别式判断点与直线的关系。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/04/image-20251104213004956.png\" alt=\"image-20251104213004956\" style=\"zoom:50%;\" />\n\n算法思路：\n$$\nF(x, y) = (m x + b) - y \\\\[6pt]\nF(x_{k+1},\\, y_k + 0.5) = 0, \n\\quad \\text{对应点 } (x_{k+1},\\, y_{k+1}) \\text{ 可能为 } (x_{k+1},\\, y_k + 1) \\text{ 或 } (x_{k+1},\\, y_k) \\\\[6pt]\n\\begin{cases}\nF(x_{k+1},\\, y_k + 0.5) < 0, & \\text{中点在直线上方，选择 } (x_{k+1},\\, y_k) \\\\[6pt]\nF(x_{k+1},\\, y_k + 0.5) > 0, & \\text{中点在直线下方，选择 } (x_{k+1},\\, y_k + 1)\n\\end{cases}\n$$\n\n### 走样与反走样\n\n**走样：用离散量表示连续量引起的失真。**\n\n**反走样：减少或消除因走样带来的阶梯形式闪烁的效果。**\n\n**反走样技术：**\n\n- **前滤波：以较高的分辨率显示对象。**\n- **后滤波：加权区域取样。**\n\n对于光栅系统来说，只能用光栅网格上的像素近似地描绘平滑的直线、多边形和圆、椭圆等曲线图元。如果引起了图中看到的**锯齿状或阶梯状的边界线问题**，在图形学中称为“走样”。\n\n用于减少或消除这种现象的技术称为“反走样”。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/04/image-20251104213414197.png\" alt=\"image-20251104213414197\" style=\"zoom:67%;\" />\n\n# 第二章 颜色模型\n\n## 本章复习重点\n\n- 什么是设备无关的颜色模型。\n- 什么是设备相关的颜色模型。\n- RGB 和 CMY 颜色模型的比较。\n- 哪些颜色模型是设备相关的？哪些颜色模型是设备无关的？\n- 颜色模型之前的转换。\n\n## 颜色模型\n\n颜色模型就是用一组数值来描述颜色的数学模型。\n\n**设备无关**的颜色模型：这类颜色模型是**基于人眼对色彩感知的度量**建立的数学模型，这些颜色模型主要用于**计算和测量**。\n\n**设备相关**的颜色模型：以最常见的 RGB 模型为例，一组确定的 RGB 数值，在一个 LED 屏上显示，最终会作用到三色 LED 的电压上。这样一组值**在不同设备上解释时，得到的颜色可能并不相同**。\n\n颜色模型是某个三维空间中的一个可见光子集。**任何一个色彩域都只是可见光的子集，任何一个颜色模型都无法包含所有的可见光。**\n\n**三原色：红、绿、蓝。**\n\n## RGB 颜色模型\n\n三维直角坐标颜色系统中的一个单位正方体。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185701763.png\" alt=\"image-20251109185701763\" style=\"zoom:75%;\" />\n\nRGB 颜色模型构成的颜色空间是 CIE 原色空间的一个真子集。RGB 三原色是**加性原色**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185942413.png\" alt=\"image-20251109185942413\" style=\"zoom:66%;\" />\n\nRGB 颜色模型通常用于彩色阴极射线管和彩色光栅图形显示器。\n\n## CMY 颜色模型\n\n**CMY 颜色模型是以红、绿、蓝三色的补色青（Cyan）、品红（Magenta）、黄（Yellow）为原色构成的颜色模型。**\n\nCMY 颜色模型常用于**从白光中滤去某种颜色**，故称为**减色原色**空间。\n\n![image-20251109185958804](https://cdn.davidingplus.cn/images/2025/11/09/image-20251109185958804.png)\n\nCMY 颜色模型对应的直角坐标系的子空间与 RGB 颜色模型对应的子空间几乎完全相同。\n\n## RGB 和 CMY 颜色模型的对比\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109190252186.png\" alt=\"image-20251109190252186\" style=\"zoom:60%;\" />\n\n## HSV 颜色模型\n\n**HSV 颜色模型是面向用户的。**在 HSV 颜色模型中，每一种颜色和它的补色**相差 180 度**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109190711853.png\" alt=\"image-20251109190711853\" style=\"zoom:80%;\" />\n\nHSV 颜色模型的优点：\n\n- 符合人眼对颜色的感觉。\n- 当采用 RGB（或者 CMY）颜色模型时，改变某一颜色的属性，比如改变色调就必须同时改变 R、G、B（或者 C、M、Y）三个坐标；而**采用 HSV 颜色模型时只需改变 H 坐标。即它的三个坐标是独立的。**\n- HSV 颜色模型构成的是一个**均匀**的颜色空间，采用线性的标尺，彩色之间感觉上的距离与 HSV 颜色模型坐标上点的欧几里德距离成正比。\n\n## CIE（国际照明委员会）颜色模型\n\nCIE 颜色模型包括一系列颜色模型，这些颜色模型是由国际照明委员会提出的，是**基于人的眼睛对 RGB 的反应，被用于精确表示对色彩的接收**。\n\nCIE 是**设备无关性**：\n\n- 被用来定义所谓的**独立于设备**的颜色。\n- 它能够在任何类型的设备上产生真实的颜色，例如：扫描仪、监视器和打印机。\n- 很适合计算机描述颜色的范围。\n\n### CIE XYZ\n\nXYZ 三刺激值的概念是以色视觉的三元理论为根据的，它说明**人眼具有接受三原色(红、绿、蓝)的接受器**，而所有的颜色均被视作该三原色的混合色。\n\nCIE 制定了一种配色函数，能和 RGB 通过矩阵运算进行转化。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191400975.png\" alt=\"image-20251109191400975\" style=\"zoom:40%;\" />\n\n**颜色的概念可以分为两部分：亮度（光的振幅，即明暗程度）、色度（光的波长组合，即具体某种颜色）。**我们将光的亮度 Y 变量分离出来，之后用比例来表示三色刺激值：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191459184.png\" alt=\"image-20251109191459184\" style=\"zoom:60%;\" />\n\n可以发现，r、g、b 三者和为 1，只要知道其中两个就能求出另外一个。然后再和光的亮度 Y 结合起来，就能绘制 Yxy 颜色空间。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109191806008.png\" alt=\"image-20251109191806008\" style=\"zoom:50%;\" />\n\n### CIE L\\*a\\*b\\*\n\nL\\*a\\*b\\* 颜色空间是在 1976 年制定的，它是 CIE XYZ 颜色模型的改进型，以便**克服 Yxy 颜色空间存在的在 x、y 色度图上相等的距离并不相当于所觉察到的相等色差的问题**。同样是一种描述人类视觉感知的、设备无关的颜色模型。\n\nL\\*a\\*b\\* 的概念图：\n\n- **L：明亮度。**\n- **a：从绿色到红色。**\n- **b：从蓝色到黄色。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109192447257.png\" alt=\"image-20251109192447257\" style=\"zoom:50%;\" />\n\n**与 XYZ 比较，CIE L\\*a\\*b\\* 颜色更适合人眼的感觉。**\n\n利用 CIE L\\*a\\*b\\*，颜色的亮度（L）、灰阶和饱和度（a、b）可以单独修正，这样，图像的整个颜色都可以在不改变图像或其亮度的情况下，发生改变。\n\n## YUV\n\n“Y” 表示明亮度（Luminance），“U” 和 “V” 分别表示色度（Chrominance）和浓度（Chroma)。\n\n**采用 YUV 颜色空间的重要性是它的亮度信号 Y 和色度信号 U、V 是分离的。**这样能**解决彩色电视机和黑白电视机的兼容问题**，使黑白电视机也能接收到彩色信号。如果只有 Y 信号分量而没有 U、V 分量，那么这样表示的图就是黑白灰度图。\n\n## 各种颜色模型之间的转换\n\n各种颜色模型之间的转换一般是以 **RGB 和 CIE XYZ** 作为桥梁进行的。\n\n这个图里面，**左边（红色）部分都是设备相关的，右边（蓝色）部分都是设备无关的**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193132489.png\" alt=\"image-20251109193132489\" style=\"zoom:50%;\" />\n\n### RGB 和 CMY\n\nRGB 的取值通常是 0 ~ 255 的整数。\n\n```markdown\nC = 255 – R\nM = 255 – G\nY = 255 – B\n```\n\n### RGB 和 HSV\n\n1. 查表法\n\n最可靠方法：\n\n把 RGB 坐标转换为 1931 CIE XYZ 系统中的 (x， y， Y) 坐标。根据 (x， y， Y) 查找对应表，得到相应的 (H， S， V) 坐标。逆向操作则可以从 HSV 坐标转换到 RGB 坐标。\n\nxyY 坐标与 HSV 坐标的对照表已由色度学实验得到。这种方法需要依赖对照表，比较笨重。\n\n2. 数学公式\n\n从 RGB 到 HSV：\n\n设 m=max(r, g, b)，n=min(r, g, b)。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193605016.png\" alt=\"image-20251109193605016\" style=\"zoom:80%;\" />\n\n从 HSV 到 RGB：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193725839.png\" alt=\"image-20251109193725839\" style=\"zoom:50%;\" />\n\n### RGB 和 CIE XYZ\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193801097.png\" alt=\"image-20251109193801097\" style=\"zoom:67%;\" />\n\n### CIE XYZ 和 CIE L\\*a\\*b\\*\n\nL 的范围是 0 ~ 100，a, b 的范围是 -300 ~ 300。从 -a 到 +a 表示绿到红过渡，-b 到 +b 表示蓝到黄过渡。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193926183.png\" alt=\"image-20251109193926183\" style=\"zoom:77%;\" />\n\n### RGB 和 CIE YUV\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109193949447.png\" alt=\"image-20251109193949447\" style=\"zoom:80%;\" />\n\n# 第三章 物体表示\n\n## 本章复习重点\n\n- 什么是建模坐标系，和世界坐标系的区别。\n- OBJ 数据结构。\n- 什么是 BREP，其结构中包含哪些信息。\n- 半边数据结构。\n- 多边形的优缺点。\n- Bézier 曲线优缺点。\n- NURBS 曲线和 B 样条曲线的改进是什么。\n- 参数曲线的优缺点。\n- 细分曲面的作用。\n- 细分曲面的原理。\n- Catmull-Clark subdivision。\n- 有哪些常见的细分规则。\n- 细分曲面的翼边存储。\n- 物体的 CSG 表示。\n- 什么是分形几何。\n- 分型维数计算。\n- L- 系统，能够用 L- 系统绘制物体。\n\n## 多边形\n\n### 坐标表示\n\n一些概念：\n\n1. 世界坐标系(WC)：场景参照坐标系，一个场景只有一个世界坐标系。\n2. 观察坐标系(VC)：根据场景观察时的视点和观察方向所建立的坐标系。\n3. 投影坐标(PC)：观察坐标系下场景的二维投影坐标。\n4. 设备坐标系(DC)或屏幕坐标系：该场景的世界坐标系描述转换为一个或多个输出设备参照系来显示。该坐标系依赖于具体的显示输出设备。\n5. 规范化坐标系(NC)：指独立于具体物理设备的一种坐标系，它的显示范围在 x 和 y 上都是 0 到 1，主要用于在计算机内部处理图形，对一个具体物理设备，NC 与 DC 仅仅是相差一个比例因子，NC可被看成是一个抽象的图形设备。 \n\n在一个世界坐标系中，由许多物体组成。不同物理的几何描述和空间坐标系密切相关，在不同坐标系中有着不同的表示方式。**选择某个空间坐标系能使得该物体的几何表示最简单，这就是建模坐标系。**\n\n例如，一个单位正方体在世界和建模坐标系中的不同表示如下。明显建模坐标系更简洁。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109202426738.png\" alt=\"image-20251109202426738\" style=\"zoom:67%;\" />\n\n建模坐标系除了形式简洁，还方便几何操作。在同一几何场景中，一个物体可能会多次出现，它们可以通过复制加变换的方式得到：标准体素＋变换＝新的物体。\n\n例如，以下是在建模和世界坐标系中旋转一个圆柱面。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109202703686.png\" alt=\"image-20251109202703686\" style=\"zoom:60%;\" />\n\n### 多边形表示\n\n物体的多边形表示是通过大量的平面片，三角形、四边形以及 n 边形。本质是**线性表示形式**。\n\n#### 数据来源\n\n一个物体经过三维测量和扫描以后，原始数据一般是三维空间中的点集。通过适当的重建算法得到其多边形的表示。\n\n常用物体外形用数学表示方法包括参数曲面、细分曲面、隐式曲面等。\n\n#### 表示方法：OBJ 格式\n\n**重点！！！**\n\n1. **顶点坐标表（x, y, z）：每个顶点处可能有多个平面片，一般情况下顶点数小于面片数。**\n2. **纹理坐标表（u, v）：控制纹理映射时纹理在表面上的位置。**\n3. **法向表 (nx, ny, nz) ：控制物体绘制时的着色光滑程度。如果顶点法向为取作该面片的法向，绘制出来的多边形物体棱角分明如果顶点法向是周围面片法向的某种平均，则绘制结果是光滑的。**\n4. **面表：由指向顶点、纹理坐标以及法向的指针组成。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109203355330.png\" alt=\"image-20251109203355330\" style=\"zoom:67%;\" />\n\n#### 数据结构\n\n##### BRep 表示\n\n**边界表示，也称为 BRep 表示**，它是几何造型中最成熟、无二义的表示法。**实体的边界通常是由面的并集来表示，而每个面又由它所在的曲面的定义加上其边界来表示，面的边界是边的并集，而边又是由点来表示的。**\n\n在边界表示法中，边界表示按照**体－面－环－边－点**的层次，详细记录构成形体的所有几何元素的几何信息及其相互连接的拓朴关系。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109203820619.png\" alt=\"image-20251109203820619\" style=\"zoom:60%;\" />\n\n1. 顶点：0 维度几何元素。\n2. 边：一维几何元素。对正则形体，边是两邻面的交集，对非正则形体，边有可能是多个邻面的交集。边的形状可以是直线，也可以是曲线。\n3. 环：二维几何元素。有序、有向边（直线段或曲线段）组成的面的封闭边界。外环边通常按逆时针方向排序，内环边通常按顺时针方向排序。\n4. 面：二维几何元素。可以无内环，但必须有且只有一个外环。面有方向性，一般用其外法线方向作为该面的正向。面的形状可以是平面，也可以是曲面。\n5. 体：三维几何元素。由封闭表面围成的空间，其边界是有限面的并集。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204101621.png\" alt=\"image-20251109204101621\" style=\"zoom:67%;\" />\n\n##### 半边数据结构\n\n半边结构（Half-Edge Structure）：可定向的二维流形及其子集。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204222651.png\" alt=\"image-20251109204222651\" style=\"zoom:55%;\" />\n\n每条边被记为两条半边，记录每条半边：\n\n- 起始顶点的指针。\n- 邻接面的指针(如果为边界，指针为 NULL)。\n- 下一条半边(逆时针方向)。\n- 相邻的半边。\n- 前一条半边(可选)。\n\n面：边界上的一条半边。\n\n顶点：\n\n- 坐标值。\n- 指向以此顶点为起始端点的半边。\n\n对于一个半边数据结构的简单形式，一个面仅仅需要储存一条围绕它的半边的指针。在半边数据结构中的点储存着 x，y，z 的位置和以其为起始点的半边的指针。\n\n一个半边结构的实例：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204623522.png\" alt=\"image-20251109204623522\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/09/image-20251109204648499.png\" alt=\"image-20251109204648499\" style=\"zoom:60%;\" />\n\n半边结构的优势和不足：\n\n- 优势：查询时间 O(1)， 操作时间 (通常) O(1)。\n- 缺点：只能表示**可定向流形**，信息冗余。\n\n#### 优势与不足\n\n优势：\n\n- **表示简单。**\n- **可以表示具有任意拓扑的物体。**\n- **可以表示具有丰富细节的物体。**\n- **大部分图形硬件支持多边形物体的加速绘制。**\n\n不足：\n\n- **逼近表示，难以满足交互时放大要求。**\n- **难以用传统方法修改(编辑)物体外形。**\n- **缺乏解析表达式，几何属性计算困难。**\n- **在表示复杂拓扑和具有丰富细节的物体时，数据量庞大，建模、编辑、绘制、存储的负担重。**\n\n## 参数曲面\n\n### 数学原理\n\n直线段的参数表示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120174021235.png\" alt=\"image-20251120174021235\" style=\"zoom:55%;\" />\n\n直线段参数表示的直观几何意义：\n\n- 参数空间中每一个参数(点)都对应于直线段上一个点。\n- 参数空间的两个端点对应于直线段的两个端点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120174302971.png\" alt=\"image-20251120174302971\" style=\"zoom:50%;\" />\n\n一般三维参数曲线形式：\n\n![image-20251120174343653](https://cdn.davidingplus.cn/images/2025/11/20/image-20251120174343653.png)\n\n- 参数空间中每一个 t 对应于曲线上一个点 R(t)。\n- 图形学中，参数空间通常是有限区间，此时参数曲线称为参数曲线段。\n- 图形学中，参数函数通常为分段多项式或有理多项式曲线。\n\n参数表示的平面：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120174425595.png\" alt=\"image-20251120174425595\" style=\"zoom:55%;\" />\n\n参数表示的曲面：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120174443843.png\" alt=\"image-20251120174443843\" style=\"zoom:55%;\" />\n\n参数表示的优势：\n\n- **参数表示是显式的。**\n  - 对每一个参数值，可以直接计算曲面上的对应点。\n  \n  - 参数表示的物体可以方便地转化为多边形逼近表示。\n  \n- 曲面上的**几何量计算简便**(微分几何)：法向、曲率、测地线、曲率线等。\n\n- **特殊形式的参数表示的外形控制十分直观。**Bézier、B- 样条、NURBS(Non-Uniform Rational B-Spline, 非均匀有理 B- 样条)曲线/曲面。\n\n### 参数曲线\n\n#### Bézier 曲线\n\n曲线长这样：\n\n![image-20251120174922835](https://cdn.davidingplus.cn/images/2025/11/20/image-20251120174922835.png)\n\n曲线定义：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120175318689.png\" alt=\"image-20251120175318689\" style=\"zoom:60%;\" />\n\n例如二次曲线，由三个控制点生成：\n$$\nB_{0,2}(t) = (1-t)^2\\\\\n\nB_{1,2}(t) = 2t(1-t)\\\\\n\nB_{2,2}(t) = t^2\n$$\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120175450363.png\" alt=\"image-20251120175450363\" style=\"zoom:65%;\" />\n\n曲线性质：\n\n- **Bézier 多项式次数 ＝ 控制点个数 - 1**\n- 端点插值：R(0)=R0，R(1)=Rn。**Bézier 曲线总是通过第一和最后一个控制点。**\n- 端点切向：R'(0)=n(R1−R0)，R'(1)=n(Rn−Rn-1)。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120175640951.png\" alt=\"image-20251120175640951\" style=\"zoom:50%;\" />\n\n- 剖分性质：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120175704101.png\" alt=\"image-20251120175704101\" style=\"zoom:50%;\" />\n\n曲线的不足：\n\n整体性质：当移动曲线的一个控制顶点时，整条曲线的形状都会发生改变。\n\n表示复杂形状时，需要将多条 Bézier 曲线光滑拼接起来，即 Bézier 样条曲线。\n\n- 位置连续：C0(或 G0)。\n- n 次导数(或几何)连续：Cn(或 Gn)。\n\n#### B- 样条曲线\n\n曲线长这样：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120175813919.png\" alt=\"image-20251120175813919\" style=\"zoom:50%;\" />\n\n曲线定义：\n\n**B- 样条曲线是分段连续的多项式曲线**，其定义与节点向量密切相关。\n\n设 U 是 n + 1 个非递减数的集合，u0 <= u1 <= u2 <= ... <= un。ui 称为节点，集合 U 称为节点向量，半开区间 [ui, ui+1) 是第 i 个节点区间。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120175923155.png\" alt=\"image-20251120175923155\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120175933719.png\" alt=\"image-20251120175933719\" style=\"zoom:50%;\" />\n\nK = 2 的均匀 B 样条基函数：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180040307.png\" alt=\"image-20251120180040307\" style=\"zoom:50%;\" />\n\nK = 3 的均匀 B 样条基函数：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180229605.png\" alt=\"image-20251120180229605\" style=\"zoom:50%;\" />\n\n曲线性质：\n\n- B- 样条曲线具有**凸包性和几何不变性**。\n- 当曲线的两个端节点的重复度 R=k-1 时，\n  - B- 样条曲线具有类似于 Bézier 曲线的性质：**端点插值**性质、**端点导数与控制的起始边与终止边相切**。\n  - 当 n=k-1 时，节向量有 2k 个,分别有 k 个节点在首尾固定，B- 样条曲线就是一条 Bézier 曲线。例如，三次（四阶）B- 样条，则节点向量 {0，0，0，0，1，1，1，1}。\n- **局部性**：当移动一个控制顶点时，只会影响曲线的一部分，而不是整条曲线。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180503397.png\" alt=\"image-20251120180503397\" style=\"zoom:50%;\" />\n\n优点：\n\n- B- 样条**曲线多项式独立于控制点数目**。\n- B- 样条允许**局部控制**曲线或曲面。\n\n缺点：\n\n- B- 样条比 Bezier 样条更复杂。\n\n#### NURBS 曲线\n\nB- 样条**不能精确表示二次曲面与平面的交线的情形**，如圆锥曲线(平面与圆锥的交线)。\n\nNUBRS：**非均匀有理 B- 样条**的简称。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180651137.png\" alt=\"image-20251120180651137\" style=\"zoom:50%;\" />\n\n曲线定义：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180724643.png\" alt=\"image-20251120180724643\" style=\"zoom:50%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180734103.png\" alt=\"image-20251120180734103\" style=\"zoom:53%;\" />\n\n曲线例子：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180757117.png\" alt=\"image-20251120180757117\" style=\"zoom:65%;\" />\n\n### 参数曲面\n\n#### Bézier 曲面\n\n曲面定义：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120180842130.png\" alt=\"image-20251120180842130\" style=\"zoom:50%;\" />\n\n曲面性质：\n\n- Bézier 曲面的**控制顶点所形成的控制网格大致反应了曲面的形状**，所以可通过编辑控制顶点的方式来实现对曲面形状的改变。\n- 在角点处曲面与控制多边形相切。\n- Bézier 曲面具有剖分算法：用加密的控制多边形来逼近显示 Bézier 曲面。\n\n曲面不足：\n\n- 全局性：当移动一个控制顶点的位置时，整个曲面的形状会发生改变，这对于外形设计是很不方便的。\n- 生成复杂外形需要多个 Bézier 曲面的光滑拼接，十分复杂。\n\n#### B- 样条曲面\n\n曲面定义：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120181024158.png\" alt=\"image-20251120181024158\" style=\"zoom:50%;\" />\n\n曲面性质：\n\n- 局部性质。\n- 控制顶点数目。\n- Bézier 曲面的次数确定后，控制顶点数目就定了。\n- B- 样条曲面的次数确定后，控制顶点数目可任意。\n- 其它性质：参考曲线情形。\n\n曲面不足：不能精确表示常用的二次曲面，如球面、圆柱面、圆锥面等。\n\n#### NURBS 曲面\n\nNURBS 曲面：\n\n- **增加了权因子作为形状控制手段。**\n- 包含 B- 样条曲面和 Bézier 曲面。\n- 可以精确表示机械零件中常用的**二次曲面**。\n\n## 细分曲面（Subdivision Surfaces）\n\n### 简介\n\n如何使得一条曲线变光滑？\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118200350174.png\" alt=\"image-20251118200350174\" style=\"zoom:40%;\" />\n\n**每次细分都是在每条边上插入一个新的顶点，可以看到随着细分次数的增加，折线逐渐变成一条光滑的曲线。**曲面细分需要有几何规则和拓扑规则，几何规则用于计算新顶点的位置，拓扑规则用于确定新顶点的连接关系。\n\n应用细分曲面做三维模型的原型设计非常的方便。通常只需要两个步骤，**先创建出模型的大致轮廓，然后设置需要切割的点线面**。比如这个桌子模型，先创建出它的轮廓模型，看起来非常简单，然后设置哪些点线面需要切割。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118201523267.png\" alt=\"image-20251118201523267\" style=\"zoom:50%;\" />\n\n关键问题：\n\n- 怎样计算曲面？使得物体平滑。\n- 怎样存储曲面？能够有效的实现曲面细分。\n\n**细分曲面的核心就一个点：细分规则。不同的细分规则，生成的细分曲面外形是有区别的。**常见的细分规则有 Catmull-Clark 细分，Doo-Sabin 细分，Loop 细分等。\n\n### Loop 细分\n\nLoop 细分是一种**三角形网格**的细分法则。\n\n如何细分？增加新的顶点（分裂阶段)，通过分边和连接顶点，将每个三角形分为 4 个三角形。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118201853173.png\" alt=\"image-20251118201853173\" style=\"zoom:65%;\" />\n\n平均阶段，移动新三角形和老三角形顶点，让细分结果更光滑。\n\n边界边、内部边、边界点、内部点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118202035263.png\" alt=\"image-20251118202035263\" style=\"zoom:55%;\" />\n\n两个新增顶点位置计算的规则：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118202154927.png\" alt=\"image-20251118202154927\" style=\"zoom:65%;\" />\n\n旧顶点位置更新的规则：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118202226942.png\" alt=\"image-20251118202226942\" style=\"zoom:65%;\" />\n\nLoop 细分方案对任意拓扑结构的多边形进行细分。细分粒度实现多个分辨率自由变换。\n\n### Catmull-Clark 细分\n\nCatmull-Clark 细分是一种**四边形网格**的细分法则，每个面计算生成一个新的顶点，每条边计算生成一个新的顶点，同时每个原始顶点更新位置。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118202429995.png\" alt=\"image-20251118202429995\" style=\"zoom:60%;\" />\n\n生成过程：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205017299.png\" alt=\"image-20251118205017299\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205030052.png\" alt=\"image-20251118205030052\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205043314.png\" alt=\"image-20251118205043314\" style=\"zoom:60%;\" />\n\n举例：\n\n下图为 Catmull-Clark 细分格式的细分掩膜，对于新增加的顶点位置以及原始顶点位置更新规则如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205403782.png\" alt=\"image-20251118205403782\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205455029.png\" alt=\"image-20251118205455029\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205541708.png\" alt=\"image-20251118205541708\" style=\"zoom:60%;\" />\n\n### Butterfly 细分\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205718308.png\" alt=\"image-20251118205718308\" style=\"zoom:50%;\" />\n\n### Doo-Sabin 细分\n\nDainel Doo 和 Malcolm Sabin 在 1978 提出的一种可以**对任意拓扑的网格进行细分**的一种算法，是**递归定义**的。\n\n- 原来的顶点变面（度为几，就是几边形）。\n- 边也变面。\n- 原来的面也变为新面。\n\n每次递归，计算**面的中心点和边的中心点**，对于每一个点 P，计算一个新的点 P’，是原顶点，相邻的边的中心点和面的中心点的平均值。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118205837875.png\" alt=\"image-20251118205837875\" style=\"zoom:55%;\" />\n\n**每次递归，对于每一个面，连接面内的新点生成新的面，对于每一个点，连接点周围的新点生成新的面，对于每一条边，连接边相邻的新点生成新的面。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118210010082.png\" alt=\"image-20251118210010082\" style=\"zoom:60%;\" />\n\n### 四种细分算法效果\n\nLoop 只能用于三角形网格。\n\nDoo-Sabin 可以运用于任意拓扑的网格。\n\nDoo-Sabin 的**计算效率**不如 Catmull-Clark。\n\n在 3D 计算机图形学中，Doo-Sabin 细分曲面是一种基于双二次均匀B样条推广的细分曲面，而 Catmull-Clark 基于广义双立方均匀 B 样条。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118210132265.png\" alt=\"image-20251118210132265\" style=\"zoom:60%;\" />\n\n### 多边形的面片\n\n面表示：\n\n- **独立面。**\n- **顶点和面表。**\n- **邻近边表。**\n- **翼边表示法。**\n\n#### 面表\n\n每个面表有顶点组成，冗余顶点，没有拓扑信息。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118210342698.png\" alt=\"image-20251118210342698\" style=\"zoom:70%;\" />\n\n#### 顶点表 & 面表\n\n每个面的顶点坐标。\n\n参考：共享顶点、**仍然没有拓扑信息**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118210448144.png\" alt=\"image-20251118210448144\" style=\"zoom:70%;\" />\n\n#### 邻接边表\n\n存储所有的点, 边, 面邻接关系。\n\n邻接：**有效保存拓扑信息**、带来额外存储。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118210620615.png\" alt=\"image-20251118210620615\" style=\"zoom:70%;\" />\n\n#### 翼边表示法\n\n- 将邻接关系存储在边信息中。\n- 所有邻接信息 O(1) 查询。\n- 较小的存储开销。\n- 任意形状的多边形。\n\n**对每条边，储存其两个顶点，左右两个面，左边面与之连接的两条边，右边面与之连接的两条边。**\n\n**对每个点，储存其对应的一个边索引。**\n\n**对每个面，储存其中的一个边索引。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118210728641.png\" alt=\"image-20251118210728641\" style=\"zoom:50%;\" />\n\n例子：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118210813939.png\" alt=\"image-20251118210813939\" style=\"zoom:60%;\" />\n\n优点：\n\n- **表现面的简单方法。**\n- **容易实现。**\n- **任意拓扑结构。**\n- **实现光滑曲面。**\n- **多分辨率。**\n\n难点：\n\n- **难于直观感受。**\n- **难于参数化计算。**\n- **难于交互。**\n\n## 隐式曲面\n\n几何物体的表示：\n\n- 参数曲面，如 Bezier 曲面、B 样条曲面、NURBS 曲面等。参数曲面在造型和动画设计中取得了非常大的成功，很多造型和动画系统都是基于 NURBS 曲面的。\n- 多边形网格(Polygon Mesh)。\n- 细分曲面(Subdivision Surface)。\n- 隐式曲面(Implicit surface, level set)。\n\n**隐式曲面很适合表示可变形和可变拓扑的物体**，因而对**动画**非常有用(如 morphing)。\n\n三维空间中的隐式曲面：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120155234934.png\" alt=\"image-20251120155234934\" style=\"zoom:60%;\" />\n\n与参数曲面相比，隐式曲面的优点：\n\n- 隐式曲面可以表示具有**复杂拓扑**的形状。\n  - NURBS 曲面只能表示拓扑等价于矩形的四边曲面。\n  - NURBS 曲面表示非退化封闭光滑曲面时，需要光滑拼接。\n- 隐式曲面比 NURBS 曲面更适合于进行**布尔运算、光线跟踪、点集判断**等。\n\n与参数曲面相比，隐式曲面的不足：\n\n- 隐式曲面表示不直观，**难以进行外形的交互修改**。NURBS 曲面的外形控制手段非常直观。\n- 隐式曲面通常**没有边界**，而 NURBS 曲面具有显式的边界。\n- 隐式曲面**难以直接进行显示**，而 NURBS 曲面则可以借助于剖分算法，对逼近多边形表示进行绘制。\n\n隐式化：从参数曲面到隐式曲面。\n\n- 消除 NURBS 曲面的两个参数 (u, v) 得到其隐式表示。\n\n参数化：从隐式曲面到参数曲面。\n\n- **并非所有的隐式曲面都可以参数化。**\n- **对于非退化的二次代数曲面和具有一个奇异点的三次代数曲面，可以进行有理多项式参数化。**\n\n图形学中常用的隐式曲面造型技术：\n\n- 基于骨架的隐式曲面造型。\n\n  - 基于点、线和面骨架的 Metaball 方法。\n\n  - 基于骨架的卷积曲面。\n\n- 树木造型：\n\n  - 利用其平滑的特性建模树木分叉的平滑过渡。\n\n  - BLOBTree。\n\n  - 通过布尔操作、融合操作、变形操作，拼接成一个复杂树状结构的隐式曲面。\n\n- 代数曲面片造型技术，包括二次代数曲面、A-Patch 方法等。\n\n隐式曲面的显示：\n\n- 多边形化：用平面多边形逼近隐式曲面，Marching Cube 方法。\n- 光线跟踪：生成高质量的图像。\n- 粒子系统：在隐式曲面上均匀布撒粒子。\n\n## 物体的 CSG 树表示\n\nCSG：Constructive Solid Geometry\n\n- 表示实体：即有边界，也包含内部。\n- 表示边界：多边形、参数曲面、隐式曲面、细分曲面。\n\nCSG 树表示：面向浇铸、加工或拉伸等 CAD/CAM 过程。\n\nCSG 树：通过一系列几何操作将简单的**基本体素**组合起来。\n\n- 基本体素：立方体、球、圆柱、圆锥等。\n- 几何操作：\n  - 布尔运算：并、交、差、补等。\n  - 几何变换：平移、旋转、放缩、剪切等。\n\nCSG 树：含有丰富的造型信息。\n\n- 物体生成过程。\n- 物体表示。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120160629839.png\" alt=\"image-20251120160629839\" style=\"zoom:50%;\" />\n\nCSG 树的缺点：\n\n- 绘制耗时。\n- 限制了物体外形的修改。\n\n改进：**混合表示。将边界表示和布尔运算结合起来，形成一种边界表示和 CSG 实体表示之间的混合表示。**\n\n一个例子：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120161247669.png\" alt=\"image-20251120161247669\" style=\"zoom:50%;\" />\n\n## 自然景物表示方法\n\n### L- 系统\n\n三种常用方法：\n\n- 分形几何。\n- 基于语法规则的 L- 系统。\n- 粒子系统。\n\nL- 系统：\n\n- 语法规则：根据语法规则对所给字符进行迭代生成新字符串，每次迭代结果称为一代。\n- 字符解释：将字符串中的字符解释为适当的几何体素，就可以得到一个基于语法规则生成的物体。\n\nL- 系统成功地用于**植物建模**。\n\n一个例子：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120161706063.png\" alt=\"image-20251120161706063\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/20/image-20251120161806638.png\" alt=\"image-20251120161806638\" style=\"zoom:65%;\" />\n\n在 L- 系统中引入更多控制：\n\n- 不同“代”之中的字符的不同解释。(n+1) 代的树枝要比 n- 代的树枝细一些、短一些。\n- 终止节点处赋予树叶和花朵。\n\n### 粒子系统\n\n粒子系统：\n\n- 由一组随时间变化的粒子组成。\n- 粒子的变化由某种随机统计规律控制。\n- 粒子有生命：产生、发展（运动）、消亡。\n- 按照确定或随机运动规律进行运动。\n\n模拟火、雾、烟、焰火等**外形随时间的变化而变动的模糊物体**。\n\n粒子系统是一个**动态变化**的系统，生成其中每一瞬间画面的步骤：\n\n- 产生新的粒子并加入系统中。\n- 赋予每一个新粒子一定的属性。\n- 删除那些已经超过其生命周期的粒子。\n- 根据**粒子运动属性**对粒子进行移动和变换。\n- 绘制并显示出所有有生命粒子组成的画面。\n\n粒子系统被用来描述自然界大量的随机的运动方式。最直观的例子就是雨雪、飘落的树叶、还有节日的烟花。\n\n粒子系统的例子很多，几乎每部游戏都有粒子系统的应用，粒子系统是游戏中相当出彩的地方。就如同帧动画特效的秩序运动一样，粒子系统事实上体现了游戏世界的乱序，而这种乱序是真实世界必不可少的。\n\n粒子系统并不适于描述少量非随机的运动方式，在有些情况下，使用粒子系统并不比使用帧动画更好，那么在这种情况下，不妨使用帧动画来提高一些效率。\n\n粒子系统对游戏效率的压力是比较高的。这主要是因为大部分粒子系统都要求动态 VB 的缘故。\n\n粒子系统，从其功能而言包括如下部分：\n\n- **发射某一类粒子的发射器，Emitter。**\n- **被发射的粒子，Particle。**\n- 以上两者是最核心的部分，还有为了方便扩展而设置的影响器，Affector。\n\nEmitter 用于发射 Particle。事实上，Emitter 就是一组配置的集合，Particle “出生”时的状态被 Emitter 的配置所决定。\n\nEmitter 过于臃肿对于扩展是很不利的，因此有些人想出了 Affector 的方法，以使得扩展性得到满足。扰动子 Affector 是一类附加修缮配置的统称，主要包括粒子生成和运行的因素。\n\n### 分形\n\n分形分类：\n\n- **自相似分形**：组成部分是整个物体的收缩形式。\n- **自仿射分形**：组成部分为不同坐标方向上的不同缩放因子形成。\n- **不变分形集**：由非线性变换形成。\n  - 自平方分形。\n  - 自逆分形：由自逆过程形成。\n\n普通几何学研究的对象，一般都具有整数的维数。比如，零维的点、一维的线、二维的面、三维的立体、乃至四维的时空。但是现实生活中象弯弯曲曲的海岸线这些对象就不能用传统欧几里德几何学的整数维描述或者说测量了。**要描述这一大类复杂无规的几何对象，就引入了分形理论，把维数视为分数维数。**这是几何学的新突破，引起了数学家和自然科学者的极大关注。\n\n**分形的本意是不规则的、破碎的、分数的。是指以非整数维形式填充空间的形态特征。**分形几何通俗一点就是研究无限复杂但具有一定意义下的自相似图形和结构的几何学，基本思想是**客观事物具有自相似的层次结构，局部与整体在形态、功能、信息、时间、空间等方面具有统计意义上的相似性，称为自相似性**。\n\n如何计算分型维数？\n\n如果**某图形是由把原图缩小为 1/a 的相似的 b 个图形所组成**，有：\n$$\na^D=b, D=logb/loga\n$$\n则指数 D 称为相似性维数，D 可以是整数，也可以是分数。\n\n**分形体没有特征尺度，不能用一般测度即长度、面积、体积这类几何对象的特征量来表示**，只能用分形维数(Fractal dimension，也即“分维”)来度量，因而分维已成为描述无标度现象的特征参数。\n\n分形树：以自然界中的丫字形树杈为生成元，将生成元在每一个层次上不断重复，会得到分形树。\n\n分形树实现算法：递归算法、LS 文法、迭代函数系统算法。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/10/image-20251110095509626.png\" alt=\"image-20251110095509626\" style=\"zoom: 50%;\" />\n\n“递归”，这两个字用得十分好。递，即依次递变；归，即向一个方向归拢。“分形”，故名思议是指把一个形状细分为同样的形状。\n\n分形几何的主要特征：\n\n- **自相似性质**：分形物体的任何一个部分都和物体整体具有某种程度的相似。\n- **无限小细节性质**：当无限地放大分形物体时，物体总是表现有细节，而不是像欧氏空间的物体一样最终会表现出光滑性。\n- **维数非整数**。\n\n分形的自我相似，自我复制和自我嵌套用递归算法来实现是合适的，事实上经典分形图的绘制大多数可采用**递归算法**。一个很经典的例子就是 Koch 雪花曲线。\n\n![image-20251110095853380](https://cdn.davidingplus.cn/images/2025/11/10/image-20251110095853380.png)\n\n\n\n计算 Koch 的分形维度。Koch 曲线是把一条直线缩小为 1/3 的相似的 4 个图形组成，根据定义是 log4/log3。\n\n分形艺术的特点：\n\n- 自相似性。\n- 极小性。\n- 嵌套性。\n- 缠绕性。\n\n# 第四章 图形渲染通道\n\n## 本章复习重点\n\n- 掌握图形渲染通道由那几个部分组成。\n- 每一个功能点的作用。\n\n## 渲染\n\n渲染：通过几何物体生成真实可见图像的过程。\n\n用点线面描述物体：\n\n- 融合了数学表达。\n- 物体集合的代表。\n\n渲染物体：\n\n- 渲染通道 render pass (Vulkan)。\n- 渲染管线 rendering pipeline (OpenGL)。\n  - 立即渲染模式（Immediate mode，也就是固定渲染管线）。\n  - 核心模式(Core-profile, V 3.2)。\n\n3D 渲染管线的三个阶段：\n\n- 应用阶段：模型、数据读取、交互。\n- 几何阶段。\n- 光栅化阶段。\n\n## 照相机模型\n\n最通用的模式是**小孔成像模型**。所有捕捉到的光线都沿着指向焦点的路径到达，没有镜头变形（所有物体都处于焦点位置）。传感器响应与射线成比例。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111190809048.png\" alt=\"image-20251111190809048\" style=\"zoom:60%;\" />\n\n### 照相机参数\n\n内参：在小孔成像模型中有一个光点P，其将光以直线的方式穿过纸板的小孔(光心），射到显示纸板（物理成像平面）上，其坐标系结构如下图所示。而内参的作用即是在知道P的x、y、z后可以求出x\\`、y\\`。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191053719.png\" alt=\"image-20251111191053719\" style=\"zoom:60%;\" />\n\n外参：假象你的头部就是三维世界的中心，相机、篮球都有一个坐标，但是现在要知道的是相机中照片中的篮球的一个点的位置，因此应该将以你头部为中心的世界转换为以相机焦点为中心的世界，这样不就更直观了么。所以第一步就是求外参矩阵，然后把 xw,yw,zw 转换为以相机为中心的世界中的坐标 xc,yc,zc。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191229526.png\" alt=\"image-20251111191229526\" style=\"zoom:60%;\" />\n\n第二步，就是小孔成像问题，将转换为相机为中心世界的 xw,yw,zw，利用相机内参转换为图片中的点的位置，在将图片中的点转换为是哪个像素（像素坐标）。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111191302377.png\" alt=\"image-20251111191302377\" style=\"zoom:67%;\" />\n\n## 渲染通道\n\n经典的 3D 渲染通道：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192044693.png\" alt=\"image-20251111192044693\" style=\"zoom:55%;\" />\n\n### 模型变换\n\n将所有场景中的点 3D 世界变换到世界坐标系。大小缩放、平移、旋转物体，**建模（局部）坐标系 -> 世界坐标系**。\n\n### 光线模拟\n\n光照参数：光源发散、表面反射、大气衰减、相机感应。\n\n直接光照模型、全局光照模型。\n\n### 取景转换\n\n旋转转换世界坐标系为相机坐标系。**世界坐标系 -> 视点坐标系**。\n\n### 裁剪\n\n去掉视点窗口外的几何物体部分。\n\n### 投影变换\n\n应用透视原理。**视点坐标系 -> 图像坐标系**。\n\n### 光栅化\n\n转换图像坐标系为像素和颜色。\n\n# 第五章 变换\n\n## 本章复习重点\n\n- 齐次坐标系及其作用。\n- 二维平移，旋转、缩放矩阵。\n- 理解模型变换、取景变换、投影变换、设备变换、视窗变换的作用。\n- 一点透视、两点透视、三点透视。\n\n## 几何（模型）变换\n\n### 基本变换\n\n#### 2D 平移\n\n图形对象沿直线运动产生的变换。\n$$\nx' = x + t_x\n\\\\\ny' = y + t_y\n\\\\\n\\\\\n\nP = \\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n\nP' = \\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n\nT = \\begin{bmatrix}\nt_x \\\\\nt_y\n\\end{bmatrix}\n\n\\\\\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n+\n\\begin{bmatrix}\nt_x \\\\\nt_y\n\\end{bmatrix}\n\\\\\n\nP' = P + T\n$$\n\n#### 2D 旋转\n\n图形对象沿圆弧路径运动产生的变换。\n\n基准点(pivot)，坐标原点或任意点。旋转角 θ。方向,约定：逆时针为正。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112104312207.png\" alt=\"image-20251112104312207\" style=\"zoom:67%;\" />\n\n$$\nP = \\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n\nP' = \\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n\nR = \\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\cos\\theta\n\\end{bmatrix}\n\n\\\\\n\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n\n=\n\n\\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta \\\\\n\\sin\\theta & \\cos\\theta\n\\end{bmatrix}\n\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n\n\\\\\n\nP' = R \\cdot P\n$$\n\n\n#### 2D 缩放\n\n改变图形对象大小的变换。\n\n$$\nP = \\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n\nP' = \\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n\nS = \\begin{bmatrix}\nS_x & 0 \\\\\n0 & S_y\n\\end{bmatrix}\n\n\\\\\n\n\\begin{bmatrix}\nx' \\\\\ny'\n\\end{bmatrix}\n\n=\n\n\\begin{bmatrix}\nS_x & 0 \\\\\n0 & S_y\n\\end{bmatrix}\n\n\\begin{bmatrix}\nx \\\\\ny\n\\end{bmatrix}\n\n\\\\\n\nP' = S \\cdot P\n$$\n\n2D 缩放讨论：\n\n1. 如果 |Sx| 或 |Sy| 大于 1，则表示图形在 X 轴方向或 Y 轴方向放大；\n2. 如果 |Sx| 或 |Sy| 小于 1，则表示图形在 X 轴方向或 Y 轴方向缩小；\n3. 如果 |Sx| = |Sy|，则表示均匀缩放；\n4. 如果 |Sx| < |Sy| 或 |Sx| > |Sy|，则表示差值缩放；\n5. 如果 |Sx| 或 |Sy| 等于 1，则表示图形在 X 轴方向或 Y 轴方向不变；\n6. 如果 Sx 或 Sy 小于零，则表示图形在 X 轴方向或 Y 轴方向作**镜面变换**。\n\n### 2D 矩阵表示\n\n对于平移、旋转和缩放变换，每个基本的变换都可表示为通用矩阵形式：\n\n$$\nP' = M1 \\cdot P + M2\n\n\\\\\n\nP’、P 表示变换前后两个点的坐标的列向量。\\\\\n\nM1 是一个包含乘法系数的 2×2 矩阵。\\\\\n\nM2 是一个包含平移项的两元素列矩阵。\n$$\n**齐次坐标**表示：基本思想是把一个 n 维空间的几何问题转换到 n+1 维空间中去。\n\n例如：二维空间中点的坐标(x, y)的齐次坐标表示为(h\\*x，h\\*y，h)(h≠0的任意实数)。只要给定一个点的齐次坐标表示(xh，yh，h)，就能得到唯一的笛卡儿坐标(x, y)。其中 x=xh/h，y=yh/h。\n\n一个笛卡儿坐标表示的点，用齐次坐标表示时，是无穷的（h 取值不同），但一个齐次坐标表示的点，用笛卡儿坐标表示时，是唯一的。\n\n齐次坐标表示不是唯一的，**通常当 h=1 时，称为规格化齐次坐标**。用齐次坐标技术，可改写平移变换、缩放变换和旋转变换为统一的乘积形式。\n\n规格化齐次坐标下的变换矩阵如下：\n\n1. 平移变换\n\n$$\nP' = T(t_x, t_y) \\cdot P\\\\\n\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 0 & t_x \\\\\n0 & 1 & t_y \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n$$\n\n2. 旋转变换（坐标原点为旋转中心）\n\n$$\nP' = R(\\theta) \\cdot P\\\\\n\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta & 0 \\\\\n\\sin\\theta & \\cos\\theta & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n$$\n\n3. 缩放变换\n\n$$\nP' = S(S_x, S_y) \\cdot P\\\\\n\n\\begin{bmatrix}\nx' \\\\\ny' \\\\\n1\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nS_x & 0 & 0 \\\\\n0 & S_y & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\n\\begin{bmatrix}\nx \\\\\ny \\\\\n1\n\\end{bmatrix}\n$$\n\n\n\n### 复合变换\n\n利用矩阵表示，就可通过计算单个变换的矩阵乘积，将任意顺序变换的矩阵建立为复合变换矩阵。\n\n#### 连续平移\n\n两个连续的平移向量(tx1, ty1)和(tx2, ty2)被用于点 P，那么最后的点坐标可计算为 \n$$\nP'\n= T(tx2, ty2) · { T(tx1, ty1) · P }\n= { T(tx2, ty2) · T(tx1, ty1) } · P\n$$\n计算时，可先计算两个平移变换矩阵的乘积。\n$$\nT(tx2, ty2) · T(tx1, ty1) = T(tx2 + tx1, ty2+ ty1)\n$$\n连续平移是可加的。\n\n#### 连续旋转\n\n应用于点 P 的两个连续旋转，得到的点P'的坐标可计算为 \n$$\nP' = R(θ2) · { R(θ1) · P } = {R(θ2) · R(θ1)} · P\n\\\\\nR(θ2) · R(θ1)= R(θ1+θ2)\n$$\n则P’的坐标可计算为\n$$\nP' = R(θ1+θ2) · P\n$$\n连续旋转是可加的。\n\n#### 连续缩放\n\n两个连续缩放操作的变换矩阵连接，产生的复合变换矩阵：\n$$\nS(sx2, sy2) · S(sx1, sy1) = S(sx1· sx2, sy1· sy1)\n$$\n连续缩放操作是相乘的，非叠加的。\n\n#### 通用基准点变换\n\n1. **平移使基准点移动到坐标原点。**\n2. **针对原点做指定变换。**\n3. **反向平移使基准点回到原始位置。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123329996.png\" alt=\"image-20251112123329996\" style=\"zoom:60%;\" />\n\n#### 通用方向变换\n\n1. **旋转对象使任意方向与坐标轴方向重合。**\n2. **针对坐标轴方向做指定变换。**\n3. **反向旋转使任意方向回到原方向。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123501361.png\" alt=\"image-20251112123501361\" style=\"zoom:50%;\" />\n\n#### 连接特性\n\n$$\nA*B*C = (A*B)*C = A*(B*C)\n\\\\\nA*B <> B*A\n$$\n\n\n\n### 复合二维变换\n\n平移、旋转和放缩矩阵通常记为 T、R 和 S。\n\n二维变换具有结合性：(AB)C=A(BC)。\n\n二维变换不具有交换性，一个例子是如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123813026.png\" alt=\"image-20251112123813026\" style=\"zoom:55%;\" />\n\n两个特殊的二维变换：\n\n1. 刚体变换\n\n可以分解为：平移和旋转的组合。\n\n物体的形状没有变化，位置和方位有变化。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123903470.png\" alt=\"image-20251112123903470\" style=\"zoom:67%;\" />\n\n2. 仿射变换\n\n可以分解为：平移、旋转和放缩的组合。\n\n保持点的共线性、长度的比例＝>平行线。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112123909492.png\" alt=\"image-20251112123909492\" style=\"zoom:67%;\" />\n\n### 3D 几何变换\n\n#### 3D 平移\n\n$$\n平移向量：t_x, t_y, t_z\n\n\\\\\n\nT = \\begin{bmatrix}\n1 & 0 & 0 & t_x \\\\\n0 & 1 & 0 & t_y \\\\\n0 & 0 & 1 & t_z \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n#### 3D 缩放\n\n$$\n缩放因子：S_x, S_y, S_z\n\n\\\\\n\nT = \\begin{bmatrix}\nS_x & 0 & 0 & 0 \\\\\n0 & S_y & 0 & 0 \\\\\n0 & 0 & S_z & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n针对给定点缩放（思路依旧是平移，然后按照原点缩放的方式，然后平移回去）：\n$$\n参数: s_x, s_y, s_z, (x_f, y_f, z_f)\n\n\\\\\n\n变换矩阵 M = T(x_f, y_f, z_f)S(s_x, s_y, s_z)T(-x_f,-y_f, -z_f)\n$$\n\n#### 3D 旋转\n\n1. 绕 Z 轴旋转\n\n绕 Z 轴旋转，Z 坐标不变，矩阵上只有 x, y 有因子。\n$$\nP' = R_z(\\theta) \\cdot P\\\\\n\nR_z(\\theta) =\n\\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta & 0 & 0\\\\\n\\sin\\theta & \\cos\\theta & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n2. 绕 X 轴旋转\n\n同理。\n$$\nP' = R_x(\\theta) \\cdot P\\\\\n\nR_x(\\theta) =\n\\begin{bmatrix}\n1 & 0 & 0 & 0\\\\\n0 & \\cos\\theta & -\\sin\\theta & 0\\\\\n0 & \\sin\\theta & \\cos\\theta & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n3. 绕 Y 轴旋转\n\n同理。\n$$\nP' = R_y(\\theta) \\cdot P\\\\\n\nR_y(\\theta) =\n\\begin{bmatrix}\n\\cos\\theta & 0 & \\sin\\theta & 0\\\\\n0 & 1 & 0 & 0\\\\\n-\\sin\\theta & 0 & \\cos\\theta & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n### 3D 复合变换\n\n一般 3D 物体旋转：\n\n- 旋转轴平行于坐标轴。\n- 旋转轴不平行于坐标轴。\n\n1. 旋转轴平行于坐标轴之一。\n\n- **平移使旋转轴与平行坐标轴重合。**\n- **完成指定旋转。**\n- **反向平移使回到原位置。**\n\n2. 旋转轴不平行于任何坐标轴。\n\n- **平移使旋转轴过原点。**\n- **旋转使旋转轴与坐标轴之一重合。**\n- **完成指定旋转。**\n- **反向旋转。**\n- **反向平移。**\n\n下面我们需要细细分析一下这个过程。\n$$\n旋转轴由两个坐标点确定\\\\\n\nP1(x1, y1, z1) -> P2(x2, y2, z2)\\\\\n\n\\\\\n\n旋转轴矢量\\\\\n\nV = P2－P1 = (Vx, Vy, Vz)\\\\\n\n\\\\\n\n沿旋转轴的单位向量\\\\\n\nu=V/|V| =(a, b, c)\\\\\n\na=(x2-x1)/|V|、b=(y2-y1)/|V|\\\\\n\nc=(z2-z1)/|V|\\\\\n\n|V| = sqrt(Vx2 + Vy2 + Vz2)\n$$\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112191648140.png\" alt=\"image-20251112191648140\" style=\"zoom:55%;\" />\n\n#### 第一步\n\n平移旋转轴矢量使其过原点。\n$$\nT_1 = \\begin{bmatrix}\n1 & 0 & 0 & -x_1 \\\\\n0 & 1 & 0 & -y_1 \\\\\n0 & 0 & 1 & -z_1 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n\n#### 第二步\n\n旋转物体使旋转轴与 z 轴重合。\n\n这一步又分为两小步：\n\n- 将向量 U 绕 x 轴旋转到 xz 平面上: Rx(α)。\n- 将向量 U 绕 y 轴旋转到 z 轴上: Ry(β)。\n\n第一小步，Rx(α)。\n\n**计算 α 的关键点是利用旋转角等于在 Y-Z 平面里的投影来计算。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112192902539.png\" alt=\"image-20251112192902539\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193020675.png\" alt=\"image-20251112193020675\" style=\"zoom:55%;\" />\n$$\nR_x(\\alpha) = \\begin{bmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & c/d & -b/d & 0 \\\\\n0 & b/d & c/d & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n第二小步，Ry(β)。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193438032.png\" alt=\"image-20251112193438032\" style=\"zoom:55%;\" />\n\n注意在我们假想的正方向情境下，绕 y 轴旋转是顺时针，是负方向，所以 sin(β)=-a。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112193451270.png\" alt=\"image-20251112193451270\" style=\"zoom:55%;\" />\n$$\nR_y(\\beta) = \\begin{bmatrix}\nd & 0 & -a & 0 \\\\\n0 & 1 & 0 & 0 \\\\\na & 0 & d & 0 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n#### 第三步\n\n完成指定旋转 Rz(θ)。\n$$\nR_z(\\theta) =\n\\begin{bmatrix}\n\\cos\\theta & -\\sin\\theta & 0 & 0\\\\\n\\sin\\theta & \\cos\\theta & 0 & 0\\\\\n0 & 0 & 1 & 0\\\\\n0 & 0 & 0 & 1\n\\end{bmatrix}\n$$\n\n#### 第四步\n\n反向旋转使旋转轴回到原始方向。\n$$\nR_y(-β)= R_y^{-1}(β)\n\\\\\nR_x(-α)= R_x^{-1}(α)\n$$\n\n#### 第五步\n\n反向平移使旋转轴回到原始位置。\n$$\nT_2 = \\begin{bmatrix}\n1 & 0 & 0 & x_1 \\\\\n0 & 1 & 0 & y_1 \\\\\n0 & 0 & 1 &z_1 \\\\\n0 & 0 & 0 & 1\n\\end{bmatrix} = T_1^{-1}\n$$\n整个过程的流程图如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112191212935.png\" alt=\"image-20251112191212935\" style=\"zoom:55%;\" />\n\n## 观察（取景）变换\n\n观察平面和观察坐标系的确定。\n\n- 观察平面：也叫投影平面。\n- 观察坐标系：用来指定观察者的观察位置及投影平面的参照系。\n\n观察坐标系的建立：\n\n- 观察参考点 Pref，观察坐标原点 P0。\n- 观察平面法向量 N。观察 Zv 轴的正方向和观察平面方向。Zview = N = P0 - Pref\n- 建立 Yview 轴的正方向，将 V 在观察平面上投影，即可得到 Yview 轴。\n- 指定观察向上向量，只要与 N 不平行，如：Vup = (0,1,0)。\n- 利用右手原则得到 Xview, Yview。X_view = V_up×Z_view，Y_view = Z_view×X_view。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113165742798.png\" alt=\"image-20251113165742798\" style=\"zoom:50%;\" />\n\n视点坐标系：\n\n- 视点坐标系定义于世界坐标系中。\n- 类似拍照片：\n  - 照相机镜头的朝向：视线方向。\n  - 照相机的位置。\n  - UP 方向。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113170551868.png\" alt=\"image-20251113170551868\" style=\"zoom:60%;\" />\n\n视点坐标系的交互建立：\n\n- 坐标原点 C = (Cx, Cy, Cz)：相机的位置。\n\n- 单位向量 N = (Nx, Ny, Nz)：镜头的朝向。\n- 与 N 不平行的向量 UP：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113170801982.png\" alt=\"image-20251113170801982\" style=\"zoom:65%;\" />\n\n- 得到两个向量 U = (Ux, Uy, Uz) 和 V = (Vx, Vy, Vz)，然后单位化。\n- 四个矢量 C、U、V、N 组成了视点坐标系。\n- 由世界坐标系到视点坐标系的取景变换，其中 (x, y, z, 1) 为世界坐标系中的点，(u, v, n, 1) 为视点坐标系中的点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113170841181.png\" alt=\"image-20251113170841181\" style=\"zoom:75%;\" />\n\n## 投影变换\n\n### 投影分类\n\n- **平行投影：物体坐标位置沿平行线变换到观察平面上。**\n- **透视投影：物体坐标位置沿收敛于某点的直线变换到观察平面。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113171111232.png\" alt=\"image-20251113171111232\" style=\"zoom:60%;\" />\n\n二者的对比：\n\n- **平行投影保持对象相关比例，立体感不强，常用于建筑和工程制图。**\n- **透视投影符合人类的视觉特点，不保持对象的相关比例，但立体感较好。**\n\n投影的分类图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113171442051.png\" alt=\"image-20251113171442051\" style=\"zoom:55%;\" />\n\n### 平行投影\n\n正投影的投影向量垂直于观察平面，斜投影不垂直。\n\n正投影：\n\n- **正三面投影**：三视图（正视图、俯视图、侧视图），投影平面法向量与三个坐标轴之一**平行**。\n- **轴测正投影**：**显示物体多个侧面**的正投影。\n- **等轴测投影：投影平面与每个坐标轴的交点距原点距离相等。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113171910449.png\" alt=\"image-20251113171910449\" style=\"zoom:50%;\" />\n\n斜投影：\n\n- **斜等测投影**：α 等于 45°，生成的视图。**所有垂直于投影平面的线条投影后长度不变。**\n- **斜二测投影**：投影角满足 tanα=2(63.4°) 生成的视图。**垂直于投影平面的线条投影后得到一半长度。**\n\n### 透视投影\n\n透视投影是一种中心投影法。\n\n透视投影类型：\n\n- **灭点：3D 物体的一组平行线投影后收敛于一点，此点称为灭点。** \n- **主灭点：3D 物体平行于坐标轴的平行线收敛产生的灭点 -> 主灭点。**\n- **一点、二点、三点透视。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113172455456.png\" alt=\"image-20251113172455456\" style=\"zoom:55%;\" />\n\n<img src=\"./计算机高级图形学 期末复习.assets/image-20251122164955611.png\" alt=\"image-20251122164955611\" style=\"zoom:57%;\" />\n\n<img src=\"./计算机高级图形学 期末复习.assets/image-20251122165002544.png\" alt=\"image-20251122165002544\" style=\"zoom:60%;\" />\n\n<img src=\"./计算机高级图形学 期末复习.assets/image-20251122165008461.png\" alt=\"image-20251122165008461\" style=\"zoom:60%;\" />\n\n投影中心与投影平面之间的距离为有限的，例如室内白炽灯的投影，视觉系统等。特点是产生**近大远小的视觉效果**，由它产生的图形深度感强，看起来更加真实。 \n\n透视投影点坐标计算：\n\n1. 假定投影参考点在 z 轴 的（xprp, yprp, zprp)，投影平面在 zvp，直线参数方程为：\n\n$$\nx_r = x - (x - x_{prp})u\\\\\ny_r = y - (y - y_{prp})u\\\\\nz_r = z - (z - z_{prp})u\\\\\n\nu 的取值范围为 [0,1], (x_r, y_r, z_r) 代表投影线上任意点。\n$$\n\n2. 投影点的 Z 坐标是 Zvp，计算 u：\n\n$$\nu = (z_{vp} - z) / (z_{prp} - z)\n$$\n\n3. 计算投影点的 X、Y 坐标，带入 u 即可。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113172932538.png\" alt=\"image-20251113172932538\" style=\"zoom: 67%;\" />\n\n#### 透视投影变换矩阵\n\n透视投影变换矩阵，当其中的元素（p , q , r)取非全 ０ 时，能产生透视效果。\n\n![image-20251113173510466](https://cdn.davidingplus.cn/images/2025/11/13/image-20251113173510466.png)\n\n1. 一点透视\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113173737378.png\" alt=\"image-20251113173737378\" style=\"zoom:55%;\" />\n\n现在来对 Ｙ 的取值情况进行讨论：\n\n- 当 y = 0（在 X0Z 坐标平面内）：[x’ y’ z’ 1] = [x 0 z 1]。\n- 当 y 趋于无穷：[x’ y’ z’ 1] = [0  1/q  0  1]。\n\n当 Ｙ 值无限变大时，所有点经过变换后均集中于 Ｙ 轴上的 1/q 处，于是所有平行于 Ｙ 轴的直线将延伸相交于此点。该点(0，1/q，0)称为灭点。形成一个灭点的透视称为一点透视。为了取得较好的效果，取 q<0。（让灭点位于Ｙ轴的负半轴上）\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174102380.png\" alt=\"image-20251113174102380\" style=\"zoom:65%;\" />\n\n2. 两点透视\n\n如果在 p , q , r 中有两个非 ０ 元素，这时将会产生两个灭点，得到的透视图称为两点透视，或称**成角透视**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174322785.png\" alt=\"image-20251113174322785\" style=\"zoom:55%;\" />\n\n3. 三点透视\n\n以此类推，当 p、q、r 三个元素全为非 0 时，变换的结果将形成三点透视。产生的三个灭点将分别位于 Ｘ 轴上的 1/p 处、Ｙ 轴上的 1/q 处和 Ｚ 轴上的 1/r 处。此时，投影平面与三坐标轴均不平行。这时的三组平行线均产生灭点。\n\n最后，可以简单的推断：\n\n- 与一个坐标轴垂直的平面作为投影平面的话，该平面上的投影一定是一点投影。\n- 与两个坐标轴相交且与第三个坐标轴不相交的平面作为投影平面的话，该平面上的投影一定是两点投影。\n- 与三个坐标轴都相交且不含有任何坐标轴的平面作为投影平面的话，该平面上的投影一定是三点投影。\n\n#### 透视图的生成\n\n1. 一点透视图\n\n在生成一点透视图时，为了避免特殊位置透视，使产生的透视图立体感较好，通常要在进行透视变换前先将立体平移到一个合适的位置（例如离开坐标系中心)，然后再进行透视变换。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174912026.png\" alt=\"image-20251113174912026\" style=\"zoom:67%;\" />\n\n2. 两点透视图\n\n先使立体绕 Ｚ 轴旋转一个角度 θ，以使得立体上原平行于坐标平面 XOZ 和 YOZ 的表面与投影面 XOZ 产生一定的倾斜角（成角透视），向 XOZ 投影面作透视投影。\n\n变换矩阵：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113174959778.png\" alt=\"image-20251113174959778\" style=\"zoom:55%;\" />\n\n在以上生成的变换矩阵中，有两个透视参数为非 ０（qsinθ, qcosθ)，故生成的透视图为两点透视。**在两点透视图中，只有原来与 Ｚ 轴平行的立体上的棱线仍旧保持与 Ｚ 轴平行，其余的棱线（例如原来与 Ｘ 轴及 Ｙ 轴平行的棱线）将倾斜（成角）。**\n\n3. 三点透视图\n\n类似的。先使立体绕 Ｚ 轴旋转一个角度 θ，再绕 Ｘ 轴旋转一个角度 Φ（类似于轴测变换），这样使得立体上原平行于三个坐标平面的表面均与投影面 XOZ 产生一定的倾斜角；向 XOZ 投影面作透视投影。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113175432804.png\" alt=\"image-20251113175432804\" style=\"zoom:67%;\" />\n\n## 设备变换\n\n在投影平面上，有一个矩形区域称为视窗。\n\n- “视域四棱锥” 图中的矩形。\n- 物体投影后：二维齐次坐标表示。\n\n**设备变换：投影后二维齐次坐标除以最后一个坐标分量 w，便得到了规格化设备坐标。**\n\n## 视窗变换\n\n屏幕坐标系：通常以像素为单位。\n\n视窗变换\n\n- 二维变换：将定义在视窗中的规格化设备坐标转换到以像素为单位的屏幕坐标。\n- 扫描转换：将连续的几何物体转换为离散的光栅表示。\n\n## 三维变换流程图（牢记）\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/12/image-20251112195236840.png\" alt=\"image-20251112195236840\" style=\"zoom:50%;\" />\n\n这几个变换不同的作用总结：\n\n1. 模型变换（Model Transformation）\n   - 作用：**将物体从模型坐标系（物体自身的局部坐标）变换到世界坐标系**。意义：确定物体在整个三维场景中的位置、朝向和大小。\n   - 常见操作：平移、旋转、缩放。\n   - 举例：把一个立方体从原点移动到 (3, 0, 2)，并绕 y 轴旋转 45°。\n2. 取景变换（View Transformation）\n   - 作用：**将场景从世界坐标系变换到观察（摄像机）坐标系。**\n   - 意义：相当于“确定摄像机的视角”，即从哪个位置、方向去看这个世界。\n   - 实质：通过移动与旋转整个世界，让摄像机位于原点并面向 -Z 方向。\n   - 参数：通常由摄像机位置、目标点、上方向确定。\n3. 投影变换（Projection Transformation）\n   - 作用：**把三维场景投影到二维平面（视平面）。**\n   - 分类：\n     - 透视投影：近大远小，符合人眼视觉。\n     - 平行投影：无透视变化，保持比例，用于工程绘图。\n   - 结果：将三维点转为“规范立方体空间”（裁剪空间），为后续设备映射做准备。\n4. 设备变换（Device Transformation）\n   - 作用：**将投影后的坐标标准化为设备坐标**（NDC，Normalized Device Coordinates）。\n   - 意义：将投影结果进行透视除法（除以齐次坐标 w）得到规格化设备坐标，便于硬件统一处理。\n5. 视窗变换（Viewport Transformation）\n   - 作用：**将设备坐标映射到屏幕坐标（像素坐标）。**\n   - 意义：确定最终图像显示在屏幕上的具体位置与大小。\n   - 最终输出：屏幕上可见的二维图像。\n\n# 第六章 裁剪\n\n## 本章复习重点\n\n- 二维剪裁和三维剪裁在渲染 pipeline 中的位置。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190221289.png\" alt=\"image-20251113190221289\" style=\"zoom:60%;\" />\n\n- Cohen-Sutherland 裁剪算法。\n- 中点分割算法。\n- 梁友栋剪裁方法。\n\n## 关于裁剪\n\n裁剪\n\n- 二维线裁剪。\n- 二维多边形裁剪。\n- 文本裁剪。\n- 三维裁剪。\n\n裁剪是确定场景或画面中位于给定区域(2D 或 3D 裁剪窗口)之内的部分。\n\n裁剪还可用于图形反走样、隐藏线、隐藏面、阴影、纹理等算法中。\n\n裁剪推广应用：\n\n- 多面体对多面体的裁剪，实体造型系统中执行布尔运算。\n- 在窗口系统中复制、移动或删除画面中某一部分(Cut-Copy-Paste)。\n\n## 二维线裁剪\n\n图形裁剪的策略：\n\n- 先变换后裁剪：将图形经过扫描转换后变成像素的集合，然后对图形中的每一个像素进行裁剪。\n- 先裁剪后变换：**将原始图形进行裁剪，保留窗口内的可见部分，舍弃窗口外的不可见部分。然后对窗口内保留的这部分图形进行扫描转换。**\n- 先裁剪后变换！可以省去许多不必要的扫描转换的工作。\n\n### 点的裁剪\n\n对于一点 P(x,y)，要判断其是否可见：\n$$\nx_{min} \\le x \\le x_{max}\\ and\\ y_{min} \\le y \\le y_{max}\n$$\n满足上述不等式组的点则在窗口范围内，则保留；反之，该点落在窗口外，应裁剪。\n\n### 直线的裁剪\n\n对于矩形窗口，任何直线至多只有一段处于该窗口之内，即在此窗口范围内永远不会产生一条直线的两条或更多的可见部分线段。\n\n基本思想是判断直线与窗口的位置关系，确定该直线是完全可见、部分可见或完全不可见，输出处于窗口内线段的端点，并显示此线段。\n\n#### Cohen-Sutherland 裁剪算法\n\n对矩形窗口的不同区域进行编码：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113184303324.png\" alt=\"image-20251113184303324\" style=\"zoom:67%;\" />\n\n编码规则：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113184321649.png\" alt=\"image-20251113184321649\" style=\"zoom:55%;\" />\n\n算法运行过程：\n\n1. 若某线段两个端点的四位二进制编码全为 0000，线段位于窗口内，显示之。\n2. 若对两端点的四位二进制编码进行逻辑与运算（&）结果不为 0，线段位于窗口外，直接舍弃。\n3. 若线段既不能直接保留，也不能直接舍弃，它可能与窗口相交。这个时候对线段进行再分割，并找到与窗口边线的一个交点，根据交点位置，赋予 4 位二进制编码。对分割后的线段，舍弃一定在窗口外部分，另一部分做进一步检查。\n\n求交的过程：\n\n1. 将两个端点的编码 CtCbCrCl 进行逻辑或操作。\n2. 根据其结果中 1 的位置来确定可能相交的窗口边。\n3. 求交按照固定的顺序来进行（左右下上或上下右左）。\n4. 一条线段与窗口最多求交 4 次。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113184821113.png\" alt=\"image-20251113184821113\" style=\"zoom:55%;\" />\n\n特点：简单，易实现。依次裁剪在窗口外部分，直到直线完全处于窗口内。快速判断线段的完全可见和显然不可见，巧妙的编码方法。\n\n#### 中点分割算法\n\n与 Cohen-Sutherland 裁剪算法类似，但是求交的过程不同。\n\n中点将线段分割为两个部分，必然有一个部分存在最近可见点（交点）。**保留存在最近可见点部分，舍弃另一部分。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113185219153.png\" alt=\"image-20251113185219153\" style=\"zoom:55%;\" />\n\n求出中点以后，如何判断应该舍弃线段的哪个部分呢？\n\n1. 若如果 P1 与 P 同侧，移动 P1 点；（即可能的交点只能出现在 PP2 段，此时的新线段是 PP2，相当于 P1 移动打了 P）。\n\n```cpp\nif ( (C1 & C) != 0 ) P1 = P;\n```\n\n2. 若 P1 与 P 不同侧，移动 P2 点。（即可能的交点只能出现在 P1P 段）。\n\n```cpp\nif ( (C2 & C) != 0 ) P2 = P;\n```\n\n3. 然后，将中点分割进行到底！最终收敛到最近可见点！\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113185433780.png\" alt=\"image-20251113185433780\" style=\"zoom:67%;\" />\n\n特点：\n\n- 求交点的次数（n）与线段长度（L)有关，其关系为：L=2^n 。线段长度为 256，则求交点的次数为 8。\n- **求出的交点是边界上的有效交点（最近可见点），而非边界及其延长线上的交点。**这点与 Cohen-Sutherland 算法不同。\n- 使用加法和除法，硬件容易实现。\n\n#### 梁友栋-Barsky 裁剪算法\n\nTODO。\n\n## 二维多边形裁剪\n\n多边形的各条边是顺次连接。\n\n直线裁剪：\n\n- 把一条线段的两个端点孤立考虑，会产生孤立线段。\n- 裁剪之后各条边不一定能保持原来的连接顺序。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190557762.png\" alt=\"image-20251113190557762\" style=\"zoom:55%;\" />\n\n多边形可以描述为一组顶点按一定顺序连接而成的有向点列。一般可将多边形的顶点按逆时针方向顺序形成有向线段，进而连接成一个环来描述多边形的组成。数据结构上，可用链表结构来描述。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190736546.png\" alt=\"image-20251113190736546\" style=\"zoom:60%;\" />\n\n### Sutherland-Hodgman 算法\n\n每次用窗口的一条边界对多边形进行裁剪。把落在窗口外部的图形去掉，落在窗口内部的图形保留。并把它作为下一次待裁剪的多边形。连续用窗口的四条边界对原始多边形进行裁剪后，最后得到的就是裁剪后的结果多边形。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113190828219.png\" alt=\"image-20251113190828219\" style=\"zoom:55%;\" />\n\n对**凸多边形**应用本算法可以得到正确的结果，但是**对凹多边形的裁剪将显示出一条多余的直线**。这种情况在裁剪后的多边形有两个或者多个分离部分的时候出现。因为只有一个输出顶点表，所以表中最后一个顶点总是连着第一个顶点。\n\n解决这个问题有多种方法，一是把凹多边形分割成若干个凸多边形，然后分别处理各个凸多边形。二是修改本算法，沿着任何一个裁剪窗口边检查顶点表，正确的连接顶点对。三就是 Weiler-Athenton 算法。\n\n### Weiler-Athenton 算法\n\n我们按照一个方向，将多边形和裁剪窗口的交点分成两类。一类是入点，即**裁剪多边形由该点进入裁剪窗口**（顺时针），如图中 a、c、e。另一类是出点，如图 b、d、f。\n\n算法从被裁剪多边形的一个入点开始，**碰到入点，沿着被裁剪多边形按顺时针方向搜集顶点序列；而当遇到出点时，则沿着裁剪窗口按顺时针方向搜集顶点序列**。\n\n按上述规则，**如此交替地沿着两个多边形的边线行进，直到回到起始点**。这时，收集到的全部顶点序列就是裁剪所得的一个多边形。\n\n由于可能存在分裂的多边形，因此算法要考虑：**将搜集过的入点的入点记号删去，以免重复跟踪**。将所有的入点搜集完毕后算法结束。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113191034786.png\" alt=\"image-20251113191034786\" style=\"zoom:55%;\" />\n\n执行过程如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113191950706.png\" alt=\"image-20251113191950706\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113191957562.png\" alt=\"image-20251113191957562\" style=\"zoom:55%;\" />\n\n特点：\n\n1. 裁剪窗口可以是矩形、任意凸多边形、任意凹多边形。\n2. 可实现被裁剪多边形相对裁剪窗口的内裁或外裁，即保留窗口内的图形或保留窗口外的图形，因此在三维消隐中可以用来处理物体表面间的相互遮挡关系。\n3. 裁剪思想新颖，方法简洁，裁剪一次完成，与裁剪窗口的边数无关。\n\n## 字符裁剪\n\n串精度裁剪，字符精度裁剪，以及笔画象素精度：将笔划分解成直线段对窗口作裁剪，构成字符最小元素裁剪。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113192136443.png\" alt=\"image-20251113192136443\" style=\"zoom:67%;\" />\n\n## 三维裁剪\n\n裁剪对象：线裁剪、面裁剪。\n\n裁剪窗口：规范的立方体、视域四棱锥。\n\n## 关于三维变换与裁剪\n\n什么时候裁剪？\n\n1. 投影之前裁剪：三维裁剪。\n\n优点：只对可见的物体进行投影，**提高消隐效率**。缺点：三维裁剪相对复杂。\n\n2. 投影之后裁剪：二维裁剪。\n\n优点：二维裁剪相对容易。缺点：**需要对所有的物体进行投影变换。**\n\n# 第七章 光栅化\n\n光栅化在三维变换流程图中的位置如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113192724362.png\" alt=\"image-20251113192724362\" style=\"zoom:60%;\" />\n\n## 本章复习重点\n\n- 区域填充算法及其递归函数实现。\n- 扫描线算法中如何判断一个点是在面内还是面外。\n- 分类的边表 ET 构建方法。\n- 活化边链表 AEL 构建方法。\n- 参考第 7 章案例。\n\n## 光栅图形的基本概念\n\n光栅图形：\n\n- 本质：点阵表示。\n- 特点：面着色，画面明暗自然、色彩丰富。\n- 与线框图相比：更加生动、直观、真实感强。\n\n图形学中多边形的两种表示方式：\n\n1. 顶点表示：用多边形的有序顶点序列表示多边形。\n\n优点：直观、几何意义明显、存储量小。缺点：难以判断哪些像素位于多边形内部、不能直接用多边形着色。\n\n2. 点阵表示：用位于多边形内部的像素集合来表示多边形。\n\n优点：便于用帧着色器（Frame Buffer）表示图形。面着色所需的图形表示。缺点：丢失几何信息、存储量大。\n\n多边形的扫描转换：把顶点表示转换为点阵表示。**从多边形的给定边界出发，求出其内部的各个像素。并给帧缓冲器中各个对应元素设置相应灰度或颜色。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113193344875.png\" alt=\"image-20251113193344875\" style=\"zoom:67%;\" />\n\n## 区域填充\n\n区域的表示：\n\n1. 内部表示：把给定区域内部的像素枚举出来。\n2. 外部表示：把区域边界上的像素枚举出来。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113193633027.png\" alt=\"image-20251113193633027\" style=\"zoom:55%;\" />\n\n区域填充的类型：\n\n1. 四连通区域：区域内任意两个像素，从一个像素出发，可以通过上、下、左、右四种运动，到达另一个像素。\n2. 八连通区域：区域内任意两个像素，从一个像素出发，可以通过水平、垂直、正对角线、反对角线八种运动，到达另一个像素。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113193704090.png\" alt=\"image-20251113193704090\" style=\"zoom:55%;\" />\n\n### 区域种子填充算法\n\n假设内部表示区域为 G，其中的像素原有颜色为 G0，需要填充的颜色为 G1。算法需要提供一个种子点(x, y)，它的颜色为 G0。以四连通区域为例。\n\n注意整个填充是一个**递归**的过程。考试写填充顺序的时候需要注意。\n\n1. 内部表示区域种子填充算法\n\n```cpp\nFlood_Fill_4(x, y, G0, G1)\n{\n    if (GetPixel(x, y) == G0) // GetPixel(x,y) 返回(x,y)的颜色\n    {\n        SetPixel(x, y, G1); // 将(x,y)的添上颜色G1\n        Flood_Fill_4(x - 1, y, G0, G1);\n        Flood_Fill_4(x, y + 1, G0, G1);\n        Flood_Fill_4(x + 1, y, G0, G1);\n        Flood_Fill_4(x, y - 1, G0, G1);\n    }\n}\n```\n\n2. 边界表示区域种子填充算法\n\n```cpp\nFill_Boundary_4_Connnected(x, y, BoundaryColor, InteriorColor)\n// (x,y) 种子像素的坐标；\n// BoundaryColor 边界像素颜色； InteriorColor 需要填充的内部像素颜色\n{\n    if (GetPixel(x, y) != BoundaryColor && GetPixel(x, y) != InteriorColor)\n    // GetPixel(x,y): 返回像素(x,y)颜色\n    {\n        SetPixel(x, y, InteriorColor); // 将像素(x, y)置成填充颜色\n        Fill_Boundary_4Connnected(x, y + 1, BoundaryColor, InteriorColor);\n        Fill_Boundary_4Connnected(x, y - 1, BoundaryColor, InteriorColor);\n        Fill_Boundary_4Connnected(x - 1, y, BoundaryColor, InteriorColor);\n        Fill_Boundary_4Connnected(x + 1, y, BoundaryColor, InteriorColor);\n    }\n}\n```\n\n## 多边形的扫描转换\n\n### 逐点判断算法\n\n逐个像素判别其是否位于多边形内部。\n\n判断一个点是否位于多边形内部：**射线法**。从当前像素发射一条不经过顶点的射线，计算射线与多边形的交点个数。**内部：奇数个交点，外部：偶数个交点**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113194409882.png\" alt=\"image-20251113194409882\" style=\"zoom:55%;\" />\n\n问题在于速度慢，并且没有考虑像素之间的联系。最终结论是不可取。\n\n### 连贯性\n\n扫描线算法充分利用了相邻像素之间的连贯性，避免了对像素的逐点判断和求交运算，提高了算法效率。\n\n各种连贯性：区域连贯性、扫描线连贯性、边的连贯性。\n\n#### 区域连贯性\n\n区域的连贯性是指多边形定义的**区域内部相邻的像素具有相同的性质**。例如具有相同的颜色。\n\n两条扫描线之间的长方形区域被所处理的多边形分割成若干梯形(三角形可以看作退化梯形)。梯形的底边为扫描线，梯形的腰为多边形的边或窗口边缘。\n\n梯形分为两类：多边形内部（图中红色）和多边形外部（图中绿色）。两类梯形在多边形内部相间排列(相邻的两个梯形必然有一个位于多边形内部，有一个在多边形外部)。\n\n如果上述梯形属于多边形内(外)，那么该梯形内所有点的均属于多边形内(外)。这样就把逐点判断转换成了区域判断。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113194626999.png\" alt=\"image-20251113194626999\" style=\"zoom:55%;\" />\n\n#### 扫描线连贯性\n\n交点序列：扫描线与多边形的交点个数为**偶数**(1, 2, 3, 4, 5, 6)（一进一出）。\n\n红色区间(1, 2)、(3, 4)、(5, 6)位于多边形内部。其余绿色区间位于多边形外部。两类区间相间排列。\n\n如果上述交点区间属于多边形内(外)，那么该区间内所有点均属于多边形内(外)。这样就把逐点判断转换成了区间判断。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113194859565.png\" alt=\"image-20251113194859565\" style=\"zoom:70%;\" />\n\n#### 边的连贯性\n\n相邻两条扫描线的 y 相差 1。相邻扫描线与多边形的同一条边的交点的关系如下：\n\n当知道扫描线与一条边的一个交点之后，通过上述公式可以通过增量算法迅速求出其他交点。\n$$\n\\frac{y_1 - y_{11}}{x_1 - x_{11}} = k\n\n\\\\\n\nx_1 = x_{11} + \\frac{1}{k}\n$$\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113195054747.png\" alt=\"image-20251113195054747\" style=\"zoom:60%;\" />\n\n**边的连贯性是连接区域连贯性和扫描线连贯性的纽带。**\n\n扫描线连贯性＋边连贯性＝区域连贯性\n\n#### 奇异点\n\n奇异点是**扫描线与多边形交交于多边形的顶点**。\n\n奇异点计为几个交点？\n\n- 扫描线 1：一个交点。\n- 扫描线 2：两个交点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113195642366.png\" alt=\"image-20251113195642366\" style=\"zoom:67%;\" />\n\n极值点：相邻三个顶点的 y 坐标满足如下条件，即**相邻三个顶点位于扫描线的同一侧**。\n$$\n(y{i-1} - y_i)(y_{i+1} - y_i) \\ge 0\n$$\n非极值点则反过来，相邻三个顶点位于扫描线的两侧。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113195845379.png\" alt=\"image-20251113195845379\" style=\"zoom:65%;\" />\n\n关于奇异点的处理，**在极值点处，按两个交点计算，在非极值点处，按一个交点计算**。\n\n实际计算前，奇异点(非极值点)的预处理。将扫描线上方线段**截断一个单位**，这样扫描线就只与多边形有一个交点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113200107564.png\" alt=\"image-20251113200107564\" style=\"zoom:50%;\" />\n\n### 多边形扫描转换算法\n\n核心思想(从下到上扫描)：\n\n1. 计算扫描线 y = ymin 与多边形的**交点**，通常这些交点由多边形的顶点组成。\n2. 根据多边形**边的连贯性**，按从下到上的顺序求得各条扫描线的交点序列。\n3. 根据**区域和扫描线的连贯性**判断位于多边形内部的区段。\n4. 对位于多边形内的直线段进行**着色**。\n\n算法实现的数据结构：\n\n1. **分类的边表 ET (Sorted Edge Table)：记录多边形信息。**\n2. **活化边链表 AEL (Active Edge List)：记录当前扫描线信息。**\n\n边的数据结构：\n\n1. ymax：边的上端点的 y 坐标。\n2. x：边的下端点 x 坐标，在活化边链表中，表示扫描线与边的交点的 x 坐标。\n3. dx：边的斜率的倒数。\n4. next：指向下一条边的指针。\n\n分类的边表 ET：按边的下端点的纵坐标*y*对非水平边进行分类的指针数组。\n\n1. 下端点的纵坐标 y 值等于 i 的边，归入第 i 类；\n2. 同一类中，各边按 x 值(x 值相等时，按 dx 的值)递增的顺序排成行；\n3. 水平边不加入分类边表中。\n\n**注意 P0 和 P4 是非极值点，所以按一个交点计算，在扫描转换的时候需要截掉底部一个像素的宽度，所以起始的坐标需要 y + 1。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202037218.png\" alt=\"image-20251113202037218\" style=\"zoom:55%;\" />\n\n活化边链表 AEL：由与当前扫描线相交的边组成。\n\n1. 记录了多边形的边沿扫描线的交点序列。\n2. 根据边的连贯性不断刷新交点序列。\n3. 基本单元是边(与扫描线相交的边)。\n4. 与分类边表不同：分类边表记录初始状态。活化边表随扫描线的移动而动态更新。\n\n注意 Xcur 填入的是扫描线和当前直线的交点的 x 坐标。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202210093.png\" alt=\"image-20251113202210093\" style=\"zoom:55%;\" />\n\n\n\n算法执行过程（我们只需要掌握写 ET 和 AEL 即可）\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202847977.png\" alt=\"image-20251113202847977\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202854415.png\" alt=\"image-20251113202854415\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202859369.png\" alt=\"image-20251113202859369\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/13/image-20251113202903871.png\" alt=\"image-20251113202903871\" style=\"zoom:60%;\" />\n\n优点：充分利用多边形的区域、扫描线和边的连贯性，避免了反复求交的大量运算。\n\n不足：算法的数据结构和程序结构复杂。对各种表的维持和排序开销太大，适合软件实现而不适合硬件实现。\n\n## 多边形的扫描转换与区域填充的比较\n\n基本思想不同：\n\n1. 多边形扫描转换将多边形顶点表示转换为点阵表示，扫描过程利用了多边形的各种连贯性。\n2. 区域填充只改变区域的颜色，不改变区域的表示方法。填充过程利用了区域的连贯性。\n\n对边界的要求不同：\n\n1. 多边形扫描转换只要求每一条扫描线与多边形有偶数个交点。\n2. 区域填充中，四连通区域必须是封闭的八连通边界。八连通区域必须是封闭的四连通边界。\n\n出发点不同：\n\n1. 区域填充：知道需要区域内一个种子点(复杂计算)。\n2. 多边形扫描转换：没有要求。\n\n# 第八章 隐藏面消除\n\n消隐在三位变换流程图中的位置如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115142526119.png\" alt=\"image-20251115142526119\" style=\"zoom:65%;\" />\n\n## 本章复习重点\n\n- 图像空间算法，及其特点。\n- 对象空间算法。\n- Z-buffer 算法，及其优缺点。\n- 如何检测后向面。\n- 画家算法原理，及其特性。\n- 二叉空间剖分树构建过程。\n- 二叉空间剖分树遍历过程。\n- Area Subdivision 算法原理。\n- 有哪些常用的消隐算法。\n\n## 消隐\n\n为什么要消除不可见部分？\n\n1. 怎加图形真实感。\n2. 减少歧义。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115142922319.png\" alt=\"image-20251115142922319\" style=\"zoom:67%;\" />\n\n排序：根据对象到视点的距离对场景中的对象进行排序。连贯性：区域中的像素通常表现出相似性。两者决定了消隐的效率。\n\n按输出形式分类：隐藏线、隐藏面。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115143110993.png\" alt=\"image-20251115143110993\" style=\"zoom:55%;\" />\n\n按消隐空间分类：图形空间消隐，景物/对象空间消隐。\n\n## 按照不同空间分类的两种算法\n\n**注意：这里是一种类型的算法，不是某个具体算法。**\n\n### 图像空间消隐算法\n\n**遍历图像中的每个像素，连接像素和视点找到最近的对象，计算像素的颜色。**\n\n![image-20251115143326362](https://cdn.davidingplus.cn/images/2025/11/15/image-20251115143326362.png)\n\n受分辨率限制。\n\n时间复杂度 O(nN)：\n\n- 每个像素都需对物体排序(能否采用连贯性)。\n- n: polygons 数。\n- N: 像素个数。\n\n示例算法：z-buffer, scan line algorithm。\n\n### 对象空间消隐算法\n\n对于世界坐标空间中的每个对象，确定其不被遮挡的部分，然后使用扫描转换算法查找像素。计算像素的颜色。\n\n![image-20251115143716749](https://cdn.davidingplus.cn/images/2025/11/15/image-20251115143716749.png)\n\n适合于精密的 CAD 工程领域。\n\n复杂度 O(n^2)：\n\n- n: 对象数\n\nBack surface culling(后向面剔除)。\n\n示例算法：画家算法。\n\n算法思想：**从视点向每个像素点发射射线，并找到第一个相交平面。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115145901088.png\" alt=\"image-20251115145901088\" style=\"zoom:60%;\" />\n\n后向面剔除：\n\nV：摄像机的视线。n：面法线。\n$$\nN \\cdot V<0：不可见\\\\\nN \\cdot V>=0：可见\n$$\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115150422326.png\" alt=\"image-20251115150422326\" style=\"zoom:55%;\" />\n\n如何计算 N？面上的两个边叉乘即可。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115150525265.png\" alt=\"image-20251115150525265\" style=\"zoom:50%;\" />\n\n局限性：**仅适用于凸多面体。不能处理遮挡。可以被用于预处理过程。**\n\n\n\n## Z-Buffer 算法（图形空间）\n\nFrame-buffer: 存储像素颜色值(帧缓存)。\n\nZ-buffer：存储像素的 z-coordinates。\n\n- 投影面：z=0; 观察方向：(0,0,-1)。\n- 投影类型：**平行投影**。\n- 深度值：z-component。\n\n在像素层级进行存储。思想是**扫描多边形时，只画离视点更近的点**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115144148626.png\" alt=\"image-20251115144148626\" style=\"zoom:55%;\" />\n\n算法步骤如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115144310101.png\" alt=\"image-20251115144310101\" style=\"zoom:55%;\" />\n\n如何计算 Z-Buffer 的 Z 值？利用直线的方程计算。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115144452427.png\" alt=\"image-20251115144452427\" style=\"zoom:55%;\" />\n\n优缺点：\n\n- 复杂度：O(nN)。\n- 不需要物体排序。\n- 能够处理任意几何形状。\n- 可以使用硬件加速。\n- Z-buffer 很吃占显存。\n  - 如果深度范围从 0 到 106, 一个像素点需要 24 bits。\n  - 如果分辨率 is 1280×1024， z-buffer 空间需要 4 MB。\n- 受限分辨率，存在走样。\n- 不好处理透明物体。\n\n能否对该算法进行加速呢？利用扫描线的连贯性。\n\n对于每个扫描线, 构建深度分类 span。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115145548302.png\" alt=\"image-20251115145548302\" style=\"zoom:60%;\" />\n\n## 画家算法（对象空间，背面剔除）\n\n原理：**离视点远的不会遮挡离视点近的**。在景物空间确定物体的可见性顺序(离视点远近)，**由远及近**地绘制出正确的图像结果。\n\n条件：场景中物体在 z 方向上没有相互重叠。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115150936170.png\" alt=\"image-20251115150936170\" style=\"zoom:67%;\" />\n\n关键是如何进行可见性顺序的排序，也就是对象深度排序？\n\n画家算法按**减小最大深度的顺序**对曲面进行排序。扫描转换曲面，从深度最大的曲面开始，根据重叠进行绘制。\n\n若物体之间的 Z 值不重合，例如下面假设 Z 越大离视点越近，由于 QZmin > PZmax，那么 Q 肯定离视点更近，P 的优先级更低。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115151613634.png\" alt=\"image-20251115151613634\" style=\"zoom:55%;\" />\n\n当物体间的 z 值范围重叠时：判断多边形 P 是否遮挡场景中多边形 Q，需作如下 5 个判别步骤：\n\n1. 多边形 P 和 Q 的 x 坐标范围是否不重叠。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115151730222.png\" alt=\"image-20251115151730222\" style=\"zoom:50%;\" />\n\n2. 多边形 P 和 Q 的 y 坐标范围是否不重叠。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115151743953.png\" alt=\"image-20251115151743953\" style=\"zoom:50%;\" />\n\n3. 从视点看去，多边形 P 是否完全位于 Q 的背面。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115151757643.png\" alt=\"image-20251115151757643\" style=\"zoom:50%;\" />\n\n4. 从视点看去，多边形 Q 是否完全位于 P 的同一侧。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115151806237.png\" alt=\"image-20251115151806237\" style=\"zoom:50%;\" />\n\n5. 多边形 P 和 Q 在 xy 平面上的投影是否不重叠。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115151814589.png\" alt=\"image-20251115151814589\" style=\"zoom:50%;\" />\n\n如果上述五种情况中只要有一种成立，就表明多边形 P 和 Q 是互不遮挡的，即多边形 P 的绘制优先级低于 Q。\n\n如果上述判断都不成立，说明多边形 P 有可能遮挡 Q，此时把多边形 P 和 Q 进行互换重新进行判断，而重新判断只要对上述条件 3 和 4 进行即可。\n\n如果 P 和 Q 交换顺序后，仍不能判断其优先级顺序，可以按如下方法处理：**将其中一个多边形沿另一个物体剖分。**\n\n- 避免循环判断：P 做标记。\n- 多边形剖分：将 P 沿 Q 剖分。\n\n相互遮挡时，将其中一个多边形沿另一个多边形进行剖分。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115152208571.png\" alt=\"image-20251115152208571\" style=\"zoom:70%;\" />\n\n深度排序算法**有时可能将具有正确深度顺序的多边形进行剖分**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115152351727.png\" alt=\"image-20251115152351727\" style=\"zoom:50%;\" />\n\n三维物体的深度排序算法适合于**固定视点**的消隐。\n\n- 通过多边形的剖分，总是可以实现多边形物体在三维空间中的深度排序。\n- 深度排序算法可以有效地实现透明效果。\n\n在**视点变化**的场合中(如飞行模拟)，深度排序算法难以满足实时性的要求。算法复杂度 O(nlogn)。\n\n## 二叉树空间剖分树算法（表面优先级）\n\n如果场景中的多边形可以被一个平面分割成两部分，**与视点同侧的物体不会被异侧物体遮挡**。\n\n对位于分割平面两侧的多边形继续进行递归分割，直至每一个分割平面两侧或一侧只有一个多边形。\n\n分割过程可以用一个二叉树的数据结构来表示。\n\n在 BSP 树算法中，分割平面取作场景中的多边形。\n\n适用于**视点变化场景不变**的绘制。\n\n一个切分的简单例子：如图空间 ABC 由 A、B、C 三个独立的房间组成，首先，分割平面 1 将空间分成了平面正向的 A 房间和平面负向的 BC 空间，BC 空间被 2 紧接着分割为平面 2 正向的 C 房间和负向的 B 房间。注意这里平面的方向一般由墙壁面向的方向而定。\n\n如果有一个人处于 C 房间内，那么如何判断所有房间的遮挡顺序呢？从树根开始，由于人处于平面 1 的“后”面，所以，BC 空间应该先于 A 房间（后：先负后正），然后，由于人处于分割平面 2 的“前”面，所以，C 房间应该先于 B 房间（前：先正后负）。这样，整个房间离人由近到远的顺序就可以确定了：C－B－A。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115152940322.png\" alt=\"image-20251115152940322\" style=\"zoom:67%;\" />\n\n对于由多边形面组成的物体，**可以选择与多边形面重合的分割平面**，利用平面方程来区分“内”、“外”多边形顶点。随着将每个多边形面作为分割平面，可生成一棵树，**与分割平面相交的每个多边形将被分割为两部分**。一旦 BSP 树创建完毕，即可选择树上的面并由后往前显示，即前面物体覆盖后面的物体。\n\n另一个切分例子：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115153220298.png\" alt=\"image-20251115153220298\" style=\"zoom:60%;\" />\n\n二叉剖分树的遍历：可以从后往前, 也可以从前往后(被绘制的象素不再绘制)。\n\n例如，BSP 树的**从后往前**遍历：\n\n- 视点位于分割平面的**正侧**，遍历顺序：**负侧分支 → 根结点多边形 → 正侧分支**。\n- 视点位于分割平面的负侧，遍历顺序：正侧分支 → 根结点多边形 → 负侧分支。\n\n算法优点：\n\n- 可以处理**带透明度的遮挡**。\n- 快：不用每个像素点都计算 Z 并检测。\n\n# 第九章 真实感图形绘制\n\n## 本章复习重点\n\n- 基础的光照模型。\n  - Lambert 漫反射模型构成。\n  - Phong 镜面反射模型构成。\n  - Whitted 整体光照明模型构成。\n- 基础的明暗处理模型。\n  - Flat Shading。\n  - Gouraud Shading。\n  - Phong Shading。\n- 光线跟踪算法步骤。\n- 光线树生成过程。\n- 终止条件。\n- 光线跟踪的 4 类光线。\n- 包含阴影的 phone 模型。\n- 光线跟踪加速技术：包围盒技术，空间分割技术。\n- 纹理分类。\n- 纹理的两种映射方法。\n- 常用纹理反走样方法：前置滤波方法，超采样方法，Mipmap 方法。\n- Mipmap 映射方法原理。\n- 常用的三维纹理：凹凸映射，法向映射，位移映射，及其原理。\n- 辐射度系统方程。\n- 辐射度算法流程。\n- Gathering 方法与 Shooting 方法的区别。\n- 本影与半影的区别。\n- Depth Fail 计算方法。\n- Depth Pass 计算方法。\n\n## 引言\n\n目的是让计算机生成如同照片般真实的图像。步骤如下：\n\n1. 建立**几何模型**，确定景物表面的光照属性。\n2. 进行取景变换，将物体**投影**到二维平面上。\n3. 采用**消隐算法**剔除当前视点处不可见的场景表面。\n4. 根据**光照明模型**，计算在可见场景表面的光亮度。\n\n## 光照明模型\n\n影响物体表面光照明效果的因素：\n\n- 光源。\n- 观察点位置。\n- 物体表面局部几何形状。\n- 表面朝向。\n- 材料属性。\n\n光照明模型考虑物体表面上每一个点所代表的微小面元受到来自光源或周围环境光线的照射而产生的**反射或透射光亮度**。\n\n最常用的光照明模型：\n\n- 泛光模型。\n- Lambert 漫反射模型。\n- Phong 镜面反射模型。\n- Whitted 整体光照明模型。\n\n### 泛光模型\n\n**最简单**的光照明模型。试图刻画**周围环境反射光**对物体表面照明贡献。照明效果如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115154736495.png\" alt=\"image-20251115154736495\" style=\"zoom:50%;\" />\n\n**假定环境反射光沿任何方向对任何物体表面入射的光亮度都相等。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115154906806.png\" alt=\"image-20251115154906806\" style=\"zoom:60%;\" />\n\n### Lambert 模型（考虑漫反射）\n\n直接光源对物体表面的照射有方向性。物体表面的反射光分为：**漫反射光、镜面反射光**。\n\n**纯漫射表面只产生漫反射**，例如地面、树木等。\n\n漫反射光是**物体表面对入射光线朝各个方向的均匀反射**。大小**只与入射光的光亮度和入射方向有关，与漫反射光的反射方向无关**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115155216585.png\" alt=\"image-20251115155216585\" style=\"zoom:65%;\" />\n\n漫反射光亮度和光源入射角（入射光线和表面法向量的夹角）的余弦成正比。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115155318032.png\" alt=\"image-20251115155318032\" style=\"zoom:60%;\" />\n\n计算 cosα。\n\n![image-20251115155521030](https://cdn.davidingplus.cn/images/2025/11/15/image-20251115155521030.png)\n\nLambert 光照模型：考虑上**漫反射及泛光反射分量**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115155719413.png\" alt=\"image-20251115155719413\" style=\"zoom:50%;\" />\n\n模型效果对比：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115155848640.png\" alt=\"image-20251115155848640\" style=\"zoom:50%;\" />\n\n\n\n### 光传播计算模型\n\n**光的强度与距离 d 的平方成反比。**当 d 为极限值时，光的强度改变得太快，导致不同的物体的明暗差别太大。通常使用 d 的线性或是二次函数的倒数来实现光强度的衰减。\n\n![image-20251115155456303](https://cdn.davidingplus.cn/images/2025/11/15/image-20251115155456303.png)\n\n\n\n### Phong 模型（考虑镜面反射）\n\n镜面反射光：一种朝向一定方向的反射光，它遵从光的反射定律。\n\n**在靠近反射光方向上仍然可以观察到反射光，形成了反射光方向周围的一个高光区。**这与物体表面粗糙度有关系。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115160138587.png\" alt=\"image-20251115160138587\" style=\"zoom:55%;\" />\n\nPhong 采用余弦函数的幂次来模拟镜面反射光。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115160206233.png\" alt=\"image-20251115160206233\" style=\"zoom:55%;\" />\n\n镜面反射方向的计算。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115160254734.png\" alt=\"image-20251115160254734\" style=\"zoom:55%;\" />\n\n### Blinn-Phong 模型（对 Phong 的改进）\n\nPhong 模型中**计算反射光线的向量是一件相对比较耗时的任务**，因此 Blinn-Phong 对这一点进行了改进。\n\n定义虚拟镜面法向 H。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115160447155.png\" alt=\"image-20251115160447155\" style=\"zoom:60%;\" />\n\nPhong 模型综合了**综合了漫反射、镜面反射及泛光反射分量**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115160639522.png\" alt=\"image-20251115160639522\" style=\"zoom:65%;\" />\n\n### Whitted 模型（考虑光线在物体之间的相互反射和透射）\n\n局部光照明模型的局限：\n\n- 仅考虑从光源直接发出的光线对物体表面光亮度的贡献。\n- **没有考虑光线在物体之间的相互反射和透射。**\n\nWhitted 模型是整体光照明模型。可模拟现实世界中景物表面之间的镜面反射和透射现象。\n\n从某一观察方向 V 所观察到的物体表面某点 P 的光亮度的贡献来自于三个方面：\n\n- **由光源直接照射引起的反射光亮度 Ic。**\n- **镜面反射光。**\n- **规则透射光。**\n\n![image-20251115161149164](https://cdn.davidingplus.cn/images/2025/11/15/image-20251115161149164.png)\n\nWhitted 整体光照明模型：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115161124394.png\" alt=\"image-20251115161124394\" style=\"zoom:60%;\" />\n\n### 进一步完善\n\n光照明模型分类：\n\n1. 基于经验的简单光照明模型。\n   - Phong 模型。\n2. 基于物理的光照明模型。\n   - Blinn 模型。\n   - Cook-Torrence 模型。\n3. 双向反射率函数（BRDF）模型。\n\n## 多边形物体的明暗处理\n\n在计算机图形学中，场景中的许多物体都采用多边形表示。\n\n三类常用的明暗处理（Shading）方式：\n\n- Flat Shading\n- Gouraud Shading\n- Phong Shading\n\n### Flat Shading\n\n方法：\n\n- **依据局部光照明模型按每一个多边形的法向计算出一个颜色值 C。**\n- **将 C 赋给该多边形在屏幕上的投影所覆盖的全体像素。**\n\n优缺点：\n\n- 处理简单，计算量小。\n- 景物表面上相邻的多边形之间颜色差异较大，存在**马赫带效应**。\n\n### Gouraud Shading\n\n方法：\n\n- **为多边形物体的每一个顶点赋一个法向量。**\n- **利用局部光照明模型计算每一顶点处的光亮度。**\n- **多边形内部各点处的光亮度值通过对多边形顶点处的光亮度的双线性插值得到。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115161700418.png\" alt=\"image-20251115161700418\" style=\"zoom:55%;\" />\n\nGouraud 明暗处理法举例：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115161838955.png\" alt=\"image-20251115161838955\" style=\"zoom:55%;\" />\n\nGouraud Shading 又称**光亮度插值明暗处理**。\n\n优缺点：\n\n- 简单快速，所生成的图形在真实感上较 Flat Shading 有了较大的提高。\n- **马赫带效应**依然存在。\n- **不能正确模拟高光。**\n\n### Phong Shading\n\n方法：\n\n- **为多边形物体的每一个顶点赋一个法向量。**\n- **多边形内部各点处的法向量则通过对多边形顶点处法向量的双线性插值得到。**\n- **利用 Phong 模型计算每一点的光亮度。**\n\n### 总结\n\nGouraud 和 Phong 的明暗处理方法在**处理静态画面**时可以得到很好的效果。\n\n处理动画显示时：**当画面逐帧更新时，明暗变化太快。**\n\n因为是对投影后的图形而不是对原始空间中的三维物体本身的图形进行明暗处理。\n\n因此用这两种方法得到的处理结果都不具备对物体旋转的不变性。\n\n## 光线跟踪算法\n\n光线跟踪算法是迄今为止最为成功的生成真实感图形算法之一。\n\n- 算法简单。\n- 生成的图形真实感强。\n- 计算量大。\n- 其前身是光线投射（Ray Casting）算法。\n\n光线传播方式很复杂，如果按照光照路线去计算效果，计算过程会非常复杂。因此，我们采用**由视线出发求出视线与其他物体或光源的关系**。\n\n### 算法原理\n\n对屏幕上每一像素，执行下述 3 步操作：\n\n1. **从视点出发通过该像素中心向场景发出一条光线，并求出该条光线与场景中物体的全部交点。**\n2. **将各交点沿光线方向排序，获得离视点最近交点。**\n3. **依据局部光照明模型计算该交点处的光亮度，并将所得光亮度值赋给该像素。**\n\n当所有屏幕像素都处理完毕时，即得到一幅真实感图形。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117121638126.png\" alt=\"image-20251117121638126\" style=\"zoom:65%;\" />\n\n下面具体说明一下：\n\n1. 从视点出发通过该像素中心向场景发出一条光线，并求出该条光线与场景中物体的全部交点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117121805063.png\" alt=\"image-20251117121805063\" style=\"zoom:75%;\" />\n\n2. 将各交点沿光线方向排序，获得离视点最近交点。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117122003226.png\" alt=\"image-20251117122003226\" style=\"zoom:75%;\" />\n\n回顾 Whitted 模型：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117122112114.png\" alt=\"image-20251117122112114\" style=\"zoom:55%;\" />\n\n对于屏幕上的每个像素，执行一下 4 个步骤：\n\n1. **从视点出发通过该像素中心向场景发出一条光线 R，并求出 R 与场景中物体的全部交点；获得离视点最近交点 P；并依据局部光照明模型计算 P 处颜色值 Ic。**\n2. 在 P 处沿着 R 镜面反射方向和透射方向各衍生一条光线。若点 P 所在表面**非镜面或不透明体**，则无需衍生出相应光线。\n3. **分别对衍生出的光线递归地执行前面步骤**，计算来自镜面反射和透射方向上**周围环境**对点 P 光亮度的贡献 Is 和 It。\n4. 依据 **Whitted 光照明模型**即可计算出点 P 处的光亮度，并将计算出的光亮度赋给该像素。\n\n### 光线树\n\n树的结点代表物体表面与跟踪线的交点。结点连线代表跟踪线。**每个结点的左儿子代表反射产生的跟踪线（r），右儿子代表透射产生的跟踪线（t)。空箭头表示跟踪线射出场景。**P0 处的光强是 P0、P1、P2、P3 点光强的合成。计算方法是以**后序算法**遍历这颗光线跟踪树。在每一结点处，递归调用光照模型，算出跟踪射线方向的光强，并按两表面交点之间的距离进行衰减后，传递给父结点。如此上递，最后得出 P0 点处的光强，亦即得到屏幕象素处的亮度。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117122642122.png\" alt=\"image-20251117122642122\" style=\"zoom:60%;\" />\n\n一个例子如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117122746269.png\" alt=\"image-20251117122746269\" style=\"zoom:45%;\" />\n\n对于树上任一结点 Pi 所受到的光照，除了光照模型中的**漫射光源 Ipd、直射光源 Ips、透射光源 Ipb** 之外，还有**左儿子结点传来的光强 Is（反射跟踪线传来的光强），和右儿子结点传来的光强 It（透视跟踪线传来的光强）**。设前三种光源（Ipd、Ips、Ipb）使得 Pi 沿着跟踪线射回的光强为 IC。Is 沿着跟踪线在 Pi 点射的回光强主要由 Pi 点的镜面反射系数所控制，强度为 Ks × Is。因为跟踪线 V 正在 Ir 之反射线上。It 在 Pi 处射出的光强为 Kt × It。\n\n综合起来，Pi 处沿视线方向 V 射去的光强 I 为：\n$$\nI = I_C + K_s * I_S + K_t * I_t\n$$\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117123106188.png\" alt=\"image-20251117123106188\" style=\"zoom:55%;\" />\n\n### 递归终止条件\n\n1. **光线与环境中任何物体均不相交，或交于纯漫射面。**\n2. **被跟踪光线返回的光亮度值对像素颜色的贡献很小。**\n3. **已递归到给定深度。**\n\n### 伪代码\n\n```cpp\nmain() // 主函数\n{\n    for (需要计算颜色的每一像素pixel)\n    {\n        确定通过视点V和像素pixel的光线R;\n        depth = 0;   // 递归深度\n        ratio = 1.0; // 当前光线的衰减系数，1.0表示无衰减\n        // color是经计算后返回的颜色值\n        RayTrace(R, ratio, depth, color);\n        置当前像素pixel的颜色为color;\n    }\n} // 主函数main( )结束\n\nRayTrace(R, ratio, depth, color) // 说明：光线跟踪子函数\n{\n    if (ratio < THRESHOLD)\n    { // 终止条件2\n        置color为黑色； return;\n    }\n    if (depth > MAXDEPTH)\n    { // 终止条件3\n        置color为黑色； return;\n    }\n\n    光线R与场景中的所有物体求交。若存在交点，找出离R起始点最近的交点P；\n\n    if (交点不存在)\n    { // 终止条件1\n        置color为黑色； return;\n    }\n    用局部光照明模型计算交点P处的颜色值，并将其存入local_color；\n\n    if (交点P所在的表面为光滑镜面)\n    {\n        计算反射光线Rs;\n        // 递归调用！\n        RayTrace(Rs, ks * ratio, depth + 1, reflected_color);\n    }\n    if (交点P所在的表面为透明表面)\n    {\n        计算透射光线Rt;\n        // 递归调用！\n        RayTrace(Rt, kt * ratio, depth + 1, transmitted_color);\n    }\n\n    依照Whitted模型合成最终的颜色值，即：\n        color = local_color + ks * reflected_color +\n                kt * transmitted_color；\n\n    return;\n} // 光线跟踪子函数 RayTrace() 结束\n```\n\n### 关键问题\n\n1. 光线怎么和物体求交点？\n2. 镜面反射如何计算？\n3. 折射如何计算？\n4. 如何处理阴影？\n\n#### 光线的表示\n\n一般用直线的参数方程进行表示：\n$$\nR(t) = P+tD\\\\\n\n\\\\\n\nP: 起始点。\\\\\nD: 方向，单位矢量。\\\\\n一般在世界坐标系中进行计算。\\\\\nt = 0表示为光线起点，即点 P。\\\\\nt > 0表示在光线的正方向。\\\\\nt < 0表示在光线的负方向，此时交点为无效交点。\n$$\n![image-20251117124219039](https://cdn.davidingplus.cn/images/2025/11/17/image-20251117124219039.png)\n\n#### 光线与物体的求交\n\n光线方程：R(t) = P + tD。\n\n物体表示：\n\n- 函数表示： f(X) = 0。\n- 参数表示： X = g(u, v)。\n\n计算交点：将光线方程待入曲面方程，求根。\n\n- 隐函数表示：f(P + tD) = 0。一个方程一个未知数，单变量求根。\n- 参数表示 P + tD - g(u, v) = 0。三个方程三个未知数（t, u, v），多变量求根。\n- 多数时候需要采用数值求解。会遇到计算量大、误差累积、甚至不收敛等问题。\n\n##### 光线与球相交\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117124644452.png\" alt=\"image-20251117124644452\" style=\"zoom:55%;\" />\n\n##### 光线与三角形相交\n\n思路：光线与三角形所在平面求交点。若存在，判断交点是否在三角形的内部。\n\n第一步：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117124850181.png\" alt=\"image-20251117124850181\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117124855795.png\" alt=\"image-20251117124855795\" style=\"zoom:60%;\" />\n\n第二步：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117125037389.png\" alt=\"image-20251117125037389\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117125220955.png\" alt=\"image-20251117125220955\" style=\"zoom:63%;\" />\n\n#### 镜面反射方向计算\n\nP 为入射光线 L 和物体的交点；N 为点 P 处的物体表面法向；Rr 为镜面反射光线的方向。θi 为 L 与 N 的夹角；θr 为 Rr 与 N 的夹角。\n\n由光线反射定律知道，θi＝θr。假设 L，N 均为单位矢量，Rr = L - 2(L·N)N。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117125650535.png\" alt=\"image-20251117125650535\" style=\"zoom:80%;\" />\n\n#### 透视方向计算\n\nP 为入射光线 L 和物体的交点；N 为点 P 处的物体表面法向 Rt 为透射光线的方向。\n\n折射定律：位于折射率为 η1 的介质 1 中、与表面法向 N 的夹角为 θ1 的入射光线 L，在进入折射率为 η2 的介质 2 后，将产生折射，其折射方向 Rt 与 N 的夹角为 θ2，且有 η1sinθ1 ＝ η2sinθ。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117125908636.png\" alt=\"image-20251117125908636\" style=\"zoom:75%;\" />\n\n### 阴影计算\n\n从 P 出发向光源 L 发射一条阴影测试光线 R，若 R 在到达 L 的途中与场景中的物体不相交，则点 P 受光源 L 直接照射。反之，点 P 被位于它与光源 L 之间某一物体所遮挡，若遮挡物为不透明体，则点 P 位于光源阴影之中。\n\n![image-20251117193317438](https://cdn.davidingplus.cn/images/2025/11/17/image-20251117193317438.png)\n\n包含阴影计算的 Phong 模型：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117193356663.png\" alt=\"image-20251117193356663\" style=\"zoom:60%;\" />\n\n### 产生颜色\n\n前面的光照模型仅用于白光，只能产生灰度。\n\n彩色模型计算：选择合适模型（如 RGB、HSV 等），为颜色的三个分量分别建立光照方程。\n\nRGB 模型：\n\n- 光源的颜色 [IpR, IpG, IpB]，环境光的颜色 [IaR, IaG, IaB]。\n- 表面反射系数\n  - 环境反射：[KaR, KaG, KaB]\n  - 漫反射：[KdR, KdG, KdB]\n  - 镜面反射：[KsR, KsG, KsB]\n\n彩色光照方程（模型）：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117193823043.png\" alt=\"image-20251117193823043\" style=\"zoom:67%;\" />\n\n### 光线跟踪中的四类光线\n\n1. Eye rays：从视点发出。\n2. Shadow rays：从物体表面上的点向光源发出。\n3. Reflected rays：从物体表面上的点沿镜面反射方向发出。\n4. Refracted rays：从物体表面上的点沿透射方向发出。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117193948736.png\" alt=\"image-20251117193948736\" style=\"zoom:60%;\" />\n\n### 优缺点\n\n它不仅考虑到**光源的光照**，而且考虑到场景中各物体之间**彼此反射**的影响，因此显示效果十分逼真。\n\n有**消隐**功能：采用光线跟踪方法，在显示的同时，自然完成消隐功能。\n\n有**影子**效果：光线跟踪能完成影子的显示。\n\n该算法具有**并行**性质：每条光线的处理过程相同，结果彼此独立，因此可以大并行处理的硬件上快速实现光线跟踪算法。\n\n光线跟踪算法的缺点是**计算量非常大**，因此，显示速度极慢。\n\n### 反走样\n\n引起走样的原因：**光线跟踪算法本质上是对画面的点采样**。\n\n反走样处理方法：\n\n- 超采样。\n- 自适应超采样。\n\n### 光线跟踪加速技术\n\n常用加速技术：\n\n- 包围盒技术。\n- 空间分割技术。\n\n#### 包围盒技术\n\n原理：\n\n- **将场景中的所有表面按其空间位置关系分层次组织成树状结构。**\n\n  - 根结点：整个场景。\n\n  - 中间结点：空间位置较为接近的一组表面。\n\n  - 叶结点：单个景物表面。\n\n- 每一结点中的表面或表面片集合**都用一形状简单的包围盒包裹**起来。\n\n- 当光线与包围盒有交时，才进行光线与其中所含的景物面片求交运算。光线与包围盒不相交，必定不与其中所含的景物面片相交。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117194645686.png\" alt=\"image-20251117194645686\" style=\"zoom:50%;\" />\n\n常用包围盒：包围盒、包围球、包围圆柱、平行 2n 面体。\n\n#### 空间分割技术\n\n原理：\n\n- **将景物空间分割成一个个小的空间单元。**\n- 被跟踪的光线仅与它所穿过空间单元中所含物体表面进行求交测试。\n- 利用相邻空间单元的空间连贯性，使光线快速跨越空单元，迅速到达非空单元，求得光线与景物的第一个交点。\n\n典型方法：\n\n- 均匀网格。\n- Kd 树。\n- BSP 树。\n- 四叉树（二维）/八叉树（三维)。\n\n## 纹理映射\n\n传统光照明模型仅考虑表面法向的变化，且假设表面反射率为一常数，因而**只能生成颜色单一的的光滑景物表面**。通过纹理映射技术可以解决这个问题。\n\n纹理（texture）通常指物体的表面细节。**纹理贴图是一个用图像、函数或其它数据源来改变表面在每一处的外观的过程。**\n\n例如，我们不必用精确的几何去表现一块砖墙，而只需把一幅砖墙的图像贴到一个多边形上。除非观察者非常靠近墙，否则我们并不会觉得缺少几何细节。既节省了大量的造型工作量，也节省了内存空间，加快了绘制速度。\n\n纹理生成过程实质上是**将所定义的纹理映射为反映某种三维景物表面的属性，并参与后续的光照明计算**。\n\n表面属性：与光照明模型及表面几何有关的各种参数，如表面法向、漫/镜面反射率等。\n\n景物表面的纹理属性主要有以下几种：\n\n1. 表面颜色，色彩分布。即表面的反射率；例如漫反射和镜面反射分量，即表面的镜面反射率；\n2. 透明度；\n3. 表面法向，即挠动表面法向来产生表面的凹凸纹理；\n4. 环境的漫反射和镜面反射效果；\n5. 光源强度和色彩。\n\n### 纹理分类\n\n根据纹理定义域的不同，纹理可分为：\n\n- 二维纹理。\n- 三维纹理。\n\n基于纹理的表现形式，纹理又可分为：\n\n- 颜色纹理。\n- 几何纹理。\n- 过程纹理。\n\n两类最常用的纹理：**颜色纹理、三维/几何纹理**。\n\n确定表面上颜色纹理的两个步骤：\n\n1. 预先建立表面的纹理模型。\n2. 纹理映射：建立表面上的每一点和一已知图像上的点的对应关系，取图像上相应点的颜色值作为表面上各点的颜色值。\n\n实际纹理非常复杂，难以解析描述。采用**图象**来描述表面纹理细节。\n\n### 纹理映射\n\n**采用景物表面的参数化表示来确立表面的纹理映射坐标，即可实现纹理图像在景物表面的映射。**\n\n- 景物表面参数化表示为 f(u，v)。\n- 纹理图像表示为 T(s，t)。\n- 建立景物表面参数空间 (u，v) 和纹理图像参数空间 (s，t) 之间的一一对应关系。\n\n两种映射方法：纹理扫描和像素次序扫描。\n\n#### 纹理扫描\n\n**将纹理模式映射至物体表面，然后再进行投影变换映射至投影平面，称为纹理扫描。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117200246315.png\" alt=\"image-20251117200246315\" style=\"zoom:35%;\" />\n\n纹理扫描通常用线性函数进行纹理映射变换，实现纹理空间到物体空间的映射。\n\n![image-20251117200412945](https://cdn.davidingplus.cn/images/2025/11/17/image-20251117200412945.png)\n\n不利因素：**选中的纹理表面常常与像素边界不匹配，需要进行像素分割计算**。因此**像素次序扫描方法成为最常用的纹理映射方法**。\n\n#### 像素次序扫描\n\n**将投影平面的像素区域映射至物体表面，再映射至纹理空间，称为像素次序扫描。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117200304023.png\" alt=\"image-20251117200304023\" style=\"zoom:35%;\" />\n\n之所以叫投影映射，是因为主要有两种方法可以将三维的空间坐标点转化为二维的纹理坐标点：**Projector 和 UV Mapping**。\n\n对于一些简单的几何体，通常用投影的方式，例如这种将矩形地图纹理均匀贴到球表面的投影。Projector 只适用于简单情况，对于更复杂的几何体贴图，往往需要用到 UV Mapping：用于将 3 维模型中的每个顶点与 2 维纹理坐标一一对应。UV map 则需要建模师精心制作。例如下图所示的 Uvmapping。像素次序扫描将一个像素映射到物体表面一个区域，再投影到纹理数据的一个区域获得具体的颜色数据。具体的运算就是前面已经讲过的投影变换，坐标系变换。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117200646767.png\" alt=\"image-20251117200646767\" style=\"zoom:50%;\" />\n\n#### 思考\n\n##### 纹理采样方式\n\n若投影得到的象素数目比原始纹理大，则需要把纹理图像放大(magnification)。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117200846687.png\" alt=\"image-20251117200846687\" style=\"zoom:50%;\" />\n\n若投影得到的象素数目比原始纹理小，则需要把纹理图像缩小(minification)。**当纹理图像缩小时，多个纹素可能覆盖一个象素单元。**为了得到每个象素正确的颜色，应该综合考虑影响该象素的那些纹素。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117200916450.png\" alt=\"image-20251117200916450\" style=\"zoom:50%;\" />\n\n有三种办法：\n\n- **最近邻域法**：选择在象素中心可见的纹素。但会**引起严重的走样现象**，见上图。当这类表面相对视点移动时，走样现象更加明显，称为时间走样（temporal aliasing）。\n- **双线性插值**：效果仅比最近邻域法稍好，也会**引起较严重的走样现象**。\n- **Mipmap 方式**：对纹理进行预处理，建立多个纹素覆盖单个象素的快速逼近计算的数据结构。这样，**一个采样点可以检索出一个或多个纹素的效果**。\n\n##### 纹理重复方式\n\n- **wrap or tile**：纹理图像在表面重复。例子：地上的大理石贴图。\n- **mirror**：纹理图像在表面重复，但每隔一幅进行翻转(flipped)。这样在纹理的边界处，纹理可以保持连续。\n- **clamp**：把 [0,1) 范围之外的进行截断。截断到 [0,1) 内的半个纹素。\n- **border**：参数范围在 [0,1) 之外的用单独定义的边界颜色或把纹理的边作为边界。用于在表面上印花样，地形绘制中相邻纹理的缝合。截断到 [0,1) 外的半个纹素。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117201214133.png\" alt=\"image-20251117201214133\" style=\"zoom:60%;\" />\n\n##### 纹理与背景的叠加融合\n\n- Replace：把原来表面的颜色替换为纹理的颜色。\n- Decal(印花)：与替换类似，但是若纹理中包含 Alpha 值，则用它与表面的颜色进行混合。\n- Modulate(调节)：把表面的颜色与纹理颜色相乘。\n\n### 纹理反走样\n\n常用纹理反走样方法：\n\n- **前置滤波方法。**\n- **超采样方法。**\n- **Mipmap 方法。**\n\n#### 前置滤波方法\n\n- 确定屏幕像素 P 上可见的景物表面区域 A。\n- 将区域 A 直接映射到纹理空间区域 T。\n- 取区域 T 内的**所有纹理像素颜色值的平均**作为景物表面区域 A 的平均纹理颜色。\n- 代入光照明模型，计算出像素 P 应显示的光亮度值。\n\n#### 超采样方法\n\n- 将**屏幕像素 P 的四个角点**分别映射到纹理空间，得到四个纹理像素值。\n- 将**上述四个纹理颜色值取平均**作为像素 P 所对应的可见表面区域的纹理颜色。\n\n#### Mipmap 方法\n\n目前应用最广的纹理反走样算法之一。\n\n1. **预处理：生成一个由不同分辨率图像构成的纹理图像序列。**\n\n从原始纹理图像出发，生成一个其分辨率为原始图像 1/4 的新的纹理图像版本。新版本中的每一个像素值取为原始图像中相对应的四个像素颜色值的平均。类似地基于所得到的新纹理图像版本生成一个更低分辨率的、尺寸更小的纹理图像版本。这一过程一直持续到最后生成的纹理图像仅包含一个像素为止。\n\n2. **映射阶段**：屏幕上的每一像素内的可见表面区域被映射到原始纹理图像上的一块区域。估计该区域所覆盖的原始纹理图像中像素的个数并以此作为选取适当分辨度的纹理图像版本的一种测度。\n\n从预先构造的纹理图像序列中**找出其压缩率最接近当前纹理像素与屏幕像素比率的两个纹理图像**。在相邻分辨率的两纹理图像上计算当前屏幕像素映射点的纹理颜色值。根据两纹理图像对原始图像的压缩率在所得到的两个纹理颜色值间取加权平均，作为当前屏幕像素可见表面区域的颜色值。\n\n### 三维纹理映射技术\n\n二维纹理映射技术的缺陷：\n\n1. 在一般情况下，**由纹理平面至景物表面的映射是一种非线性映射，在曲面上曲率变化较大的区域可能发生纹理的非均匀变形**，导致不真实的视觉效果。\n1. 对具有非平凡拓扑（由多个曲面拼接而成）的景物表面进行二维纹理映射时，**很难保证相邻曲面片间纹理的连续性**。\n\n解决方案：三维纹理映射技术、优化纹理映射技术。\n\n三维纹理映射技术：纹理直接定义于三维空间中。映射变成是一个简单的嵌入映射。通过**过程纹理合成**生成三维纹理。\n\n常见的三维纹理：\n\n1. **凹凸映射**（bump mapping）：在不改变物体宏观几何的前提下，**模拟物体表面粗糙的、褶皱的、凹凸不平的光照效果**。\n\n凹凸纹理的基本思想是：**用纹理去修改物体的法向而不是颜色。物体表面的几何法向保持不变，我们仅仅改变光照明模型计算中的法向。**\n\n方法如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117202702570.png\" alt=\"image-20251117202702570\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117202709494.png\" alt=\"image-20251117202709494\" style=\"zoom:60%;\" />\n\n2. **法向映射**（normal mapping）：利用**法向纹理**保证高质量的表面细节复现。\n\n借助低精度模型和一个法向纹理，获得高精度模型的绘制效果。先计算高精度模型的法向，保存在法向纹理中，再将法向纹理映射到低精度模型上进行光照计算。\n\n3. **位移映射**（displacement mapping）：**利用纹理改变物体表面上点的几何位置**，获得很强的深度感和细节。\n\n依据与表面上点所对应的纹理值，沿表面法向偏移该点的几何位置。能产生很强的深度感（自遮挡、自阴影、轮廓），但相比凹凸映射、法向映射，计算代价大。\n\n### 纹理优化处理技术\n\n#### 纹理缓存（Texture Caching）\n\n复杂的应用需要相当多的纹理, 不一定把所有的纹理都一次性送到显存。\n\n有多种纹理高速缓存技术，在速度和内存中的纹理数目之间取得平衡。例如：当贴了纹理的多边形离视点较远时，可只载入需要的子纹理。\n\n使用纹理内存的一般原则：\n\n- 尽量使用**较小**的纹理。\n- 尽量**使相同的纹理多边形成组**。\n- 采用 Tiling 或者 Mosaicing 技术：**把一些小纹理拼成一块大纹理**，这样可以避免纹理的切换，加快存取的速度。\n\n#### 纹理压缩\n\n一个直接针对纹理内存和带宽的解决方法是**固定速率的纹理压缩**（fixed-rate texture compression)。\n\n通过硬件**即时对压缩的纹理进行解压，所需的纹理内存可减少**，从而增加了有效 Cache 的大小，同时减少了带宽需要。\n\n### 环境映照\n\n这一技术的雏形是为近似模拟光线跟踪的效果而又不必去跟踪反射光线而设计的。原因是光线跟踪计算量太大了。在低硬件条件下，光线跟踪要实时计算比较难以实现。这种技术中将视点移动到物体的中心处，然后将环境图贴图到物体上。纹理图像通过正投影观察一个纯反射球面的外形来得到，故得到的纹理称为球面图(sphere map)。将几何体参数化到一个球上, 然后进行映射。\n\n当前象素内可见景物区域的平均纹理属性：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/17/image-20251117203100247.png\" alt=\"image-20251117203100247\" style=\"zoom:67%;\" />\n\n纹理图像通过正投影观察一个纯反射球面的外形来得到，故得到的纹理称为球面图(sphere map)。\n\n立方体环境映照通过把摄像机置于立方体的中心，然后把环境投影到立方体的面上。立方体上的图像作为环境图。\n\n## 辐射度方法\n\n### 辐射度技术概述\n\n直接照明效果。\n\n艺术家在此场景中精心放置了三类光源以模拟真实的光照效果：\n\n聚光灯：能产生阴影，置于窗外。\n\n泛光：缺少泛光，房间内所有可见但未被光源直接照射的表面会是全黑的。\n\n点光源：不产生阴影，可减弱泛光产生的“平板”效果。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118190522189.png\" alt=\"image-20251118190522189\" style=\"zoom:60%;\" />\n\n辐射度效果。\n\n采用辐射度算法绘制，光效未经艺术家特别处理。场景中仅包含一个面光源，即放置于窗外的天空。与直接照明效果相比，主要区别在于：\n\n- 房间有**发光效果**。\n- 地板上**软影清晰可见**，房间周围可观察到**细微的光效**。\n- 地毯上的红色辉映到灰墙上，产生淡淡的温暖的感觉。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118191220008.png\" alt=\"image-20251118191220008\" style=\"zoom:60%;\" />\n\n辐射度技术原理：\n\n- 光是一种**辐射能**，在一个封闭环境中，场景中的光能经过表面之间的反射和透射，最终达到平衡状态。\n- 场景中各表面的光亮度实际上是场景中**光能分布的反映**。\n- 前提：**针对理想漫射环境**。\n\n什么是辐射度：**单位时间内从物体单位表面积向外辐射的光能。**包含两部分：\n\n- 物体作为光源自身向外发出的能量。\n- 物体表面接受来自周围场景表面传递给它的能量后，再次反射出去的部分。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118191525057.png\" alt=\"image-20251118191525057\" style=\"zoom:55%;\" />\n\n### 辐射度方法\n\n基本前提：\n\n1. **光源和普通物体之间没有区别。**\n2. **场景中的一个表面被它周围的所有可见的表面所照亮。**\n\n简单地说，辐射度算法就是：**把场景细分到很细很细的面片**(如 1 个像素那么大的三角形)，分别计算它们接受和发出的光能，然后逐次递归，直到每个面片的光能数据不再变化（或者到一定的阀值）为止。因此，**计算量很大（要计算很多次），而且难以并行（因为递归）**。\n\n优点：\n\n- 非常真实的漫反射表面光照。\n- 概念简单，容易实现。\n- 能够容易地使用 3D 硬件加速计算。\n\n缺点：\n\n- 慢。\n- **不能很好地处理点光源**。\n- 也**不能处理有光泽的表面**。\n- 总是过于复杂而且很少在书本中解释。\n\n### 辐射度系统方程\n\n根据辐射度的思想，将场景中的每个物体的表面分解为互不重叠的小面片（patch），Ai（i = 1, 2, 3...）。\n\n- 前提：假设每一小面片的辐射度和漫反射率均为常数。\n- 小面片大小可以不一致，一般分解为方形，也有分解为三角形等其他形状的。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118192444695.png\" alt=\"image-20251118192444695\" style=\"zoom:60%;\" />\n\n辐射度计算中的几个定义：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118192632541.png\" alt=\"image-20251118192632541\" style=\"zoom:60%;\" />\n\n方程的推导过程如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118192856282.png\" alt=\"image-20251118192856282\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118192910112.png\" alt=\"image-20251118192910112\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118192930853.png\" alt=\"image-20251118192930853\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118192949153.png\" alt=\"image-20251118192949153\" style=\"zoom:70%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193005973.png\" alt=\"image-20251118193005973\" style=\"zoom:50%;\" />\n\n矩阵形式：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193023379.png\" alt=\"image-20251118193023379\" style=\"zoom:50%;\" />\n\n### 辐射度系统方程实例\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193149597.png\" alt=\"image-20251118193149597\" style=\"zoom:65%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193201997.png\" alt=\"image-20251118193201997\" style=\"zoom:65%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193252544.png\" alt=\"image-20251118193252544\" style=\"zoom:65%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193304462.png\" alt=\"image-20251118193304462\" style=\"zoom:65%;\" />\n\n矩阵形式：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193314694.png\" alt=\"image-20251118193314694\" style=\"zoom:60%;\" />\n\n### 辐射度算法流程图\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193359511.png\" alt=\"image-20251118193359511\" style=\"zoom:55%;\" />\n\n#### 表面分割\n\n均匀网格化。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193513812.png\" alt=\"image-20251118193513812\" style=\"zoom:60%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193522884.png\" alt=\"image-20251118193522884\" style=\"zoom:60%;\" />\n\n自适应网格化。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193548637.png\" alt=\"image-20251118193548637\" style=\"zoom:60%;\" />\n\n#### 形状因子计算\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193941043.png\" alt=\"image-20251118193941043\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118193951856.png\" alt=\"image-20251118193951856\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118194015161.png\" alt=\"image-20251118194015161\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118194025836.png\" alt=\"image-20251118194025836\" style=\"zoom:55%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118194047076.png\" alt=\"image-20251118194047076\" style=\"zoom:55%;\" />\n\n#### 方程求解\n\n理论上说，辐射度系统方程可采用任何一种线性方程组的求解算法来求解。\n\n![image-20251118194121296](https://cdn.davidingplus.cn/images/2025/11/18/image-20251118194121296.png)\n\n直接求逆：高斯消去法(Gauss elimination)。\n\n迭代法：\n\n- Gauss-Seidel 迭代—Gathering。\n- Southwell 迭代—Shooting。\n\n**Gathering：对于每一面片，收集场景中其它面片对它辐射的光能，更新该面片的辐射度。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118194230231.png\" alt=\"image-20251118194230231\" style=\"zoom:50%;\" />\n\n**Shooting：选取辐射源面片（具有最大待辐射光能），将其辐射光能发送到其他面片，更新各面片的辐射度。选取新的辐射源面片。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/18/image-20251118194319387.png\" alt=\"image-20251118194319387\" style=\"zoom:55%;\" />\n\n逐步求精辐射度算法：\n\n- 通过迭代过程求解辐射度方程。\n- 每次迭代相当于一次光能传递过程。\n- 每次迭代后，采用场景中各面片的当前辐射度值绘制整个场景。\n- 经过多次迭代后，各面片的辐射度值逐渐逼近方程组的解。\n- 可用于对场景进行交互预览。\n\n### 辐射度和光追对比\n\n辐射度方法**能很好的解决光能传播**。\n\n- **处理漫反射。**\n- **无法处理镜面反射。**\n- **图像是视点独立的。**\n\n光线跟踪反应的是**光线复杂的反射行为**。\n\n- **对于镜面表面表现很好。**\n- **漫反射光线反射到各个方向光线跟踪无法抓住所有方向光线。**\n- **必须使用环境映照来替换缺失的扩散。**\n\n## 阴影\n\n阴影可以反映物体之间的相对位置，增强场景的立体感和层次感。\n\n阴影是由于物体截断了光线而产生的，如果光源位于物体的一侧，**阴影总是位于物体的另一侧，也就是与光源相反的一侧**。\n\n### 本影和半影\n\n场景中的一个点 P，如果它不被光源的任何一部分所照射到，就称为在本影区里。**本影就是不被任何光源所照到的区域。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115162703120.png\" alt=\"image-20251115162703120\" style=\"zoom:55%;\" />\n\n**半影是指只有部分光线到达的区域。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115162750661.png\" alt=\"image-20251115162750661\" style=\"zoom:55%;\" />\n\n在单点光源的照射下，阴影分为自身阴影与投射阴影。一部分是由于物体自身的遮挡而使光线照射不到它的某些表面产生自身阴影；另一部分是由于不透明的物体遮挡光线使得位于物体另一侧的区域受不到光照而形成投射阴影。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115162921069.png\" alt=\"image-20251115162921069\" style=\"zoom:50%;\" />\n\n### 阴影计算方法\n\n一般有三种：\n\n- Planar Shadow\n- Shadow Mapping\n- Shadow Volume\n\nPlanar Shadow 类似投影，计算最简单，缺点只能绘制抛射在平面上的阴影。\n\nShadow mapping 利用站在光源处所沿光源法线看去所生成的深度图来检测场景中的体象素是否处于阴影中，缺点是光源与物体位置相对固定、且在极端情况下计算精度差，不太适合精确到象素的动态光阴场合。\n\nShadow Volume 是目前最适合精确表现动态光阴场景的技术，适用性最广。\n\n#### Planar Shadow\n\nPlanar Shadow 的思想很简单，根据光源和投影面位置推导一个**投影矩阵**，通过这个矩阵能把模型上所有顶点投射到投影面（比如地面）上，也就是**将渲染物体压扁到一个平面上**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115163532338.png\" alt=\"image-20251115163532338\" style=\"zoom:67%;\" />\n\n地面如果不平整，影子就会穿插到地表以下。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115163543550.png\" alt=\"image-20251115163543550\" style=\"zoom:50%;\" />\n\n#### Shadow Mapping\n\n绘制自身阴影与投射阴影图形的算法如下：\n\n1. 根据**视点原来的观察位置**，对物体实施隐面算法，使用正常的光照模型计算光强来绘制可见表面。\n2. **将视点移到光源的位置。**从光源处向物体**所有背光面**投射光线，建立光线的参数方程，计算该光线与投影面（地面）的交点，使用深灰色填充交点所构成的阴影多边形，形成投射阴影。若选用简单光照模型，对于背光面，由于得不到光源的直接照射，只有环境光对其光强有贡献。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115163709867.png\" alt=\"image-20251115163709867\" style=\"zoom:60%;\" />\n\n#### Shadow Volume\n\nShadow Volume 的一般步骤为：\n\n1. 生成阴影体积（Mesh）。\n2. 阴影渲染。\n\n**只有处于 shadow volume 里面的物体才会受阴影的影响。**\n\n优点：\n\n- 全方位方法。\n- 视窗空间的阴影确定。\n  - 阴影精确到像素。\n  - 超采样是可行的。\n\n缺点：\n\n- 仅适合理想光源。\n\n  - 适用于点光源和直接光源。\n\n  - 不适用区域光源和 soft shadows。\n\n- 要求多边形是连接封闭的。\n\n  - 模型必须是闭合的 (2-manifold)。\n\n  - 不适用非平面多变形。\n\n- 需要轮廓计算。\n\n  - 大量 CPU 计算。\n\n  - 动态场景计算量大。\n\n阴影体积算法背后的想法是将光线减弱时创建的对象轮廓扩展到一个 Volume 中，然后使用一些简单的模版操作将该 Volume 映射到模板缓冲区中。关键的想法是，当一个对象在 Volume 内（因此在阴影中）时，Volume 前面的多边形会对对象的多边形进行深度测试，并且该 Volume 后部的多边形将相同的测试，或者说不参与测试。\n\n- ZPass\n- ZFail\n\n##### Depth Pass 算法\n\nZPass：\n\n1. 先关闭光源，将整个 scence 渲染一遍，此时一片漆黑，但获得了深度值 depth map（注意是以真实视点作为视点得到的）。\n2. 关闭深度写，然后渲染所有的 shadow volume，渲染阴影体的正面（既面对视点的这一面），如果 depth test 的结果是 pass, 那么和这个象素对应的 stencil 值加 1。如果 depth test 的结果是 fail, stencil 值不变。\n3. 然后渲染阴影体的背面，深度测试通过则模板值减 1。\n4. 最后模板值不为 0 的面就在阴影体中，开启深度写。\n5. 用模板手法重新渲染一次加光的 scence 即可，让阴影部分为黑色。\n\n算法过程：\n\n1. 初始化 depth buffer。Depth values 指出了最近的可见面片（消隐）。\n2. 使用 stencil 进出计数方法。\n   - 用面消隐算法画 shadow volume 两次。\n     - 1st pass: 渲染前面并当深度测试通过时计数增。\n     - 2nd pass: 渲染背面并当深度测试通过时减一。\n   - 不更新深度和颜色。\n3. 后续, 像素的 stencil 非零，像素在阴影中，否则如果是零则不在阴影中。\n\n例子：\n\n现在假设我们要计算这个蓝色的物体的 stencil 值，我们从视线引射线到达物体的最近面。这条视线要穿过部分 shadow volume。在本例中是穿过了所有的 shadow volume。那么首次检测每个 shadow volume 的前面，三条红色虚线。根据深度值，可以看到所有的 shadow volume 的前面，相对视点靠前的面都在物体之前，都位于物体之前，物体没有遮挡任何一个 shadow volume 的前面。因此对每一个 shadow volume 的前面进行通过测试，都通过。因此每个从左向右，第一个 shadow volume 前面测试通过，stencil 值加 1，此时 stencil 值为1，检测第二个 shadow volume 前面测试通过，stencil 值加 1，此时 stencil 值为 2，检测第二个 shadow volume 前面测试通过，stencil 值加 1，此时 stencil 值为 3。然后进行后面的检测，三条绿色虚线。同样物体在三个 shadow volume 后面的后面。因此三次后面检测也通过。检测第 1 个 shadow volume 后面测试通过，stencil 值减 1，此时 stencil 值为 2。检测第 2 个 shadow volume 后面测试通过，stencil 值减 1，此时 stencil 值为 1。检测第 3 个 shadow volume 后面测试通过，stencil 值减 1，此时 stencil 值为 0 。由于 stencil 值为 0，因此物体不在阴影范围中。\n\n> 图中有三个可能遮挡阴影的物体。三条红色虚线是前面的光线，三条绿色虚线是后面的光线。\n>\n> ZPass 的过程是，从视点开始往物体扫，遇到红色虚线加 1，绿色虚线减 1，直到到达物体。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115164852405.png\" alt=\"image-20251115164852405\" style=\"zoom:50%;\" />\n\nZ-PASS 算法在视点位于阴影锥内或者跟近裁剪面相交时，会得到错误的 stencil values，如下图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115165236640.png\" alt=\"image-20251115165236640\" style=\"zoom:60%;\" />\n\n##### Depth Fail 算法\n\nZFail：\n\n1. 先关闭光源，将整个 scence 渲染一遍，获得深度值。\n2. 关闭深度写，渲染阴影体的背面，深度测试失败则模板值加 1。\n3. 渲染阴影体的正面，深度测试失败则模板值减 1。\n4. 最后模板值不为 0 的面便处于阴影体中，开启深度写。\n5. 用模板手法重新渲染一次加光的 scence 即可，阴影部分不渲染色度。\n\n算法过程如下：\n\n1. 渲染场景初始化 depth buffer。\n   - 深度值指示最近的可见面片。\n2. 使用 stencil 进出计数方法。\n   - 用面消隐画 shadow volume 两次。\n     - 1st pass: 渲染背面并当深度检测失败时加 1。\n     - 2nd pass: 渲染前面并当深度检测失败时减 1。\n   - 不更新深度和颜色。\n3. 然后, 像素的 stencil 值非零则像素在阴影中, 如果为零则不在阴影中。\n\n> ZFail 和 ZPass 几乎相反。过程是，从物体开始往视点反方向扫，遇到绿色虚线（物体后面）加 1，红色虚线（物体前面）减 1，直到到达无穷远。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/d36c9a6ea283a44c0d3f60370e7e50dc.png\" alt=\"d36c9a6ea283a44c0d3f60370e7e50dc\" style=\"zoom:60%;\" />\n\n# 第十章 实时绘制加速技术\n\n## 本章复习重点\n\n- 什么是 LOD 技术。\n- 三角形带方法点传输序列。\n- 三角形扇方法点传输序列。\n\n## 实时绘制技术\n\n利用计算机快速生成三维场景的真实感图形。与图形硬件发展和人们对人机交互的需求密不可分。图像绘制速度采用帧频（单位为帧/秒）来衡量。关键是如何充分发挥图形硬件和图形算法各自长处，在绘制速度和图形质量之间取得平衡。\n\n图形绘制流水线：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115170345319.png\" alt=\"image-20251115170345319\" style=\"zoom:50%;\" />\n\n图形硬件、硬件驱动程序、图形 API 及应用程序间的关系：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115170416798.png\" alt=\"image-20251115170416798\" style=\"zoom:65%;\" />\n\n## LOD 技术\n\n细节层次模型是**以不同精度刻画物体几何细节**的一组模型。\n\n基本思想：根据物体在画面上的视觉重要性选取适当细节层次绘制该物体。\n\n**LOD 是图形交互化处理的重要工具。**\n\n- 关注保真度/性能折衷。\n- 不是唯一的方式! 可以配合以下技术：\n  - Parallel rendering\n  - Occlusion culling\n  - Image-based rendering\n\n问题是原始几何数据集可能过于复杂，无法以交互速率进行渲染。\n\n解决方法是**简化小对象物体或远处对象的多边形几何体**，称为 Level of Detail 或 LOD。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115170704222.png\" alt=\"image-20251115170704222\" style=\"zoom:55%;\" />\n\n### 离散 LOD\n\n传统 LOD:\n\n- 在预处理中分别为每个对象创建 LOD。\n- 在运行时，根据对象的距离（或类似标准）选取每个对象的 LOD。\n\n由于 LOD 是**以固定分辨率离线创建**的，因此我们称之为离散 LOD(discrete LOD)。\n\n优点：\n\n1. **最简单的编程模型；解耦简化和渲染。**\n   - LOD 创建不需要受到实时渲染约束。\n   - 运行时渲染只需要选取 LOD。\n2. **非常适合现代图形硬件。**\n   - 易于将每个 LOD 预编译为三角形条带、显示列表、顶点阵列等。\n   - 这些渲染速度比当今硬件上的无组织三角形快得多(3-5 x)。\n\n缺点：有时离散的 LOD 不适合进行剧烈的简化。例如：地形交叉、体积等曲面、超细节范围扫描（GIS 地图）、多个模型等问题。对于剧烈的简化，大的对象必须进过切分处理，小的对象必须进过连接后处理。离散 LOD 处理非常困难或不可行。\n\n### 连续 LOD\n\n与传统的离散方法不同：\n\n- 离散 LOD：在预处理中创建各个详细级别。\n- 连续 LOD：在运行时创建各个详细级别。\n\n优点：\n\n1. **更好的粒度、更好的保真度。**\n   - LOD 是精确计算的，而不是从几个预先创建的选项中选择的。\n   - 因此，对象使用的多边形不超过所需数量，这将为其他对象释放多边形。\n   - 最终结果：更好的资源利用率，导致更好的整体保真度/多边形。\n2. **更好的粒度、平滑过渡。**\n   - 在传统 LOD 之间切换会引入视觉“冲击”效果。\n   - 连续 LOD 可以逐步增量调整细节，减少视觉冲击。\n3. **支持渐进传输。**\n4. **引出了 view-dependent LOD技术。**\n   - 使用当前视图参数为当前视图选择最佳表达。\n   - 单个对象可能跨越多个细节级别。\n   - 以比远处更高的分辨率显示对象的附近部分。\n   - 显示用户看的地方比他们的周边视觉更详细。\n\n### 分层 LOD（Hierarchical LOD）\n\n**View-dependent LOD 解决了大物体渲染的问题。Hierarchical LOD 可以解决小物体渲染的问题。**\n\nHierarchical LOD 和 view-dependent LOD 很好的吻合。将整个场景视为单个对象，以与视图相关的方式进行简化。\n\n### 总结\n\n1. 离散 LOD：为每个对象生成少量 LOD。\n\n2. 连续 LOD (CLOD)：为每个对象在线生成数据结构，从中可以提取细节光谱。\n\n3. View-dependent LOD：\n   - 生成数据结构，从中可以动态生成专门用于当前视图参数的 LOD。\n   - 一个对象可以跨越多个详细级别。\n4. Hierarchical LOD：用各个部件的 LOD 聚合成为对象。\n\n## 网格压缩传输技术\n\n场景绘制的速度受到场景中三角形数目的制约，在绘制一个三角形时，必须将其全部三个顶点的信息传送到图形硬件。为避免同一顶点信息的重复传送，大多数图形 API 均采用三角形带和三角形扇等复合三角形结构进行传输，以充分利用图形硬件的有限带宽。\n\n三角形带：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115171818067.png\" alt=\"image-20251115171818067\" style=\"zoom:65%;\" />\n\n三角形扇：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/15/image-20251115171847833.png\" alt=\"image-20251115171847833\" style=\"zoom:65%;\" />\n\n采用类似于三角形带或三角形扇这样的复合结构，将把处理与传输 m 个三角形的代价从 3m 个顶点降到 m＋2 个顶点。\n\n## 遮挡剔除技术\n\n在对场景作取景变换之前剔除场景中对于当前视点不可见的某些物体的整体或局部，从而加速场景的绘制。\n\n为实现遮挡剔除，需要对物体进行可见性检查。\n\n- 物体的可见性检查一般在场景数据组织阶段由计算机 CPU 计算完成，不涉及到图形硬件。\n- 针对当前视点，预计算其可能可见的所有面片的集合。\n\n## IBR 技术\n\n以待绘制的场景的一系列二维图像作为输入，通过将其画面像素重新整合来生成在新的视点和新的视线方向上的场景画面。前身是环境映射技术。\n\n优点：\n\n- 无需进行复杂的场景几何造型即可实现对场景的浏览、漫游。\n- 绘制计算量与场景的几何复杂度无关，而仅与所需绘制的画面分辨率有关。\n\n缺点：\n\n- 仅适用于静态场景，用户无法与场景中的景物进行实时交互。\n- 绘制质量在很大程度上取决于原始图像的采样数目和相应的插值方法。\n\n# 第十二章 OpenGL 编程基础\n\n## 10 中基本图元模型\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192540046.png\" alt=\"image-20251111192540046\" style=\"zoom:55%;\" />\n\n## 程序的基本结构\n\n一段实例代码如下：\n\n```cpp\n#include <windows.h>\n#include <gl/gl.h>\n#include <gl/glu.h>\n#include <gl/glaux.h>\n#include <stdio.h>\n\n\nvoid myinit(void);\nvoid CALLBACK myReshape(int w, int h);\nvoid CALLBACK display(void);\n\n\nvoid myinit(void)\n{                                     // 初始化\n    glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色\n}\nvoid CALLBACK display(void)\n{\n    glClear(GL_COLOR_BUFFER_BIT);\n    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色\n    glColor4f(0.2, 0.8, 1.0, 1.0); // 选颜色(R,G,B)\n    glRotatef(30, 1.0, 1.0, 0.0);  // 做旋转变换\n    auxWireCube(1.0);              // 绘制六面体的虚线图\n    glFlush();                     // 强制绘图，不驻留缓存\n     \n}\n\nvoid CALLBACK myReshape(int w, int h)\n// 用于窗口大小改变时的处理，与绘图无关\n{\n    glViewport(0, 0, w, h);\n}\n\n\nvoid main(void)\n{\n    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA); // 窗口显示单缓存和彩色模式\n    auxInitPosition(0, 0, 200, 200);           // 屏幕左上点及大小\n    auxInitWindow(\"openglsample.c\");           // 初始化窗口，标题\n    myinit();\n    auxReshapeFunc(myReshape);\n    auxMainLoop(display);\n}\n```\n\n绘制效果如图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111192641692.png\" alt=\"image-20251111192641692\" style=\"zoom:55%;\" />\n\n代码中需要注意以下几点：\n\n1. 头文件使用\n\n若应用程序使用 OpenGL 核心函数，应包括头文件 <gl/gl.h>。\n\n使用 GLU 库函数，应包括头文件 <gl/glu.h>。\n\n使用 AUX 库函数，应包括头文件 <gl/glaux.h>。\n\n使用 WGL 和 Win32 应包括头文件 <windows.h>。\n\n2. 程序的基本结构\n\n（1）定义窗口\n\nWindows 下的 OpenGL 实现提供了一个辅助函数库 aux，用于解决开窗口和处理输入事件等问题\n\n窗口管理函数：\n\n```cpp\nvoid auxInitDisplayMode(Glbitfield mask); // 函数定义窗口的特性，如颜色和缓存区的性质。\n\n// 窗口显示单缓存和 RGB(彩色)模式。\n// auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);\n\nvoid auxInitPosition(Glint x, Glint y, Glint width, Glint height); // 定义窗口在屏幕上的位置和大小。\n\nvoid auxInitWindow(Glbyte *titleString) // 打开窗口。窗口的标题为字符串 titleString。窗口把 ESC 键与退出函数联系起来，可以用来关闭窗口，退出程序。\n```\n\n处理输入事件:\n\n当改变窗口尺寸、移动窗口、重新显示窗口时，由 auxReshapeFunc(myReshape) 调用函数 myReshape 重新定义窗口属性。通常 myReshape 函数调用 glViewPort 函数，对当前图形进行裁剪，重新定义投影矩阵等。\n\nOpenGL 辅助函数库中还包括处理键盘和鼠标输入事件的函数。\n\n（2）初始化操作\n\n由于 OpenGL 的绘图方式是由一系列的状态确定的，因而在绘制图形前需要做一些准备工作，包括清缓存区、定义光照模型、纹理映射等基本操作的初始化状态、设置三维视景体、定义视口。 \n\n例如：\n\n```cpp\nglClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色。\n\nglClear(GL_COLOR_BUFFER_BIT); // 将颜色缓存清为 glClearColor 命令所设置的颜色，即背景色。\n```\n\n（3）设置观察坐标系下的取景模式和取景框位置及大小，主要利用了三个函数：\n\n```cpp\n// 设置屏幕上视口大小。(x, y)指定视口左下角在窗口坐标系中的位置，width 和 height 分别确定矩形视口宽和高，均以像素为单位。注意：视口的大小和尺寸是在窗口坐标系中进行度量的，默认状态下其坐标原点位于窗口的左下角，其尺寸与窗口的大小相同。\nvoid glViewport(GLint x, Glint y, Glsizei width, Glsizei height);\n\n// 设置投影方式为正交投影（平行投影），其取景体积是一个各面均为矩形的六面体，在默认状态为平行正交投影。\nvoid glOrtho(left, right, bottom, top, near, far);\n\n// 设置投影方式为透视投影，其取景体积是一个截头锥体。\n// 它通过指定 x-z 平面内的视角大小及宽高比来确定沿视线方向的棱锥，并通过指定远、近剪切面与视点间的距离来截断棱锥，得到观察体。\nvoid gluPerspective(fovy, aspect, zNear, zFar);\n```\n\n（4）使用 OpenGL 的库函数构造几何物体对象的数学描述，包括点线面的位置和拓扑关系、几何变换、光照处理等，这是 OpenGL 程序的主要部分。\n\n（5）程序的微机运行环境配置\n\n程序中除了包含必需的头文件如 <windows.h> <gl/gl.h> <gl/glaux.h> <gl/glu.h> 外。在创建执行文件时，在 VC 环境设置中要链接 opengl32.lib, glu32.lib 和 glaux.lib 三个函数库。运行已创建的执行文件时，在 windows\\system 目录下要有 opengl32.dll，glu32.dll 两个动态连接库。\n\n## 基本绘制单元\n\n要绘制某个几何对象，必须指明究竟是哪种类型的几何对象（例如点、线和多边形）。\n\nOpenGL 绘制部分的代码结构类似于代码分段的形式：\n\n```cpp\nglBegin(mode);\n\n\t...\n\n    glVertex3f(x,y,z);\n    glVertex3f(x,y,z);\n    glVertex3f(x,y,z);\n\n\t...\n\nglEnd();\n```\n\n### 点的绘制\n\nOpenGL 中点定义为一个方块，在默认状态下，点是屏幕上的一个像素。在 OpenGL 中，一个点是当作一个 n（2,3,4）维向量来处理的。\n\n例如在屏幕上绘制三个点：\n\n```cpp\nglBegin(GL_POINTS)\n    glVertex3f(1.0, 0.0, 0.0);\n    glVertex3f(1.0, 1.0, 0.0);\n    glVertex3f(0.0, 1.0, 1.0);\nglEnd();\n```\n\n### 线的绘制\n\n与数学意义上两端无限延伸的直线不同，OpenGL的线是数学定义中的线段，用**成对的端点**来描述。\n\n```cpp\n// 一条由坐标原点到点（1.0,1.0）的线段。\nglBegin(GL_LINES)\n    glVertex2f(0.0, 0.0);\n    glVertex2f(1.0, 1.0);\nglEnd()；\n```\n\n### 多边形的绘制\n\n多边形指封闭线段围成的区域。但 OpenGL 中可以描述的多边形有两点限制：多边形的边除了多边形的顶点外不允许相交，即确保多边形为**简单多边形**；多边形为**凸多边形**，即任给多边形的两个内部点，其连线完全在多边形内。\n\n```cpp\n// 其中，* 表示 glVertex 函数的上述任一种组合形式，由多边形顶点 v0,v1,…,vn 的表示形式而定。注意：多边形顶点应按一定顺序排列（如逆时针）。\nglBegin(GL_POLYGON);\n    glVertex*(v0);\n    glVertex*(v1);\n    ...\n    glVertex*(vn);\nglEnd();\n```\n\n### 矩形的绘制\n\n用的比较频繁，OpenGL 专门设置了绘制矩形的函数。\n\n```cpp\n// 矩阵的左上、右下角点坐标分别为（x1,y1）和(x2,y2)，或者用数组指针 v1、v2 表示。用上述函数描述的矩形位于 z=0 平面内，并且各边分别平行于 x、y 轴。但注意：经过坐标变换之后，这些特性可能改变。 \nvoid glRect{dfis}(TYPE x1, TYPE y1, TYPE x2, TYPE y2);\nvoid glRect{dfis} v(TYPE *v1, TYPE *v2);\n```\n\n## 例 10.2\n\n```cpp\nvoid CALLBACK display(void)\n{\n    glClear(GL_COLOR_BUFFER_BIT);    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色\n    glColor4f(1.0, 1.0, 1.0, 1.0); // 选颜色(R,G,B)\n    glPointSize(6.0);                // 设置点的大小\n\nglBegin(GL_POINTS);              // 在屏幕上绘制三个点\n    glVertex3f(0.1, 0.2, 0.0);\n    glVertex3f(0.2, 0.7, 0.0);\n    glVertex3f(0.5, 0.8, 0.0);\nglEnd();\n\nglBegin(GL_LINES); // 在屏幕上绘制一条线段\n    glVertex2f(0.0, 0.4);\n    glVertex2f(-0.3, 0.8);\nglEnd();\n\nglBegin(GL_POLYGON); // 在屏幕上绘制一个四边形\n    glVertex2f(-0.6, 0.0);\n    glVertex2f(-0.4, 0.0);\n    glVertex2f(-0.4, 0.3);\n    glVertex2f(-0.6, 0.4);\nglEnd();\n\n    glColor3f(1.0, 0.0, 0.0);    // 设置当前颜色为红色\n    glColor3f(0.0, 0.0, 1.0);    // 设置当前颜色为蓝色\n    glRectf(0.5, 0.5, 0.7, 0.7); // 绘制一个矩形\n    glColor3f(0.0, 1.0, 0.0);    // 设置当前颜色为绿色\n    glRectf(0.8, 0.8, 0.9, 0.9); // 绘制一个矩形\n    glRectf(0.2, 0.2, 0.4, 0.4); // 绘制一个矩形\n   \tglFlush();                  // 强制绘图，不驻留缓存\n}\n```\n\n最终绘制效果如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111200407898.png\" alt=\"image-20251111200407898\" style=\"zoom:70%;\" />\n\n## 坐标变换\n\n在二维平面上创建三维物体的过程：在三维空间中创建所绘制物体的模型，由计算机经过适当的变换，将三维坐标系中的点转换为屏幕上的相应位置，以得到理想的视觉效果。\n\nOpenGL 就是实现将物体的各个顶点通过各种变换矩阵的作用映射到屏幕的过程。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111200529792.png\" alt=\"image-20251111200529792\" style=\"zoom:50%;\" />\n\n（1）通用的矩阵操作命令\n\n```cpp\n// 参数取值：GL_MODELVIEW、GL_PROJECTION或GL_TEXTURE\n// 默认的选定矩阵为 GL_MODELVIEW 变换矩阵。\nvoid glMatrixMode(Glenum mode);\n\n// OpenGL 中的变换命令都是对当前矩阵进行操作，因此在选定可修改矩阵后，应首先用上述命令设置当前操作矩阵为单位矩阵。\nvoid glLoadIdentity(void);\n```\n\n（2）模型观察变换\n\n模型观察变换过程就是一个将顶点坐标从世界坐标变换到视觉坐标的过程。\n\n世界坐标系是一个右手坐标系，是固定不变的，在初始态下，其 x 轴为沿屏幕水平向右，y 轴为沿屏幕垂直向上，z 轴则为垂直屏幕面向外指向用户\n\n观察坐标系是一个左手坐标系，是可以活动的。在初始态下，原点及 x、y 轴分别与世界坐标系的原点及 x、y 轴重合，而 z 轴则正好相反，即为垂直屏幕面向内。\n\n在初始状态下，相机在观察坐标系的原点且指向z轴正向，即为垂直屏幕面向内。\n\n```cpp\n// 平移变换。\nvoid glTanslate{fd}(TYPE x, TYPE y, TYPE z);\n\n// 旋转变换。\n// 绕矢量 v = (x, y, z)T 逆时针方向旋转 angle 指定的角度。旋转角度的范围是 0 ~ 360 度。\nvoid glRotate{fd}(TYPE angle, TYPE x, TYPE y, TYPE z);\n\n// 缩放变换。\nvoid glScale{fd}(TYPE x, TYPE y, TYPE z);\n```\n\n变换的顺序：\n\n```cpp\nglMatrixMode(GL_MODELVIEW);\nglLoadIdentity();\nglMultMatrixf(N); /* apply transformation N */\nglMultMatrixf(M); /* apply transformation M */\nglMultMatrixf(L); /* apply transformation L */\nglBegin(GL_POINTS);\nglVertex3f(v); /* draw transformed vertex v */\nglEnd();\n\n// 在这个过程中，在 GL_MODELVIEW 状态下，相继引入了 I（单位阵），N，M，L 矩阵。\n\n// 变换后的顶点为 NMLv(顶点取列向量)。\n\n// 顶点的变换为 N(M(Lv))，即是先作变换 L，然后是变换 M，最后才是 N。\n\n// 顶点 v 的实际变换顺序正好与指定的顺序相反。\n```\n\n（3）投影变换\n\n在调用投影变换命令前必须先在程序中加入下述语句：\n\n```cpp\nglMatrixMode(GL_PROJECTION);\n\nglLoadIdentity();\n```\n\n这两条命令一方面指定接下来的变换命令只影响投影矩阵，同时也将当前投影矩阵设置为单位阵。\n\n一些函数：\n\n```cpp\n// 透视投影。\nvoid gluPerspective(Gldouble fovy, Gldouble aspect, Gldouble zNear, Gldouble zFar);\n\n// 正交投影。\nvoid glOrtho(Gldouble left, Gldouble right, Gldouble bottom, Gldouble top, Gldouble near, Gldouble far);\n\n// 对于二维图形向二维屏幕的投影，则应使用实用库中的如下函数：\n// 前面提到过，用二维顶点命令绘制的二维物体的 z 坐标均为零，而 gluOrtho2D() 命令假定场景中的 z 坐标介于 -1.0 和 1.0 之间。\nvoid gluOrtho2D(Gldouble left, Gldouble right, Gldouble bottom, Gldouble top);\n```\n\n（4）视口变换\n\n```cpp\n// 注意：应该使视口的长宽比与取景体积的长宽比相等，否则会使图像变形。\nvoid glViewport(GLint x, Glint y, Glsizei width, Glsizei height);\n```\n\n## 例 10.3\n\n绘制三维空间绘制立方体的程序。\n\n```cpp\n#include <windows.h>\n#include <GL/gl.h>\n#include <GL/glu.h>\n#include <GL/glaux.h>\n#include <stdio.h>\n\n\nvoid myinit(void);\nvoid CALLBACK myReshape(int w, int h);\nvoid CALLBACK display(void);\n\n\n// 初始化\nvoid myinit(void)\n{\n    glClearColor(0.0, 0.0, 0.0, 0.0); // 将窗口清为黑色\n    glShadeModel(GL_FLAT);            // 常量明暗处理方式\n}\n\nvoid CALLBACK display(void)\n{\n    glClear(GL_COLOR_BUFFER_BIT);\n    // 将颜色缓存清为glClearColor命令所设置的颜色，即背景色\n    glColor3f(1.0, 1.0, 1.0); // 选当前颜色(R,G,B)为白色\n    glLoadIdentity();         // 设置当前矩阵为单位矩阵\n\n    glTranslatef(0.0, 0.0, -3.0); // 平移变换\n    glRotatef(45, 1.0, 1.0, 0.0); // 旋转变换\n    glScalef(1.0, 2.0, 1.0);      // 缩放变换\n    auxWireCube(1.0);             // 绘制立方体\n    glFlush();                    // 强制绘图，不驻留缓存\n}\n\nvoid CALLBACK myReshape(int w, int h) // 用于窗口改变大小时的处理，与绘图无关\n{\n    glMatrixMode(GL_PROJECTION);                              // 指明当前矩阵操作是针对投影矩阵进行的\n    glLoadIdentity();                                         // 设置当前矩阵为单位矩阵\n    gluPerspective(70.0, (GLfloat)w / (GLfloat)h, 1.5, 40.0); // 投影变换\n    glMatrixMode(GL_MODELVIEW);                               // 返回视点-模型矩阵\n    glViewport(0, 0, w, h);                                   // 定义视口变换\n}\n\n\nvoid main(void)\n{\n    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);\n    // 窗口显示单缓存和RGB(彩色)模式\n    auxInitPosition(0, 0, 200, 200);          // 大小 x=200、y=200 ， (0,0)是屏幕左上点\n    auxInitWindow(“Perspective 3 - D Cubes”); // 初始化窗口，参数是标题\n    myinit();\n    auxReshapeFunc(myReshape);\n    auxMainLoop(display);\n}\n```\n\n最终绘制效果如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111201527191.png\" alt=\"image-20251111201527191\" style=\"zoom:60%;\" />\n\n## OpenGL 状态管理\n\nOpenGL 是一个状态机，应用程序通过 OpenGL 函数调用来实现状态的设置。\n\nOpenGL 的绘图方式是由一系列的状态决定的，如果设置了一种状态或模式而不改变它，OpenGL 在绘图过程中将一直保持这种状态或模式。\n\nOpenGL 总是按照应用程序的发送顺序执行命令。状态影响应该是最接近绘制的状态改变函数来决定。注意：状态改变影响效率。\n\n## 考试参考\n\n### 实例二\n\n画一个三角形和一个正方形。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111201944028.png\" alt=\"image-20251111201944028\" style=\"zoom:55%;\" />\n\n```cpp\nint DrawGLScene(GLvoid)\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n\n    glTranslatef(-1.5f, 0.0f, -6.0f);\n    glBegin(GL_TRIANGLES);          // 绘制三角形\n    glVertex3f(0.0f, 1.0f, 0.0f);   // 上顶点\n    glVertex3f(-1.0f, -1.0f, 0.0f); // 左下\n    glVertex3f(1.0f, -1.0f, 0.0f);  // 右下\n    glEnd();                        // 三角形绘制结束\n\n    glTranslatef(3.0f, 0.0f, 0.0f); // 右移3单位\n    glBegin(GL_QUADS);              // 绘制正方形\n    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上\n    glVertex3f(1.0f, 1.0f, 0.0f);   // 右上\n    glVertex3f(1.0f, -1.0f, 0.0f);  // 左下\n    glVertex3f(-1.0f, -1.0f, 0.0f); // 右下\n    glEnd();                        // 正方形绘制结束\n\n    return TRUE;\n}\n```\n\n### 实例三\n\n着色。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/11/11/image-20251111202057148.png\" alt=\"image-20251111202057148\" style=\"zoom:55%;\" />\n\n```cpp\nint DrawGLScene(GLvoid)\n{\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n    glLoadIdentity();\n    glTranslatef(-1.5f, 0.0f, -6.0f);\n    glBegin(GL_TRIANGLES);\n    glColor3f(1.0f, 0.0f, 0.0f);\n    glVertex3f(0.0f, 1.0f, 0.0f);\n    glColor3f(0.0f, 1.0f, 0.0f);\n    glVertex3f(-1.0f, -1.0f, 0.0f);\n    glColor3f(0.0f, 0.0f, 1.0f);\n    glVertex3f(1.0f, -1.0f, 0.0f);\n    glEnd();\n\n    glTranslatef(3.0f, 0.0f, 0.0f); // 右移3单位\n    glColor3f(0.5f, 0.5f, 1.0f);    // 一次性将当前色设置为蓝色\n    glBegin(GL_QUADS);              // 绘制正方形\n    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上\n    glVertex3f(1.0f, 1.0f, 0.0f);   // 右上\n    glVertex3f(1.0f, -1.0f, 0.0f);  // 左下\n    glVertex3f(-1.0f, -1.0f, 0.0f); // 右下\n    glEnd();                        // 正方形绘制结束\n\n    return TRUE;\n}\n```\n\n### 实例四\n\n### 实例五\n\n","categories":["校内课程","计算机高级图形学"]},{"title":"Rtems Source Code","url":"/posts/4936fe45.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# Rtems 源码阅读\n\nRTEMS（Real‑Time Executive for Multiprocessor Systems）是一款始于 1988 年、1993 年正式发布的开源实时操作系统，专为多处理器嵌入式环境设计，支持 POSIX 和 BSD 套接字等开放标准 API，并可运行于 ARM、PowerPC、SPARC、MIPS、RISC‑V 等 18 种处理器架构及近 200 个 BSP（Board Support Package）上。它以库形式发布，应用程序与内核静态链接为单一映像，采用单地址空间、无用户/内核隔离设计，从而简化资源管理并确保确定性响应。2025 年 1 月 22 日发布的 6.1 版本全面将构建系统由 GNU Autotools 切换到基于 Python 的 Waf，大幅提升了构建速度并优化了依赖管理，同时引入了改进的调度算法和增强的 SMP 支持。\n\n本文章用于记录阅读 Rtems 内核源码的笔记，尝试理解其中的逻辑。Rtems 内核的版本是 6.1，在线代码网站见 [https://rtems.davidingplus.cn/lxr/source/](https://rtems.davidingplus.cn/lxr/source/)。\n\n本文章中涉及到的源码摘抄见项目 [DavidingPlus/rtems-source-code: Rtems 源码阅读。](https://github.com/DavidingPlus/rtems-source-code)。\n\n<!-- more -->\n\n# 文件系统\n\n## 系统调用\n\n### open()\n\nopen() 函数的调用流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始 open 函数] --> B[初始化变量 rv=0, mode=0, iop=NULL]\n    B --> C[va_start 开始处理可变参数]\n    C --> D[获取 mode 参数]\n    D --> E{是否成功分配 iop}\n    E -- 是 --> F[调用 do_open 打开文件]\n    F --> G[设置 rv 为 do_open 返回值]\n    E -- 否 --> H[设置 errno = ENFILE]\n    H --> I[rv = -1]\n    G --> J[va_end 结束可变参数处理]\n    I --> J\n    J --> K[返回 rv]\n```\n\n#### struct rtems_libio_t\n\nrtems_libio_t 结构体定义如下。该结构体用于表示一个文件描述符的内部状态，Rtems 中每打开一个文件都会关联一个该结构体的实例，通常简称为 iop（I/O pointer）。\n\n```c\ntypedef struct rtems_libio_tt rtems_libio_t;\n\nstruct rtems_libio_tt\n{\n    // 文件状态标志，使用原子类型以支持线程安全操作。\n    // 可能标志：是否打开、读/写权限、文件类型等。\n    Atomic_Uint flags;\n\n    // 当前文件偏移量，用于读写操作时定位文件指针位置。\n    off_t offset;\n\n    // 文件路径定位信息，类似于 inode。\n    // 包含挂载点、节点、驱动等信息，用于实际文件访问。\n    rtems_filesystem_location_info_t pathinfo;\n\n    // 驱动或文件系统使用的私有字段。\n    // 通常用于存储轻量级状态、句柄或标志值。\n    uint32_t data0;\n\n    // 驱动或文件系统使用的扩展字段。\n    // 可指向任意类型数据，支持更复杂的上下文管理。\n    void *data1;\n};\n```\n\n##### struct rtems_filesystem_location_info_t\n\nrtems_filesystem_location_info_t 结构体定义如下。它表示一个路径位置，用于描述文件系统中某个具体节点（如文件或目录）的位置及其访问方式。\n\n```c\n// 表示文件系统中一个节点（如文件或目录）的位置及其访问信息。\ntypedef struct rtems_filesystem_location_info_tt\n{\n    // 用于将该节点插入到挂载点的链表中（如目录项列表）。\n    rtems_chain_node mt_entry_node;\n\n    // 指向具体节点的访问结构，一般是与具体文件系统实现相关的 inode 或数据结构。\n    void *node_access;\n\n    // 可选的第二个访问字段，供文件系统使用，如软链接或扩展元数据。\n    void *node_access_2;\n\n    // 指向该节点所使用的文件操作处理器集合（如 open、read、write、close 等函数指针）。\n    const rtems_filesystem_file_handlers_r *handlers;\n\n    // 当前节点所属的挂载表条目，表示该节点来自哪个挂载的文件系统。\n    rtems_filesystem_mount_table_entry_t *mt_entry;\n\n} rtems_filesystem_location_info_t;\n```\n\n##### struct rtems_filesystem_file_handlers_r\n\n比较重要的成员是 `const rtems_filesystem_file_handlers_r *handlers`，该结构类似于 Linux 内核中的 file_operations，定义如下：\n\n```c\n/**\n * @brief File system node operations table.\n */\nstruct _rtems_filesystem_file_handlers_r\n{\n    // 打开文件的处理函数指针。\n    rtems_filesystem_open_t open_h;\n\n    // 关闭文件的处理函数指针。\n    rtems_filesystem_close_t close_h;\n\n    // 读取文件的处理函数指针。\n    rtems_filesystem_read_t read_h;\n\n    // 写入文件的处理函数指针。\n    rtems_filesystem_write_t write_h;\n\n    // 控制操作（如设备控制）的处理函数指针。\n    rtems_filesystem_ioctl_t ioctl_h;\n\n    // 文件位置指针移动（如 lseek）的处理函数指针。\n    rtems_filesystem_lseek_t lseek_h;\n\n    // 获取文件状态信息的处理函数指针。\n    rtems_filesystem_fstat_t fstat_h;\n\n    // 截断文件大小的处理函数指针。\n    rtems_filesystem_ftruncate_t ftruncate_h;\n\n    // 将文件缓冲区数据同步到存储设备的处理函数指针。\n    rtems_filesystem_fsync_t fsync_h;\n\n    // 同步文件数据（但不一定包括元数据）的处理函数指针。\n    rtems_filesystem_fdatasync_t fdatasync_h;\n\n    // 文件控制（如修改文件描述符属性）的处理函数指针。\n    rtems_filesystem_fcntl_t fcntl_h;\n\n    // 轮询文件状态（如是否可读写）的处理函数指针。\n    rtems_filesystem_poll_t poll_h;\n\n    // 用于事件过滤（BSD kqueue）的处理函数指针。\n    rtems_filesystem_kqfilter_t kqfilter_h;\n\n    // 读取多个缓冲区（向量读）的处理函数指针。\n    rtems_filesystem_readv_t readv_h;\n\n    // 写入多个缓冲区（向量写）的处理函数指针。\n    rtems_filesystem_writev_t writev_h;\n\n    // 内存映射文件的处理函数指针。\n    rtems_filesystem_mmap_t mmap_h;\n};\n```\n\n##### struct rtems_filesystem_mount_table_entry_tt\n\n另一个成员是 struct rtems_filesystem_mount_table_entry_tt。这个结构体的作用是为每一个已挂载的文件系统提供一个集中式的描述，包含了文件系统的根节点信息、挂载点、类型、设备、访问控制状态等关键信息。对每个文件系统，Rtems 会维护一个这样的挂载表链表。在挂载和卸载文件系统时，Rtems 会对这个结构体进行相应的初始化、操作或释放。文件系统的挂载、查找路径、访问权限、卸载等都依赖于这个结构体中记录的信息。\n\n```c\ntypedef struct rtems_filesystem_mount_table_entry_tt\n    rtems_filesystem_mount_table_entry_t;\n\n// 表示一个挂载的文件系统实例，是 Rtems 文件系统挂载表中的一项。\nstruct rtems_filesystem_mount_table_entry_tt\n{\n    // 用于将该挂载点插入全局挂载链表。\n    rtems_chain_node mt_node;\n\n    // 文件系统私有信息，由具体文件系统实现定义，如 ext2 的 superblock 信息。\n    void *fs_info;\n\n    // 指向文件系统操作函数表，定义如 mount、unmount、eval_path 等。\n    const rtems_filesystem_operations_table *ops;\n\n    // 文件系统的常量信息，不可变，例如初始挂载参数。\n    const void *immutable_fs_info;\n\n    // 该文件系统中所有节点的全局链表，便于遍历。\n    rtems_chain_control location_chain;\n\n    // 表示该文件系统挂载在哪个目录（挂载点）上。\n    rtems_filesystem_global_location_t *mt_point_node;\n\n    // 表示该文件系统的根节点位置。\n    rtems_filesystem_global_location_t *mt_fs_root;\n\n    // 是否已挂载成功。\n    bool mounted;\n\n    // 是否支持写操作。\n    bool writeable;\n\n    // 是否禁止创建设备节点和普通文件（mknod）。\n    bool no_regular_file_mknod;\n\n    // 该文件系统的路径名限制和选项。\n    const rtems_filesystem_limits_and_options_t *pathconf_limits_and_options;\n\n    // 挂载点路径字符串，例如 \"/mnt/usb\"。\n    const char *target;\n\n    // 文件系统类型名称，例如 \"imfs\"、\"devfs\"、\"nfs\" 等。\n    const char *type;\n\n    // 设备名称，如 \"/dev/sda1\"，以字符串形式表示，供底层文件系统使用。\n    char *dev;\n\n    // 发起卸载操作的任务 ID，卸载完成后通过事件通知该任务。\n    rtems_id unmount_task;\n};\n```\n\n在 RTEMS 中，文件系统的操作由 rtems_filesystem_operations_table 结构体统一管理，它定义了路径解析、节点创建、删除、克隆等核心操作函数，作用上相当于 Linux 中的 inode_operations。每个挂载的文件系统通过 rtems_filesystem_mount_table_entry_t 表示，类似于 Linux 的 super_block，其中包含了指向操作表 ops 的指针。当用户发起如 open、read、write 等文件访问请求时，系统首先通过 eval_path_h 函数解析路径并定位到目标节点，然后使用该节点中挂载的 rtems_filesystem_file_handlers_r（类似 Linux 的 file_operations）来完成具体操作。整个设计将挂载管理、路径解析和文件操作职责分离，形成清晰的模块边界，同时借鉴了 Linux 文件系统架构的思想。\n\n```c\nstruct _rtems_filesystem_operations_table\n{\n    // 挂载点加锁函数，防止并发访问挂载点结构。\n    rtems_filesystem_mt_entry_lock_t lock_h;\n\n    // 挂载点解锁函数，与 lock_h 成对使用。\n    rtems_filesystem_mt_entry_unlock_t unlock_h;\n\n    // 路径解析函数，将路径转换为文件系统节点。\n    rtems_filesystem_eval_path_t eval_path_h;\n\n    // 创建硬链接的函数。\n    rtems_filesystem_link_t link_h;\n\n    // 判断两个节点是否表示同一对象的函数。\n    rtems_filesystem_are_nodes_equal_t are_nodes_equal_h;\n\n    // 创建文件系统节点（如文件、目录、设备节点）的函数。\n    rtems_filesystem_mknod_t mknod_h;\n\n    // 删除文件系统节点的函数。\n    rtems_filesystem_rmnod_t rmnod_h;\n\n    // 更改节点权限的函数，相当于 chmod。\n    rtems_filesystem_fchmod_t fchmod_h;\n\n    // 更改节点所有者信息的函数，相当于 chown。\n    rtems_filesystem_chown_t chown_h;\n\n    // 克隆节点的函数，通常用于目录项引用增加时复制节点。\n    rtems_filesystem_clonenode_t clonenod_h;\n\n    // 释放节点资源的函数，通常在节点引用减少到 0 时调用。\n    rtems_filesystem_freenode_t freenod_h;\n\n    // 文件系统挂载处理函数，处理实际挂载逻辑。\n    rtems_filesystem_mount_t mount_h;\n\n    // 文件系统卸载处理函数，释放挂载相关资源。\n    rtems_filesystem_unmount_t unmount_h;\n\n    // 文件系统自定义卸载钩子，用于挂载入口被清理时的回调。\n    rtems_filesystem_fsunmount_me_t fsunmount_me_h;\n\n    // 修改节点时间戳信息的函数，相当于 utimensat。\n    rtems_filesystem_utimens_t utimens_h;\n\n    // 创建符号链接的函数。\n    rtems_filesystem_symlink_t symlink_h;\n\n    // 读取符号链接目标路径的函数。\n    rtems_filesystem_readlink_t readlink_h;\n\n    // 重命名文件或目录的函数。\n    rtems_filesystem_rename_t rename_h;\n\n    // 获取文件系统统计信息的函数，如空间大小、inode 数等。\n    rtems_filesystem_statvfs_t statvfs_h;\n};\n```\n\n#### rtems_libio_allocate()\n\nopen 函数中分配文件描述符结构使用的函数是 rtems_libio_allocate()，执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始 rtems_libio_allocate 函数] --> B[加锁保护空闲链表]\n    B --> C[从空闲链表头获取 iop]\n    C --> D{iop 是否为 NULL?}\n    D -- 否 --> E[获取 iop->data1 到 next]\n    E --> F[更新空闲链表头指针为 next]\n    F --> G{next 是否为 NULL}\n    G -- 是 --> H[更新尾指针为 &rtems_libio_iop_free_head]\n    G -- 否 --> I[不操作]\n    D -- 是 --> I\n    H --> J[解锁释放访问]\n    I --> J\n    J --> K[返回 iop]\n```\n\n##### rtems_libio_iop_free_head\n\nrtems_libio_iop_free_head 是一个全局变量，用于维护 Rtems 文件描述符（rtems_libio_t）的空闲链表头指针。\n\n在初始化阶段，Rtems 会预分配一定数量的 rtems_libio_t 结构，并通过 data1 字段将它们串成一个单向链表。rtems_libio_iop_free_head 指向第一个可用节点。每次 rtems_libio_allocate() 被调用时，从头部取出一个节点，并更新链表。如果分配后链表为空，rtems_libio_iop_free_tail 会被指向 &rtems_libio_iop_free_head，表示空了。释放节点时会调用一个对应的 rtems_libio_free(iop)，将节点重新挂回链表尾部。\n\n那其实对于 rtems_libio_t 链表而言，在预分配的时候就需要将 rtems_filesystem_location_info_tt 中关于文件系统全局的 rtems_filesystem_file_handlers_r 和 rtems_filesystem_mount_table_entry_tt 信息写入，这样才能保证系统调用的时候能够成功调用底层函数。\n\n初始化阶段的函数逻辑如下：\n\n```mermaid\nflowchart TD\n    A[开始 rtems_libio_init 函数] --> B{rtems_libio_number_iops > 0?}\n    B -- 否 --> Z[结束函数]\n    B -- 是 --> C[设置空闲链表头指针]\n    C --> D[初始化循环变量 i = 0]\n    D --> E{i + 1 < rtems_libio_number_iops?}\n    E -- 是 --> F[设置 iop->data1 = iop + 1]\n    F --> G[i++, iop++]\n    G --> E\n    E -- 否 --> H[设置最后一个 iop->data1 = NULL]\n    H --> I[设置链表尾指针 rtems_libio_iop_free_tail = &iop->data1]\n    I --> Z\n```\n\nrtems_libio_iops 是 Rtems 预先分配的 I/O 控制块数组，配置了 CONFIGURE_MAXIMUM_FILE_DESCRIPTORS 以后，会预先创建出这个数组。\n\n问题来了：有了这个数组，为什么还要一个额外的 free list 链表来管理呢？\n\n```c\n#if CONFIGURE_MAXIMUM_FILE_DESCRIPTORS > 0\nrtems_libio_t rtems_libio_iops[CONFIGURE_MAXIMUM_FILE_DESCRIPTORS];\n\nconst uint32_t rtems_libio_number_iops = RTEMS_ARRAY_SIZE(rtems_libio_iops);\n#endif\n```\n\n#### do_open()\n\nopen() 函数中分配好文件描述符结构以后，最终会到达 do_open() 函数的位置进行处理。\n\n函数开始时，从 iop 获取文件描述符 fd，并根据 oflag 解析读写权限、创建、独占、截断和目录打开等标志。然后确定是否跟随符号链接，组合路径解析所需的权限标志 eval_flags。\n\n接着初始化路径解析上下文，解析路径并获取当前文件系统位置。若支持创建普通文件且路径未结束，则调用创建文件的函数。随后判断是否以目录方式打开，并检查写权限和目录类型的合法性，防止写目录或以目录方式打开非目录。\n\n路径信息保存到 iop->pathinfo，清理路径解析上下文后，设置文件控制标志，调用底层驱动的 open 函数打开文件。若成功且指定截断，则调用 ftruncate 截断文件内容，截断失败时关闭文件。\n\n最后，若操作全部成功，设置文件打开标志并返回文件描述符；失败时释放资源并返回错误。整个过程确保了路径解析、权限检查和文件打开的正确性和安全性。\n\ndo_open() 函数的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始 do_open] --> B[解析参数和标志]\n    B --> C[路径解析启动: rtems_filesystem_eval_path_start]\n    C --> D[获取 currentloc 和是否支持创建文件]\n    D --> E{是否需要创建普通文件?}\n    E -- 是 --> F[create_regular_file]\n    E -- 否 --> G[跳过创建]\n    F --> H[是否为目录打开或需要写权限?]\n    G --> H\n    H --> I{路径类型检查}\n    I -- 错误: 写目录 --> J[设置 EISDIR 错误]\n    I -- 错误: 非目录 --> K[设置 ENOTDIR 错误]\n    I --> L[提取 pathinfo 并清理上下文]\n\n    L --> M[设置 LibIO 打开标志]\n    M --> N[调用底层 open 函数]\n    N --> O{open 是否成功?}\n    O -- 否 --> P[释放 iop 并返回 -1]\n    O -- 是 --> Q{是否需要截断?}\n    Q -- 是 --> R{是否有写权限?}\n    R -- 否 --> S[errno = EINVAL, 返回错误]\n    R -- 是 --> T[调用 ftruncate]\n    T --> U{ftruncate 成功?}\n    U -- 否 --> V[调用 close, 返回 -1]\n    U -- 是 --> W[设置 LIBIO_FLAGS_OPEN, 返回 fd]\n    Q -- 否 --> W\n    S --> P\n    V --> P\n```\n\n##### 路径解析过程\n\ndo_open() 涉及到的路径解析代码片段如下：\n\n```c\n// 启动路径解析，准备解析文件路径。\nrtems_filesystem_eval_path_start(&ctx, path, eval_flags);\n\n// 获取解析后的当前路径位置信息。\ncurrentloc = rtems_filesystem_eval_path_get_currentloc(&ctx);\n```\n\nrtems_filesystem_eval_path_start() 的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[调用 rtems_filesystem_eval_path_start] --> B[调用 rtems_filesystem_eval_path_start_with_root_and_current]\n    B --> C[清空上下文 memset]\n    C --> D[设置 ctx 路径和长度]\n    D --> E[设置 ctx 标志位]\n    E --> F[初始化起始位置 set_startloc]\n    F --> G[锁定起始位置 rtems_filesystem_instance_lock]\n    G --> H[复制 startloc 到 currentloc]\n    H --> I[继续解析路径 rtems_filesystem_eval_path_continue]\n    I --> J[返回 ctx currentloc]\n```\n\n可以看出最后进入了 rtems_filesystem_eval_path_continue() 函数，嵌套太深了。目前看不懂整个路径的解析过程。\n\n路径解析完毕后，do_open() 函数中执行以下函数用于维护状态：\n\n```c\n// 获取解析后的当前路径位置信息。\ncurrentloc = rtems_filesystem_eval_path_get_currentloc(&ctx);\n\n// 判断当前路径所在文件系统是否允许创建普通文件。\ncreate_reg_file = !currentloc->mt_entry->no_regular_file_mknod;\n\n......\n\n\n// 将路径解析得到的当前路径信息保存到 iop 的 pathinfo 中。\nrtems_filesystem_eval_path_extract_currentloc(&ctx, &iop->pathinfo);\n\n// 清理路径解析上下文，释放资源。\nrtems_filesystem_eval_path_cleanup(&ctx);\n```\n\n##### 底层文件系统的 open 函数\n\n拿到所有信息以后，do_open() 函数中调用底层文件系统的 open() 函数真正打开文件：\n\n```c\n// 调用底层文件系统的 open 函数打开文件。\nrv = (*iop->pathinfo.handlers->open_h)(iop, path, oflag, mode);\n```\n\n### close()\n\nclose() 函数的执行流程图如下。在前面更改完状态标志位后，还是会进入到底层文件系统的 close_h 函数。\n\n```mermaid\nflowchart TD\n  A[开始关闭 fd] --> B{文件描述符是否越界}\n  B -- 是 --> C[设置错误码坏文件描述符并返回失败]\n  B -- 否 --> D[获取对应的 I/O 对象]\n  D --> E[读取 I/O 对象标志]\n  E --> F{标志中是否包含打开状态}\n  F -- 否 --> G[设置错误码坏文件描述符并返回失败]\n  F -- 是 --> H[清除引用计数部分]\n  H --> I[构造去掉打开标志的新标志]\n  I --> J[执行原子比较交换操作]\n  J --> K{比较交换是否成功}\n  K -- 是 --> L[继续关闭处理]\n  K -- 否 --> M{标志中是否有非法状态}\n  M -- 是 --> N[设置错误码设备忙并返回失败]\n  M -- 否 --> F\n\n  L --> O[调用文件系统的关闭函数]\n  O --> P[释放 I/O 对象]\n  P --> Q[返回关闭结果]\n```\n\n### read()\n\nread() 函数的执行流程图如下。可以看出除了做了一些检查以外，直接调用了底层文件系统的 read_h() 函数。\n\n```mermaid\nflowchart TD\n  A[开始调用 read 函数] --> B[确认缓冲区指针有效]\n  B --> C[确认读取长度合理]\n  C --> D{尝试获取对应的 I/O 对象并检查是否可读}\n  D -- 失败 --> E[设置错误码为坏文件描述符并返回失败]\n  D -- 成功 --> F[调用底层读操作完成读取]\n  F --> G[释放 I/O 资源]\n  G --> H[返回读取到的字节数或者错误码]\n```\n\n### write()\n\nwrite() 函数的执行流程图如下。大致逻辑同样同 read 函数。\n\n```mermaid\nflowchart TD\n  A[开始调用 write 函数] --> B[确认缓冲区指针有效]\n  B --> C[确认写入字节数合理]\n  C --> D{尝试获取对应的 I/O 对象并检查是否可写}\n  D -- 失败 --> E[设置错误码坏文件描述符并返回失败]\n  D -- 成功 --> F[调用底层写操作完成写入]\n  F --> G[释放 I/O 资源]\n  G --> H[返回写入的字节数或错误码]\n```\n\n## 文件系统启动流程\n\n### rtems_filesystem_initialize()\n\n该函数用于初始化 Rtems 的根文件系统，通常是 IMFS。[官方文档](https://docs.rtems.org/docs/6.1/filesystem/system_init.html) 提到，其他文件系统可以被挂载，但它们只能挂载到基础文件系统中的某个目录挂载点。对于我们想注册的自定义文件系统，有两种手段，一种是在根文件系统挂载好以后，找到某个目录手动挂载新文件系统，另一种是直接修改 rtems_filesystem_root_configuration 根文件系统的配置，使用我们自己的文件系统，这样 Rtems 在启动的时候就会默认跑我们自己的文件系统。\n\nrtems_filesystem_initialize() 函数的执行流程图如下：\n\n```mermaid\nflowchart TD\n  A[开始初始化文件系统] --> B[获取根文件系统挂载配置信息]\n  B --> C[挂载根文件系统]\n  C --> D{挂载是否成功}\n  D -- 否 --> E[触发致命错误停止系统]\n  D -- 是 --> F[创建 /dev 目录]\n  F --> G{目录创建是否成功}\n  G -- 否 --> H[触发致命错误停止系统]\n  G -- 是 --> I[根文件系统和 /dev 目录创建完成]\n  I --> J[说明其他文件系统需手动挂载]\n  J --> K[初始化完成]\n```\n\n#### struct rtems_filesystem_mount_configuration\n\n挂载根文件系统的挂载配置信息的结构体是 struct rtems_filesystem_mount_configuration。该结构体是 Rtems 中用于挂载文件系统时传递参数的配置结构。它的作用是将挂载一个文件系统所需的各种信息（如设备源、挂载点、文件系统类型等）集中在一起，作为参数传给 mount() 函数。\n\n```c\ntypedef struct\n{\n    // 描述挂载源，通常是设备路径，如 \"/dev/sd0\"；对 IMFS 等内存文件系统可为 NULL。\n    const char *source;\n\n    // 挂载目标目录，必须是系统中已存在的路径，如 \"/\" 或 \"/mnt/usb\"。\n    const char *target;\n\n    // 文件系统类型的名称字符串，如 \"imfs\"、\"dosfs\"、\"devfs\" 等。\n    const char *filesystemtype;\n\n    // 挂载选项，定义为 rtems_filesystem_options_t 类型，控制如只读、读写等行为。\n    rtems_filesystem_options_t options;\n\n    // 指向文件系统特定的附加数据，一般为 NULL，某些文件系统可能使用此字段传递配置。\n    const void *data;\n} rtems_filesystem_mount_configuration;\n```\n\n在 rtems_filesystem_initialize() 中，根文件系统的配置是预定义好的全局变量 rtems_filesystem_root_configuration。\n\n```c\nconst rtems_filesystem_mount_configuration rtems_filesystem_root_configuration = {\n    NULL,\n    NULL,\n    \"/\",\n    RTEMS_FILESYSTEM_READ_WRITE,\n    &IMFS_root_mount_data,\n};\n```\n\n### rtems_filesystem_register()\n\nrtems_filesystem_register() 用于在 Rtems 操作系统中注册一个新的文件系统类型。它接收文件系统的类型名称和对应的挂载函数指针，动态分配内存创建一个文件系统节点，将类型名称和挂载函数保存到该节点中，并检查该类型是否已被注册。如果未注册，则将该节点添加到全局文件系统链表完成注册；如果已注册，则释放内存并返回错误。通过这个注册机制，系统能够识别和管理多种文件系统类型，并在需要时调用对应的挂载函数进行挂载操作。\n\nrtems_filesystem_register() 的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始 rtems_filesystem_register] --> B[计算 type_size 与 fsn_size 并 malloc 分配 fsn]\n    B --> C{fsn 是否为 NULL?}\n    C -- 是 --> D[设置 errno 等于 ENOMEM 并返回 -1]\n    C -- 否 --> E[计算 type_storage 并 memcpy 复制类型字符串]\n    E --> F[设置 fsn->entry.type 等于 type_storage]\n    F --> G[设置 fsn->entry.mount_h 等于 mount_h]\n    G --> H[rtems_libio_lock 进入临界区]\n    H --> I{rtems_filesystem_get_mount_handler 判断 type 是否已注册}\n    I -- 未注册 --> J[rtems_chain_initialize_node 初始化链表节点]\n    J --> K[rtems_chain_append_unprotected 将 fsn 添加到全局链表]\n    K --> L[rtems_libio_unlock 解锁]\n    L --> M[返回 0 注册成功]\n    I -- 已注册 --> N[rtems_libio_unlock 解锁]\n    N --> O[free fsn 释放内存]\n    O --> P[设置 errno 等于 EINVAL 并返回 -1]\n```\n\n在 rtems_filesystem_register() 的源码中，有几行比较细节的地方。在 Rtems 中，文件系统的注册全局表有两个，一个是静态表 rtems_filesystem_table，一个是动态表 filesystem_chain。静态表是 Rtems 预先定义好的常量，提供了 Rtems 内置的文件系统。动态表用于用户动态注册文件系统，在下面的函数实现中，如果发现全局表没有注册该文件系统，Rtems 会将该文件系统挂到 filesystem_chain 上。\n\n好，问题来了，表里面除了 type 成员，更重要的是挂载函数 rtems_filesystem_fsmount_me_t。这个函数是需要我们自己写的，也就是说 Rtems 在注册文件系统的时候，除了记录到注册全局表以后，就没有其他架构上的操作了。后面的操作都需要我们自己做，Rtems 的文件系统虚拟层目前看起来几乎没有。\n\n```c\nrtems_chain_control *chain = &filesystem_chain;\n\n...\n\nif (rtems_filesystem_get_mount_handler(type) == NULL)\n{\n    rtems_chain_initialize_node(&fsn->node);\n    rtems_chain_append_unprotected(chain, &fsn->node);\n}\nelse\n{\n    ...\n}\n```\n\n#### struct filesystem_node\n\nstruct filesystem_node 结构体的作用是将一个文件系统的描述信息封装为链表中的一个节点，使得多个文件系统表项可以通过链表的形式组织和管理。它结合了 Rtems 的链表节点结构 rtems_chain_node 与文件系统表项 rtems_filesystem_table_t，方便在系统中动态维护、查找和操作支持的文件系统。该结构体通常用于构建一个文件系统注册表，实现对多个文件系统的统一管理和遍历。\n\n```c\n// 定义一个结构体类型 filesystem_node，用于表示文件系统链表中的一个节点。\ntypedef struct\n{\n    // RTEMS 提供的双向链表节点结构，用于将多个文件系统节点连接成链表。\n    rtems_chain_node node;\n\n    // 文件系统表项，包含该文件系统的初始化函数、挂载函数等描述信息。\n    rtems_filesystem_table_t entry;\n} filesystem_node;\n```\n\n#### struct rtems_filesystem_table_t\n\nstruct rtems_filesystem_table_t 结构体的作用是描述一个可挂载的文件系统类型，包括文件系统的类型名称和对应的挂载函数。它为 RTEMS 提供了一种统一的方式来表示和管理不同类型的文件系统，使系统能够在运行时根据类型名称选择合适的挂载函数进行文件系统初始化和挂载操作。这种设计有助于扩展文件系统支持，并实现灵活的文件系统管理机制。\n\n在 rtems_filesystem_register() 函数中，成员 type 和 mount_h 通过函数参数传入，并在函数内赋值。\n\n```c\n// 定义一个结构体类型 rtems_filesystem_table_t，用于描述一个可挂载的文件系统类型。\ntypedef struct rtems_filesystem_table_t\n{\n    // 文件系统的类型名称，通常为字符串形式，例如 \"imfs\" 或 \"dosfs\"。\n    const char *type;\n\n    // 文件系统的挂载函数指针，用于挂载该类型的文件系统。\n    rtems_filesystem_fsmount_me_t mount_h;\n} rtems_filesystem_table_t;\n```\n\n#### rtems_filesystem_fsmount_me_t\n\nrtems_filesystem_fsmount_me_t 是一个函数指针，定义如下：\n\n```c\n/**\n * @brief 初始化一个文件系统实例。\n *\n * 该函数负责初始化挂载表项中的文件系统根节点。\n *\n * @param[in] mt_entry 指向挂载表项的指针，表示要挂载的文件系统实例。\n * @param[in] data 用户提供的初始化数据，如设备路径或挂载选项。\n *\n * @retval 0 操作成功，文件系统实例初始化完成。\n * @retval -1 操作失败，设置 errno 以指示具体错误。\n */\n\n// 定义函数指针类型 rtems_filesystem_fsmount_me_t，表示挂载文件系统的函数。\n// 该函数接受挂载表项指针和用户数据作为参数，返回挂载结果。\n// 返回 0 表示挂载成功，返回 -1 表示挂载失败且设置 errno。\ntypedef int (*rtems_filesystem_fsmount_me_t)(\n    rtems_filesystem_mount_table_entry_t *mt_entry, // 指向挂载表项，表示要挂载的文件系统。\n    const void *data                                // 用户传入的初始化数据。\n);\n```\n\nstruct rtems_filesystem_mount_table_entry_t 结构体的作用是为每一个已挂载的文件系统提供一个集中式的描述，包含了文件系统的根节点信息、挂载点、类型、设备、访问控制状态等关键信息。Rtems 会维护一个这样的挂载表链表，每个表项都是这个结构体的一个实例。在挂载和卸载文件系统时，Rtems 会对这个结构体进行相应的初始化、操作或释放。文件系统的挂载、查找路径、访问权限、卸载等都依赖于这个结构体中记录的信息。\n\n关于 struct rtems_filesystem_mount_table_entry_tt 和 struct _rtems_filesystem_operations_table，前面在 struct rtems_libio_t 的时候提到过，不再赘述。\n\n### rtems_fsmount()\n\nrtems_fsmount() 函数的作用是批量挂载多个文件系统，它按照用户提供的挂载表（fstab）顺序，依次创建每个挂载点目录并调用 mount() 执行挂载操作。该函数支持错误报告和失败控制机制，允许用户根据挂载结果决定是否继续处理后续项。通过这种方式，rtems_fsmount 提供了一种统一、高效的接口，适用于系统启动时自动挂载多个文件系统，简化了挂载流程并增强了可配置性。\n\nrtems_fsmount() 的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始, 初始化 rc, fstab_idx, terminate] --> B[检查循环条件 fstab_idx 小于 fstab_count, 且 terminate 为 false]\n    B -->|是| C[创建挂载点, 调用 rtems_mkdir]\n    C --> D{创建成功}\n    D -- 否 --> E[根据配置报告错误, 更新 terminate 和 rc]\n    D -- 是 --> F[执行挂载, 调用 mount]\n    F --> G{挂载成功}\n    G -- 否 --> H[根据配置报告挂载失败, 更新 terminate 和 rc]\n    G -- 是 --> I[根据配置报告挂载成功, 更新 terminate]\n    E & H & I --> J{terminate}\n    J -- 否 --> K[fstab_ptr 前移, fstab_idx 加一, 然后返回 B]\n    J -- 是 --> L[退出循环]\n    B -->|否| L\n    L --> M{fail_idx 是否存在}\n    M -- 是 --> N[写入失败索引]\n    M -- 否 --> O\n    N --> P[返回 rc]\n    O --> P\n```\n\n#### struct rtems_fstab_entry\n\nstruct rtems_fstab_entry 用于描述单个文件系统的挂载配置信息，包括挂载源设备或路径、挂载点目录、文件系统类型以及挂载时的选项和行为控制标志。它为系统批量挂载文件系统时提供了统一的数据格式，使挂载操作可以根据该结构体中的信息依次执行，支持对挂载过程中的错误报告和中止条件进行灵活管理。\n\n```c\n// 文件系统挂载表条目结构体。\n// 用于描述一个文件系统的挂载信息，包括挂载源、挂载点、文件系统类型及挂载选项。\ntypedef struct\n{\n    // 挂载源，表示要挂载的设备、分区或路径。\n    const char *source;\n\n    // 挂载目标，即挂载点路径，文件系统将挂载到该目录下。\n    const char *target;\n\n    // 文件系统类型名称，如 \"imfs\"、\"dosfs\" 等。\n    const char *type;\n\n    // 文件系统挂载选项，包含挂载时的参数配置。\n    // // 文件系统挂载选项枚举类型，定义了文件系统挂载时支持的不同访问权限模式。\n    // typedef enum\n    // {\n    //     // 只读模式，文件系统以只读方式挂载。\n    //     RTEMS_FILESYSTEM_READ_ONLY,\n\n    //     // 读写模式，文件系统以读写方式挂载。\n    //     RTEMS_FILESYSTEM_READ_WRITE,\n\n    //     // 无效或错误的挂载选项。\n    //     RTEMS_FILESYSTEM_BAD_OPTIONS\n    // } rtems_filesystem_options_t;\n    rtems_filesystem_options_t options;\n\n    // 报告条件标志，用于指定哪些情况需要报告错误或信息。\n    uint16_t report_reasons;\n\n    // 终止条件标志，用于指定哪些情况会导致挂载流程终止。\n    uint16_t abort_reasons;\n} rtems_fstab_entry;\n```\n\n#### mount()\n\nmount() 函数用于根据指定的源路径、目标挂载点、文件系统类型和挂载选项，完成文件系统的挂载操作。它首先根据文件系统类型获取对应的挂载处理函数，然后创建一个挂载表项来保存挂载信息，调用具体文件系统的挂载函数进行挂载，并将挂载点注册到系统的文件系统层次中。如果挂载或注册失败，会进行相应的资源释放和错误处理。函数最终返回挂载结果，成功返回 0，失败返回 -1 并设置相应的错误码。\n\nmount() 函数的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始, 调用 mount] --> B[验证 options 是否为只读 或 读写]\n    B -->|无效| C[设置 errno 为 EINVAL, 返回 -1]\n    B -->|有效| D[调用 rtems_filesystem_get_mount_handler, 获取挂载函数]\n    D -->|无 函数| E[设置 errno 为 EINVAL, 返回 -1]\n    D -->|有 函数| F[调用 alloc_mount_table_entry, 分配挂载表项]\n    F -->|分配 失败| G[设置 errno 为 ENOMEM, 返回 -1]\n    F -->|分配 成功| H[根据 options 设置 writeable 标志]\n    H --> I[调用挂载函数, 执行挂载]\n    I -->|挂载 失败| J[释放挂载表项, 返回 -1]\n    I -->|挂载 成功| K[注册 文件系统]\n    K -->|注册 成功| L[返回 0]\n    K -->|注册 失败| M[调用 fsunmount, 卸载, 释放挂载表项, 返回 -1]\n```\n\n## IMFS 文件系统\n\nIMFS（In‐Memory File System）是 Rtems 提供的一个内存文件系统。它将文件和目录全部存储在 RAM 中，为嵌入式应用提供快速、轻量级的 POSIX 风格文件操作接口；其核心模块负责管理目录树结构、路径解析和文件读写逻辑，而底层的节点分配与销毁、元数据初始化等则通过回调函数（如 node_initialize、node_remove、node_destroy）由系统默认实现或用户自定义实现来完成，使得 IMFS 在不修改主体框架的情况下能够灵活适配不同内存布局或特殊需求，启动时通过 IMFS_initialize 自动注册并挂载为根文件系统，用户即可直接使用标准的 open/read/write/close 等接口访问内存中存储的文件。\n\n### rtems_filesystem_get_mount_handler()\n\n在 rtems_filesystem_register() 中，有一步是调用 rtems_filesystem_get_mount_handler 函数判断节点类型是否注册。这不仅让我们联想到，可能 Rtems 内部维护了一张全局表，专门用于记录目前已挂载的文件系统的信息。\n\nrtems_filesystem_get_mount_handler() 的执行流程如下。\n\n```mermaid\nflowchart TD\n    A[开始 rtems_filesystem_get_mount_handler] --> B{type 为空?}\n    B -- 是 --> C[返回 NULL]\n    B -- 否 --> D[遍历表 rtems_filesystem_table]\n    D --> E{表项匹配?}\n    E -- 是 --> F[返回对应 mount_h]\n    E -- 否 --> G[遍历表 filesystem_chain]\n    G --> H{表项匹配?}\n    H -- 是 --> I[返回对应 mount_h]\n    H -- 否 --> J[返回 NULL]\n```\n\n在 rtems_filesystem_iterate 函数中，可以发现 Rtems 定义了全局的两个表 filesystem_chain 和 rtems_filesystem_table。源码中无法直接跳转 filesystem_chain，目前无法得知他的具体状况。\n\n```c\nrtems_chain_control *chain = &filesystem_chain;\n\nconst rtems_filesystem_table_t *table_entry = &rtems_filesystem_table[0];\n```\n\n#### variable rtems_filesystem_table\n\n关于 rtems_filesystem_table，它用于表示挂载的文件系统的信息，并且猜测大概率是预挂载的文件系统的信息。结构体 rtems_filesystem_table_t 前面提到过，两个成员分别代表文件系统的类型名称 type 和文件系统的挂载函数指针 mount_h。\n\nrtems_filesystem_table 的定义如下。其中关于 IMFS 有两个地方提到，一个是文件系统名字叫 \"/\" 的文件系统，一个是下面的 IMFS 文件系统。他们对应的挂载函数分别叫 IMFS_initialize_support() 和 IMFS_initialize()。\n\n```c\nconst rtems_filesystem_table_t rtems_filesystem_table[] = {\n    {\"/\", IMFS_initialize_support},\n#ifdef CONFIGURE_FILESYSTEM_DOSFS\n    {RTEMS_FILESYSTEM_TYPE_DOSFS, rtems_dosfs_initialize},\n#endif\n#ifdef CONFIGURE_FILESYSTEM_FTPFS\n    {RTEMS_FILESYSTEM_TYPE_FTPFS, rtems_ftpfs_initialize},\n#endif\n#ifdef CONFIGURE_FILESYSTEM_IMFS\n    {RTEMS_FILESYSTEM_TYPE_IMFS, IMFS_initialize},\n#endif\n#ifdef CONFIGURE_FILESYSTEM_JFFS2\n    {RTEMS_FILESYSTEM_TYPE_JFFS2, rtems_jffs2_initialize},\n#endif\n#ifdef CONFIGURE_FILESYSTEM_NFS\n    {RTEMS_FILESYSTEM_TYPE_NFS, rtems_nfs_initialize},\n#endif\n#ifdef CONFIGURE_FILESYSTEM_RFS\n    {RTEMS_FILESYSTEM_TYPE_RFS, rtems_rfs_rtems_initialise},\n#endif\n#ifdef CONFIGURE_FILESYSTEM_TFTPFS\n    {RTEMS_FILESYSTEM_TYPE_TFTPFS, rtems_tftpfs_initialize},\n#endif\n    {NULL, NULL}};\n```\n\n### IMFS_initialize() 和 IMFS_initialize_support()\n\nIMFS_initialize() 的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始 IMFS_initialize] --> B[调用 calloc 分配并清零 fs_info 内存]\n    B --> C{fs_info 是否为 NULL}\n    C -- 是 --> D[设置 errno 为 ENOMEM] --> E[返回 -1, 初始化失败]\n    C -- 否 --> F[构造 IMFS_mount_data 结构体]\n    F --> G[填入 fs_info 指针<br>填入文件系统操作集 &IMFS_ops<br>填入默认节点创建控制表 &IMFS_default_mknod_controls]\n    G --> H[调用 IMFS_initialize_support 进行实际初始化和挂载]\n    H --> I[返回初始化结果]\n```\n\n其中填充 IMFS_mount_data 结构体的代码截取如下，可以看出 rtems_filesystem_operations_table 结构体的回调函数是在这里被注册进去的。\n\n```c\ntypedef struct\n{\n    IMFS_fs_info_t *fs_info;\n    const rtems_filesystem_operations_table *ops;\n    const IMFS_mknod_controls *mknod_controls;\n} IMFS_mount_data;\n\n// 构造挂载所需的初始化数据结构，包括操作集和创建节点控制表。\nIMFS_mount_data mount_data = {\n    .fs_info = fs_info,                            // 文件系统内部信息。\n    .ops = &IMFS_ops,                              // 文件系统操作函数集合。\n    .mknod_controls = &IMFS_default_mknod_controls // 创建节点控制信息。\n};\n```\n\nIMFS_initialize() 最后会调用 IMFS_initialize_support()，IMFS_initialize_support() 的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始 IMFS_initialize_support 函数] --> B[将 data 转为 IMFS_mount_data 指针]\n    B --> C[提取 fs_info 和 mknod_controls]\n    C --> D[获取 node_control 和 root_node 指针]\n    D --> E[设置挂载点 mt_entry 的各项字段, 包括 fs_info, ops, pathconf, root 节点信息]\n    E --> F[调用 IMFS_initialize_node 初始化根目录节点]\n    F --> G[断言 root_node 不为 NULL]\n    G --> H[返回 0, 表示初始化成功]\n```\n\n这其中也做了很多赋值操作，代码片段截取如下。其中 _rtems_filesystem_file_handlers_r 结构体的回调函数是在这里注册进去的。\n\n```c\n// 转换传入的 data 参数为具体类型。\nmount_data = data;\n\n// 提取文件系统信息和 mknod 控制器。\nfs_info = mount_data->fs_info;\nfs_info->mknod_controls = mount_data->mknod_controls;\n\n// 获取根目录所用的节点控制器。\nnode_control = &mount_data->mknod_controls->directory->node_control;\n\n// 获取根节点结构体的地址。\nroot_node = &fs_info->Root_directory.Node;\n\n// 设置挂载点结构 mt_entry 的基本信息。\nmt_entry->fs_info = fs_info;                                      // 文件系统私有数据。\nmt_entry->ops = mount_data->ops;                                  // 文件系统操作集。\nmt_entry->pathconf_limits_and_options = &IMFS_LIMITS_AND_OPTIONS; // 路径相关限制。\n\n// 设置挂载根目录的节点访问和操作处理函数。\nmt_entry->mt_fs_root->location.node_access = root_node;\nmt_entry->mt_fs_root->location.handlers = node_control->handlers;\n```\n\n#### IMFS_initialize_node()\n\nIMFS_initialize_support() 最后会调用 IMFS_initialize_node() 函数。该函数用于初始化一个 IMFS 节点（内存文件系统中的目录或文件节点）。根据传入的信息填充节点结构体的基本字段，并调用节点类型控制器提供的初始化回调。成功返回已初始化的节点指针，失败返回 NULL 并设置 errno。\n\nIMFS_initialize_node() 的执行流程图如下：\n\n```mermaid\nflowchart TD\n    A[开始 IMFS_initialize_node 函数] --> B{namelen 是否超过 IMFS_NAME_MAX}\n    B -- 是 --> C[设置 errno 为 ENAMETOOLONG<br>返回 NULL]\n    B -- 否 --> D[填充节点基本字段 name, namelen, reference_count, st_nlink, control]\n    D --> E[设置权限和属主信息 mode, uid, gid]\n    E --> F[获取当前时间 now]\n    F --> G[设置时间戳 atime, mtime, ctime]\n    G --> H[调用 node_control 的 node_initialize 回调]\n    H --> I[返回初始化后的节点指针]\n```\n\n该函数在设置了节点 node 的信息以后，会调用 node_control 结构体的 node_initialize 回调函数进行 node 初始化。代码片段如下：\n\n```c\n// 调用节点控制器中定义的初始化函数以执行具体类型的初始化。\nreturn (*node_control->node_initialize)(node, arg);\n```\n\n### struct IMFS_jnode_tt\n\nIMFS_jnode_tt 是 IMFS 自己设计的 inode 结构，作用和 Linux 中文件系统自己的 inode 结构效果相同，定义如下：\n\n```c\n// IMFS_jnode_tt 是 IMFS 文件系统中用于表示一个文件或目录的节点结构体。这是内存文件系统（IMFS）中最核心的数据结构之一，包含名称、权限、所有者、时间戳等元数据，以及指向父节点和控制操作的指针。\nstruct IMFS_jnode_tt\n{\n    // 用于将该节点链接入链表中。\n    rtems_chain_node Node;\n\n    // 指向父节点的指针。\n    IMFS_jnode_t *Parent;\n\n    // 节点名称，不以 \\0 结尾（即不是 C 字符串）。\n    const char *name;\n\n    // 节点名称的长度（对应上面的 name）。\n    uint16_t namelen;\n\n    // 文件类型和权限信息（如目录、常规文件、权限位）。\n    mode_t st_mode;\n\n    // 节点的引用计数，用于资源管理。\n    unsigned short reference_count;\n\n    // 硬链接数量（链接计数）。\n    nlink_t st_nlink;\n\n    // 拥有者的用户 ID。\n    uid_t st_uid;\n\n    // 拥有者的组 ID。\n    gid_t st_gid;\n\n    // 最后一次访问时间。\n    time_t stat_atime;\n\n    // 最后一次修改内容的时间。\n    time_t stat_mtime;\n\n    // 最后一次属性更改（如权限、所有者等）的时间。\n    time_t stat_ctime;\n\n    // 节点控制器，定义节点的行为和操作函数。\n    const IMFS_node_control *control;\n};\n```\n\n#### struct IMFS_node_control\n\nstruct IMFS_jnode_tt 中除了 inode 的基本信息以外，需要关注的一点就是 struct IMFS_node_control。该结构体定义了 IMFS inode 节点的操作函数，并作统一控制管理。\n\n```c\n/**\n * @brief IMFS node control.\n */\n// IMFS_node_control：定义 IMFS 节点类型的操作控制器。\n// 每种节点类型（如普通文件、目录、符号链接等）可以拥有自己的 handlers 和初始化、销毁等函数指针。\n// 该结构体允许 IMFS 在操作不同类型节点时通过回调机制实现多态行为。\ntypedef struct\n{\n    // 文件操作处理器集合，包含 open、read、write、ioctl 等函数指针。\n    // 每种节点类型可以定义不同的 handlers。\n    const rtems_filesystem_file_handlers_r *handlers;\n\n    // 节点初始化函数，在创建该类型节点时调用。\n    // 通常在 IMFS_initialize_node 中调用，用于执行类型特定的初始化逻辑。\n    IMFS_node_control_initialize node_initialize;\n\n    // 节点删除函数，在执行 unlink/remove 操作时调用。\n    // 用于处理节点类型特定的清理逻辑，如从父结构中移除等。\n    IMFS_node_control_remove node_remove;\n\n    // 节点销毁函数，在释放节点内存或引用计数归零时调用。\n    // 通常用于释放节点中私有数据或执行资源回收。\n    IMFS_node_control_destroy node_destroy;\n} IMFS_node_control;\n```\n\n前面提到，_rtems_filesystem_file_handlers_r 结构体的回调函数是在 IMFS_initialize_support() 中注册的，最终就来源于 IMFS_node_control 中的 rtems_filesystem_file_handlers_r *handlers。\n\n```c\nmt_entry->mt_fs_root->location.handlers = node_control->handlers;\n```\n\n下一步就是找到这些函数最开始是在哪里被注册的。最终在 cpukit/libfs/src/imfs/imfs_linfile.c 中找到了答案：\n\n```c\nstatic const rtems_filesystem_file_handlers_r IMFS_linfile_handlers = {\n    .open_h = IMFS_linfile_open,\n    .close_h = rtems_filesystem_default_close,\n    .read_h = IMFS_linfile_read,\n    .write_h = rtems_filesystem_default_write,\n    .ioctl_h = rtems_filesystem_default_ioctl,\n    .lseek_h = rtems_filesystem_default_lseek_file,\n    .fstat_h = IMFS_stat_file,\n    .ftruncate_h = rtems_filesystem_default_ftruncate,\n    .fsync_h = rtems_filesystem_default_fsync_or_fdatasync_success,\n    .fdatasync_h = rtems_filesystem_default_fsync_or_fdatasync_success,\n    .fcntl_h = rtems_filesystem_default_fcntl,\n    .kqfilter_h = rtems_filesystem_default_kqfilter,\n    .mmap_h = rtems_filesystem_default_mmap,\n    .poll_h = rtems_filesystem_default_poll,\n    .readv_h = rtems_filesystem_default_readv,\n    .writev_h = rtems_filesystem_default_writev};\n\nconst IMFS_node_control IMFS_node_control_linfile = {\n    .handlers = &IMFS_linfile_handlers,\n    .node_initialize = IMFS_node_initialize_linfile,\n    .node_remove = IMFS_node_remove_default,\n    .node_destroy = IMFS_node_destroy_default};\n```\n\n# 参考文档\n\n1. [RTEMS Filesystem Design Guide (6.1). — RTEMS Filesystem Design Guide 6.1 (22nd January 2025) documentation](https://docs.rtems.org/docs/6.1/filesystem/index.html)\n2. [rtems文件系统部分 - 《ext4文件系统移植》 - 极客文档](https://geekdaxue.co/read/linggs@qnf7q6/pnhxbw)\n\n","categories":["Linux 学习","内核层"]},{"title":"Block Device Drivers","url":"/posts/69869e7f.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n块设备是与字符设备并列的概念，这两类设备（一共三类，还有一类是网络设备）在 Linux 中的驱动结构有较大差异。总体而言，块设备驱动比字符设备驱动复杂得多，在 I/O 操作上也有极大的不同。缓冲、I/O 调度、请求队列等都是与块设备驱动相关的概念。\n\n# 块设备的 I/O 操作特点\n\n块设备 I/O 操作与字符设备的不同之处如下：\n\n1. **块设备只能以块为单位接收输入和返回输出，而字符设备则以字节为单位。大多数设备是字符设备，因为它们不需要缓冲而且不以固定块大小进行操作。**\n2. **块设备对于 I/O 请求有对应的缓冲区，故它们可以选择以什么顺序进行响应，而字符设备无须缓冲且被直接读写。对存储设备而言，调整读写的顺序作用巨大，因为在读写连续的扇区的存储速度比分离的扇区更快。**\n3. **字符设备只能顺序读写，而块设备能随机访问。**\n\n<!-- more -->\n\n虽然块设备可随机访问，但对于磁盘这类机械设备而言，顺序地组织块设备的访问可以提高性能。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241211095908580.png\" alt=\"image-20241211095908580\" style=\"zoom:70%;\" />\n\n在 Linux 中通常通过磁盘文件系统 EXT4、UBIFS 等访问磁盘，但磁盘也有一种原始设备的访问方式，如直接访问 /dev/sdb1 等。所有的 EXT4、UBIFS、原始块设备都工作于 VFS 之下，而 EXT4、UBIFS、原始块设备之下又包含块 I/O 调度层以进行排序和合并。**I/O 调度层的基本目的是将请求按照它们对应在块设备上的扇区号进行排列，以减少磁头的移动，提高效率。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241211100707232.png\" alt=\"image-20241211100707232\" style=\"zoom:75%;\" />\n\n# 块设备驱动结构\n\n## block_device_operations 结构体\n\n块设备驱动有个类似字符设备驱动 file_operations 的 block_device_operations 结构体，是对块设备操作的集合。\n\n```c\nstruct block_device_operations {\n\tblk_qc_t (*submit_bio) (struct bio *bio);\n\tint (*open) (struct block_device *, fmode_t);\n\tvoid (*release) (struct gendisk *, fmode_t);\n\tint (*rw_page)(struct block_device *, sector_t, struct page *, unsigned int);\n\tint (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\n\tint (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\n\tunsigned int (*check_events) (struct gendisk *disk,\n\t\t\t\t      unsigned int clearing);\n    /* ->media_changed() is DEPRECATED, use ->check_events() instead */\n\tvoid (*unlock_native_capacity) (struct gendisk *);\n\tint (*getgeo)(struct block_device *, struct hd_geometry *);\n\tint (*set_read_only)(struct block_device *bdev, bool ro);\n\t/* this callback is with swap_lock and sometimes page table lock held */\n\tvoid (*swap_slot_free_notify) (struct block_device *, unsigned long);\n\tint (*report_zones)(struct gendisk *, sector_t sector,\n\t\t\tunsigned int nr_zones, report_zones_cb cb, void *data);\n\tchar *(*devnode)(struct gendisk *disk, umode_t *mode);\n\tstruct module *owner;\n\tconst struct pr_ops *pr_ops;\n\n\t/*\n\t * Special callback for probing GPT entry at a given sector.\n\t * Needed by Android devices, used by GPT scanner and MMC blk\n\t * driver.\n\t */\n\tint (*alternative_gpt_sector)(struct gendisk *disk, sector_t *sector);\n};\n```\n\n1. 打开与释放\n\n当设备被打开和关闭的时会调用这两个函数。\n\n```c\nint (*open) (struct block_device *, fmode_t);\nvoid (*release) (struct gendisk *, fmode_t);\n```\n\n2. I/O 控制\n\n同字符设备，进行系统调用 ioctl() 时会走到驱动的这两个函数，具体调用哪个看具体情况。块设备包含大量的标准请求，这些请求由 Linux 通用块设备层处理，故大部分块设备驱动的 ioctl() 函数相当短。一个 64 位系统内的 32 位进程调用 ioctl() 时，调用的是 compat_ioctl()。\n\n```c\nint (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\nint (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long);\n```\n\n3. 介质改变\n\n老版本使用的是函数 media_changed()，Linux 4.0 以后已废除，改而使用 check_events()。\n\n内核调用此函数检查驱动器中的介质是否已经改变。若是，返回一个非 0 值，否则返回 0。此函数仅适用于支持可移动介质的驱动器，通常需要在驱动中增加一个表示介质状态是否改变的标志变量，非可移动设备的驱动无需实现此方法。\n\nmedia_changed() 在用户空间轮询可移动磁盘介质是否存在，而 check_events() 在内核空间里轮询。check_events() 检查有无挂起事件，若有 DISK_EVENT_MEDIA_CHANGE 和 DISK_EVENT_EJECT_REQUEST 事件，就返回。\n\n```c\nint (*media_changed) (struct gendisk *gd);\nunsigned int (*check_events) (struct gendisk *disk, unsigned int clearing);\n```\n\n4. 使介质有效\n\nLinux 5.15 以前存在接口 revalidate_disk()，目前已移除。暂未找到替代接口，可能牵扯到了部分设计。\n\n```c\n// 用于响应一个介质改变，它给驱动一个机会进行必要的工作以使新介质准备好。\nint (*revalidate_disk) (struct gendisk *gd);\n```\n\n5. 获得驱动器信息\n\ngetgeo() 函数根据驱动器的几何信息填充一个 hd_geometry 结构体，包含磁头、扇区、柱面等信息。\n\n```c\nint (*getgeo)(struct block_device *, struct hd_geometry *);\n\nstruct hd_geometry {\n      unsigned char heads;\n      unsigned char sectors;\n      unsigned short cylinders;\n      unsigned long start;\n};\n```\n\n6. 模块指针\n\n拥有这个结构体的模块的指针，通常被初始化为 THIS_MODULE。\n\n```c\nstruct module *owner;\n```\n\n## gendisk 结构体\n\nLinux 内核使用 gendisk（通用磁盘）结构体表示一个独立的磁盘设备（例如分区）。\n\n```c\nstruct gendisk {\n\t/* major, first_minor and minors are input parameters only,\n\t * don't use directly.  Use disk_devt() and disk_max_parts().\n\t */\n\tint major;\t\t\t/* major number of driver */\n\tint first_minor;\n\tint minors;                     /* maximum number of minors, =1 for\n                                         * disks that can't be partitioned. */\n\n\tchar disk_name[DISK_NAME_LEN];\t/* name of major driver */\n\n\tunsigned short events;\t\t/* supported events */\n\tunsigned short event_flags;\t/* flags related to event processing */\n\n\tstruct xarray part_tbl;\n\tstruct block_device *part0;\n\n\tconst struct block_device_operations *fops;\n\tstruct request_queue *queue;\n\tvoid *private_data;\n\n\tint flags;\n\tunsigned long state;\n#define GD_NEED_PART_SCAN\t\t0\n#define GD_READ_ONLY\t\t\t1\n#define GD_DEAD\t\t\t\t2\n#define GD_NATIVE_CAPACITY\t\t3\n\n\tstruct mutex open_mutex;\t/* open/close mutex */\n\tunsigned open_partitions;\t/* number of open partitions */\n\n\tstruct backing_dev_info\t*bdi;\n\tstruct kobject *slave_dir;\n#ifdef CONFIG_BLOCK_HOLDER_DEPRECATED\n\tstruct list_head slave_bdevs;\n#endif\n\tstruct timer_rand_state *random;\n\tatomic_t sync_io;\t\t/* RAID */\n\tstruct disk_events *ev;\n#ifdef  CONFIG_BLK_DEV_INTEGRITY\n\tstruct kobject integrity_kobj;\n#endif\t/* CONFIG_BLK_DEV_INTEGRITY */\n#if IS_ENABLED(CONFIG_CDROM)\n\tstruct cdrom_device_info *cdi;\n#endif\n\tint node_id;\n\tstruct badblocks *bb;\n\tstruct lockdep_map lockdep_map;\n\tu64 diskseq;\n};\n```\n\nmajor、first_minor 和 minors 共同代表磁盘的主、次设备号，同一个磁盘的各个分区共享一个主设备号，而次设备号则不同。fops 为 block_device_operations，即块设备的操作集合。queue 是内核用来管理这个设备的 I/O 请求队列的指针。private_data 指向磁盘的任何私有数据，用法类似字符设备的 private_data。\n\nLinux 提供了一组函数操作 gendisk。\n\n1. 分配 gendisk\n\ngendisk 结构体是个动态分配的结构体，需要特别的内核操作来初始化，驱动不能自己分配这个结构体。\n\n旧版使用接口 alloc_disk() 分配 gendisk。注意下面新版和旧版代码的区别。 \n\n```c\n// 旧版\n// minors 参数是这个磁盘使用的次设备号的数量，一般也是磁盘分区的数量，此后不能被修改。\n#define alloc_disk(minors) alloc_disk_node(minors, NUMA_NO_NODE)\n\n#define alloc_disk_node(minors, node_id)\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\t\\\n\tconst char *__name;\t\t\t\t\t\t\\\n\tstruct gendisk *__disk;\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__name = \"(gendisk_completion)\"#minors\"(\"#node_id\")\";\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__disk = __alloc_disk_node(minors, node_id);\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (__disk)\t\t\t\t\t\t\t\\\n\t\tlockdep_init_map(&__disk->lockdep_map, __name, &__key, 0); \\\n\t\t\t\t\t\t\t\t\t\\\n\t__disk;\t\t\t\t\t\t\t\t\\\n})\n```\n\n在 __alloc_disk_node() 函数中将 minors 参数赋值给 disk->minors。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241211113728841.png\" alt=\"image-20241211113728841\" style=\"zoom:85%;\" />\n\nLinux 5.15 以后已移除 alloc_disk() 接口，转而使用宏函数 blk_alloc_disk()。\n\n新版本让用户传入参数 node_id，根据注释知道是类似之前 NUMA_NO_NODE 的东西，一般传这个就可以了，当然也可以手动指定。关于 NUMA 的含义，请参考 [https://www.kernel.org/doc/html/latest/translations/zh_CN/mm/numa.html](https://www.kernel.org/doc/html/latest/translations/zh_CN/mm/numa.html)。至于 minors 参数，结合旧版的处理，猜测新版中在分配以后对 gendisk 结构体的属性赋值即可。\n\n```c\n// 新版\n/**\n * blk_alloc_disk - allocate a gendisk structure\n * @node_id: numa node to allocate on\n *\n * Allocate and pre-initialize a gendisk structure for use with BIO based\n * drivers.\n *\n * Context: can sleep\n */\n#define blk_alloc_disk(node_id)\t\t\t\t\t\t\\\n({\t\t\t\t\t\t\t\t\t\\\n\tstatic struct lock_class_key __key;\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\t__blk_alloc_disk(node_id, &__key);\t\t\t\t\\\n})\n\n// 在 __blk_alloc_disk() 中调用了 __alloc_disk_node()。\nstruct gendisk *__blk_alloc_disk(int node, struct lock_class_key *lkclass)\n{\n\tstruct request_queue *q;\n\tstruct gendisk *disk;\n\n\tq = blk_alloc_queue(node);\n\tif (!q)\n\t\treturn NULL;\n\n\tdisk = __alloc_disk_node(q, node, lkclass);\n\tif (!disk) {\n\t\tblk_cleanup_queue(q);\n\t\treturn NULL;\n\t}\n\treturn disk;\n}\nEXPORT_SYMBOL(__blk_alloc_disk);\n\nstruct gendisk *__alloc_disk_node(struct request_queue *q, int node_id, struct lock_class_key *lkclass);\n```\n\n2. 增加 gendisk\n\ngendisk 结构体被分配之后，系统还不能使用这个磁盘，需调用 add_disk() 函数来注册这个磁盘设备。\n\n```c\nint add_disk(struct gendisk *disk)\n{\n\treturn device_add_disk(NULL, disk, NULL);\n}\n\nint device_add_disk(struct device *parent, struct gendisk *disk, const struct attribute_group **groups);\n```\n\n> 特别注意：add_disk() 的调用必须在驱动程序的初始化工作完成并能响应磁盘的请求之后。\n\n3. 释放 gendisk\n\n不再需要磁盘时，使用 del_gendisk() 函数释放 gendisk。\n\n```c\nvoid del_gendisk(struct gendisk *gp);\n```\n\n4. gendisk 引用计数\n\n使用 put_disk() 可操作 gendisk 的引用计数，这个工作一般无需驱动亲自做。\n\n```c\nvoid put_disk(struct gendisk *disk)\n{\n\tif (disk)\n\t\tput_device(disk_to_dev(disk));\n}\nEXPORT_SYMBOL(put_disk);\n```\n\n旧版还有 get_disk() 函数，可以获取引用计数，返回 kobject * 类型。新版中已移除，可能可以直接通过 gendisk 结构体获得相关结果。\n\n```c\n// 旧版\nstruct kobject *get_disk(struct gendisk *disk);\n```\n\n## bio、request和request_queue\n\n### bio\n\n通常一个 bio 对应上层传给块层的 I/O 请求。每个 bio 结构体及其包含的 bvec_iter、bio_vec 结构体描述了该 I/O 请求的开始扇区、数据方向（读还是写）、数据放入的页等。\n\n```c\nstruct bio {\n\tstruct bio\t\t*bi_next;\t/* request queue link */\n\tstruct block_device\t*bi_bdev;\n\tunsigned int\t\tbi_opf;\t\t/* bottom bits REQ_OP, top bits\n\t\t\t\t\t\t * req_flags.\n\t\t\t\t\t\t */\n\tunsigned short\t\tbi_flags;\t/* BIO_* below */\n\tunsigned short\t\tbi_ioprio;\n\tunsigned short\t\tbi_write_hint;\n\tblk_status_t\t\tbi_status;\n\tatomic_t\t\t__bi_remaining;\n\n\tstruct bvec_iter\tbi_iter;\n\n\tbio_end_io_t\t\t*bi_end_io;\n\n\tvoid\t\t\t*bi_private;\n#ifdef CONFIG_BLK_CGROUP\n\t/*\n\t * Represents the association of the css and request_queue for the bio.\n\t * If a bio goes direct to device, it will not have a blkg as it will\n\t * not have a request_queue associated with it.  The reference is put\n\t * on release of the bio.\n\t */\n\tstruct blkcg_gq\t\t*bi_blkg;\n\tstruct bio_issue\tbi_issue;\n#ifdef CONFIG_BLK_CGROUP_IOCOST\n\tu64\t\t\tbi_iocost_cost;\n#endif\n#endif\n\n#ifdef CONFIG_BLK_INLINE_ENCRYPTION\n\tstruct bio_crypt_ctx\t*bi_crypt_context;\n#endif\n\n\tunion {\n#if defined(CONFIG_BLK_DEV_INTEGRITY)\n\t\tstruct bio_integrity_payload *bi_integrity; /* data integrity */\n#endif\n\t};\n\n\tunsigned short\t\tbi_vcnt;\t/* how many bio_vec's */\n\n\t/*\n\t * Everything starting with bi_max_vecs will be preserved by bio_reset()\n\t */\n\n\tunsigned short\t\tbi_max_vecs;\t/* max bvl_vecs we can hold */\n\n\tatomic_t\t\t__bi_cnt;\t/* pin count */\n\n\tstruct bio_vec\t\t*bi_io_vec;\t/* the actual vec list */\n\n\tstruct bio_set\t\t*bi_pool;\n\n\t/*\n\t * We can inline a number of vecs at the end of the bio, to avoid\n\t * double allocations for a small number of bio_vecs. This member\n\t * MUST obviously be kept at the very end of the bio.\n\t */\n\tstruct bio_vec\t\tbi_inline_vecs[];\n};\n\nstruct bvec_iter {\n\tsector_t\t\tbi_sector;\t/* device address in 512 byte\n\t\t\t\t\t\t   sectors */\n\tunsigned int\t\tbi_size;\t/* residual I/O count */\n\n\tunsigned int\t\tbi_idx;\t\t/* current index into bvl_vec */\n\n\tunsigned int            bi_bvec_done;\t/* number of bytes completed in\n\t\t\t\t\t\t   current bvec */\n};\n```\n\n**与 bio 对应的数据每次存放的内存不一定是连续的。**bio_vec 结构体用来描述与这个 bio 请求对应的所有的内存，它可能不总是在一个页面里面，故需要一个向量来记录。向量中的每个元素实际是一个 [page，offset，len]，也称为一个片段。\n\n```c\nstruct bio_vec {\n\tstruct page\t*bv_page;\n\tunsigned int\tbv_len;\n\tunsigned int\tbv_offset;\n};\n```\n\n### request 和 request_queue\n\n**I/O 调度算法可将连续的 bio 合并成一个请求。请求是 bio 经 I/O 调度调整后的结果，这是二者的区别。**一个 request 可包含多个 bio。当 bio 被提交给 I/O 调度器时，I/O 调度器可能会将这个 bio 插入现存的请求中，也可能生成新的请求。\n\n每个块设备或者块设备的分区都有自身的 request_queue，从 I/O 调度器合并和排序出来的请求会被分发（Dispatch）到设备级别的 request_queue。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241211121458861.png\" alt=\"image-20241211121458861\" style=\"zoom:70%;\" />\n\n**随着高速 SSD 的出现并展现出越来越高的性能，传统的块设备层已无法满足这么高的 IOPS（IOs per second），逐渐成为系统 I/O 性能的瓶颈。故在 Linux 5 后废弃了原有的 blk-sq（block single queue）架构，而采用新的 blk-mq（block multi queue）架构。**API 发生了非常大的变化。关于更多 blk-mq 的细节，可参考 [https://blog.csdn.net/Wang20122013/article/details/120544642](https://blog.csdn.net/Wang20122013/article/details/120544642)。\n\n下面是涉及处理 bio、request 和 request_queue 的 API。\n\n1. 初始化请求队列\n\nblk_mq_init_queue() 一般在块设备的初始化过程中使用。此函数会发生内存分配的行为，可能会失败，需检查它的返回值。\n\n```c\nstruct request_queue *blk_mq_init_queue(struct blk_mq_tag_set *set)\n{\n\treturn blk_mq_init_queue_data(set, NULL);\n}\nEXPORT_SYMBOL(blk_mq_init_queue);\n\n// 此函数的主要流程：\n// 1. 调用 blk_alloc_queue() 分配请求队列的内存，分配的内存节点与设备连接的 NUMA 节点一致，避免远端内存访问问题。\n// 2. 调用 blk_mq_init_allocated_queue() 初始化分配的请求队列。\nstruct request_queue *blk_mq_init_queue_data(struct blk_mq_tag_set *set, void *queuedata)\n{\n\tstruct request_queue *q;\n\tint ret;\n\n\tq = blk_alloc_queue(set->numa_node);\n\tif (!q)\n\t\treturn ERR_PTR(-ENOMEM);\n\tq->queuedata = queuedata;\n\tret = blk_mq_init_allocated_queue(set, q);\n\tif (ret) {\n\t\tblk_cleanup_queue(q);\n\t\treturn ERR_PTR(ret);\n\t}\n\treturn q;\n}\n```\n\n其中 blk_mq_tag_set 结构体定义为：\n\n```c\nstruct blk_mq_tag_set {\n\tstruct blk_mq_queue_map\tmap[HCTX_MAX_TYPES];\n\tunsigned int\t\tnr_maps;\n\tconst struct blk_mq_ops\t*ops;\n\tunsigned int\t\tnr_hw_queues;\n\tunsigned int\t\tqueue_depth;\n\tunsigned int\t\treserved_tags;\n\tunsigned int\t\tcmd_size;\n\tint\t\t\tnuma_node;\n\tunsigned int\t\ttimeout;\n\tunsigned int\t\tflags;\n\tvoid\t\t\t*driver_data;\n\tatomic_t\t\tactive_queues_shared_sbitmap;\n\n\tstruct sbitmap_queue\t__bitmap_tags;\n\tstruct sbitmap_queue\t__breserved_tags;\n\tstruct blk_mq_tags\t**tags;\n\n\tstruct mutex\t\ttag_list_lock;\n\tstruct list_head\ttag_list;\n};\n```\n\n2. 清除请求队列\n\n此函数将请求队列归还给系统，一般在块设备驱动卸载过程中调用。\n\n```c\nstatic inline void blk_mq_cleanup_rq(struct request *rq)\n{\n\tif (rq->q->mq_ops->cleanup_rq)\n\t\trq->q->mq_ops->cleanup_rq(rq);\n}\n```\n\n3. 分配请求队列\n\n此函数在初始化请求队列的 blk_mq_init_queue_data() 函数中被调用过。\n\n```c\nstruct request_queue *blk_alloc_queue(int node_id);\n```\n\n4. 提取请求\n\nTODO。暂未找到替代函数。可能是设计和语义发生了改变导致的。后续调研。\n\n5. 启动请求\n\n```c\n// 启动并从请求队列中移除请求。\nvoid blk_mq_start_request(struct request *rq);\n```\n\n6. 遍历 I/O 和片段\n\n`__rq_for_each_bio()` 遍历一个请求的所有 bio。\n\n```c\n#define __rq_for_each_bio(_bio, rq)\t\\\n\tif ((rq->bio))\t\t\t\\\n\t\tfor (_bio = (rq)->bio; _bio; _bio = _bio->bi_next)\n```\n\nbio_for_each_segment() 遍历一个 bio 的所有 bio_vec。\n\n```c\n#define __bio_for_each_segment(bvl, bio, iter, start)\t\t\t\\\n\tfor (iter = (start);\t\t\t\t\t\t\\\n\t     (iter).bi_size &&\t\t\t\t\t\t\\\n\t\t((bvl = bio_iter_iovec((bio), (iter))), 1);\t\t\\\n\t     bio_advance_iter_single((bio), &(iter), (bvl).bv_len))\n\n#define bio_for_each_segment(bvl, bio, iter)\t\t\t\t\\\n\t__bio_for_each_segment(bvl, bio, iter, (bio)->bi_iter)\n```\n\nrq_for_each_segment() 遍历一个请求所有 bio 中的所有 segment。\n\n```c\n#define rq_for_each_segment(bvl, _rq, _iter)\t\t\t\\\n\t__rq_for_each_bio(_iter.bio, _rq)\t\t\t\\\n\t\tbio_for_each_segment(bvl, _iter.bio, _iter.iter)\n```\n\n7. 报告完成\n\n这两个函数用于报告请求是否完成，error 为 0 表示成功，小于 0 表示失败。\n\n```c\nvoid blk_mq_end_request(struct request *rq, blk_status_t error)\n{\n\tif (blk_update_request(rq, error, blk_rq_bytes(rq)))\n\t\tBUG();\n\t__blk_mq_end_request(rq, error);\n}\nEXPORT_SYMBOL(blk_mq_end_request);\n\nvoid __blk_mq_end_request(struct request *rq, blk_status_t error)\n{\n\tu64 now = 0;\n\n\tif (blk_mq_need_time_stamp(rq))\n\t\tnow = ktime_get_ns();\n\n\tif (rq->rq_flags & RQF_STATS) {\n\t\tblk_mq_poll_stats_start(rq->q);\n\t\tblk_stat_add(rq, now);\n\t}\n\n\tblk_mq_sched_completed_request(rq, now);\n\n\tblk_account_io_done(rq, now);\n\n\tif (rq->end_io) {\n\t\trq_qos_done(rq->q, rq);\n\t\trq->end_io(rq, error);\n\t} else {\n\t\tblk_mq_free_request(rq);\n\t}\n}\nEXPORT_SYMBOL(__blk_mq_end_request);\n```\n\n## I/O 调度器\n\nLinux 2.6 以后的内核包含 4 个 I/O 调度器，分别是 Noop I/O 调度器、Anticipatory I/O 调度器、Deadline I/O 调度器与 CFQ I/O 调度器。其中，Anticipatory I/O 调度器算法已经在 2010 年从内核中去掉了。\n\nNoop I/O 调度器是一个简化的调度程序，实现了一个简单 FIFO 队列，它只进行最基本的合并，比较适合基于 Flash 的存储器。\n\nAnticipatory I/O 调度器算法推迟 I/O 请求，以期能对它们进行排序，获得最高的效率。在每次处理完读请求之后，不是立即返回，而是等待几个微秒。在这段时间内，任何来自临近区域的请求都被立即执行。超时以后，继续原来的处理。\n\nDeadline I/O 调度器针对 Anticipatory I/O 调度器的缺点进行改善而得来，试图把每次请求的延迟降至最低，并重排了请求的顺序来提高性能。它使用轮询的调度器，简洁小巧，提供最小的读取迟和尚佳的吞吐量，特别适合于读取较多的环境（例如数据库）。\n\nCFQ I/O 调度器为系统内的所有任务分配均匀的 I/O 带宽，提供一个公平的工作环境，在多媒体应用中，能保证音、视频及时从磁盘中读取数据。\n\n","categories":["Linux 学习","内核层"]},{"title":"Virtual Filesystem","url":"/posts/68b0f3fd.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n笔记摘抄自 [Linux 内核教学 — Linux 系统内核文档](https://linux-kernel-labs-zh.xyz/) 的 VFS 部分，并总结记录。\n\n# 虚拟文件系统（VFS）\n\n虚拟文件系统（VFS）是内核的组件，处理所有与文件和文件系统相关的系统调用。VFS 是用户与特定文件系统之间的通用接口。这种抽象简化了文件系统的实现，使得各种文件系统更容易集成。各种文件系统通过使用 VFS 提供的 API 来实现文件系统，通用硬件以及 I/O 子系统的通信部分由 VFS 处理。\n\n文件系统按照功能可分为：\n\n1. 磁盘文件系统（ext3、ext4、xfs、fat 以及 ntfs 等）。\n2. 网络文件系统（nfs、smbfs/cifs、ncp 等）。\n3. 虚拟文件系统（procfs、sysfs、sockfs、pipefs 等）。\n\n<!-- more -->\n\nLinux 内核使用 VFS 处理目录和文件的层次结构（其实是一棵树）。通过挂载操作，新的文件系统被添加为 VFS 子树。文件系统通常是从其所对应的环境中挂载的（从块类型设备、网络等）。**然而 VFS 可以将普通文件作为虚拟块设备使用，可以将普通文件挂载为磁盘文件系统。**\n\nVFS 的基本思想是提供可以表示任何文件系统文件的单一文件模型。文件系统驱动程序需要遵守公共的基准。这样，内核可以创建包含整个系统的单一目录结构。其中一个文件系统将作为根文件系统，其他文件系统将挂载在其各个目录下。\n\n# 存储栈整体结构\n\nLinux 存储栈的整体结构图如下。从上到下分别是：**VFS、通用块层、SCSI 层、块设备层**。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241227142615377.png\" alt=\"image-20241227142615377\" style=\"zoom:75%;\" />\n\n各个层次的作用如下。\n\n1. VFS：VFS 层是 Linux 最为津津乐道的设计，也就是所谓的一切皆文件。它通过统一的接口，底层封装了各种各样的文件系统。\n\n2. 通用块层：文件系统将读/写请求转换成 bio 和 request，提交给通用块层，通用块层对 request 进行调度，发往下一层。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241227143348812.png\" alt=\"image-20241227143348812\" style=\"zoom:80%;\" />\n\n3. SCSI 层：SCSI（Small Computer Systems Interface）是一组标准集，定义了与大量设备（主要是与存储相关的设备）通信所需的接口和协议。Linux 提供了一种 SCSI 子系统，用于与这些设备通信。\n\n4. 块设备层：块设备层负责对某种具体的物理设备进行处理，完成相应的读写请求。\n\n# 常见的文件系统模型\n\n任何实现的文件系统都需要包含这几种明确定义的类型：super_block、inode、file 和 dentry。这些也是文件系统的元数据。\n\n模型实体间通过某些 VFS 子系统或内核子系统进行交互：dentry cache（目录项缓存）、inode cache（索引节点缓存）和 buffer cache（缓冲区缓存）。每个实体都被视为对象，具有关联的数据结构和指向方法表的指针。通过替换关联的方法来为每个组件引入特定的行为（类似于 C++ 的多态）。\n\n## super_block\n\n**super_block 超级块存储挂载文件系统需要的信息。**具体如下：\n\n1. inode 和块的位置。\n2. 文件系统块大小。\n3. 最大文件名长度。\n4. 最大文件大小。\n5. 根 inode 的位置。\n\n磁盘上的 super_block 通常存储在磁盘的第一个块中，即文件系统控制块。\n\n在 VFS 中，super_block 实体都保留在类型为 `struct super_block` 的结构列表中，方法则保留在类型为 `struct super_operations` 的结构中。\n\n## inode\n\n**inode 索引节点存储有关文件的信息。**这里的文件泛指意义上的文件，常规文件、目录、特殊文件（如管道、fifo 等）、块设备、字符设备、链接或可以抽象为文件的任何内容都包括在内。\n\ninode 存储了以下信息：\n\n1. 文件类型。\n2. 文件大小。\n3. 访问权限。\n4. 访问或修改时间。\n5. 数据在磁盘上的位置（指向包含数据的磁盘块的指针）。\n\n> inode 通常不包含文件名。文件名由 dentry 存储。一个 inode 可以有多个名称（如多个硬链接文件指向同一个 inode）。\n\n磁盘上的 inode 通常分组存储在一个专用的 inode 区域中，与数据区域分开。\n\n在 VFS 中，inode 实体由 `struct inode` 结构表示，由 `struct inode_operations` 结构定义与之相关的操作。\n\n## file\n\nfile 是文件系统模型中距离用户最近的组件。**inode 抽象了磁盘上的文件，file 抽象了进程打开的文件。**与其他结构不同的是，file 结构体在内存中作为 VFS 的实体存在，但没有在磁盘上的物理物对应。\n\nfile 存储了以下信息：\n\n1. 文件游标位置。\n2. 文件打开权限。\n3. 指向关联 inode 的指针（inode 的索引）。\n\n在 VFS 中，file 实体由 `struct file` 结构表示，与之相关的操作由 `struct file_operations` 结构表示。\n\n## dentry\n\n**dentry 将 inode 和 文件名关联起来。**存储以下信息：\n\n1. 用于标识 inode 的整数。\n2. 表示文件名的字符串。\n\ndentry 是目录或文件路径的特定部分。例如，对于路径 `/bin/vi`，为 `/`、`bin` 和 `vi` 创建共 3 个 dentry 对象。\n\ndentry 在磁盘上有对应物，但对应关系不是直接的。每个文件系统都有特定的方式维护 dentry。\n\n在 VFS 中，dentry 实体由 `struct dentry` 结构表示，与之相关的操作在 `struct dentry_operations` 结构中定义。\n\n## 其他数据结构\n\n除了上述，VFS 中还有一些数据结构。\n\n1. address_space/mapping：表示一个文件缓存，结构体的名字称为 address_space。但在其它结构体中被引用时，该指针的名字通常是 mapping。\n2. mount：表示一个文件系统被挂载的信息。\n3. file_system_type：表示一个文件系统类型，例如 ext4、proc、sys 等。\n\n# 注册和注销文件系统\n\n## struct file_system_type\n\nLinux 内核支持很多文件系统，包括 ext2/ext4、reiserfs、xfs、fat、ntfs 等。但在单个系统上，不太可能超过 5/6 个文件系统。文件系统在内核中被实现为内核模块，可以动态的加载和卸载。\n\n描述特定文件系统的结构是 `struct file_system_type`，定义如下：\n\n```c\n// linux/fs.h\n\n\nstruct file_system_type\n{\n    // 表示该文件系统的名称（传递给 mount -t 的参数）。\n    const char *name;\n\n    // 指定文件系统必须以哪些标志挂载。例如标志 FS_REQUIRES_DEV，指定 VFS 文件系统需要一个磁盘（而不是虚拟文件系统）\n    int fs_flags;\n\n    // 在加载文件系统时从磁盘中读取超级块到内存中。每种文件系统的函数都是独一无二的。\n    struct dentry *(*mount)(struct file_system_type *, int, const char *, void *);\n\n    // 释放内存中的超级块。\n    void (*kill_sb)(struct super_block *);\n\n    // 如果是内核模块实现，则为 THIS_MODULE。如果直接写在内核中，则为 NULL。\n    struct module *owner;\n\n    struct file_system_type *next;\n\n    // 一个列表，包含与该文件系统关联的所有超级块。由于同一文件系统可能会被多次挂载，因此每个挂载点都会有一个单独的超级块。\n    struct hlist_head fs_supers;\n\n    struct lock_class_key s_lock_key;\n\n    struct lock_class_key s_umount_key;\n\n    ...\n};\n```\n\n内核中的所有 file_system_type 都是通过一根单向链表组织起来的，register_filesystem() 函数负责将新的 file_system_type 加入到这个链表中。\n\n每个文件系统类型下都挂载了多个文件系统，比如 sda、sdb 都是 ext4 文件系统，这些 super_block 以链表的形式连接到 `file_system_type->fs_supers` 字段中。系统中所有的 super_block 也是通过一根双向链表进行连接。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241227120407496.png\" alt=\"image-20241227120407496\" style=\"zoom:75%;\" />\n\n在模块加载函数中，将文件系统注册到内核，需要做以下几步：\n\n1. 初始化 `struct file_system_type` 结构体类型的实体，并填充相应的字段以及回调函数。\n2. 调用 register_filesystem() 函数。\n\n例如，ramfs 的部分代码如下：\n\n```c\nstatic struct file_system_type ramfs_fs_type = {\n    .name = \"ramfs\",\n    .mount = ramfs_mount,\n    .kill_sb = ramfs_kill_sb,\n    .fs_flags = FS_USERNS_MOUNT,\n};\n\nstatic int __init init_ramfs_fs(void)\n{\n    if (test_and_set_bit(0, &once)) return 0;\n\n\n    return register_filesystem(&ramfs_fs_type);\n}\n```\n\n## mount() 和 kill_sb()\n\n加载文件系统时，内核调用 `struct file_system_type` 结构定义的 mount() 函数。此函数对每个文件系统都是唯一的，进行初始化操作以后返回挂载点的目录 dentry 指针。mount() 函数一般会调用以下函数之一：\n\n1. mount_bdev()：挂载存储在块设备上的文件系统。\n2. mount_single()：挂载一个在所有挂载操作之间是共享实例的文件系统。\n3. mount_nodev()：挂载不在物理设备上的文件系统。\n4. mount_pseudo()：用于伪文件系统的辅助函数（如 sockfs、pipefs 等无法被挂载的文件系统）。\n\n这些函数的其中一个参数是指向 fill_super() 函数的指针，该函数在超级块初始化后被调用，借助驱动程序完成超级块的初始化。\n\n卸载文件系统时，内核调用 kill_sb() 函数，执行清理动作。kill_sb() 函数一般会调用以下函数之一：\n\n1. kill_block_super()：卸载块设备上的文件系统。\n2. kill_anon_super()：卸载虚拟文件系统（当请求时生成信息）。\n3. kill_litter_super()：卸载不在物理设备上的文件系统（信息保存在内存中）。\n\n对没有磁盘支持的文件系统，一个实例是 ramfs 文件系统的 ramfs_mount() 函数：\n\n```c\nstruct dentry *ramfs_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)\n{\n    return mount_nodev(fs_type, flags, data, ramfs_fill_super);\n}\n```\n\n对来自磁盘的文件系统，一个实例是 minix 文件系统的 minix_mount() 函数：\n\n```c\nstruct dentry *minix_mount(struct file_system_type *fs_type, int flags, const char *dev_name, void *data)\n{\n     return mount_bdev(fs_type, flags, dev_name, data, minix_fill_super);\n}\n```\n\n# super_block\n\n## struct super_block\n\n超级块作为物理实体（磁盘上的实体）存在，也作为 VFS 实体（`struct super_block` 结构）存在。超级块仅包含元信息，并用于从磁盘中读取和写入元数据（如 inode、目录项）。超级块及 `struct super_block` 结构包含有关所使用的块设备、inode 列表、文件系统根目录的 inode 指针以及超级块操作的指针的信息。\n\nstruct super_block 定义如下：\n\n```c\nstruct super_block\n{\n    ...\n\n    dev_t s_dev;                     // 标识符\n    unsigned char s_blocksize_bits;  // 块大小（以位为单位）\n    unsigned long s_blocksize;       // 块大小（以字节为单位）\n    unsigned char s_dirt;            // 脏标志\n    loff_t s_maxbytes;               // 最大文件大小\n    struct file_system_type *s_type; // 文件系统类型\n    struct super_operations *s_op;   // 超级块方法\n\n    ...\n    unsigned long s_flags; // 挂载标志\n    unsigned long s_magic; // 文件系统的魔数\n    struct dentry *s_root; // 目录挂载点\n\n    ...\n\n    char s_id[32];   // 信息标识符\n    void *s_fs_info; // 文件系统私有信息\n};\n```\n\n超级块存储了文件系统的全局信息：\n\n1. 所使用的物理设备。\n2. 块大小。\n3. 文件的最大大小。\n4. 文件系统类型。\n5. 支持的操作。\n6. 魔数（用于标识文件系统）。\n7. 根目录的 dentry。\n\n另外，`void *s_fs_info` 可用于存储文件系统的私有数据，具体实现时候可加入自己的数据。类似于 `struct file` 的 `void *private_data`。\n\n## super_block 操作\n\n超级块操作由 super_block 描述，定义如下：\n\n```c\nstruct super_operations\n{\n    ...\n\n    // 写入与 inode 相关的资源。\n    int (*write_inode)(struct inode *, struct writeback_control *wbc);\n\n    // 分配与 inode 相关的资源。\n    struct inode *(*alloc_inode)(struct super_block *sb);\n\n    // 释放与 inode 相关的资源。\n    void (*destroy_inode)(struct inode *);\n\n    // 卸载时调用，释放文件系统私有数据的任何资源（通常是内存）。\n    void (*put_super)(struct super_block *);\n\n    // 在执行 statfs 系统调用时调用（尝试 stat - f 或 df）。此调用必须填充 struct kstatfs 结构的字段，就像在 ext4_statfs() 函数中所做的那样。\n    int (*statfs)(struct dentry *, struct kstatfs *);\n\n    // 在内核检测到重新挂载尝试（挂载标志 MS_REMOUNTM）时调用。大部分情况下，需要检测是否尝试从只读切换到读写或反之。这可以简单地通过访问旧标志（在 sb->s_flags 中）和新标志 (flags 参数) 来完成。data 是由 mount() 发送的表示文件系统特定选项的数据的指针。\n    int (*remount_fs)(struct super_block *, int *, char *);\n\n    ...\n};\n```\n\n# fill_super()\n\nfill_super() 函数用于在文件系统加载时的 mount() 函数中调用，**用于超级块初始化的最后一段，包括填充 struct super_block 字段和根目录的 inode 结构的初始化**。\n\n一个实例是 ramfs_fill_super() 函数：\n\n```c\n#include <linux/pagemap.h>\n\n\n#define RAMFS_MAGIC 0x858458f6\n\n\nstatic const struct super_operations ramfs_ops = {\n    .statfs = simple_statfs,\n    .drop_inode = generic_delete_inode,\n    .show_options = ramfs_show_options,\n};\n\nstatic int ramfs_fill_super(struct super_block *sb, void *data, int silent)\n{\n    struct ramfs_fs_info *fsi;\n    struct inode *inode;\n    int err;\n\n    save_mount_options(sb, data);\n\n    fsi = kzalloc(sizeof(struct ramfs_fs_info), GFP_KERNEL);\n    sb->s_fs_info = fsi;\n    if (!fsi)\n        return -ENOMEM;\n\n    err = ramfs_parse_options(data, &fsi->mount_opts);\n    if (err)\n        return err;\n\n    sb->s_maxbytes = MAX_LFS_FILESIZE;\n    sb->s_blocksize = PAGE_SIZE;\n    sb->s_blocksize_bits = PAGE_SHIFT;\n    sb->s_magic = RAMFS_MAGIC;\n    sb->s_op = &ramfs_ops;\n    sb->s_time_gran = 1;\n\n    inode = ramfs_get_inode(sb, NULL, S_IFDIR | fsi->mount_opts.mode, 0);\n    sb->s_root = d_make_root(inode);\n    if (!sb->s_root)\n        return -ENOMEM;\n\n    return 0;\n}\n```\n\n内核提供了一些实现文件系统结构的通用函数，例如上面的 generic_delete_inode() 和 simple_statfs()。\n\n上面的 ramfs_fill_super() 函数填充了超级块中的一些字段，然后读取根 inode 并分配根 dentry。读取根 inode 在 ramfs_get_inode() 函数中完成，包括使用 new_inode() 函数分配新的 inode 并进行初始化。为了释放 inode，使用了 iput()，并使用 d_make_root() 函数分配根 dentry。\n\nVFS 函数通常以超级块、索引节点或包含指向超级块的指针的目录项作为实参，以便能够轻松访问这些私有数据。\n\n# 缓冲区缓存\n\n**缓冲区缓存是处理块设备读写缓存的内核子系统。**磁盘文件系统的功能与虚拟文件系统类似，唯一区别是使用了缓冲区缓存。基本结构体是 `struct buffer_head`，定义如下：\n\n```c\nstruct buffer_head\n{\n    unsigned long b_state;           // 缓冲区的状态。\n    struct buffer_head *b_this_page; // circular list of page's buffers\n    struct page *b_page;             // the page this bh is mapped to\n\n    sector_t b_blocknr; // 已加载或需要保存在磁盘上的设备的块号。\n    size_t b_size;      // 缓冲区大小。\n    char *b_data;       // 指向读取数据或写入数据的内存区域的指针。\n\n    struct block_device *b_bdev;       // 块设备。\n    bh_end_io_t *b_end_io;             // I/O completion\n    void *b_private;                   // reserved for b_end_io\n    struct list_head b_assoc_buffers;  // associated with another mapping\n    struct address_space *b_assoc_map; // mapping this buffer is associated with\n    atomic_t b_count;                  // users using this buffer_head\n    spinlock_t b_uptodate_lock;        // Used by the first bh in a page, to serialise IO completion of other buffers in the page\n};\n```\n\n以下函数一般会与 `struct buffer_head` 一起使用：\n\n1. `__bread()`：读取具有给定编号和给定大小的块到一个 `struct buffer_head` 中。如果成功，则返回指向 `struct buffer_head` 的指针，否则返回 NULL。\n2. sb_bread()：与前一个函数相同，但读取的块的大小从超级块中获取，读取的设备也从超级块中获取。\n3. mark_buffer_dirty()：将缓冲区标记为脏（设置 BH_Dirty 位）。缓冲区将在稍后的时间写入磁盘 (bdflush 内核线程会定期唤醒并将缓冲区写入磁盘)。\n4. brelse()：在先前将缓冲区写入磁盘（如果需要）后，释放缓冲区使用的内存。\n5. map_bh()：将 buffer-head 与相应的扇区关联。\n\n# 函数和有用的宏\n\n超级块通常包含以位图（位向量）形式表示的占用块的映射（索引节点、目录条目、数据占用）。为处理这种映射，建议使用以下功能：\n\n1. find_first_zero_bit()：用于在内存区域中查找第一个为零的位。size 参数表示搜索区域中的位数。\n2. test_and_set_bit()：设置位并获取旧值。\n3. test_and_clear_bit()：删除位并获取旧值。\n4. test_and_change_bit()：取反位的值并获取旧值。\n\n以下宏定义可用于验证索引节点的类型：\n\n1. S_ISDIR(inode->i_mode)：用于检查索引节点是否为目录。\n2. S_ISREG(inode->i_mode)：用于检查索引节点是否为普通文件（非链接或设备文件）。\n\n# inode\n\ninode 是文件系统的元数据（它包含信息的信息）。inode 是磁盘上文件的唯一标识，保存文件的信息（uid、gid、访问权限、访问时间以及指向数据块的指针等）。重要的一点是，inode 不保存文件名信息，文件名由相关的 `struct dentry` 结构保存。\n\ninode 用于引用磁盘上的文件。对于进程打开的文件，使用 `struct file` 结构。一个 inode 可以关联一个或多个 `struct file` 结构。多个进程可以打开同一个文件，一个进程可以多次打开同一个文件。\n\ninode 既存在于内存中的 VFS 结构，也存在于磁盘中（UNIX、HFS 以及 NTFS 等）。VFS 中的 inode 由 `struct inode` 结构表示。和 VFS 中的其他结构一样，`struct inode` 是通用结构，涵盖了所有支持的文件类型的选项，甚至包括那些没有关联磁盘实体的文件类型（例如 FAT 文件系统）。\n\n## struct inode\n\n`struct inode` 定义如下：\n\n```c\nstruct inode\n{\n    umode_t i_mode; // i_uid 以及 i_gid：访问权限、uid 以及 gid。\n    unsigned short i_opflags;\n    kuid_t i_uid;\n    kgid_t i_gid;\n    unsigned int i_flags;\n\n#ifdef CONFIG_FS_POSIX_ACL\n    struct posix_acl *i_acl;\n    struct posix_acl *i_default_acl;\n#endif\n\n    const struct inode_operations *i_op; // 指向结构 inode_operations 的指针。\n    struct super_block *i_sb;            // inode 所属的文件系统的超级块结构。\n    struct address_space *i_mapping;     // i_mapping->a_ops 包含指向 struct address_space_operations 的指针。\n\n#ifdef CONFIG_SECURITY\n    void *i_security;\n#endif\n\n    /* Stat data, not accessed from path walking */\n    unsigned long i_ino; // inode 的编号（在文件系统内唯一标识 inode）。\n    /*\n     * Filesystems may only read i_nlink directly.  They shall use the\n     * following functions for modification:\n     *\n     *    (set|clear|inc|drop)_nlink\n     *    inode_(inc|dec)_link_count\n     */\n\n    // 使用此 inode 的名称条目（dentry）的数量；对于没有链接（既没有硬链接也没有符号链接）的文件系统，这个值总是设置为 1。\n    union\n    {\n        const unsigned int i_nlink;\n        unsigned int __i_nlink;\n    };\n\n    dev_t i_rdev;              // 挂载的文件系统所在的设备。\n    loff_t i_size;             // 文件/目录等的大小（以字节为单位）。\n    struct timespec64 i_atime; // 访问时间。\n    struct timespec64 i_mtime; // 修改时间。\n    struct timespec64 i_ctime; // 创建时间。\n    spinlock_t i_lock;         /* i_blocks, i_bytes, maybe i_size */\n    unsigned short i_bytes;\n    u8 i_blkbits; // 块大小使用的比特数 == log2(块大小)。\n    u8 i_write_hint;\n    blkcnt_t i_blocks; // 文件使用的块数（所有块，不仅仅是数据块）。这仅由配额子系统使用。\n\n#ifdef __NEED_I_SIZE_ORDERED\n    seqcount_t i_size_seqcount;\n#endif\n\n    /* Misc */\n    unsigned long i_state;\n    struct rw_semaphore i_rwsem;\n\n    unsigned long dirtied_when; /* jiffies of first dirtying */\n    unsigned long dirtied_time_when;\n\n    struct hlist_node i_hash;\n    struct list_head i_io_list; /* backing dev IO list */\n#ifdef CONFIG_CGROUP_WRITEBACK\n    struct bdi_writeback *i_wb; /* the associated cgroup wb */\n\n    /* foreign inode detection, see wbc_detach_inode() */\n    int i_wb_frn_winner;\n    u16 i_wb_frn_avg_time;\n    u16 i_wb_frn_history;\n#endif\n    struct list_head i_lru; /* inode LRU list */\n    struct list_head i_sb_list;\n    struct list_head i_wb_list; /* backing dev writeback list */\n    union\n    {\n        struct hlist_head i_dentry;\n        struct rcu_head i_rcu;\n    };\n    atomic64_t i_version;\n    atomic64_t i_sequence; /* see futex */\n    atomic_t i_count;      // inode 计数器，指示有多少内核组件在使用它。\n    atomic_t i_dio_count;\n    atomic_t i_writecount;\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\n    atomic_t i_readcount; /* struct files open RO */\n#endif\n    union\n    {\n        const struct file_operations *i_fop; // 指向结构 file_operations 的指针。former ->i_op->default_file_ops\n        void (*free_inode)(struct inode *);\n    };\n    struct file_lock_context *i_flctx;\n    struct address_space i_data;\n    struct list_head i_devices;\n    union\n    {\n        struct pipe_inode_info *i_pipe;\n        struct cdev *i_cdev;\n        char *i_link;\n        unsigned i_dir_seq;\n    };\n\n    __u32 i_generation;\n\n#ifdef CONFIG_FSNOTIFY\n    __u32 i_fsnotify_mask; /* all events this inode cares about */\n    struct fsnotify_mark_connector __rcu *i_fsnotify_marks;\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\n    struct fscrypt_info *i_crypt_info;\n#endif\n\n#ifdef CONFIG_FS_VERITY\n    struct fsverity_info *i_verity_info;\n#endif\n\n    void *i_private; /* fs or device private pointer */\n} __randomize_layout;\n```\n\n每个文件系统都缓存了一定的 inode 数量到内存中。同一个文件系统的 inode 以双向链表连接起来，挂在 `super_block->s_inodes` 字段中。同时，内核中所有的 inode 被组织在了一个哈希表 inode_hashtable 上。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241227141716401.png\" alt=\"image-20241227141716401\" style=\"zoom:75%;\" />\n\n一些可用于处理 inode 的函数如下：\n\n1. new_inode()：创建新的 inode，将 i_nlink 字段设置为 1，并初始化 i_blkbits, i_sb 和 i_dev。\n2. insert_inode_hash()：将 inode 添加到 inode 哈希表中。这个调用的一个有趣的效果是，如果 inode 被标记为脏，它将被写入磁盘。\n3. mark_inode_dirty()：将 inode 标记为脏，稍后它将被写入磁盘。\n4. iget_locked()：从磁盘加载具有给定编号的 inode，如果它尚未加载。\n5. unlock_new_inode()：与 iget_locked() 一起使用，释放对 inode 的锁定。\n6. iput()：告诉内核对 inode 的操作已经完成。若没有其他进程在使用，它将被销毁（如果被标记为脏，则写入磁盘后再销毁）。\n7. make_bad_inode()：告诉内核该 inode 无法使用；通常在从磁盘读取 inode 时发现无法读取的情况下使用，表示该 inode 无效。\n\n## inode 操作\n\n### 获取 inode\n\n获取 inode 是 inode 的主要操作之一。Linux 2.6 以前，存在 read_inode() 函数。Linux 2.6 以后，编程者必须自己定义 `<fsname>_get()` 函数，`fsname` 是文件系统的名称。此函数负责查找 VFS 中的 inode，如果存在则获取该 inode，否则创建一个新的 inode，并用磁盘中的信息填充它。\n\n一般情况下，这个函数会调用 iget_locked() 从 VFS 中获取 inode 结构。如果 inode 是新创建的，则需要使用 sb_bread() 从磁盘中读取 inode，并填充有用的信息。\n\n实例函数是 minix_iget()：\n\n```c\nstatic struct inode *V1_minix_iget(struct inode *inode)\n{\n    struct buffer_head *bh;\n    struct minix_inode *raw_inode;\n    struct minix_inode_info *minix_inode = minix_i(inode);\n    int i;\n\n    raw_inode = minix_V1_raw_inode(inode->i_sb, inode->i_ino, &bh);\n    if (!raw_inode)\n    {\n        iget_failed(inode);\n        return ERR_PTR(-EIO);\n    }\n\n    ...\n}\n\n// 此函数通过 iget_locked() 获取 inode。如果 inode 已经存在即不是新建的，则函数返回。否则使用 V1_minix_iget() 函数从磁盘读取 inode，然后使用读取的信息初始化 VFS inode。\nstruct inode *minix_iget(struct super_block *sb, unsigned long ino)\n{\n    struct inode *inode;\n\n    inode = iget_locked(sb, ino);\n    if (!inode)\n        return ERR_PTR(-ENOMEM);\n    // I_NEW 标志表示 inode 是否为新建的。\n    if (!(inode->i_state & I_NEW))\n        return inode;\n\n    if (INODE_VERSION(inode) == MINIX_V1)\n        return V1_minix_iget(inode);\n\n    ...\n}\n```\n\n### 超级块操作\n\n许多超级块操作在处理 inode 的时候使用，如下：\n\n1. alloc_inode()：分配 inode()。通常，此函数会分配一个 `struct <fsname>_inode_info` 结构，并使用 inode_init_once() 执行基本的 VFS inode 初始化。minix 文件系统使用 kmem_cache_alloc() 函数进行分配，该函数与 SLAB 子系统交互。对于每个分配，都会调用缓存构造函数，在 minix 下是 init_once() 函数。或者也可以使用 kmalloc()。在这种情况下，应调用 inode_init_once() 函数。alloc_inode() 函数将由 new_inode() 和 iget_locked() 函数调用。\n2. write_inode()：将作为参数接收的 inode 保存或更新到磁盘。此函数要更新 inode，尽管效率不高。对初学者而言，建议使用以下操作：\n   - 使用 sb_bread() 函数从磁盘加载 inode。\n   - 根据保存的 inode 修改缓冲区。\n   - 使用 mark_buffer_dirty() 将缓冲区标记为脏。内核将处理其在磁盘上的写入。\n3. evict_inode()：从磁盘和内存中移除通过 i_ino 字段接收的 inode 的任何信息，包括磁盘上的 inode 和相关的数据块。涉及以下操作：\n   - 从磁盘中删除 inode。\n   - 更新磁盘位图（如果有）。\n   - 通过调用 truncate_inode_pages() 从 page cache 中删除 inode。\n   - 通过调用 clear_inode() 从内存中删除 inode。\n4. destroy_inode()：释放 inode 占用的内存。\n\n### inode_operations\n\ninode 索引节点的相关操作由 `struct inode_operations` 结构描述。\n\n索引节点分为多种类型：文件、目录、特殊文件（管道、FIFO）、块设备、字符设备以及链接等。每种类型需要实现的操作都不同。\n\n访问 `struct inode` 中的 i_op 字段可以对索引节点的操作进行初始化和访问。\n\n# mount\n\n**mount 代表了一个文件系统被挂载到了某个地方。**只有被挂载的文件系统，才能通过 VFS 的目录树进行访问。\n\n一个文件系统可能被多次 mount 到不同的地方，这样一个 super_block 会对应多个不同的 mount 结构，这些 mount 以双向链表的形式组织起来，挂在 super_block->s_mounts 字段。\n\n被 mount 的目录称为一个 mount 点。目录也是一个 dentry，mount 通过 mnt_mountpoint 字段指向该 dentry。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241227145405084.png\" alt=\"image-20241227145405084\" style=\"zoom:75%;\" />\n\n挂载点用 mountpoint 结构体表示。所有的挂载点被放到一个哈希表 mountpoint_hashtable 中，以 dentry 为键（Key），mountpoint 为值（T）。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241230094606623.png\" alt=\"image-20241230094606623\" style=\"zoom:75%;\" />\n\n> 注：这里的 mountpoint 是一个结构体。与上面的 mount->mnt_mountpoint 不一样，上面的是一个指针，指向 dentry。\n\n```c\nstruct mount {\n\tstruct hlist_node mnt_hash;\n\tstruct mount *mnt_parent;\n\tstruct dentry *mnt_mountpoint;\n\tstruct vfsmount mnt;\n\tunion {\n\t\tstruct rcu_head mnt_rcu;\n\t\tstruct llist_node mnt_llist;\n\t};\n#ifdef CONFIG_SMP\n\tstruct mnt_pcp __percpu *mnt_pcp;\n#else\n\tint mnt_count;\n\tint mnt_writers;\n#endif\n\tstruct list_head mnt_mounts;\t/* list of children, anchored here */\n\tstruct list_head mnt_child;\t/* and going through their mnt_child */\n\tstruct list_head mnt_instance;\t/* mount instance on sb->s_mounts */\n\tconst char *mnt_devname;\t/* Name of device e.g. /dev/dsk/hda1 */\n\tstruct list_head mnt_list;\n\tstruct list_head mnt_expire;\t/* link in fs-specific expiry list */\n\tstruct list_head mnt_share;\t/* circular list of shared mounts */\n\tstruct list_head mnt_slave_list;/* list of slave mounts */\n\tstruct list_head mnt_slave;\t/* slave list entry */\n\tstruct mount *mnt_master;\t/* slave is on master->mnt_slave_list */\n\tstruct mnt_namespace *mnt_ns;\t/* containing namespace */\n\tstruct mountpoint *mnt_mp;\t/* where is it mounted */\n\tunion {\n\t\tstruct hlist_node mnt_mp_list;\t/* list mounts with the same mountpoint */\n\t\tstruct hlist_node mnt_umount;\n\t};\n\tstruct list_head mnt_umounting; /* list entry for umount propagation */\n#ifdef CONFIG_FSNOTIFY\n\tstruct fsnotify_mark_connector __rcu *mnt_fsnotify_marks;\n\t__u32 mnt_fsnotify_mask;\n#endif\n\tint mnt_id;\t\t\t/* mount identifier */\n\tint mnt_group_id;\t\t/* peer group identifier */\n\tint mnt_expiry_mark;\t\t/* true if marked for expiry */\n\tstruct hlist_head mnt_pins;\n\tstruct hlist_head mnt_stuck_children;\n} __randomize_layout;\n\nstruct mountpoint {\n\tstruct hlist_node m_hash;\n\tstruct dentry *m_dentry;\n\tstruct hlist_head m_list;\n\tint m_count;\n};\n```\n\n同一个目录可被多个文件系统 mount。这些文件系统会相互覆盖，通过 VFS 只能看到最近那个被 mount 的文件系统。\n\n为了处理这种情况，文件系统中所有的 mount 都被组织到同一个哈希表 mount_hashtable 中。哈希表以 `<mount, dentry>` 为键（Key），以新的 mount 作为值（Value），将其组织起来。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241230101507978.png\" alt=\"image-20241230101507978\" style=\"zoom:70%;\" />\n\n将上述整理以后，能得到一个整体的架构图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241230102023524.png\" alt=\"image-20241230102023524\" style=\"zoom:70%;\" />\n\n# file\n\n**file 结构对应于由进程打开的文件，仅存在于内存中，并与 inode 索引节点关联。**它是最接近用户空间的 VFS 实体。结构字段包含用户空间文件的熟悉信息（访问模式、文件位置等），与之相关的操作由已知的系统调用（read, write 等）执行。\n\n文件操作由 `struct file_operations` 结构描述。文件系统的文件操作使用 `struct inode` 结构中的 i_fop 字段进行初始化。在打开文件时，VFS 使用 inode->i_fop 的地址初始化 `struct file` 结构的 f_op 字段。后续的系统调用使用存储在 file->f_op 中的值。\n\nfile 与 inode 的区别在于，一个文件的 inode 在内核中是唯一的，但 file 可以有多个。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241230104309655.png\" alt=\"image-20241230104309655\" style=\"zoom:70%;\" />\n\n# 常规文件索引节点\n\n使用索引节点必须要填充 inode 结构的 i_op 和 i_fop 字段。索引节点的类型决定了他要实现的操作。\n\n一个例子是 minix 文件系统的对象实例 minix_file_operations 和 minix_file_inode_operations。\n\nLinux 内核实现了 generic_file_llseek()、generic_file_read_iter()、generic_file_write_iter()、generic_file_mmap() 函数，定义了一些通用的 file 操作，具体做了哪些处理可参见源码。\n\n```c\nconst struct file_operations minix_file_operations = {\n    .llseek = generic_file_llseek,\n    .read_iter = generic_file_read_iter,\n    //...\n    .write_iter = generic_file_write_iter,\n    //...\n    .mmap = generic_file_mmap,\n    //...\n};\n\nconst struct inode_operations minix_file_inode_operations = {\n    .setattr = minix_setattr,\n    .getattr = minix_getattr,\n};\n\n\n{\n    //...\n\n    if (S_ISREG(inode->i_mode))\n    {\n        inode->i_op = &minix_file_inode_operations;\n        inode->i_fop = &minix_file_operations;\n    }\n\n    //...\n}\n```\n\n对于简单的文件系统，只需实现截断 truncate() 系统调用。从 Linux 3.14 开始，该操作已嵌入到 setattr() 中。如果粘贴大小与索引节点的当前大小不同，则必须执行截断操作。\n\n一个例子是 minix_setattr() 函数：\n\n```c\nstatic int minix_setattr(struct dentry *dentry, struct iattr *attr)\n{\n    struct inode *inode = d_inode(dentry);\n    int error;\n\n    error = setattr_prepare(dentry, attr);\n    if (error)\n        return error;\n\n    if ((attr->ia_valid & ATTR_SIZE) &&\n        attr->ia_size != i_size_read(inode))\n    {\n        error = inode_newsize_ok(inode, attr->ia_size);\n        if (error)\n            return error;\n\n        truncate_setsize(inode, attr->ia_size);\n        minix_truncate(inode);\n    }\n\n    setattr_copy(inode, attr);\n    mark_inode_dirty(inode);\n\n    return 0;\n}\n```\n\n截断操作涉及以下内容：\n\n1. 释放磁盘上多余的数据块（如果新尺寸小于旧尺寸），或者分配新的数据块（当新尺寸较大时）。\n2. 更新磁盘位图（如果使用）。\n3. 更新索引节点。\n4. 使用 block_truncate_page() 函数，将上一个块中未使用的空间填充为零。\n\n# page cache\n\n笔记摘抄自文章 [https://blog.ywang-wnlo.xyz/posts/9ba60726/](https://blog.ywang-wnlo.xyz/posts/9ba60726/)。\n\n由于磁盘 HDD 以及现在广泛使用的固态硬盘 SSD 的读写速度都远小于内存 DRAM 的读写速度。为避免每次读取数据都要直接访问这些低速的底层存储设备，Linux 利用 DRAM 实现了一个缓存层，缓存的粒度是 page，也叫 page cache，也就是页（面）缓存。\n\n经过这层 page cache 的作用，I/O 的性能得到了显著的提升。不过由于 DRAM 具有易失性，在掉电后数据会丢失，因此内核中的 回写机制定时将 page cache 中的数据下刷到设备上，保证数据的持久化。此外内核还在 page cache 中实现了巧妙的预读机制，提升了顺序读性能。\n\n写入到 page cache 的数据不会立刻写入后端设备，而是标记为“脏”，并被加入到脏页链表，后续由内核中的回写进程周期性的将脏页写回到底层存储设备。\n\n在拥有 page cache 这一层后，写数据就有了三种不同的策略：\n\n1. **不经过缓存，直接写底层存储设备，但同时要使缓存中数据失效，也叫不缓存（nowrite）。**\n\n2. **只写缓存，缓存中数据定期刷到底层存储设备上，也叫写回（write back）。**\n\n3. **同时写缓存和底层存储设备，也叫写穿（write through）。**\n\n前两种就是直接 I/O（direct_io）和缓存 I/O（buffer_io）。\n\n第三种策略虽然能非常简单保证缓存和底层设备的一致性，不过基于时间局部性原理，page cache 中的数据可能只是中间态，会被频繁修改，每次写穿会产生大量的开销。\n\n关于 page cache 的写回机制（write back），参考 [https://blog.ywang-wnlo.xyz/posts/646202b9/](https://blog.ywang-wnlo.xyz/posts/646202b9/)。\n\n# address_space\n\n**进程的地址空间与文件之间有着密切的联系：程序的执行几乎完全是通过将文件映射到进程的地址空间中进行的。**这种方法非常有效且相当通用，也可以用于常规的系统调用，如 read() 和 write()。\n\n描述地址空间的结构是 `struct address_space`，与之相关的操作由结构 `struct address_space_operations` 描述。初始化 `struct address_space_operations` 需填充文件类型索引节点的 `inode->i_mapping->a_ops`。\n\n> `struct address_space` 是 page cache 的核心结构体。每一个 address_space 与一个 inode 对应，同时 file 中的 f_mapping 字段通常由该文件的 inode 中 i_mapping 赋值。也就是说每个文件都会有独自的 file、inode 以及 address_space 结构体。\n>\n> `struct address_space` 中的 `struct xarray i_pages` 就是该文件的 page cache 中缓存的所有物理页。它是通过基数树结构进行管理的，而 xarray 只是在基数树上进行了一层封装。\n>\n> 通常 `struct address_space` 上会挂载一个 `struct address_space_operations`，自定义对 page cache 中的页面操作的函数。\n\n```c\nstruct address_space {\n\tstruct inode\t\t*host;\n\tstruct xarray\t\ti_pages;\n\tstruct rw_semaphore\tinvalidate_lock;\n\tgfp_t\t\t\tgfp_mask;\n\tatomic_t\t\ti_mmap_writable;\n#ifdef CONFIG_READ_ONLY_THP_FOR_FS\n\t/* number of thp, only for non-shmem files */\n\tatomic_t\t\tnr_thps;\n#endif\n\tstruct rb_root_cached\ti_mmap;\n\tstruct rw_semaphore\ti_mmap_rwsem;\n\tunsigned long\t\tnrpages;\n\tpgoff_t\t\t\twriteback_index;\n\tconst struct address_space_operations *a_ops;\n\tunsigned long\t\tflags;\n\terrseq_t\t\twb_err;\n\tspinlock_t\t\tprivate_lock;\n\tstruct list_head\tprivate_list;\n\tvoid\t\t\t*private_data;\n} __attribute__((aligned(sizeof(long)))) __randomize_layout;\n\n...\n\nstruct address_space_operations {\n\tint (*writepage)(struct page *page, struct writeback_control *wbc);\n\tint (*readpage)(struct file *, struct page *);\n\n\t/* Write back some dirty pages from this mapping. */\n    // writepage() 或 writepages() 负责对这些物理页的实际写入。\n\tint (*writepages)(struct address_space *, struct writeback_control *);\n\n\t/* Set a page dirty.  Return true if this dirtied it */\n\tint (*set_page_dirty)(struct page *page);\n\n\t/*\n\t * Reads in the requested pages. Unlike ->readpage(), this is\n\t * PURELY used for read-ahead!.\n\t */\n\tint (*readpages)(struct file *filp, struct address_space *mapping,\n\t\t\tstruct list_head *pages, unsigned nr_pages);\n\tvoid (*readahead)(struct readahead_control *);\n\n    // 主要负责查找、或者分配新的物理页，并将其锁定，有时还需要先从底层读取最新的数据页。\n\tint (*write_begin)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned flags,\n\t\t\t\tstruct page **pagep, void **fsdata);\n    // 主要负责解锁这些物理页，并且更新 inode 中的元数据信息，例如 i_size。\n\tint (*write_end)(struct file *, struct address_space *mapping,\n\t\t\t\tloff_t pos, unsigned len, unsigned copied,\n\t\t\t\tstruct page *page, void *fsdata);\n\n\t/* Unfortunately this kludge is needed for FIBMAP. Don't use it */\n\tsector_t (*bmap)(struct address_space *, sector_t);\n\tvoid (*invalidatepage) (struct page *, unsigned int, unsigned int);\n\tint (*releasepage) (struct page *, gfp_t);\n\tvoid (*freepage)(struct page *);\n\tssize_t (*direct_IO)(struct kiocb *, struct iov_iter *iter);\n\t/*\n\t * migrate the contents of a page to the specified target. If\n\t * migrate_mode is MIGRATE_ASYNC, it must not block.\n\t */\n\tint (*migratepage) (struct address_space *,\n\t\t\tstruct page *, struct page *, enum migrate_mode);\n\tbool (*isolate_page)(struct page *, isolate_mode_t);\n\tvoid (*putback_page)(struct page *);\n\tint (*launder_page) (struct page *);\n\tint (*is_partially_uptodate) (struct page *, unsigned long,\n\t\t\t\t\tunsigned long);\n\tvoid (*is_dirty_writeback) (struct page *, bool *, bool *);\n\tint (*error_remove_page)(struct address_space *, struct page *);\n\n\t/* swapfile support */\n\tint (*swap_activate)(struct swap_info_struct *sis, struct file *file,\n\t\t\t\tsector_t *span);\n\tvoid (*swap_deactivate)(struct file *file);\n};\n```\n\naddress_space 是以基数树进行组织的文件 Cache。以页为单位，`page->index = 该页在文件中的逻辑偏移 / page_size`。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241230103801350.png\" alt=\"image-20241230103801350\" style=\"zoom:30%;\" />\n\n例如 minix 文件系统的 minix_aops 结构如下：\n\n```c\nstatic const struct address_space_operations minix_aops = {\n    .readpage = minix_readpage,\n    .writepage = minix_writepage,\n    .write_begin = minix_write_begin,\n    .write_end = generic_write_end,\n    .bmap = minix_bmap};\n\n\n{\n    ...\n\n    if (S_ISREG(inode->i_mode))\n    {\n        inode->i_mapping->a_ops = &minix_aops;\n    }\n\n    ...\n}\n```\n\n内核已实现 generic_write_end() 函数。并且上述的大多数函数的实现其实都非常简单：\n\n```c\nstatic int minix_writepage(struct page *page, struct writeback_control *wbc)\n{\n    return block_write_full_page(page, minix_get_block, wbc);\n}\n\nstatic int minix_readpage(struct file *file, struct page *page)\n{\n    return block_read_full_page(page, minix_get_block);\n}\n\nstatic void minix_write_failed(struct address_space *mapping, loff_t to)\n{\n    struct inode *inode = mapping->host;\n\n    if (to > inode->i_size)\n    {\n        truncate_pagecache(inode, inode->i_size);\n        minix_truncate(inode);\n    }\n}\n\nstatic int minix_write_begin(struct file *file, struct address_space *mapping,\n                             loff_t pos, unsigned len, unsigned flags,\n                             struct page **pagep, void **fsdata)\n{\n    int ret;\n\n    ret = block_write_begin(mapping, pos, len, flags, pagep,\n                            minix_get_block);\n    if (unlikely(ret))\n        minix_write_failed(mapping, pos + len);\n\n    return ret;\n}\n\nstatic sector_t minix_bmap(struct address_space *mapping, sector_t block)\n{\n    return generic_block_bmap(mapping, block, minix_get_block);\n}\n```\n\n上面函数中能经常见到 minix_get_block 这个东西。查看 block_write_full_page() 函数定义发现是一个函数指针。\n\n在 minix 文件系统中，minix_get_block() 函数将文件的一个数据块转换为设备上的一个数据块。如果接收到的 create 标志被设置，那么必须分配一个新的数据块。在创建新的数据块时，必须相应地更新位图。为通知内核不要从磁盘中读取该数据块，必须使用 set_buffer_new() 函数标记 bh。通过 map_bh() 函数，将缓冲区与数据块关联起来。\n\n```c\nint block_write_full_page(struct page *page, get_block_t *get_block, struct writeback_control *wbc);\n\ntypedef int (get_block_t)(struct inode *inode, sector_t iblock, struct buffer_head *bh_result, int create);\n```\n\n# dentry\n\n## struct dentry\n\ndentry 将 inode 和 文件名关联起来。VFS 中的 dentry 实体用 `struct dentry` 表示，相关操作用 `struct dentry_operations` 表示。\n\n`struct dentry` 重要字段定义如下：\n\n```c\nstruct dentry\n{\n    ...\n\n    struct inode *d_inode; // 关联的索引节点。\n\n    ...\n\n    struct dentry *d_parent; // 父目录的 dentry 对象。\n    struct qstr d_name;      // dentry 名称，struct qstr 类型，包含字段 name（名称）和 len（名称的长度）。\n\n    ...\n\n    struct dentry_operations *d_op; // 与 dentry 相关的操作。内核实现了默认操作，理论上无需重新实现它们。某些文件系统可以根据 dentry 的特定结构进行优化。\n    struct super_block *d_sb;       // 文件的超级块。\n    void *d_fsdata;                 // 文件系统特定的数据。\n\n    ...\n};\n```\n\ndentry 也有一个全局哈希表进行组织，与它对应的 inode 互指。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241230102953331.png\" alt=\"image-20241230102953331\" style=\"zoom:75%;\" />\n\n## dentry 操作\n\ndentry 最常见的操作包括：\n\n1. d_make_root()：分配根 dentry。通常在读取超级块的函数 fill_super() 中使用。此函数必须初始化根目录。一般从超级块获取根索引节点，并将其作为实参传递给此函数，以填充 struct super_block 结构的 s_root 字段。\n2. d_add()：将 dentry 与索引节点关联起来。作为参数传递的 dentry 表示需要创建的条目（名称、长度）。在创建或加载尚未与任何 dentry 关联并尚未添加到索引节点哈希表中的新索引节点时，将使用此函数（在 lookup() 函数中）。\n3. d_instantiate()：d_add() 的轻量级版本，其中 dentry 先前已添加到哈希表中。注意，d_instantiate() 必须用于实现创建调用 (mkdir, mknod, rename 以及 symlink)，而不是 d_add。\n\n# 目录索引节点\n\n## 目录索引节点操作\n\n目录索引节点的操作比常规文件索引节点的操作要复杂的多。在 minix 中，由对象实例 minix_dir_inode_operations 和 minix_dir_operations 定义。\n\n```c\nstruct inode_operations minix_dir_inode_operations = {\n    .create = minix_create,\n    .lookup = minix_lookup,\n    .link = minix_link,\n    .unlink = minix_unlink,\n    .symlink = minix_symlink,\n    .mkdir = minix_mkdir,\n    .rmdir = minix_rmdir,\n    .mknod = minix_mknod,\n    //...\n};\n\nstruct file_operations minix_dir_operations = {\n    .llseek = generic_file_llseek,\n    .read = generic_read_dir,\n    .iterate = minix_readdir,\n    //...\n};\n\n\n{\n    //...\n\n    if (S_ISDIR(inode->i_mode))\n    {\n        inode->i_op = &minix_dir_inode_operations;\n        inode->i_fop = &minix_dir_operations;\n        inode->i_mapping->a_ops = &minix_aops;\n    }\n\n    //...\n}\n```\n\n## 相关函数\n\n目录索引节点操作的相关函数如下所述。\n\n### 创建索引节点\n\n由 inode_operations 的 create 字段（回调函数）表示。此函数由 open() 和 creat() 系统调用调用，执行以下操作：\n\n1. 在磁盘上的物理结构中引入新条目。不要忘记更新磁盘上的位图。\n2. 使用传入函数的访问权限配置访问权限。\n3. 使用 mark_inode_dirty() 函数将索引节点标记为脏。\n4. 使用 d_instantiate() 函数实例化目录条目 (dentry)。\n\n### 创建目录\n\n由 mkdir 字段表示，由 mkdir() 系统调用调用，执行以下操作：\n\n1. 调用 create 字段对应的回调函数。\n2. 为目录分配一个数据块。\n3. 创建 `\".\"` 和 `\"..\"` 条目。\n\n### 创建链接\n\n由 link 字段表示，由 link() 系统调用调用，执行以下操作：\n\n1. 将新的 dentry 绑定到索引节点。\n2. 递增索引节点的 i_nlink 字段。\n3. 使用 mark_inode_dirty() 函数将索引节点标记为脏。\n\n### 创建符号链接\n\n由 symlink 字段表示，由 symlink() 系统调用调用。执行操作与 link 的回调函数类似，区别在于此函数创建的是符号链接。\n\n### 删除链接\n\n由 unlink 字段表示，由 unlink() 系统调用调用，执行以下操作：\n\n1. 从物理磁盘结构中删除作为参数给出的 dentry。\n2. 将条目指向的索引节点的 i_nlink 计数器减一，否则该索引节点将永远不会被删除（引用计数无法减到 0）。\n\n### 删除目录\n\n由 rmdir 字段表示，由 rmdir() 系统调用调用，执行以下操作：\n\n1. 执行 unlink 字段对应回调函数完成的操作。\n2. 确保目录为空，否则返回 ENOTEMPTY。\n3. 同时删除数据块。\n\n### 在目录中搜索索引节点\n\n由 lookup 字段表示。当需要有关与目录中条目关联的索引节点的信息时，会间接调用此函数。此函数执行以下操作：\n\n1. 在由 dir 指示的目录中搜索具有名称 `dentry->d_name.name` 的条目。\n2. 如果找到条目，则返回 NULL 并使用 d_add() 函数将索引节点与名称关联。\n3. 否则，返回 ERR_PTR。\n\n### 遍历目录中的条目\n\n由 iterate 字段表示，由 readdir() 系统调用调用。\n\n此函数返回目录中的所有条目，或者当为其分配的缓冲区不可用时，仅返回部分条目。可能的返回如下：\n\n1. 如果对应的用户空间缓冲区有足够的空间，则返回与现有条目数相等的数字。\n2. 小于实际条目数的数字，对应的用户空间缓冲区中有多少空间，就返回多少。\n3. 0，表示没有更多条目可读取。\n\n此函数会连续调用，知道读取完所有可用的条目，并且至少会调用 2 次。\n\n1. 在以下情况下仅调用两次：\n   - 第一次调用读取所有条目并返回它们的数量。\n   - 第二次调用返回 0，表示没有其他条目可读取。\n2. 如果第一次调用未返回总条目数，则会多次调用该函数。\n\n此函数执行以下操作：\n\n1. 遍历当前目录中的条目（dentry）。\n2. 对于找到的每个 dentry，递增 `ctx->pos`。\n3. 对于每个有效的 dentry（例如，除了 0 之外的索引节点），调用 dir_emit() 函数。\n4. 如果 dir_emit() 函数返回非零值，表示用户空间的缓冲区已满，函数将返回。\n\ndir_emit() 定义如下：\n\n```c\n// ctx：目录遍历上下文，作为参数传递给 iterate 函数。\n// name：条目的名称。\n// namelen：条目名称的长度。\n// ino：与条目关联的 inode 索引节点号。\n// type：标志条目类型，DT_REG（文件）、DT_DIR（目录）、DT_UNKNOWN（未知）等。\nstatic inline bool dir_emit(struct dir_context *ctx, const char *name, int namelen, u64 ino, unsigned type)\n{\n\treturn ctx->actor(ctx, name, namelen, ctx->pos, ino, type) == 0;\n}\n```\n\n# 位图操作\n\n处理文件系统时，管理信息（哪个块是空闲的或忙碌的，哪个索引节点是空闲的或忙碌的）使用位图存储。因此需要使用位操作，包括：\n\n1. 搜索第一个为 0 的位：表示一个空闲的块或索引节点。\n2. 将位标记为 1：标记忙碌的块或索引节点。\n\n位图操作常见的函数如下。这些函数定义在内核源码 include/asm-generic/bitops/ 目录下，特别是 find.h 和 atomic.h 中。\n\n1. find_first_zero_bit()\n2. find_first_bit()\n3. set_bit()\n4. clear_bit()\n5. test_and_set_bit()\n6. test_and_clear_bit()\n\n这些函数通常接收位图的地址，可能还有其大小（以字节为单位）。如果需要，还要指定需要激活（设置）或停用（清除）的位的索引。\n\n一个使用实例如下：\n\n```c\nunsigned int map;\nunsigned char array_map[NUM_BYTES];\nsize_t idx;\nint changed;\n\n/* 在 32 位整数中找到第一个为 0 的位。 */\nidx = find_first_zero_bit(&map, 32);\nprintk(KERN_ALERT \"第 %zu 位是第一个为 0 的位。\\n\", idx);\n\n/* 在 NUM_BYTES 字节的数组中找到第一个为 1 的位。 */\nidx = find_first_bit(array_map, NUM_BYTES * 8);\nprintk(KERN_ALERT \"第 %zu 位是第一个为 1 的位。\\n\", idx);\n\n/*\n * 清除整数中的第 idx 位。\n * 假设 idx 小于整数的位数。\n */\nclear_bit(idx, &map);\n\n/*\n * 测试并设置数组中的第 idx 位。\n * 假设 idx 小于数组的位数。\n */\nchanged = __test_and_set_bit(idx, &sbi->imap);\nif (changed)\n    printk(KERN_ALERT \"%zu 位已更改\\n\", idx);\n```\n\n# 流程分析\n\n## 文件系统整体运行流程\n\n1. 加载文件系统的内核模块，在 init 中，注册需要的 file_system_type。格式化过程在内核代码没有任何体现。\n\n2. 调用 mount()，挂载文件系统，通过 file_system_type 的 mount() 回调加载对应的 super_block。\n\n3. 通过 super_block 的 `s_op->alloc_inode()` 分配一个 inode。\n\n4. 分配 root 的 dentry，调用 `dentry->d_op` 初始化 dentry。inode_operation 和 dentry_operation 都被记录在 super_block 中，inode 和 dentry 各自在初始化时拷贝了该指针。\n\n5. 设置对应的挂载点，mount 过程完成。\n\n6. 应用程序 open 文件，从指定路径一级一级向下读取对应的 dentry，直到找到需要的文件的 dentry。查找时优先从 dentry 的全局唯一哈希表上查。如果哈希表没有数据，则调用 `inode->i_op->lookup()` 查找。如果最后发现没有这样的文件，则可能调用 `inode->i_op->atomic_open()` 和 `inode->i_op->create()`。在确保有文件的情况下，调用 `file->f_op->open()` 来打开文件。file 的 address_space 和 f_op 由 inode 赋予。\n\n7. read 文件。如果文件加了范围锁，则需判断是否有冲突，然后调用 `file->f_op->read()` 或者 `file->f_op->read_iter()`。\n\n8. write 文件。如果文件加了范围锁，则需判断是否有冲突，然后调用 `file->f_op->write()` 或者 `file->f_op->write_iter()`。\n\n9. close 文件，先调用 `file->f_op->flush()` 刷数据，然后进行异步关闭操作。\n\n> 如果当前进程不在中断上下文且不是 kthread 线程，将该文件的 close() 操作注册到 current->task_works 中。否则，将该文件的 close() 操作注册到全局的 delayed_fput_work 中。最终，两个异步线程会调到相同的回收代码中来。如果文件设置了 FASYNC 标志，调用 `file->f_op->fasync()` 函数，否则调用 `file->f_op->release()` 函数。\n\n10. 调用 umount()，卸载文件系统，触发 `super_block->s_op->kill_sb()` 回调。\n\n## path lookup 过程\n\npath lookup 是通过用户传递的一个绝对或相对路径，来找到对应文件的 inode 的过程。典型的应用如 open() 和 mount() 的查找。\n\n**path lookup 总共可分为 ref-walk 和 rcu-walk 两种模式。**\n\nRCU 模式对锁的争用更少，并发更好，但不适合所有场景（因为 RCU 可能会导致进程睡眠）。ref 模式是传统的 path lookup 方式，不容易失败。\n\nRCU 模式为了检测 dentry 的修改（rename）带来的查询失败，每次查询都会记录 dentry->d_seq，在查询结束后会检测当前 dentry 和父目录 dentry 的 d_seq 是否改变。针对 ref 模式，每次都会锁住当前 dentry 的 d_lock，在成功查询到需要的 dentry 后，会将其引用计数加一。\n\n当从当前目录跳转到下一层目录时，RCU 模式会丢弃掉原来的父目录的 d_seq 记录（因为不用关心祖父目录的引用计数），而 ref 模式则会丢弃对当前目录的引用。\n\n## mount 过程\n\nmount 系统调用定义如下。更多细节参考博客 [https://blog.csdn.net/bingyu880101/article/details/50481507](https://blog.csdn.net/bingyu880101/article/details/50481507)。\n\n```c\n#include <sys/mount.h>\n\n// source：要挂上的文件系统的名字，通常是一个设备名。\n// target：文件系统要挂在的目标目录。\n// filesystemtype：挂载的文件系统类型，如 \"ext4\"、\"btrfs\"、\"msdos\"、\"proc\"、\"nfs\"、\"iso9660\"、\"vfat\" 等。\n// mountflags：指定文件系统的读写访问标志。\n// data：文件系统持有的参数。\nint mount(const char *source, const char *target, const char *filesystemtype, unsigned long mountflags, const void *_Nullable data);\n```\n\nmount 的过程具体如下：\n\n1. 根据 dir_name，进行 path lookup。\n\n2. 根据 type，查找对应的 file_system_type。\n\n3. 拿到 file_system_type，调 mount() 回调，将 dev_name 对应的块设备和 data 传递给它，mount() 回调将建立好对应的 root 的 dentry，super_block 和 root 的 inode。\n\n4. 新建 mount 结构体，将 dentry 与 mount 结构体绑定。\n\n5. 在 mount_hashtable 中不断查找。如果找到匹配的 mount 结构体，说明该挂载点已被使用，需要继续查找。直到找不到对应的 mount 结构体，说明当前挂载点尚未被占用，系统可以在此挂载新的文件系统。此时系统最后得到有效的 mount 结构体就作为当前 mount 结构体的父挂载点，得到的 dentry 作为当前 mount 结构体的 mountpoint。\n\n6. 建立父 mount 与当前 mount 的联系，建立 mountpoint 与当前 mount 的联系。\n\n## open 过程\n\nopen 主要的流程如下：\n\n1. 分析 open 传进来的 flags。\n\n2. 分配 fd。\n\n3. 对文件执行 open、create 等操作（视具体情况而定）。\n\n4. 通知监控文件打开的回调。\n\n5. 将打开得到的 file 结构体放到 fdtable 的 fd 数组中。\n\nopen 具体查找文件 inode 的过程，即是 path lookup 的过程。\n\n`file->f_op` 有一个 atomic_open() 回调，允许文件系统以与原子的方式查找某个文件。如果该文件不存在，则文件系统尝试创建该文件（当设置了 O_CREAT 标志时）。故在尝试查找和创建文件时，VFS 优先使用 atomic_open()，当文件系统不支持该操作时，才回归到先 lookup，查找失败再 create 的模式。\n\n## 通用 read 流程\n\n这里不考虑文件的异步读写，也就是 aio 系列的 read 和 write。\n\n所谓通用，是指某些文件系统不单独写 read() 或 read_iter() 回调，而是调 VFS 实现的默认 read 函数 generic_file_read_iter()。\n\n在读缓存的过程中，如果不允许进程阻塞，且需要的数据不在内存中，会立即返回失败。\n\n读分为两种，一种是 direct_io，另一种是走 address_space。\n\n如果走 direct_io：\n\n1. 如果这个 read 操作不能陷入等待（NO_WAIT），且要读取的文件范围内有缓存，则返回 -EAGAIN。\n\n2. 否则，先通过 address_space 将缓存的数据刷下去。\n\n3. 再调用 `mapping->a_ops->direct_io()` 读取数据。\n\n如果走 address_space，用户需要的数据量可能很大，需要一页一页地处理。对于每一页：\n\n1. 从 address_space 中查找对应 page。如果找不到，则以同步方式进行预读，如果这样也拿不到 page，跳转到步骤 6。\n\n2. 如果拿到的 page 带有 readahead 标记，说明我们需要自己预读一些页面。\n\n3. 如果 page 带有 uptodate 标志，则跳到下一步，否则：\n   - 等待 page 的 lock 标志被清零（等待 page 被解锁）。\n   - 如果 page 带有 uptodate 标志，则跳转到步骤 4。\n   - 现在，文件可能被 truncate 了，需要进行检查。如果有 `mapping->a_ops->is_partially_uptodate()` 回调，且通过该回调发现我们需要读的范围内数据是 uptodate 的，则跳转到步骤 4，否则跳转到步骤 5。\n\n4. 现在，数据是确保在内存中的，且是 uptodate 的。将 page 里面的数据拷贝到用户的 buffer 里面，然后进行下个 page 的处理或者退出循环。\n5. 到这一步，说明有 page，但数据没有 uptodate。\n   - 如果 `page->mapping` 为空，则说明这整个页都被 truncate 了，即可以考虑下一块页面的处理（进入 continue）。\n   - 接下来需要调用 `mapping->a_ops->readpage()` 读取数据。\n   - 回到步骤 4，进行数据拷贝。\n\n6. 到这一步，说明没有对应的 page，需要先分配一个 page，加入到 address_space 和 lru 结构中，然后回到步骤 5。\n\n## 通用 write 流程\n\nwrite 操作会更新 inode 的 mtime 和 ctime，以及 version。同理分为 direct_io 和 address_space 两种。\n\n如果走 direct_io：\n\n1. 如果 address_space 中缓存有要写入范围的数据，且当前进程不能阻塞，则立即返回错误。\n\n2. 否则，先通过 address_space 将缓存的数据刷下去。\n\n3. 现在处理缓存数据的其他问题。对于处于 write 范围内的每一个被缓存的 page 而言：\n   - 首先，确保 page 的数据被刷到了磁盘上（上一步已经确保了这一步）。\n   - 如果这个 page 做了 mmap，取消这一页的 mmap。\n   - 接下来将这个 page 从 address_page 中取下，分为两步：\n     - 如果这个页是 dirty 的话，先调用 `mapping->a_ops->launder_page()` 将脏数据刷下去。这一回调与 writepage() 回调的不同在于，它不允许文件系统通过 redirty 的方式跳过对这一页的 flush 操作。\n     - 接下来将 page 从 address_page 中取下，然后调用 `mapping->a_ops->freepage()` 释放掉这一 page。\n\n4. 接下来，调用 `mapping->a_ops->direct_io()` 写数据。\n\n5. 然后，继续调用步骤 3 来刷一次 page。这是因为可能有其他进程预读了这一部分的数据，或者因为 mmap 了，然后在访问时出现 page fault 导致这一部分的数据被拉进来了。\n\n6. 如果 direct_io 调用失败了，则通过写 Cache、刷 Cache、再无效化 Cache 的方式写数据。\n   - 写 Cache。对于写入范围内的每一页：\n     - 调用 `mapping->a_ops->write_begin()`，通知文件系统准备往 page 上数据了。\n     - kmap page 后，将数据从用户空间拷贝到 page 上，然后 kunmap page，刷 tlb。\n     - 调用 `mapping->a_ops->write_end()`，通知文件系统往 page 上写数据的过程结束。\n     - 判断脏数据是否超过某一阈值，以决定是否需要后台刷数据下去。\n   - 刷 Cache 和无效化 Cache 的过程与步骤 2、3 类似。\n\n7. 至此，direct_io 的过程结束。\n\n如果是普通的写 Cache，而不是 direct_io，则与上述步骤 6 的写 Cache 步骤相同。\n\n如果写入数据成功，且用户指定了需要 fsync，则通过 `file->f_op->fsync()` 回调将更新的数据刷下去。\n\n## address_space 刷数据流程\n\n1. 先调用 `mapping->a_ops->writepages` 刷数据。\n\n2. 如果 writepages 回调不存在，只能使用 write_page 回调。\n   - blk_start_plug()\n   - 对于范围内的每个 page：\n     - 如果要等待所有 page 完成（`wbc->sync_mode == WB_SYNC_ALL`）或者标记了 `wbc->tagged_writepages`，则将 address_space 中标记为 PAGECACHE_TAG_DIRTY 的页面再标记为 PAGECACHE_TAG_TOWRITE。原来的 DIRTY 标记不去掉。\n     - 如果上一步设置了 TOWRITE 标记，则再次在 address_space 中搜索标记为 TOWRITE 的那些 page，否则搜索在 address_space 中标记为 DIRTY 的回调（仅在给定的范围内搜索）。对于搜索到的 page：\n       - 如果 page 的（不是 address_space 的）DIRTY 标记被清掉了，说明其他进程先刷下去了，我们不需要对这个 page 做任何操作。\n       - 如果 page 有 WRITEBACK 标记，如果 `wbc->sync_mode != WB_SYNC_NONE`，我们需要等待这个 page 的 writeback 操作完成。\n       - 否则，由当前进程负责调用 `mapping->a_op->writepage()` 回调刷数据。\n   - blk_finish_plug()\n\n3. 如果回调函数返回了 -NOMEM，表示对应块设备繁忙。此时如果 `wbc->sync_mode == WB_SYNC_ALL`，代表可以在这里等待设备刷数据，因此调用 io_schedule() 稍微等待一段时间后回到第一步重试。\n\n4. 搜索 address_space，对于范围内的每个标记为 PAGECACHE_TAG_WRITEBACK 的 page，等待 page 的 writeback 标记被清空。\n\n> 我们并没有设置 address_space 的 PAGECACHE_TAG_WRITEBACK 标志，但是在等待数据被刷下去时，却是搜索的该标志。其实 PAGECACHE_TAG_WRITEBACK 标志是被 `a_op->readpage()` 或 `a_op->readpages()` 回调函数设置的。\n\n## 等待 page 标志流程\n\n等待 page 标志被清零，这是常见的操作。例如等待 page 的 writeback 标志被清零，表示 page 被写下去了。\n\npage 的等待机制是用哈希表完成的，名字是 page_wait_table，共 256 根链表，以 page 的地址作为键（Key）。\n\n1. 每次需要等待 page 的某个标志位被清零时，在栈上创建一个 wait_page_queue，作为 wait_queue 的一个 entry。\n\n2. 让该 entry 将入到对应的 wait_page_queue 的尾部，然后调用 io_schedule() 进行等待。\n\n3. 当有其他进程从哈希表的链表上唤醒某个 page 时，会判断当前 entry 等待的 page 是否与将要唤醒的 page 相同，等待标志是否相同。若相同，会先调用 wait_page_queue 的回调函数将该 entry 从链表上取下，然后再唤醒进程。\n\n4. 当从阻塞中被唤醒后，判断标志位是否被清零。如果是，则从等待中返回。如果是被信号打断的，也需要返回，否则回到步骤 2 重新等待。\n\n## plug 机制\n\n### plug\n\n**plug 机制用于缓存刷向通用块层的数据。**使用方法如下：\n\n1. 调用 blk_start_plug() 初始化一个 plug。\n\n2. 处理各种往通用块层读写数据的请求。\n\n3. 调用 blk_finish_plug() 刷数据。\n\nplug 仅有三根链表：\n\n1. list：用于普通 request 的链表，上面串着单队列的 request。\n\n2. mq_list：用于 multi-queue 的链表，上面串着多队列的 request。\n\n3. cb_list：在 unplug 时需调用的回调函数链表。\n\n```c\nstruct blk_plug {\n\tstruct list_head mq_list; /* blk-mq requests */\n\tstruct list_head cb_list; /* md requires an unplug callback */\n\tunsigned short rq_count;\n\tbool multiple_queues;\n\tbool nowait;\n};\n\nstruct blk_plug_cb;\ntypedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);\nstruct blk_plug_cb {\n\tstruct list_head list;\n\tblk_plug_cb_fn callback;\n\tvoid *data;\n};\n```\n\n### blk_start_plug\n\nplug 总是与进程绑在一起的，一个进程只会有一个 plug，但 plug 机制可以递归进入。\n\n1. 判断 `current->plug` 是否存在，如果存在，直接返回。\n\n2. 初始化 plug 的三根链表。\n\n3. 将外界传递进来的 plug 作为 `task->plug`。\n\n### blk_finish_plug\n\n1. 如果外界传递进来的 plug 不是 `current->plug`，则处于递归调用 plug 中，直接返回。\n\n2. 调用 `plug->cb_list` 中的所有回调函数。\n\n3. 将 mq_list 的 request 刷下去。\n   - 对 mq_list 进行排序。这样属于同一个 blk_mq_ctx 的那些 request 就被放在一起了。\n   - 将属于同一个 blk_mq_ctx 的 request 搜集到一根链表上，统一提交到同一个 blk_mq_hw_ctx 中。\n\n4. 将 list 的 request 刷下去。\n   - 对 list 进行排序。这样属于同一个 request_queue 的那些 request 就被放在一起了。\n   - 将属于同一个 request_queue 的 request 搜集到一根链表上，统一提交到对应的 request_queue 中。\n\n5. 设置 `current->plug` 为 NULL。\n\n## inode、super_block 和 dentry 的并发查找机制\n\n以 inode 为例，经常会遇到 malloc() 一个 inode 的情况。一般来说，内核中对于一个文件只对应一个 inode，但如果两个进程同时想针对硬盘上的同一个文件创建 inode，就会造成冲突。\n\n内核为解决这个问题，将所有的 inode 放在了 inode_hashtable，被自旋锁保护。当需要一个文件对应的 inode 时：\n\n1. 加锁，从该哈希表查找对应的 inode，解锁。\n\n2. 若没有，分配一个 inode。\n\n3. 加锁。\n\n4. 从该哈希表中再次查找对应的 inode。\n\n5. 若不存在对应的 inode，将新的 inode 加入到哈希表中。\n\n6. 解锁。\n\n7. 若存在对应的 inode，将刚才分配的 inode 释放掉。\n\ndentry 和 super_block 也有类似机制，设计内核的一系列函数 iget_locked()、sget()、d_alloc_parallel() 等。\n\ndentry 比较特殊。它将要查找的 dentry 放到一个名为 in_lookup_hashtable 的哈希表中，而将所有的 dentry 放入到 dentry_hashtable 中。\n\n# 参考文章\n\n1. [Linux Kernel Teaching — The Linux Kernel documentation](https://linux-kernel-labs.github.io/refs/heads/master/)\n\n2. [Linux 内核教学 — Linux 系统内核文档](https://linux-kernel-labs-zh.xyz/)\n\n","categories":["Linux 学习","内核层"]},{"title":"TeRM：Extending RDMA-Attached Memory with SSD","url":"/posts/2d325f6a.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n原文地址：[https://www.usenix.org/conference/fast24/presentation/yang-zhe](https://www.usenix.org/conference/fast24/presentation/yang-zhe)\n\n这篇论文提出了一种名为 TeRM 的系统，旨在通过 SSD 扩展 RDMA（远程直接内存访问）附加内存，以应对数据中心内存资源有限的问题。TeRM 通过软件化处理页面错误、分层 I/O 和动态热点提升等技术，减少了 CPU 和网络开销，提升了内存扩展的效率。\n\n<!-- more -->\n\n# 背景\n\n1. RDMA（远程内存直接访问）\n\nRDMA 是一种网络通信技术，允许客户端直接访问服务器端的内存，无需通过服务器的 CPU 处理，从而实现了非常低的延迟和高效的性能。相比传统的 TCP/IP 网络，RDMA 避免了数据在 CPU 和内存之间的多次传输，减少了延迟。因此，RDMA 非常适用于高性能的内存系统，如分布式文件系统、键值存储和事务性数据库。\n\n尽管 RDMA 能够带来高性能，但数据中心的内存资源昂贵且有限。因此，仅依赖内存来满足存储需求并不实际。这一局限性促使研究人员寻找其他方式，例如通过 SSD 来扩展 RDMA 内存，使得这些系统能够处理超过物理内存容量的数据集。\n\n2. ODP（按需分页）\n\nODP 通过硬件支持来扩展 RDMA 内存，其工作原理是当 RDMA 访问存储在 SSD 上的数据时，触发页面错误（page fault），然后由 CPU 从 SSD 中读取数据并更新 RNIC（RDMA 网络接口卡）的页面表。\n\nODP 的一个关键问题在于其页面错误处理效率低下。当页面错误发生时，RNIC 会停止队列并通知客户端的 RNIC 重新传输请求，这种方式耗时且增加了系统负担。实验表明，当从内存中访问数据时，ODP 的延迟仅为 3.66 微秒，但当数据在 SSD 上时，延迟会剧增到 570.74 微秒。ODP 的低效主要源于 RNIC 硬件资源有限，处理页面错误的能力不足。这样就导致 ODP 在扩展 RDMA 内存时并不理想。\n\n# 设计与核心技术\n\nTeRM 主要通过三大技术突破解决了现有系统的不足。\n\n1. 将页面错误处理从硬件移到软件（软件化异常处理）\n\n硬件的页面错误处理效率低下，因此 TeRM 将处理页面错误的任务从 RNIC 硬件转移到软件。这样避免了硬件在页面错误上的低效操作，从而加速了 SSD 数据的远程访问。\n\nTeRM 为存储在 SSD 上的所有页面创建了一个“魔法页面”，RNIC 页面表中的无效页面被统一映射到该“魔法页面”。当客户端访问无效页面时，RNIC 会返回“魔法页面”的数据而不会触发硬件页面错误。然后，客户端通过 RPC（远程过程调用）从服务器获取 SSD 上的数据。这种方法消除了 RNIC 页面错误带来的延迟。\n\n2. 分层 I/O（Tiering I/O）\n\n直接在虚拟内存与 SSD 之间进行 I/O 操作会触发 CPU 页面错误，影响系统性能。为了消除这种问题，TeRM 使用分层 I/O，根据数据是否在物理内存中选择不同的 I/O 方式。关键思想是通过文件 I/O 接口而非内存加载/存储接口访问 SSD 扩展的虚拟内存。\n\n分层 I/O 根据页面的状态采用不同的 I/O 方式：当数据已被缓存（缓冲 I/O），则可以快速访问；而当数据未缓存时，通过直接 I/O 绕过页面缓存来避免页面替换的开销。分层 I/O 有效地利用了内存中缓存的数据，提高了访问效率；对于存储在 SSD 中的数据，通过直接 I/O 降低了 CPU 的页面错误开销。\n\n3. 动态热点提升（Dynamic Hotspot Promotion）\n\n在实际应用中，某些数据会频繁访问（热点数据），而 TeRM 会将热点数据优先放置在物理内存中，以降低 SSD 访问的延迟。\n\nTeRM 通过在客户端跟踪数据访问频率并在服务器端聚合这些数据来确定热点区域。然后，它会将热点数据动态地从 SSD 提升到物理内存中，使后续访问更加高效。这种设计确保了系统在不同访问模式下的灵活性，减少了热点数据在 SSD 上的访问延迟。\n\n","categories":["论文阅读"]},{"title":"Linux 设备驱动开发详解","url":"/posts/484892ff.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n本书基于 Linux 4.0 内核编写，个人学习测试的内核版本是 5.15.167。\n\n# 内核及内核编程\n\n## Linux 2.6 后的内核特点\n\nLinux 2.6 相对于 Linux 2.4 有着相当大的改进，主要表现为以下几个方面。\n\n### 新的调度器\n\nLinux 2.6 以后版本的 Linux 内核使用了新的进程调度算法，它在高负载的情况下有极其出色的性能，并且当有很多处理器时也可以很好地扩展。在 Linux 内核 2.6 的早期采用了 O（1）算法，之后转移到 CFS（Completely Fair Scheduler，完全公平调度）算法。在 Linux 3.14 中，也增加了一个新的调度类：SCHED_DEADLINE，它实现了 EDF（Earliest Deadline First，最早截止期限优先）调度算法。\n\n<!-- more -->\n\n### 内核抢占\n\n在 Linux 2.6 以后版本的 Linux 内核中，一个内核任务可以被抢占，从而提高系统的实时性。这样做最主要的优势在于，可以极大地增强系统的用户交互性，用户将会觉得鼠标单击和击键的事件得到了更快速的响应。Linux 2.6 以后的内核版本还是存在一些不可抢占的区间，如中断上下文、软中断上下文和自旋锁锁住的区间。如果给 Linux 内核打上 RT-Preempt 补丁，则中断和软中断都被线程化了，自旋锁也被互斥体替换，Linux 内核变得能支持硬实时。\n\n### 改进的线程模型\n\nLinux 2.6 以后版本中的线程采用 NPTL（Native POSIX Thread Library，本地 POSIX 线程库）模型，操作速度得以极大提高，相比于 Linux 2.4 内核时代的 LinuxThreads 模型，它也更加遵循 POSIX 规范的要求。NPTL 没有使用 LinuxThreads 模型中采用的管理线程，内核本身也增加了 FUTEX（Fast Userspace Mutex，快速用户态互斥体），从而减小多线程的通信开销。\n\n### 虚拟内存的变化\n\n从虚拟内存的角度来看，新内核融合了 r-map（反向映射）技术，显著改善虚拟内存在一定大小负载下的性能。在 Linux 2.4 中，要回收页时，内核的做法是遍历每个进程的所有 PTE 以判断该 PTE 是否与该页建立了映射，如果建立了，则取消该映射，最后无 PTE 与该页相关联后才回收该页。在 Linux 2.6 后，则建立反向映射，可以通过页结构体快速寻找到页面的映射。\n\n### 文件系统\n\nLinux 2.6 版内核增加了对日志文件系统功能的支持，解决了 Linux 2.4 版本在这方面的不足。Linux 2.6 版内核在文件系统上的关键变化还包括对扩展属性及 POSIX 标准访问控制的支持。ext2/ext3/ext4 作为大多数 Linux 系统默认安装的文件系统，在 Linux 2.6 版内核中增加了对扩展属性的支持，可以给指定的文件在文件系统中嵌入元数据。 \n\n在文件系统方面，基于 B 树的 Btrfs，称为是下一代 Linux 文件系统，它在扩展性、数据一致性、多设备管理和针对 SSD 的优化等方面都优于 ext4。\n\n## 内核的组成\n\n### 内核源码的目录结构\n\nLinux 内核源代码包含以下目录，可通过网站 [https://elixir.bootlin.com/](https://elixir.bootlin.com/) 浏览。\n\n- arch：包含和硬件体系结构相关的代码，每种平台占一个相应的目录，如 i386、arm、arm64、powerpc、mips 等。Linux 内核目前已经支持 30 种左右的体系结构。在 arch 目录下，存放的是各个平台以及各个平台的芯片对 Linux 内核进程调度、内存管理、中断等的支持，以及每个具体的 SoC 和电路板的板级支持代码。\n- block：块设备驱动程序 I/O 调度。\n- crypto：常用加密和散列算法（如 AES、SHA 等），还有一些压缩和 CRC 校验算法。\n- documentation：内核各部分的通用解释和注释。\n- drivers：设备驱动程序，每个不同的驱动占用一个子目录，如 char、block、net、mtd、i2c 等。\n- fs：所支持的各种文件系统，如 EXT、FAT、NTFS、JFFS2 等。\n- include：头文件，与系统相关的头文件放置在 include/linux 子目录下。\n- init：内核初始化代码。著名的 start_kernel() 就位于 init/main.c 文件中。\n- ipc：进程间通信的代码。\n- kernel：内核最核心的部分，包括进程调度、定时器等，而和平台相关的一部分代码放在 arch/*/kernel 目录下。\n- lib：库文件代码。\n- mm：内存管理代码，和平台相关的一部分代码放在 arch/*/mm 目录下。\n- net：网络相关代码，实现各种常见的网络协议。\n- scripts：用于配置内核的脚本文件。\n- security：主要是一个 SELinux 的模块。\n- sound：ALSA、OSS 音频设备的驱动核心代码和常用设备驱动。\n- usr：实现用于打包和压缩的 cpio 等。\n\n内核一般要做到 drivers 与 arch 的软件架构分离，驱动中不包含板级信息，让驱动跨平台。同时内核的通用部分（如 kernel、fs、ipc、net 等）则与具体的硬件（arch 和 drivers）剥离。\n\n### 内核的组成部分\n\nLinux 内核主要由**进程调度（SCHED）、内存管理（MM）、虚拟文件系统（VFS）、网络接口（NET）和进程间通信（IPC）**5 个子系统组成，如图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241024101324120.png\" alt=\"image-20241024101324120\" style=\"zoom:70%;\" />\n\n#### 进程调度\n\n多个进程在 CPU 中“微观串行、宏观并行”的执行。进程调度处于系统的中心位置，内核中其他的子系统都依赖它，因为每个子系统都需要挂起或恢复进程。\n\nLinux 的进程在几个状态间进行切换。在设备驱动编程中，当请求的资源不能得到满足时，驱动一般会调度其他进程执行，并使本进程进入睡眠状态，直到它请求的资源被释放，才会被唤醒而进入就绪状态。睡眠分成可中断的睡眠和不可中断的睡眠，两者的区别在于可中断的睡眠在收到信号的时候会醒。状态转化图如图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241024102027520.png\" alt=\"image-20241024102027520\" style=\"zoom:70%;\" />\n\n完全处于 TASK_UNINTERRUPTIBLE 状态的进程甚至都无法被“杀死” ，所以 Linux 2.6.26 之后的内核 也存在一种 TASK_KILLABLE 的状态，它等于 TASK_WAKEKILL|TASK_UNINTERRUPTIBLE，可以响应致命信号。\n\n在 Linux 内核中，**使用 task_struct 结构体来描述进程**。该结构体中包含描述该进程内存资源、文件系统资源、文件资源、tty 资源、信号处理等的指针。Linux 的线程采用轻量级进程模型来实现，在用户空间通过 pthread_create() API 创建线程的时候，本质上内核只是创建了一个新的 task_struct，并将新 task_struct 的所有资源指针都指向创建它的那个 task_struct 的资源指针。\n\n绝大多数进程（以及进程中的多个线程）是由用户空间的应用创建的，当它们存在底层资源和硬件访问的需求时，会通过系统调用进入内核空间。有时候，在内核编程中，如果需要几个并发执行的任务，可以启动内核线程，这些线程没有用户空间。启动内核线程的函数如下：\n\n```c\n// #include <linux/sched/task.h>\n\npid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags);\n```\n\n#### 内存管理\n\n内存管理的主要作用是控制多个进程安全地共享主内存区域。当 CPU 提供内存管理单元（MMU）时，Linux 内存管理对于每个进程完成从虚拟内存到物理内存的转换。\n\n一般而言，32 位处理器的 Linux 的每个进程享有 4GB 的内存空间，0~3GB 属于用户空间，3~4GB 属于内核空间，内核空间对常规内存、I/O 设备内存以及高端内存有不同的处理方式。当然，内核空间和用户空间的具体界限是可以调整的，在内核配置选项 Kernel Features → Memory split 下，可以设 置界限为 2GB 或者 3GB。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241024104326004.png\" alt=\"image-20241024104326004\" style=\"zoom:75%;\" />\n\nLinux 内核的内存管理总体比较庞大，包含底层的 Buddy 算法，它用于管理每个页的占用情况，内核空间的 slab 以及用户空间的 C 库的二次管理。另外，内核也提供了页缓存的支持，用内存来缓存磁盘，per-BDI flusher 线程用于刷回脏的页缓存到磁盘。Kswapd（交换进程）则是 Linux 中用于页面回收（包括 file-backed 的页和匿名页）的内核线程，它采用最近最少使用（LRU）算法进行内存回收。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241024104439338.png\" alt=\"image-20241024104439338\" style=\"zoom:65%;\" />\n\n#### 虚拟文件系统（VFS）\n\nLinux 虚拟文件系统隐藏了各种硬件的具体细节，为所有设备提供了统一的接口。而且，它独立于各个具体的文件系统，是对各种文件系统的一个抽象。它为上层的应用程序提供了统一的 vfs_read()、vfs_write() 等接口，并调用具体底层文件系统或者设备驱动中实现的 file_operations 结构体的成员函数。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241024104730858.png\" alt=\"image-20241024104730858\" style=\"zoom:70%;\" />\n\n#### 网络接口\n\n网络接口提供了对各种网络标准的存取和各种网络硬件的支持。在 Linux 中网络接口可分为网络协议和网络驱动程序，网络协议部分负责实现每一种可能的网络传输协议，网络设备驱动程序负责与硬件设备通信，每一种可能的硬件设备都有相应的设备驱动程序。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241024110756075.png\" alt=\"image-20241024110756075\" style=\"zoom:63%;\" />\n\nLinux 内核支持的协议栈种类较多，如 Internet、UNIX、CAN、NFC、Bluetooth、WiMAX、IrDA 等，上层的应用程序统一使用套接字接口。\n\n#### 进程间通信\n\n进程间通信支持进程之间的通信，Linux 支持进程间的多种通信机制，包含信号量、共享内存、消息队列、管道、UNIX 域套接字等，这些机制可协助多个进程、多资源的互斥访问、进程间的同步和消息传递。在实际的 Linux 应用中，人们更多地趋向于使用 UNIX 域套接字，而不是 System V IPC 中的消息队列等机制。\n\n#### 组成部分的依赖关系\n\nLinux 内核 5 个组成部分之间的依赖关系如下：\n\n- 进程调度与内存管理之间的关系：这两个子系统互相依赖。在多程序环境下，程序要运行，则必须为之创建进程，而创建进程的第一件事情，就是将程序和数据装入内存。\n- 进程间通信与内存管理的关系：进程间通信子系统要依赖内存管理支持共享内存通信机制，这种机制允许两个进程除了拥有自己的私有空间之外，还可以存取共同的内存区域。\n- 虚拟文件系统与网络接口之间的关系：虚拟文件系统利用网络接口支持网络文件系统（NFS），也利用内存管理支持 RAMDISK 设备。\n- 内存管理与虚拟文件系统之间的关系：内存管理利用虚拟文件系统支持交换，交换进程定期由调度程序调度，这也是内存管理依赖于进程调度的原因。当一个进程存取的内存映射被换出时，内存管理向虚拟文件系统发出请求，同时，挂起当前正在运行的进程。\n\n除了这些依赖关系外，内核中的所有子系统还要依赖于一些共同的资源。这些资源包括所有子系统都用到的API，如分配和释放内存空间的函数、输出警告或错误消息的函数及系统提供的调试接口等。\n\n### 内核空间与用户空间\n\n在 Linux 系统中，内核可进行任何操作，而应用程序则被禁止对硬件的直接访问和对内存的未授权访问。\n\n内核空间和用户空间这两个名词用来区分程序执行的两种不同状态，它们使用不同的地址空间。Linux 只能通过**系统调用**和**硬件中断**完成从用户空间到内核空间的控制转移。\n\n## 内核的编译及加载\n\n### 编译\n\n既然要学习内核，首先肯定需要动手编译一个内核出来。在编译内核之前，首先下载想要编译安装的内核源代码到本地。然后就需要配置内核，可使用以下命令配置：\n\n```bash\nmake config #（基于文本的最为传统的配置界面，不推荐使用）\nmake menuconfig #（基于文本菜单的配置界面）\nmake xconfig #（要求 QT 被安装）\nmake gconfig #（要求 GTK+ 安装）\n```\n\nLinux 内核的配置系统有三个部分组成：\n\n- Makefile：分布在 Linux 内核源代码中，定义 Linux 内核的编译规则。\n- 配置文件（Kconfig）：给用户提供配置选择的功能。\n- 配置工具：包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界面（提供字符界面和图形界面）。这些配置工具使用的都是脚本语言，如用 Tcl/TK、Perl 等。\n\n执行完配置命令以后，会生成一个 .config 配置文件，记录了哪些部分被编译入内核、哪些部分被编译为内核模块。当然一般情况下，我们可以沿用本机的设置，将其拷贝到想要想要安装的内核源代码目录，并重命名为 .config 文件：\n\n```bash\ncp -v /boot/config-`uname -r` .config\n```\n\n更完整的编译和调试内核的办法请参考文章 [https://ignotusjee.github.io/2024/10/18/Linux-Debug/](https://ignotusjee.github.io/2024/10/18/Linux-Debug/)。\n\n另外的，在 Linux 内核中增加程序需要完成以下 3 项工作：\n\n- 将编写的源代码复制到 Linux 内核源代码的相应目录中。\n- 在目录的 Kconfig 文件中增加关于新源代码对应项目的编译配置选项。\n- 在目录的 Makefile 文件中增加对新源代码的编译条目。\n\n### Makefile\n\n这里主要涉及内核专有的 Kbuild Makefile 编译系统。\n\n1. 目标定义\n\n定义哪些内容是编译并链接入内核，哪些是作为内核模块编译。\n\n例如这段代码：\n\n```makefile\nobj-y += foo.o\n```\n\n表示需要编译 foo.c 或者 foo.s 文件得到 foo.o 并链接进内核。这是无条件编译，所以不需要 Kconfig 配置选项。\n\n`obj-m` 表示作为内核模块编译，`obj-n` 表示不会被编译。\n\n2. 多模块文件的定义\n\n如果一个模块由多个文件组成，Makefile 会稍微复杂一点。这时应该采用模块名加 -y 或 -objs 后缀的形式定义模块的组成文件，例如：\n\n```makefile\n#\n# Makefile for the linux ext2-filesystem routines.\n#\nobj-$(CONfiG_EXT2_FS) += ext2.o\next2-y := balloc.o dir.o file.o fsync.o ialloc.o inode.o \\\nioctl.o namei.o super.o symlink.o\next2-$(CONfiG_EXT2_FS_XATTR) += xattr.o xattr_user.o xattr_trusted.o\next2-$(CONfiG_EXT2_FS_POSIX_ACL) += acl.o\next2-$(CONfiG_EXT2_FS_SECURITY) += xattr_security.o\next2-$(CONfiG_EXT2_FS_XIP) += xip.o\n```\n\n模块的名字是 ext2，由 balloc.o dir.o file.o 等多个目标文件最终链接生成 ext2.o 或者 ext2.ko 的目标文件（当然 Linux 2.6 以后是 .ko）。其他的目标文件是否编译生成取决于配置文件。\n\n3. 目录层次的迭代\n\n当源代码比较多的时候，处于设计和美观的目的，按照目录分层次结构是有必要的。例如：\n\n```makefile\nobj-m += ext2/\n```\n\n这代表 Kbuild 会把 ext2/ 目录列入向下迭代的目标。ext2/ 目录中理应有自己的 Kbuild Makefile 的子构建系统。\n\n### Kconfig\n\n1. 配置选项\n\n配置选项通过 config 关键字定义，例如：\n\n```kconfig\nconfig MODVERSIONS\n    bool \"Module versioning support\"\n    help\n        Usually, you have to use modules compiled with your kernel.\n        Saying Y here makes it ...\n```\n\nconfig 关键字定义新的配置选项，之后的几行代码定义了该配置选项的属性。配置选项的属性包括类型、数据范围、输入提示、依赖关系、选择关系及帮助信息、默认值等。\n\n每个配置选项都必须指定类型，类型包括 bool、tristate、string、hex 和 int，其中 tristate 和 string 是两种基本类型，其他类型都基于这两种基本类型。类型定义后可以紧跟输入提示，下面两段代码是等价的：\n\n```kconfig\nbool “Networking support”\n\n# 等价于\n\nbool\nprompt \"Networking support\"\n```\n\n输入提示使用 prompt 关键字，一般格式如下，其中可选 if 用于表示该提示的依赖关系。\n\n```kconfig\nprompt <prompt> [if <expr>]\n```\n\n默认值的格式如下。如果用户不设置对应的选项，配置选项的值就是默认值。\n\n```kconfig\ndefault <expr> [if <expr>]\n```\n\n依赖关系的格式如下。如果定义了多重依赖关系，它们之间用 `&&` 间隔。\n\n```kconfig\ndepends on <expr>\n```\n\n依赖关系也可以应用到该菜单中所有的其他选项 （同样接受 if 表达式）内，因此下面两段脚本是等价的：\n\n```kconfig\nbool \"foo\" if BAR\ndefault y if BAR\n\n\n# 等价于\n\ndepends on BAR\nbool \"foo\"\ndefault y\n```\n\n选择关系，也成为反向依赖关系，格式如下。如果 A 选择了 B，那么 A 在被选中的情况下，B 也会自动被选中。\n\n```kconfig\nselect <symbol> [if <expr>]\n```\n\n数据范围的格式为：\n\n```kconfig\nrange <symbol> <symbol> [if <expr>]\n```\n\nexpr 表达式定义为：\n\n```kconfig\n<expr> ::= <symbol>\n            <symbol> '=' <symbol>\n            <symbol> '!=' <symbol>\n            '(' <expr> ')'\n            '!' <expr>\n            <expr> '&&' <expr>\n            <expr> '||' <expr>\n```\n\n也就是说，expr 是由 symbol、两个 symbol 相等、两个 symbol 不等以及 expr 的赋值、非、与或运算构成。symbol 分为两类，一类是由菜单入口配置选项定义的非常数 symbol，另一类是作为 expr 组成部分的常数 symbol。\n\n举个例子就明白了，如下 expr 表示依赖条件是 ARCH_R8A73A4 被选中以及 SH_DMAE 未被选中，才能出现 SHDMA_R8A73A4。\n\n```kconfig\nconfig SHDMA_R8A73A4\n    bool y\n    depends on ARCH_R8A73A4 && SH_DMAE == n\n```\n\n帮助信息的格式为，完全靠文本缩进识别结束。\n\n```kconfig\nhelp\n# 或者：---help---\n    开始\n    …\n    结束\n```\n\n2. 菜单结构\n\n配置选项在菜单树结构的位置可以由两种方法决定。\n\n第一种如下，所有处于 menu 和 endmenu 之间的配置选项都会成为 Network device support 的子菜单，而且，所有子菜单（config）选项都会继承父菜单（menu）的依赖关系。菜单 Network device support 对 NET 的依赖会加到配置选项 NETDEVICES 的依赖列表中。\n\n```kconfig\nmenu \"Network device support\"\n    depends on NET\nconfig NETDEVICES\n\n\t...\n\nendmenu\n```\n\n> 注：menu 后面跟的 Network device support 项仅仅是 1 个菜单，没有对应真实的配置选项，也不具备 3 种不同的状态。这是 menu 和 config 的区别。\n\n另一种方式是通过分析依赖关系生成菜单结构。如果菜单项在一定程度上依赖于前面的选项，它就能成为该选项的子菜单。例如这里，config MODVERSIONS 直接依赖于 MODULES，只有当 MODULES 不为 n 的时候，MODVERSIONS 才可见。\n\n```kconfig\nconfig MODULES\n    bool \"Enable loadable module support\"\nconfig MODVERSIONS\n    bool \"Set version information on all module symbols\"\n    depends on MODULES\n```\n\n更详细的编写细节，请参考内核文档 Documentation 目录内的 kbuild 子目录下的 Kconfig-language.rst 和 Makefiles.rst 文件。\n\n# 内核模块\n\n## 内核模块简介\n\n如果我们自己想要在 Linux 内核当中添加功能，有两种方法。\n\n1. 一是把所有需要的功能都编译到 Linux 内核中。但这样会导致生成的内核很大，并且如果需要增加或删除功能，将不得不重新编译内核。\n2. 二是让内核提供某种方法，使得原本的内核并不需要包含所有的功能，而是在需要使用的时候，将代码动态的加载到内核当中。\n\n巧了，Linux 内核就提供了第二种方法，这样的机制成为模块。模块具有如下特点：\n\n1. 模块本身不被编译入内核映像，从而控制了内核的大小。\n2. 模块一旦被加载，它就和内核中的其他部分完全一样。\n\n以一个最简单的 Hello World 模块为例，展示一下内核模块编程的大致认识：\n\n本程序通过内核的 Makefile + Kbuild 系统编译以后会生成 hello.ko 目标文件，通过 insmod 命令加载到内核中，rmmod 命令卸载。\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n\n\nMODULE_VERSION(\"v1.0.0\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"DavidingPlus\");\nMODULE_DESCRIPTION(\"A Simple Hello World Module\");\n\n\nstatic int __init hello_init(void)\n{\n    // 内核模块中用于输出的函数是内核空间的 printk() 而不是用户空间的 printf()，printk() 的用法和 printf() 基本相似，但前者可定义输出级别。\n    printk(KERN_INFO \"hello: Hello World\\n\");\n\n\n    return 0;\n}\n\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"hello: Goodbye World\\n\");\n}\n\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\n在 Linux 中，可通过 lsmod 命令查看系统中已加载的所有模块以及之间的依赖关系：\n\n```bash\nsudo lsmod\n\n# Module                  Size  Used by\n# ufs                    81920  0\n# qnx4                   16384  0\n# hfsplus               110592  0\n# hfs                    61440  0\n# minix                  40960  0\n# ntfs                  106496  0\n# msdos                  20480  0\n```\n\nlsmod 实际上是读取并分析 `/proc/modules` 文件，对应结果如下：\n\n```bash\ncat /proc/modules\n\n# ufs 81920 0 - Live 0x0000000000000000\n# qnx4 16384 0 - Live 0x0000000000000000\n# hfsplus 110592 0 - Live 0x0000000000000000\n# hfs 61440 0 - Live 0x0000000000000000\n# minix 40960 0 - Live 0x0000000000000000\n# ntfs 106496 0 - Live 0x0000000000000000\n# msdos 20480 0 - Live 0x0000000000000000\n```\n\n内核中已加载模块的信息也保存在 `/sys/modules/` 目录下。加载上面的 hello.ko 以后，内核中将包含 /sys/modules/hello/ 目录，该目录的结构图如下：\n\n```markdown\n.\n├── coresize\n├── holders\n├── initsize\n├── initstate\n├── notes\n│   ├── .note.gnu.build-id\n│   └── .note.Linux\n├── refcnt\n├── sections\n│   ├── .exit.data\n│   ├── .exit.text\n│   ├── .gnu.linkonce.this_module\n│   ├── .init.data\n│   ├── .init.text\n│   ├── .note.gnu.build-id\n│   ├── .note.Linux\n│   ├── .rodata.str1.1\n│   ├── .strtab\n│   ├── .symtab\n│   └── .text\n├── srcversion\n├── taint\n├── uevent\n└── version\n\n3 directories, 21 files\n```\n\n除了 insmod 命令，还有一个 modprobe 命令。与 insmod 不同的是，**modprobe 在加载某模块时，会同时加载该模块所依赖的其他模块**。使用 modprobe 命令加载的模块若以 `modprobe -r filename` 的方式卸载，将同时卸载其依赖的模块。\n\n模块之间的依赖关系存放在根文件系统的 `/lib/modules/<kernel-version>/modules.dep` 文件中，实际上是在整体编译内核的时候由 depmod 工具生成的，它的格式非常简单：\n\n```markdown\nkernel/arch/x86/events/intel/intel-cstate.ko:\nkernel/arch/x86/events/rapl.ko:\nkernel/arch/x86/kernel/cpu/mce/mce-inject.ko:\nkernel/arch/x86/kernel/msr.ko:\nkernel/arch/x86/kernel/cpuid.ko:\nkernel/arch/x86/crypto/twofish-x86_64.ko: kernel/crypto/twofish_common.ko\nkernel/arch/x86/crypto/twofish-x86_64-3way.ko: kernel/arch/x86/crypto/twofish-x86_64.ko kernel/crypto/twofish_common.ko\nkernel/arch/x86/crypto/twofish-avx-x86_64.ko: kernel/crypto/crypto_simd.ko kernel/crypto/cryptd.ko kernel/arch/x86/crypto/twofish-x86_64-3way.ko kernel/arch/x86/crypto/twofish-x86_64.ko kernel/crypto/twofish_common.ko\n...\n```\n\n使用 modinfo 命令可以获得模块的信息，包括模块作者、模块的说明、模块所支持的参数以及 vermagic：\n\n```bash\nmodinfo hello.ko\n\n# filename:       /home/lzx0626/DavidingPlus/linux-kernel-learning/build/linux/x86_64/debug/hello.ko\n# description:    A Simple Hello World Module\n# author:         DavidingPlus\n# license:        Dual BSD/GPL\n# version:        1.0.0\n# srcversion:     533BB7E5866E52F63B9ACCB\n# depends:\n# retpoline:      Y\n# name:           hello\n# vermagic:       5.15.167 SMP mod_unload modversions\n```\n\n## 内核模块程序结构\n\n一个 Linux 内核模块主要由以下几部分组成：\n\n1. 模块加载函数\n\n当通过 insmod 或 modprobe 命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相关初始化工作。\n\n2. 模块卸载函数\n\n当通过 rmmod 命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功能。\n\n3. 模块许可证声明\n\n许可证（LICENSE）声明描述内核模块的许可权限，如果不声明，模块被加载时，将收到内核被污染（Kernel Tainted）的警告。\n\n4. 模块参数（可选）\n\n模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。\n\n5. 模块导出符号（可选）\n\n内核模块可以导出的符号（symbol，对应于函数或变量）。若导出，其他模块则可以使用本模块中的变量或函数。\n\n6. 模块作者等信息声明（可选）\n\n## 模块加载函数\n\nLinux 内核模块加载函数一般以 __init 标识声明，例如：\n\n```c\nstatic int __init initialization_function(void)\n{\n\t...\n}\n\n\nmodule_init(initialization_function);\n```\n\n模块加载函数 initialization_function(void) 在内核被加载的时候，通过宏 module_init 进行调用。加载函数应该有一个返回值 int，成功返回 0，失败返回一个错误编码。该错误编码是一个接近 0 的负数，在 `<linux/errno.h>` 中定义，如 -ENODEV、-ENOMEM 等。强烈建议返回有意义的错误编码宏，因为这样用户可以通过 perror() 的方法将其转化为有意义的字符串。\n\n在 Linux 内核程序代码中，可以通过 request_module(const char*fmt, …) 函数加载内核模块，例如：\n\n```c\nrequest_module(module_name);\n```\n\n在 Linux 内核中，所有标识为 __init 的函数如果直接编译进入内核，那么会成为内核镜像的一部分，连接的时候会放在 .init.text 区段内。\n\n```c\n#define __init\t\t__section(\".init.text\") __cold  __latent_entropy __noinitretpoline __nocfi\n```\n\n所有的 `__init` 函数在区段 .initcall.init 中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些 `__init` 函数，并在初始化完成后，释放 `__init` 区段（包括 .init.text、.initcall.init 等）的内存。\n\n除了函数以外，数据也可以被定义为 __initdata。表示**只是初始化阶段需要的数据，初始化完成以后，内核会自动释放他们占用的内存。**\n\n## 模块卸载函数\n\nLinux 内核卸载加载函数一般以 __exit 标识声明，例如：\n\n```c\nstatic void __exit cleanup_function(void)\n{\n    ...\n}\n\n\nmodule_exit(cleanup_function);\n```\n\n模块卸载函数在模块卸载的时候执行，不返回任何值。通过宏 module_exit 的形式指定调用。通常来讲会完成模块加载函数相反的功能。\n\n与模块加载函数对应的，可以使用 `__exit` 修饰模块卸载函数。如果告诉内核相关模块直接被编译进内核。这种情况下 `__exit` 修饰的模块卸载函数会被忽略，不会被链进最后的镜像。因为既然都编译进内核，被内置了，那么肯定不会被卸载了。\n\n另外对应的，数据也可以被定义为 __exitdata。\n\n## 模块参数\n\n可以使用宏 `module_param(参数名，参数类型，参数读/写权限)` 为模块指定一个参数。宏函数参数分别对应模块参数名、参数类型以及参数读/写权限。\n\n在装载内核模块的时候，可以向模块提供参数，格式如下。多个参数传递用空格隔开。如果不传递参数，将使用模块内定义的默认值。如果模块被内置，则无法被 insmod ，但是 bootloader 可以通过在 bootargs 里设置`“模块名.参数名=值”`的形式给该内置模块传递参数。\n\n```bash\nsudo insmod <param_name>=<param_value>\n```\n\n参数类型可以是 byte、short、ushort、int、uint、long、ulong、charp（字符指针）、bool 或 invbool（bool 的反）。模块在编译的时候会检查传入变量的类型和传入的类型是否一致。\n\n另外，模块也可以拥有参数数组，通过宏 `module_param_array(数组名，数组类型，数组长，参 数读/写权限)` 指定，用法类似。\n\n> 传递数组参数的时候需要注意一下格式。参数之间用 `,` 隔开，并且不加大括号，参数之间没有空格，例如传递一个 int 数组：\n>\n> ```bash\n> sudo insmod hello.ko array=1,2,3,4\n> ```\n\n如果指定了模块参数，**并且参数读/写权限不为 0**，在装入模块以后会在 `/sys/modules/<module_name>` 下出现 parameters 子目录，用于记录内核模块的参数。\n\n```markdown\n.\n...\n├── parameters\n│   ├── helloExitParam\n│   └── helloInitParam\n...\n```\n\n例如这里，就记录了内核模块参数 helloInitParam 和 helloExitParam，使用 cat 命令能够得到他们分别记录的值，其中数组的表示方法和上面提到的一致。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241105100931281.png\" alt=\"image-20241105100931281\" style=\"zoom:75%;\" />\n\n实例程序如下：\n\n```c\n#include <linux/init.h>\n#include <linux/module.h>\n\n\nMODULE_VERSION(\"1.0.0\");\nMODULE_LICENSE(\"Dual BSD/GPL\");\nMODULE_AUTHOR(\"DavidingPlus\");\nMODULE_DESCRIPTION(\"A Simple Hello World Module\");\n\n\nstatic int helloInitData __initdata = -114514;\n\nstatic const char *helloExitData __exitdata = \"foo\";\n\nstatic char *helloInitParam = \"gee\";\nmodule_param(helloInitParam, charp, S_IRUGO);\n\nstatic int helloExitParam[2] = {-10086, 10086};\nint helloExitParamSize = sizeof(helloExitParam) / sizeof(int);\nmodule_param_array(helloExitParam, int, &helloExitParamSize, S_IRUGO);\n\n\nstatic int __init hello_init(void)\n{\n    printk(KERN_INFO \"hello: Hello World %d %s\\n\", helloInitData, helloInitParam);\n\n\n    return 0;\n}\n\nstatic void __exit hello_exit(void)\n{\n    printk(KERN_INFO \"hello: Goodbye World %s %d %d\\n\", helloExitData, helloExitParam[0], helloExitParam[1]);\n}\n\n\nmodule_init(hello_init);\nmodule_exit(hello_exit);\n```\n\n## 导出符号\n\n导出符号即内核可以将函数导出被其他模块使用。Linux 中 `/proc/kallsyms` 文件对应内核符号表，记录了符号以及符号所在的内存地址。\n\n使用如下宏函数导出符号到内核符号表中：\n\n```c\nEXPORT_SYMBOL(符号名);\n\n// EXPORT_SYMBOL_GPL() 只适用于包含 GPL 许可权的模块。\nEXPORT_SYMBOL_GPL(符号名);\n```\n\n例如这里导出函数 add() 和 sub()：\n\n```c\n...\n\nint add(int a, int b) { return a + b; }\n\nint sub(int a, int b) { return a - b; }\n\n\nEXPORT_SYMBOL(add);\nEXPORT_SYMBOL(sub);\n\n...\n```\n\n装载好内核模块以后查看 /proc/kallsyms 文件能得到对应的符号信息：\n\n```bash\ncat /proc/kallsyms | grep hello\n\n# ...\n# 0000000000000000 r __kstrtab_add        [hello]\n# 0000000000000000 r __kstrtabns_add      [hello]\n# 0000000000000000 r __ksymtab_add        [hello]\n# 0000000000000000 r __kstrtab_sub        [hello]\n# 0000000000000000 r __kstrtabns_sub      [hello]\n# 0000000000000000 r __ksymtab_sub        [hello]\n# 0000000000000000 T add  [hello]\n# 0000000000000000 T sub  [hello]\n```\n\n## 模块声明与描述\n\n在 Linux 内核模块中，我们可以用 MODULE_AUTHOR、MODULE_DESCRIPTION、MODULE_VERSION、MODULE_DEVICE_TABLE、MODULE_ALIAS 分别声明模块的作者、描述、版本、设备表和别名，例如：\n\n```c\nMODULE_AUTHOR(author);\nMODULE_DESCRIPTION(description);\nMODULE_VERSION(version_string);\nMODULE_DEVICE_TABLE(table_info);\nMODULE_ALIAS(alternate_name);\n```\n\n## 模块的使用计数\n\nLinux 2.4 内核中，模块自身通过 MOD_INC_USE_COUNT、MOD_DEC_USE_COUNT 宏来管理自己被使用的计数。\n\nLinux 2.6 以后的内核提供了模块计数管理接口 try_module_get(&module) 和 module_put(&module)，从而取代 Linux 2.4 内核中的模块使用计数管理宏。模块的使用计数一般不必由模块自身管理，而且模块计数管理还考虑了 SMP 与 PREEMPT 机制的影响。\n\n```c\n// 用于增加模块使用计数。若返回为0，表示调用失败，希望使用的模块没有被加载或正在被卸载中。\nint try_module_get(struct module *module);\n\n// 用于减少模块使用计数。\nvoid module_put(struct module *module);\n```\n\nLinux 2.6 以后的内核为不同类型的设备定义了 struct module *owner 域，用来指向管理此设备的模块。当开始使用某个设备时，内核使用 try_module_get(dev->owner) 去增加管理此设备的 owner 模块的使用计数；当不再使用此设备时，内核使用 module_put(dev->owner) 减少对管理此设备的管理模块的使用计数。这样，当设备在使用时，管理此设备的模块将不能被卸载。只有当设备不再被使用时，模块才允许被卸载。\n\n# 文件系统与设备文件\n\nLinux 之下一些皆文件，并且由于字符设备和块设备都良好的体现了一切皆文件的思想，因此 Linux 文件系统与设备文件的基础知识就非常重要了。\n\n## 文件操作\n\n### 系统调用\n\n1. 创建\n\n```c\nint creat(const char *pathname, mode_t mode);\n```\n\n参数 mode 代表创建文件的权限，和 umask 一起共同决定文件的最终权限（`mode & ~umask`）。umask 代表文件创建的时候需要去掉的一些权限，让最终的权限合理一些。可通过 umake() 系统调用改变：\n\n```c\nmode_t umask(mode_t mask);\n```\n\numask() 函数将 umask 设置为 newmask，然后返回旧的 umask，它只影响读、写和执行权限。\n\n2. 打开\n\n```c\nint open(const char *pathname, int flags);\nint open(const char *pathname, int flags, mode_t mode);\n```\n\nflags 参数表示文件的打开标志，可以是如下的一个或者几个的组合：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241105144109024.png\" alt=\"image-20241105144109024\" style=\"zoom:80%;\" />\n\n其中，O_RDONLY、O_WRONLY、O_RDWR 三者是互斥的，只可选择其一。\n\n如果使用了 O_CREAT 标志，还需要提供第三个参数 mode 来表示新文件的权限，同前面的 creat() 函数。mode 权限如下图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241105144550547.png\" alt=\"image-20241105144550547\" style=\"zoom:70%;\" />\n\n关于权限 mode，举个例子就明白了。Linux 下的文件权限是一个八进制数，例如 0777。3 个 7 分别表示对不同的用户（所有者，组成员，其他用户的权限）的权限。每一个都是 3 位 ，第一位表示读 R，第二位表示写 W，第三位表示可执行 X，7 对应就是 111 全有。\n\n最后，open() 函数返回一个进程唯一的文件描述符，对文件的所有操作都通过该文件描述符实现。\n\n3. 读写\n\n打开文件获得文件描述符以后，通过 read() 和 write() 函数对文件进行读写。\n\n```c\nssize_t read(int fd, void *buf, size_t count);\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n参数 buf 为存放读取数据的内存的地址指针，count 为长度。\n\n函数 read() 从文件描述符 fd 所指定的文件中读取 count 个字节到 buf 所指向的内存中，返回值为实际读取的字节数。\n\n函数 write() 实现把 count 个字节从 buf 中写到文件描述符 fd 所指向的文件中，返回值为实际写入的字节数。\n\n4. 定位\n\n对于随机文件，可以指定随机位置进行读写，使用 lseek() 函数：\n\n```c\noff_t lseek(int fd, off_t offset, int whence);\n```\n\nlseek() 函数将文件指针相对 whence 位置移动 offset 个字节，操作成功后返回文件指针现在的位置。\n\n参数 whence 可使用如下值。\n\n- SEEK_SET：相对文件开头。\n- SEEK_CUR：相对文件读写指针的当前位置。\n- SEEK_END：相对文件末尾。\n\n当然 lseek() 的 offset 可以取负值，表示往前移动。一般可以通过此函数获得文件的大小：\n\n```c\nint size = lseek(fd, 0, SEEK_END);\n```\n\n5. 关闭\n\n有始有终，在结束对文件的操作以后，需要关闭文件，释放文件描述符。通过 close() 实现：\n\n```c\nint close(int fd);\n```\n\n6. 实例 Demo\n\n编写一个程序，在当前目录下创建用户可读写文件 hello.txt，在其中写入\"He\\nllo, software weekly.\"，关闭该文件。再次打开该文件，读取其中的内容并输出在屏幕上。最后删除该文件。\n\n比较简单，cpp 程序如下：\n\n```cpp\n// 使用系统调用。\n#include <iostream>\n#include <cstring>\n\n#include <unistd.h>\n#include <fcntl.h>\n\n\n// 故意搞一个不能一次读完的数组。\n#define MAX_SIZE 10\n\n\nint main()\n{\n    const char *filePath = \"hello.txt\";\n    const char *writeStr = \"He\\nllo, software weekly.\";\n\n\n    int fd = open(filePath, O_RDWR | O_CREAT | O_TRUNC, 0755);\n    if (-1 == fd)\n    {\n        perror(\"open\");\n\n\n        return -1;\n    }\n\n    write(fd, writeStr, strlen(writeStr));\n\n    close(fd);\n\n\n    int fd2 = open(filePath, O_RDONLY);\n    if (-1 == fd2)\n    {\n        perror(\"open\");\n\n\n        return -1;\n    }\n\n\n    char readStr[MAX_SIZE] = {0};\n    ssize_t len = 0;\n\n    // 为保证读完，需循环读取。\n    while (true)\n    {\n        bzero(readStr, sizeof(readStr));\n\n        len = read(fd2, readStr, sizeof(readStr) - 1);\n        if (-1 == len)\n        {\n            perror(\"read\");\n\n\n            return -1;\n        }\n\n        std::cout << readStr;\n\n        if (0 == len) break;\n    }\n\n    std::cout << std::endl;\n\n    close(fd2);\n\n\n    unlink(filePath);\n\n\n    return 0;\n}\n```\n\n正确的输出预期应该如图：\n\n![image-20241105160211266](https://cdn.davidingplus.cn/images/2025/02/01/image-20241105160211266.png)\n\n### 标准 C 库函数\n\n1. 创建和打开\n\n这两个操作都使用 fopen() 函数：\n\n```c\nFILE *fopen(const char *pathname, const char *mode);\n```\n\nmode 表示打开模式，支持的模式如图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230907152718910.png\" alt=\"image-20230907152718910\" style=\"zoom: 80%;\" />\n\n其中，b 用于区分二进制文件和文本文件，这一点在 DOS、Windows 系统中是有区分的，但 Linux 不区分二进制文件和文本文件。\n\n2. 读写\n\n标准 C 库的 IO 函数会自动在用户层分配缓冲区，而系统调用不具有用户层缓冲区。二者都具有内核层的缓冲区。其中缓冲分为三种，**全缓冲、行缓冲和无缓冲**。\n\n罗列部分 API 接口如下：\n\n```cpp\nint fgetc(FILE *stream);\nint fputc(int c, FILE *stream);\nchar *fgets(char *s, int size, FILE *stream);\nint fputs(const char *s, FILE *stream);\nint fprintf(FILE *stream, const char *format, ...);\nint fscanf(FILE *stream, const char *format, ...);\nsize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);\nsize_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);\n```\n\n另外，标准 C 库函数还提供了读写过程的定位能力，包括：\n\n```cpp\nint fgetpos(FILE *stream, fpos_t *pos);\nint fsetpos(FILE *stream, const fpos_t *pos);\nint fseek(FILE *stream, long offset, int whence);\n```\n\n更多的具体用法和细节请参考另一篇博客 [https://blog.davidingplus.cn/posts/9e44c3b9.html](https://blog.davidingplus.cn/posts/9e44c3b9.html) 的第五章。\n\n3. 关闭\n\n同上，是非常简单的操作。\n\n```cpp\nint fclose(FILE *stream);\n```\n\n4. 实例 Demo\n\n将前面的实例 Demo 换成标准 C 库的实现方法如下：\n\n```cpp\n// 使用标准 C 库函数。\n#include <iostream>\n#include <cstring>\n\n\n#define MAX_SIZE 10\n\n\nint main()\n{\n    const char *filePath = \"hello.txt\";\n    const char *writeStr = \"He\\nllo, software weekly.\";\n\n    FILE *file = fopen(filePath, \"w\");\n    if (!file)\n    {\n        perror(\"fopen\");\n\n\n        return -1;\n    }\n\n    fputs(writeStr, file);\n\n    fclose(file);\n\n\n    FILE *file2 = fopen(filePath, \"r\");\n    if (!file2)\n    {\n        perror(\"fopen\");\n\n\n        return -1;\n    }\n\n    char readStr[MAX_SIZE] = {0};\n\n    while (true)\n    {\n        bzero(readStr, sizeof(readStr));\n\n        fgets(readStr, sizeof(readStr) - 1, file2);\n        if (ferror(file2))\n        {\n            perror(\"fgets\");\n\n\n            return -1;\n        }\n\n        std::cout << readStr;\n\n        if (feof(file2)) break;\n    }\n\n    std::cout << std::endl;\n\n    fclose(file2);\n\n\n    remove(filePath);\n\n\n    return 0;\n}\n```\n\n同样输出和上面一样的结果。\n\n## 文件系统\n\n### 目录结构\n\n进入 Linux 根目录（即 `/`，Linux 文件系统的入口，也是处于最高一级的目录），运行 `ls -la` 命令，包含以下目录：\n\n1. /bin\n\n包含基本命令，如 ls、cp、mkdir 等，这个目录中的文件都是可执行的。\n\n2. /sbin\n\n包含系统命令，如 modprobe、hwclock、ifconfig 等，大多是涉及系统管理的命令，这个目录中的文件都是可执行的。\n\n3. /dev\n\n设备文件存储目录，应用程序通过对这些文件的读写和控制以访问实际的设备。\n\n4. /etc\n\n系统配置文件的所在地，一些服务器的配置文件也在这里，如用户账号及密码配置文件。busybox 的启动脚本也存放在该目录。\n\n5. /lib\n\n系统库文件存放目录等。\n\n6. /mnt\n\n这个目录一般是用于存放挂载储存设备的挂载目录，比如含有 cdrom 等目录。可以参看 /etc/fstab 的定义。有时我们可以让系统开机自动挂载文件系统，并把挂载点放在这里。\n\n7. /opt\n\nopt 是可选的意思，有些软件包会被安装在这里。\n\n8. /proc\n\n操作系统运行时，进程及内核信息（比如 CPU、硬盘分区、内存信息等）存放在这里。/proc 目录为伪文件系统 proc 的挂载目录，proc 并不是真正的文件系统，它存在于内存之中。\n\n9. /tmp\n\n用户运行程序的时候，有时会产生临时文件，/tmp 用来存放临时文件。\n\n10. /usr\n\n这个是系统存放程序的目录，比如用户命令、用户库等。\n\n11. /var\n\nvar 表示的是变化的意思，这个目录的内容经常变动，如 /var/log/ 目录被用来存放系统日志。\n\n12. /sys\n\nLinux 2.6 以后的内核所支持的 sysfs 文件系统被映射在此目录上。Linux 设备驱动模型中的总线、驱动 和设备都可以在 sysfs 文件系统中找到对应的节点。当内核检测到在系统中出现了新设备后，内核会在 sysfs 文件系统中为该新设备生成一项新的记录。\n\n### 文件系统与设备驱动\n\n如图所示是 Linux 下虚拟文件系统、磁盘/Flash 文件系统及一般的设备文件与设备驱动程序之间的关系。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241106093412285.png\" alt=\"image-20241106093412285\" style=\"zoom: 70%;\" />\n\n应用程序和 VFS 之间的接口是系统调用，而 VFS 与文件系统以及设备文件之间的接口是 file_operations 结构体成员函数，这个结构体包含对文件进行打开、关闭、读写、控制的一系列成员函数。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241106093650313.png\" alt=\"image-20241106093650313\" style=\"zoom:75%;\" />\n\n字符设备的上层没有类似于磁盘 ext2 等文件系统，所以字符设备的 file_operations 成员函数就直接由设备驱动提供了，并且是字符驱动的核心部分。\n\n块设备有两种访问方法，一种方法是不通过文件系统直接访问裸设备，在 Linux 内核实现了统一的 def_blk_fops 这一 file_operations，它的源代码位于 fs/block_dev.c，所以当我们运行类似于 `dd if=/dev/sdb1of=sdb1.img` 的命令把整个 /dev/sdb1 裸分区复制到 sdb1.img 的时候，内核走的是 def_blk_fops 这个 file_operations；另外一种方法是通过文件系统来访问块设备，file_operations 的实现则位于文件系统内，文件系统会把针对文件的读写转换为针对块设备原始扇区的读写。ext2、fat、Btrfs 等文件系统中会实现针对 VFS 的 file_operations 成员函数，设备驱动层将看不到 file_operations 的存在。\n\n#### file 结构体\n\nfile 结构体代表一个打开的文件。系统中每个打开的文件在内核空间都会对应一个 struct file。它由内核在打开文件的时候创建，并传递给文件上进行操作的任何函数，在文件的所有实例关闭以后，内核会释放这个数据结构。一般将 struct file 的指针命名为 file 或者 filp。\n\n在内核 5.15 版本中如下定义：\n\n```c\nstruct file {\n\tunion {\n\t\tstruct llist_node\tfu_llist;\n\t\tstruct rcu_head \tfu_rcuhead;\n\t} f_u;\n\tstruct path\t\tf_path;\n\tstruct inode\t\t*f_inode;\t/* cached value */\n\tconst struct file_operations\t*f_op; // 和文件关联的操作\n\n\t/*\n\t * Protects f_ep, f_flags.\n\t * Must not be taken from IRQ context.\n\t */\n\tspinlock_t\t\tf_lock;\n\tenum rw_hint\t\tf_write_hint;\n\tatomic_long_t\t\tf_count;\n\tunsigned int \t\tf_flags; // 文件标志，如 O_RDONLY、O_NONBLOCK、O_SYNC 等\n\tfmode_t\t\t\tf_mode; // 文件读/写模式，如 FMODE_READ、FMODE_WRITE 等\n\tstruct mutex\t\tf_pos_lock;\n\tloff_t\t\t\tf_pos; // 当前读写位置\n\tstruct fown_struct\tf_owner;\n\tconst struct cred\t*f_cred;\n\tstruct file_ra_state\tf_ra;\n\n\tu64\t\t\tf_version;\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*f_security;\n#endif\n\t/* needed for tty driver, and maybe others */\n\tvoid\t\t\t*private_data; // 文件私有数据\n\n#ifdef CONFIG_EPOLL\n\t/* Used by fs/eventpoll.c to link all the hooks to this file */\n\tstruct hlist_head\t*f_ep;\n#endif /* #ifdef CONFIG_EPOLL */\n\tstruct address_space\t*f_mapping;\n\terrseq_t\t\tf_wb_err;\n\terrseq_t\t\tf_sb_err; /* for syncfs */\n} __randomize_layout\n  __attribute__((aligned(4)));\t/* lest something weird decides that 2 is OK */\n```\n\n文件读/写模式 f_mode、标志 f_flags 都是设备驱动关心的内容。私有数据指针 private_data 在设备驱动中被广泛应用，大多被指向设备驱动自定义以用于描述设备的结构体。\n\n#### inode 结构体\n\ninode 结构体包含文件访问权限、属主、组、大小、生成时间、访问时间、最后修改时间等信息。它是 Linux 管理文件系统的最基本单位，也是文件系统连接任何子目录、文件的桥梁。定义如下：\n\n```c\nstruct inode {\n\tumode_t\t\t\ti_mode; // inode 的权限\n\tunsigned short\t\ti_opflags;\n\tkuid_t\t\t\ti_uid; // inode 所有者 id\n\tkgid_t\t\t\ti_gid; // inode 所属的群组 id\n\tunsigned int\t\ti_flags;\n\n#ifdef CONFIG_FS_POSIX_ACL\n\tstruct posix_acl\t*i_acl;\n\tstruct posix_acl\t*i_default_acl;\n#endif\n\n\tconst struct inode_operations\t*i_op;\n\tstruct super_block\t*i_sb;\n\tstruct address_space\t*i_mapping;\n\n#ifdef CONFIG_SECURITY\n\tvoid\t\t\t*i_security;\n#endif\n\n\t/* Stat data, not accessed from path walking */\n\tunsigned long\t\ti_ino;\n\t/*\n\t * Filesystems may only read i_nlink directly.  They shall use the\n\t * following functions for modification:\n\t *\n\t *    (set|clear|inc|drop)_nlink\n\t *    inode_(inc|dec)_link_count\n\t */\n\tunion {\n\t\tconst unsigned int i_nlink;\n\t\tunsigned int __i_nlink;\n\t};\n\tdev_t\t\t\ti_rdev; // 若是设备文件，此字段会记录设备的设备号\n\tloff_t\t\t\ti_size; // inode 代表的文件大小\n\tstruct timespec64\ti_atime; // inode 最近一次的存取时间\n\tstruct timespec64\ti_mtime; // inode 最近一次的修改时间\n\tstruct timespec64\ti_ctime; // inode 的产生时间\n\tspinlock_t\t\ti_lock;\t/* i_blocks, i_bytes, maybe i_size */\n\tunsigned short          i_bytes;\n\tu8\t\t\ti_blkbits;\n\tu8\t\t\ti_write_hint;\n\tblkcnt_t\t\ti_blocks; // inode 使用的 block 数，一个 block 为 512 个字节\n\n#ifdef __NEED_I_SIZE_ORDERED\n\tseqcount_t\t\ti_size_seqcount;\n#endif\n\n\t/* Misc */\n\tunsigned long\t\ti_state;\n\tstruct rw_semaphore\ti_rwsem;\n\n\tunsigned long\t\tdirtied_when;\t/* jiffies of first dirtying */\n\tunsigned long\t\tdirtied_time_when;\n\n\tstruct hlist_node\ti_hash;\n\tstruct list_head\ti_io_list;\t/* backing dev IO list */\n#ifdef CONFIG_CGROUP_WRITEBACK\n\tstruct bdi_writeback\t*i_wb;\t\t/* the associated cgroup wb */\n\n\t/* foreign inode detection, see wbc_detach_inode() */\n\tint\t\t\ti_wb_frn_winner;\n\tu16\t\t\ti_wb_frn_avg_time;\n\tu16\t\t\ti_wb_frn_history;\n#endif\n\tstruct list_head\ti_lru;\t\t/* inode LRU list */\n\tstruct list_head\ti_sb_list;\n\tstruct list_head\ti_wb_list;\t/* backing dev writeback list */\n\tunion {\n\t\tstruct hlist_head\ti_dentry;\n\t\tstruct rcu_head\t\ti_rcu;\n\t};\n\tatomic64_t\t\ti_version;\n\tatomic64_t\t\ti_sequence; /* see futex */\n\tatomic_t\t\ti_count;\n\tatomic_t\t\ti_dio_count;\n\tatomic_t\t\ti_writecount;\n#if defined(CONFIG_IMA) || defined(CONFIG_FILE_LOCKING)\n\tatomic_t\t\ti_readcount; /* struct files open RO */\n#endif\n\tunion {\n\t\tconst struct file_operations\t*i_fop;\t/* former ->i_op->default_file_ops */\n\t\tvoid (*free_inode)(struct inode *);\n\t};\n\tstruct file_lock_context\t*i_flctx;\n\tstruct address_space\ti_data;\n\tstruct list_head\ti_devices;\n\tunion {\n\t\tstruct pipe_inode_info\t*i_pipe;\n\t\tstruct cdev\t\t*i_cdev; // 若是字符设备，对应其 cdev 结构体指针\n\t\tchar\t\t\t*i_link;\n\t\tunsigned\t\ti_dir_seq;\n\t};\n\n\t__u32\t\t\ti_generation;\n\n#ifdef CONFIG_FSNOTIFY\n\t__u32\t\t\ti_fsnotify_mask; /* all events this inode cares about */\n\tstruct fsnotify_mark_connector __rcu\t*i_fsnotify_marks;\n#endif\n\n#ifdef CONFIG_FS_ENCRYPTION\n\tstruct fscrypt_info\t*i_crypt_info;\n#endif\n\n#ifdef CONFIG_FS_VERITY\n\tstruct fsverity_info\t*i_verity_info;\n#endif\n\n\tvoid\t\t\t*i_private; /* fs or device private pointer */\n} __randomize_layout;\n```\n\n对于表示设备文件的 inode 结构，i_rdev 字段包含设备编号。**Linux 内核设备编号分为主设备编号和次设备编号。设备号用 dev_t 类型表示，实际上是 `unsigned int`。前者为 dev_t 的高 12 位，后者为 dev_t 的低 20 位。**使用如下函数从 inode 获得主设备号和次设备号：\n\n```c\nstatic inline unsigned iminor(const struct inode *inode)\n{\n\treturn MINOR(inode->i_rdev);\n}\n\nstatic inline unsigned imajor(const struct inode *inode)\n{\n\treturn MAJOR(inode->i_rdev);\n}\n```\n\n查看 /proc/devices 文件可以看到当前系统注册的设备，第一列为主设备号，第二列为设备名，例如：\n\n```bash\ncat /proc/devices\n\n# Character devices:\n#   1 mem\n#   4 /dev/vc/0\n#   4 tty\n#   4 ttyS\n#   5 /dev/tty\n#   5 /dev/console\n#   5 /dev/ptmx\n#   5 ttyprintk\n#   7 vcs\n#  10 misc\n#  13 input\n#  21 sg\n#  29 fb\n#  89 i2c\n# 108 ppp\n# 128 ptm\n# 136 pts\n# 180 usb\n# 189 usb_device\n# 202 cpu/msr\n# 204 ttyMAX\n# 226 drm\n# 241 aux\n# 242 cec\n# 243 hidraw\n# 244 vfio\n# 245 bsg\n# 246 watchdog\n# 247 ptp\n# 248 pps\n# 249 rtc\n# 250 dax\n# 251 dimmctl\n# 252 ndctl\n# 253 tpm\n# 254 gpiochip\n\n# Block devices:\n#   7 loop\n#   8 sd\n#   9 md\n#  11 sr\n#  65 sd\n#  66 sd\n#  67 sd\n#  68 sd\n#  69 sd\n#  70 sd\n#  71 sd\n# 128 sd\n# 129 sd\n# 130 sd\n# 131 sd\n# 132 sd\n# 133 sd\n# 134 sd\n# 135 sd\n# 253 device-mapper\n# 254 mdp\n# 259 blkext\n```\n\n查看 /dev 目录可以查看系统中在上述注册的设备上建立的设备文件。一个注册的设备可以有多个设备文件，日期前面的两列分别对应主设备号和次设备号。\n\n主设备号是与驱动对应的概念。同一类设备一般使用相同的主设备号，不同类设备一般使用不同的主设备号（但是不排除在同一主设备号下包含有一定差异的设备）。**因为同一驱动可支持多个同类设备，因此用次设备号来描述使用该驱动的设备的序号**。序号一般从 0 开始。\n\n## devfs\n\ndevfs（设备文件系统）是 Linux 内核 2.4 版本引入的，使得设备驱动程序能自主地管理自己的设备文件。具体来讲，有以下优点：\n\n1. 可以通过程序在设备初始化的时候在 /dev 目录下创建设备文件，卸载设备的时候删除。\n2. 设备驱动程序可以指定设备名、所有者和权限位，用户空间程序仍可以修改所有者和权限位。\n3. 不再需要为设备驱动程序分配主设备号以及处理次设备号，在程序中可以直接给 register_chrdev() 传递 0 主设备号以获得可用的主设备号，并在 devfs_register() 中指定次设备号。\n\n## udev\n\n### udev 和 devfs 的区别\n\n尽管 devfs 有很多的优点，但在 Linus 2.6 中，devfs 被认为是过时的方法，并最终被抛弃了，udev 取代了它。\n\nLinux 设计中强调的一个基本观点是机制和策略的分离。机制是做某样事情的固定步骤、方法，而策略就是每一个步骤所采取的不同方式。机制是相对固定的，而每个步骤采用的策略是不固定、灵活的。在 Linux 内核中，应该实现机制而非策略。\n\n例如，Linux 提供 API 可以让人把线程的优先级调高或者调低，或者调整调度策略为 SCHED_FIFO 什么的，但是 Linux 内核本身却不管谁高谁低。提供 API 属于机制，谁高谁低这属于策略，所以应该是应用程序自己去告诉内核要高或低，而内核不管这些杂事。属于策略的东西应该被移到用户空间中，谁爱给哪个设备创建什么名字或者想做更多的处理，谁自己去设定。内核只管把这些信息告诉用户就行了。这就是位于内核空间的 devfs 应该被位于用户空间的 udev 取代的原因，应该 devfs 管了一些它实际上不该管的事情。\n\nudev 是 Linux 系统下的一套**设备管理系统**，能在 /dev 目录下动态创建和删除设备节点。\n\n**udev 完全在用户态工作。它利用设备加入或移除时内核所发送的热插拔事件（Hotplug Event）来工作。在热插拔时，设备的详细信息会由内核通过 netlink 套接字发送出来，发出的事情叫 uevent。**udev 的设备命名策略、权限控制和事件处理都是在用户态下完成的，它利用从内核收到的信息来进行创建设备文件节点等工作。对于冷插拔的设备，在开机的时候就已经存在，在 udev 启动之前就已被插入。Linux 下提供了 sysfs 下面一个 uevent 节点。可以往该节点写一个 add，导致内核重新发送 netlink，之后 udev 就可以收到冷插拔的 netlink 消息了。\n\nudev 和 devfs 另一个区别在于：采用 devfs，当一个并不存在的 /dev 节点**被打开**的时候，devfs 能自动加载对应的驱动，而 udev 则不这么做。udev 的设计者认为 Linux 应该在设备**被发现**的时候加载驱动模块，而不是当它被访问的时候。系统中所有的设备都应该产生热插拔事件并加载恰当的驱动，而不是在设备被打开的时候。udev 能注意到这点并且为它创建对应的设备节点。\n\n### sysfs 文件系统与 Linux 设备模型\n\nLinux 2.6 以后的内核引入了 sysfs 文件系统，是一个虚拟文件系统，可以产生**包括所有系统硬件的层级视图**，与**提供进程和状态信息**的 proc 非常类似。\n\nsysfs 把连接在系统上的设备和总线组织成为一个分级的文件。它们可以由用户空间存取，向用户空间导出内核数据结构以及它们的属性。sysfs 的一个目的就是展示设备驱动模型中各组件的层次关系。\n\n其目录结构类似如下。block 目录包含所有的块设备；devices 目录包含系统所有的设备，并根据设备挂载的总线类型组织成层次结构；bus 目录包含系统中所有的总线类型；class 目录包含系统中的设备类型，如网卡设备、声卡设备、输入设备等。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241107100021716.png\" alt=\"image-20241107100021716\" style=\"zoom:75%;\" />\n\n在 /sys/bus/ 的 pci 等子目录下，又会再分出 drivers 和 devices 目录，而 devices 目录中的文件是对 /sys/devices/ 目录中文件的符号链接。同样地，/sys/class/ 目录下也包含许多对 /sys/devices/ 下文件的链接。Linux 设备模型与设备、驱动、总线和类的现实状况是直接对应的，如图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241107100653352.png\" alt=\"image-20241107100653352\" style=\"zoom:70%;\" />\n\n**在 Linux 内核中，使用 bus_type、device_driver、device 来描述总线、驱动和设备。**其定义如下：\n\n```c\n// include/linux/device/bus.h\nstruct bus_type {\n\tconst char\t\t*name;\n\tconst char\t\t*dev_name;\n\tstruct device\t\t*dev_root;\n\tconst struct attribute_group **bus_groups;\n\tconst struct attribute_group **dev_groups;\n\tconst struct attribute_group **drv_groups;\n\n\tint (*match)(struct device *dev, struct device_driver *drv);\n\tint (*uevent)(struct device *dev, struct kobj_uevent_env *env);\n\tint (*probe)(struct device *dev);\n\tvoid (*sync_state)(struct device *dev);\n\tvoid (*remove)(struct device *dev);\n\tvoid (*shutdown)(struct device *dev);\n\n\tint (*online)(struct device *dev);\n\tint (*offline)(struct device *dev);\n\n\tint (*suspend)(struct device *dev, pm_message_t state);\n\tint (*resume)(struct device *dev);\n\n\tint (*num_vf)(struct device *dev);\n\n\tint (*dma_configure)(struct device *dev);\n\n\tconst struct dev_pm_ops *pm;\n\n\tconst struct iommu_ops *iommu_ops;\n\n\tstruct subsys_private *p;\n\tstruct lock_class_key lock_key;\n\n\tbool need_parent_lock;\n};\n\n// include/linux/device/driver.h\nstruct device_driver {\n\tconst char\t\t*name;\n\tstruct bus_type\t\t*bus;\n\n\tstruct module\t\t*owner;\n\tconst char\t\t*mod_name;\t/* used for built-in modules */\n\n\tbool suppress_bind_attrs;\t/* disables bind/unbind via sysfs */\n\tenum probe_type probe_type;\n\n\tconst struct of_device_id\t*of_match_table;\n\tconst struct acpi_device_id\t*acpi_match_table;\n\n\tint (*probe) (struct device *dev);\n\tvoid (*sync_state)(struct device *dev);\n\tint (*remove) (struct device *dev);\n\tvoid (*shutdown) (struct device *dev);\n\tint (*suspend) (struct device *dev, pm_message_t state);\n\tint (*resume) (struct device *dev);\n\tconst struct attribute_group **groups;\n\tconst struct attribute_group **dev_groups;\n\n\tconst struct dev_pm_ops *pm;\n\tvoid (*coredump) (struct device *dev);\n\n\tstruct driver_private *p;\n};\n\n// include/linux/device.h\nstruct device {\n\tstruct kobject kobj;\n\tstruct device\t\t*parent;\n\n\tstruct device_private\t*p;\n\n\tconst char\t\t*init_name; /* initial name of the device */\n\tconst struct device_type *type;\n\n\tstruct bus_type\t*bus;\t\t/* type of bus device is on */\n\tstruct device_driver *driver;\t/* which driver has allocated this\n\t\t\t\t\t   device */\n\tvoid\t\t*platform_data;\t/* Platform specific data, device\n\t\t\t\t\t   core doesn't touch it */\n\tvoid\t\t*driver_data;\t/* Driver data, set and get with\n\t\t\t\t\t   dev_set_drvdata/dev_get_drvdata */\n#ifdef CONFIG_PROVE_LOCKING\n\tstruct mutex\t\tlockdep_mutex;\n#endif\n\tstruct mutex\t\tmutex;\t/* mutex to synchronize calls to\n\t\t\t\t\t * its driver.\n\t\t\t\t\t */\n\n\tstruct dev_links_info\tlinks;\n\tstruct dev_pm_info\tpower;\n\tstruct dev_pm_domain\t*pm_domain;\n\n#ifdef CONFIG_ENERGY_MODEL\n\tstruct em_perf_domain\t*em_pd;\n#endif\n\n#ifdef CONFIG_GENERIC_MSI_IRQ_DOMAIN\n\tstruct irq_domain\t*msi_domain;\n#endif\n#ifdef CONFIG_PINCTRL\n\tstruct dev_pin_info\t*pins;\n#endif\n#ifdef CONFIG_GENERIC_MSI_IRQ\n\traw_spinlock_t\t\tmsi_lock;\n\tstruct list_head\tmsi_list;\n#endif\n#ifdef CONFIG_DMA_OPS\n\tconst struct dma_map_ops *dma_ops;\n#endif\n\tu64\t\t*dma_mask;\t/* dma mask (if dma'able device) */\n\tu64\t\tcoherent_dma_mask;/* Like dma_mask, but for\n\t\t\t\t\t     alloc_coherent mappings as\n\t\t\t\t\t     not all hardware supports\n\t\t\t\t\t     64 bit addresses for consistent\n\t\t\t\t\t     allocations such descriptors. */\n\tu64\t\tbus_dma_limit;\t/* upstream dma constraint */\n\tconst struct bus_dma_region *dma_range_map;\n\n\tstruct device_dma_parameters *dma_parms;\n\n\tstruct list_head\tdma_pools;\t/* dma pools (if dma'ble) */\n\n#ifdef CONFIG_DMA_DECLARE_COHERENT\n\tstruct dma_coherent_mem\t*dma_mem; /* internal for coherent mem\n\t\t\t\t\t     override */\n#endif\n#ifdef CONFIG_DMA_CMA\n\tstruct cma *cma_area;\t\t/* contiguous memory area for dma\n\t\t\t\t\t   allocations */\n#endif\n#ifdef CONFIG_SWIOTLB\n\tstruct io_tlb_mem *dma_io_tlb_mem;\n#endif\n\t/* arch specific additions */\n\tstruct dev_archdata\tarchdata;\n\n\tstruct device_node\t*of_node; /* associated device tree node */\n\tstruct fwnode_handle\t*fwnode; /* firmware device node */\n\n#ifdef CONFIG_NUMA\n\tint\t\tnuma_node;\t/* NUMA node this device is close to */\n#endif\n\tdev_t\t\t\tdevt;\t/* dev_t, creates the sysfs \"dev\" */\n\tu32\t\t\tid;\t/* device instance */\n\n\tspinlock_t\t\tdevres_lock;\n\tstruct list_head\tdevres_head;\n\n\tstruct class\t\t*class;\n\tconst struct attribute_group **groups;\t/* optional groups */\n\n\tvoid\t(*release)(struct device *dev);\n\tstruct iommu_group\t*iommu_group;\n\tstruct dev_iommu\t*iommu;\n\n\tenum device_removable\tremovable;\n\n\tbool\t\t\toffline_disabled:1;\n\tbool\t\t\toffline:1;\n\tbool\t\t\tof_node_reused:1;\n\tbool\t\t\tstate_synced:1;\n\tbool\t\t\tcan_match:1;\n#if defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_DEVICE) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU) || \\\n    defined(CONFIG_ARCH_HAS_SYNC_DMA_FOR_CPU_ALL)\n\tbool\t\t\tdma_coherent:1;\n#endif\n#ifdef CONFIG_DMA_OPS_BYPASS\n\tbool\t\t\tdma_ops_bypass : 1;\n#endif\n};\n```\n\ndevice_driver 和 device 分别表示驱动和设备，而这两者都必须依附于一种总线，因此都包含 bus_type 指针。**在 Linux 内核中，设备和驱动是分开注册的。**注册 1 个设备的时候，并不需要驱动已经存在。而 1 个驱动被注册的时候，也不需要对应的设备已经被注册。设备和驱动各自涌向内核，而每个设备和驱动涌入内核的时候，都会去寻找自己的另一半。而正是 bus_type 的 match() 成员函数将两者捆绑在一起。一旦匹配成功，xxx_driver 的 probe() 函数就会被执行（xxx 是总线名， 如 platform、pci、i2c、spi、usb 等）。\n\n**总线、驱动和设备最终都会落实为 sysfs 中的 1 个目录。**它们实际上都可以认为是 kobject 的派生类，**kobject 可看作是所有总线、设备和驱动的抽象基类**，1个 kobject 对应 sysfs 中的 1 个目录。\n\n另外，**总线、驱动和设备中的各个 attribute 直接落实为 sysfs 中的一个文件。**结构体中含有 show() 和 store() 两个函数，分别用于读写对应的 sysfs 文件。这几个 attribute 相关结构体的定义如下：\n\n```c\nstruct attribute {\n\tconst char\t\t*name;\n\tumode_t\t\t\tmode;\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\tbool\t\t\tignore_lockdep:1;\n\tstruct lock_class_key\t*key;\n\tstruct lock_class_key\tskey;\n#endif\n};\n\nstruct bus_attribute {\n\tstruct attribute\tattr;\n\tssize_t (*show)(struct bus_type *bus, char *buf);\n\tssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);\n};\n\nstruct driver_attribute {\n\tstruct attribute attr;\n\tssize_t (*show)(struct device_driver *driver, char *buf);\n\tssize_t (*store)(struct device_driver *driver, const char *buf,\n\t\t\t size_t count);\n};\n\nstruct device_attribute {\n\tstruct attribute\tattr;\n\tssize_t (*show)(struct device *dev, struct device_attribute *attr,\n\t\t\tchar *buf);\n\tssize_t (*store)(struct device *dev, struct device_attribute *attr,\n\t\t\t const char *buf, size_t count);\n};\n```\n\n### udev 的组成\n\nudev 目前和 systemd 项目已合并，地址：[https://github.com/systemd/systemd](https://github.com/systemd/systemd)\n\nudev 在用户空间中执行，动态建立/删除设备文件，允许每个人都不用关心主/次设备号而提供 Linux 标准规范的名称，并且可以根据需要固定名称。\n\nudev 的工作机制如下：\n\n1. udev 以守护进程的方式运行，工作于用户空间，它监听一个 netlink socket。\n2. 当有新设备接入或设备从系统中移除时，系统内核通过这个 socket 向 udev 发送 uevent。\n3. udev 获取内核发送的信息，进行规则的匹配。匹配的事物包括 SUBSYSTEM、ACTION、atttribute、内核提供的名称（通过 KERNEL =）以及其他的环境变量。\n\n### udev 规则文件\n\nudev 规则文件以行为单位，一行代表一个规则。每个规则分为一个或多个匹配部分和赋值部分。二者带有不同的关键字。\n\n匹配关键字包括：ACTION（行为）、KERNEL（匹配内核设备名）、BUS（匹配总线类型）、SUBSYSTEM（匹配子系统名）、ATTR（属性）等。\n\n赋值关键字包括：NAME（创建的设备文件名）、SYMLINK（符号创建链接名）、OWNER（设置设备的所有者）、GROUP（设置设备的组）、IMPORT（调用外部程序）、MODE（节点访问权限）等。\n\n举个例子看一下：\n\n```markdown\nSUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\" *\", ATTR{address}==\"08:00:27:35:be:ff\", ATTR{dev_id}==\"0x0\", ATTR{type}==\"1\", KERNEL==\"eth*\", NAME=\"eth1\"\n```\n\n匹配部分包括 SUBSYSTEM、ACTION、ATTR、KERNEL 等，赋值部分有一项，是 NAME。这个规则的意思是：当系统中出现的新硬件属于 net 子系统范畴，系统对该硬件采取的动作是 add 这个硬件，且这个硬件的 address 属性信息等于 \"08:00:27:35:be:ff\"，dev_id 属性等于 \"0x0\" 、type 属性为 1 等。此时，对这个硬件在 udev 层实行的动作是创建 /dev/eth1。\n\n# 字符设备驱动\n\nLinux 系统将设备分为3类：**字符设备、块设备、网络设备**。架构图如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20250201002122884.png\" alt=\"image-20250201002122884\" style=\"zoom:70%;\" />\n\n**字符设备是指只能一个字节一个字节读写的设备，不能随机读取设备内存中的某一数据，读取数据需要按照先后数据。**字符设备是面向流的设备。常见的字符设备有鼠标、键盘、串口、控制台和 LED 设备等。\n\n**块设备是指可以从设备的任意位置读取一定长度数据的设备。**块设备包括硬盘、磁盘、U 盘和 SD 卡等。\n\n每一个字符设备或块设备都在 /dev 目录下对应一个设备文件。Linux 用户程序通过设备文件（或称设备节点）来使用驱动程序操作字符设备和块设备。\n\n## 字符设备驱动结构\n\n### cdev 结构体\n\n在 Linux 内核中，**使用 cdev 结构体描述字符设备**，定义如下：\n\n```c\nstruct cdev {\n\tstruct kobject kobj; // 内嵌的 kobject 对象\n\tstruct module *owner; // 所属模块\n\tconst struct file_operations *ops; // 文件操作结构体\n\tstruct list_head list;\n\tdev_t dev; // 设备号\n\tunsigned int count;\n} __randomize_layout;\n```\n\ncdev 的一个重要成员 file_operations 定义了字符设备驱动需要提供给虚拟文件系统 VFS 的接口函数。\n\ncdev 的成员 dev_t 定义了设备号，包含主设备号和次设备号。dev_t 实际上就是 unsigned int，32 位。其中高 12 位是主设备号，低 20  位是次设备号。如下是设备号相关的宏函数：\n\n```c\nMAJOR(dev) // 通过 dev_t 获得主设备号。\nMINOR(dev) // 通过 dev_t 获得次设备号。\nMKDEV(major, minor) // 通过主设备号和次设备号构造 dev_t 的设备号。\n```\n\nLinux 提供了一系列函数用于操作 cdev 结构体：\n\n```c\n// 初始化 cdev 成员，并建立 cdev 和 file_operations 的连接。\nvoid cdev_init(struct cdev *, const struct file_operations *);\n\n// 用于动态申请 cdev 内存。\nstruct cdev *cdev_alloc(void);\n\nvoid cdev_put(struct cdev *p);\n\n// 向系统中添加 cdev，完成字符设备的注册。一般用于模块加载函数中。\nint cdev_add(struct cdev *, dev_t, unsigned);\n\n// 从系统中删除 cdev，完成字符设备的注销。一般用于模块卸载函数中。\nvoid cdev_del(struct cdev *);\n```\n\n### 分配和释放设备号\n\n在调用 cdev_add() 函数注册字符设备之前，需要先向系统申请设备号，即主设备号和次设备号。调用函数 register_chrdev_region() 或 alloc_chrdev_region() 实现：\n\n```c\n// 用于已知起始设备的设备号的情况。\nint register_chrdev_region(dev_t from, unsigned count, const char *name);\n\n// 用于起始设备号未知，向系统动态申请设备号的情况。\nint alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *name);\n```\n\n注意函数中的参数 count，结合设备号的主设备号和次设备号的概念。我们发现整个流程中，首先需要向内核申请 dev_t 类型的设备号，包括主设备号和次设备号。同一类型的字符设备可共同同一个主设备号，而次设备号不同。因此，这样在添加注册字符设备的时候可以同时注册几个字符设备，这也是 count 的含义。\n\n相应的，在初始释放的时候，除了需要从系统中删除 cdev 完成字符设备的注销，还需要释放原先申请的设备号，函数如下：\n\n```c\nvoid unregister_chrdev_region(dev_t from, unsigned count);\n```\n\n### file_operations 结构体\n\nfile_operations 结构体中的成员函数是字符设备驱动程序设计的主体内容，这些函数实际会在应用程序进行 Linux 的 open()、write()、read()、close() 等系统调用时最终被内核调用。其定义如下：\n\n```c\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *kiocb, bool spin);\n\tint (*iterate) (struct file *, struct dir_context *);\n\tint (*iterate_shared) (struct file *, struct dir_context *);\n\t__poll_t (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tunsigned long mmap_supported_flags;\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\t\t\tloff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n} __randomize_layout;\n```\n\n下面对其进行简要分析：\n\n1. llseek()：修改一个文件的当前读写位置，并返回新位置偏移指针。出错时函数返回负值。\n2. read()：**从设备读取数据。**成功时返回读取的字节数，出错时返回一个负值。与用户空间的 `ssize_t read(int fd, void *buf, size_t count);` 函数对应。返回 0 代表 EOF（end of file）。\n3. write()：**向设备发送数据。**成功时返回写入的字节数，出错时返回一个负值。如果未实现此函数，用户进行 write() 系统调用时，将得到 -EINVAL 返回值。与用户空间的 `ssize_t write(int fd, const void *buf, size_t count);` 函数对应。同样返回 0 代表 EOF（end of file）。\n4. unlocked_ioctl()：提供**设备相关控制命令的实现**（既不是读操作，也不是写操作）。成功时返回一个非负值。与用户空间的 `int fcntl(int fd, int cmd, ... /* arg */ );` 函数对应。\n5. mmap()：**将设备内存映射到进程的虚拟地址空间中。**如果未实现此函数，用户进行 mmap() 系统调用的时，会获得 -ENODEV 返回值。这个函数对于帧缓冲等设备特别有意义，帧缓冲被映射到用户空间后，应用程序可以直接访问它而无须在内核和应用间进行内存复制。与用户空间的 `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);` 函数对应。\n6. open()、release()：当用户空间调用 open() 打开设备文件时，设备驱动的 open() 函数最终被调用。驱动程序可以不实现这个函数，在这种情况下，设备的打开操作永远成功。与 open() 函数对应的是 release() 函数，也对应用户空间的 close() 函数。\n7. poll()：一般用于询问设备是否可被非阻塞地立即读写。当询问的条件未触发时，用户空间进行 select() 和 poll() 系统调用将引起进程的阻塞。\n8. aio_read()、aio_write()：对与文件描述符对应的设备进行**异步**读、写操作。设备实现这两个函数后，用户空间可以对该设备文件描述符执行 SYS_io_setup、SYS_io_submit、SYS_io_getevents、SYS_io_destroy 等系统调用进行读写。\n\n### 字符设备驱动的组成\n\n#### 模块加载与卸载函数\n\n在模块加载函数中应实现设备号的申请和 cdev 的注册，在模块卸载函数中应实现 cdev 的注销和设备号的释放。\n\n类似的模板如下：\n\n```c\n// 设备结构体\nstruct xxx_dev_t\n{\n    struct cdev cdev;\n\n    ...\n} xxx_dev;\n\n\n// 设备驱动模块加载函数\nstatic int __init xxx_init(void)\n{\n    ... \n\n    cdev_init(&xxx_dev.cdev, &xxx_fops); // 初始化cdev\n    xxx_dev.cdev.owner = THIS_MODULE;\n\n    // 获取字符设备号\n    if (xxx_major)\n    {\n        register_chrdev_region(xxx_dev_no, 1, DEV_NAME);\n    }\n    else\n    {\n        alloc_chrdev_region(&xxx_dev_no, 0, 1, DEV_NAME);\n    }\n\n    res = cdev_add(&xxx_dev.cdev, xxx_dev_no, 1); // 注册设备\n\n    ...\n}\n\n// 设备驱动模块卸载函数\nstatic void __exit xxx_exit(void)\n{\n    unregister_chrdev_region(xxx_dev_no, 1); // 释放占用的设备号\n    cdev_del(&xxx_dev.cdev);                 // 注销设备\n\n    ...\n}\n```\n\n#### file_operations 结构体的成员函数\n\nfile_operations 结构体的成员函数是字符设备驱动与内核虚拟文件系统的接口，是用户空间对 Linux 系统调用最终的落实者。\n\n```c\n// 读设备\n// filp：文件结构体指针，buf：用户空间内存地址；count：要读的字节数；f_pos：读的位置相对文件开头的偏移。\nssize_t xxx_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)\n{\n    ...\n\n    copy_to_user(buf, ..., ...);\n\n    ...\n}\n\n// 写设备\n// filp：文件结构体指针，buf：用户空间内存地址；count：要写的字节数；f_pos：读的位置相对文件开头的偏移。\nssize_t xxx_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)\n{\n    ...\n\n    copy_from_user(..., buf, ...);\n\n    ...\n}\n\n// ioctl 函数\n// cmd 参数为事先定义的 I/O 控制命令，而 arg 为对应于该命令的参数。\n// 例如对于串行设备，若 SET_BAUDRATE 是一道设置波特率的命令，arg 就应该是波特率值。\nlong xxx_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)\n{\n    ...\n\n    switch (cmd)\n    {\n        case XXX_CMD1:\n        {\n            ...\n\n            break;\n        }\n        case XXX_CMD2:\n        {\n            ...\n\n            break;\n        }\n        default:\n            // 不能支持的命令\n            return -ENOTTY;\n    }\n\n\n    return 0;\n}\n```\n\n由于**用户空间不能直接访问内核空间的内存**，因此借助了函数 copy_from_user() 完成用户空间缓冲区到内核空间的复制，以及 copy_to_user() 完成内核空间到用户空间缓冲区的复制。这里注意一下语义，以读为例，注意主谓。xxx_read() 的含义是从内核空间中读，因此用户空间是接收的对象，因此使用 copy_to_user()，对应的也是用户空间的系统调用 read()。整个流程就是内核读 I/O（先不考虑用户区缓冲的事情），然后 copy_to_user() 到用户空间的内存。\n\n这两个函数的声明如下：\n\n```c\n// 两个函数均返回不能被复制的字节数。如果成功，返回 0；如果失败，返回负值。\nint copy_from_user(void *to, const void __user volatile *from, unsigned long n);\nint copy_to_user(void __user volatile *to, const void *from, unsigned long n);\n```\n\n如果复制的内存是简单类型，如 char、int、long 等，可以使用简化的 put_user() 和 get_user()：\n\n```c\nint val; // 内核空间整型变量。\n\nget_user(val, (int *) arg); // 用户 -> 内核，arg 是用户空间的地址。\n\nput_user(val, (int *) arg); // 内核 -> 用户，arg 是用户空间的地址。\n```\n\n上面读和写函数的参数中 `__user` 是一个宏，代表后面的指针属于用户空间，用于假注释和提醒的作用。类似于模块加载函数的 `__init` 和模块卸载函数的 `__exit`。\n\n内核空间虽然可以访问用户空间的数据，但是在访问之前，一般需要**检查合法性**。使用 `access_ok(addr, size)` 接口，以保证传入的数据的确属于用户空间。**此宏函数返回非 0 表示检查通过。**\n\n另外，`put_user()` 和 `__put_user()` 的区别在于，`put_user()` 的实现中调用了 `__put_user()`，并且已经手动做了 `access_ok()` 的检查。所以一般推荐使用 `put_user()` 和 `get_user()`。同时，也存在 `copy_from_user()` 和 `__copy_from_user()`，区别同上。`copy_to_user()` 同理。但是，总的来讲为了保险，内核空间在访问用户空间数据以前，我们的驱动程序中应再次手动检查一下合法性。\n\n在字符设备驱动中，需要定义一个 file_operations 的实例，将我们自己实现的函数注册给这些成员：\n\n```c\n// xxx_fops 在 cdev_init(&xxx_dev.cdev, &xxx_fops) 时同字符设备建立起连接。\nstruct file_operations xxx_fops = {\n    .owner = THIS_MODULE,\n    .read = xxx_read,\n    .write = xxx_write,\n    .unlocked_ioctl = xxx_ioctl,\n\n    ...\n};\n```\n\n下面是字符设备驱动的结构示意图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241108100951215.png\" alt=\"image-20241108100951215\" style=\"zoom:75%;\" />\n\n## globalmem 虚拟设备\n\n参考文章：[https://blog.csdn.net/weixin_45264425/article/details/130718602](https://blog.csdn.net/weixin_45264425/article/details/130718602)\n\n自己实现的版本：[https://github.com/DavidingPlus/linux-kernel-learning/tree/globalmem](https://github.com/DavidingPlus/linux-kernel-learning/tree/globalmem)\n\n## 小结\n\n字符设备是 3 大类设备（字符设备、块设备和网络设备）中的一类。其驱动程序完成的主要工作是初始化、添加和删除 cdev 结构体，申请和释放设备号，以及填充 file_operations 结构体中的操作函数。实现 file_operations 结构体中的 read()、write() 和 ioctl() 等函数是驱动设计的主体工作。\n\n# 设备驱动中的并发控制\n\nLinux 设备驱动中必须要解决的问题是多个进程对共享资源的并发访问，并发会导致竞态，所以需要格外小心。\n\n## 并发与竞态\n\n并发（Concurrency）是指多个执行单元同时、并行被执行。而并发的执行单元对共享资源（硬件资源和软件上的全局变量、静态变量等）的访问则很容易导致竞态（Race Conditions）。\n\n在 Linux 内核中，竞态主要分为以下几种情况：\n\n1. 对称多处理器（SMP）的多个 CPU\n\nSMP 是一种紧耦合、共享存储的系统模型，特点是多个 CPU 使用共同的系统总线，因此可访问共同的外设和储存器。体系结构如图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241111152648934.png\" alt=\"image-20241111152648934\" style=\"zoom:80%;\" />\n\n在 SMP 的情形下，两个核(例如 CPU 0 和 CPU 1)的竞态可能发生在 CPU 0 和 CPU 1 的进程之间，CPU 0 的进程和 CPU 1 的中断之间，CPU 0 和 CPU 1 的中断之间等，如图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241111152902140.png\" alt=\"image-20241111152902140\" style=\"zoom:80%;\" />\n\n2. 单 CPU 内进程与抢占它的进程\n\nLinux 2.6 以后的内核支持内核抢占调度，一个进程在内核执行的时候可能耗完了自己的时间片（timeslice），也可能被另一个高优先级进程打断，进程与抢占它的进程访问共享资源的情况类似于 SMP 的多个 CPU。\n\n3. 中断（硬中断、软中断、Tasklet、底半部）与进程之间\n\n中断可以打断正在执行的进程，如果中断服务程序访问进程正在访问的资源，竞态也会发生。\n\n另外，中断也有可能被新的更高优先级的中断打断，故多个中断之间本身也可能引起并发而导致竞态。但 Linux 2.6 之后，就取消了中断的嵌套。老版本的内核可以在申请中断时，设置标记 IRQF_DISABLED 以避免中断嵌套。但由于新内核直接就默认不嵌套中断，这个标记反而变得无用了。\n\n上述三种并发的发生，除了 SMP 是真正的并行之外，其他的都是单核上的“宏观并行、微观串行”，但遇到的问题和 SMP 类似。CPU 核内和核间的并发示意图如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241111153624322.png\" alt=\"image-20241111153624322\" style=\"zoom:75%;\" />\n\n解决竞态问题的途径是保证对共享资源的互斥访问。互斥访问是指一个执行单元在访问共享资源的时候，其他的执行单元被禁止访问。\n\n访问共享资源的代码区域称为临界区（Critical Sections），临界区需要被以某种互斥机制加以保护。中断屏蔽、原子操作、自旋锁、信号量、互斥体等都是 Linux 设备驱动中可采用的互斥途径。\n\n## 编译乱序和执行乱序\n\n编译乱序是编译器的行为，执行乱序则是处理器运行时的行为。\n\n关于编译乱序，现代的高性能编译器在目标码优化上都具备对指令进行乱序优化的能力。编译器可以对访存的指令进行乱序，减少逻辑上不必要的访存，以及尽量提高 Cache 命中率和 CPU 的 Load/Store 单元的工作效率。因此在打开编译器优化（例如 gcc 的 -O2 优化）以后，看到生成的汇编码并没有严格按照代码的逻辑顺序，这是正常的。\n\n更多编译乱序的细节，参考：[https://chonghw.github.io/blog/2016/09/05/compilermemoryreorder/](https://chonghw.github.io/blog/2016/09/05/compilermemoryreorder/)\n\n关于执行乱序，是指即便编译的二进制指令的按照顺序排放，在处理器上执行时，后排放的指令还是可能先执行完，这是处理器的“乱序执行（Out-of-Order Execution）”策略。高级的 CPU 可以根据自己缓存的组织特性，将访存指令重新排序执行。连续地址的访问可能会先执行，因为这样缓存命中率高。有的还允许访存的非阻塞，即如果前面一条访存指令因为缓存不命中，造成长延时的存储访问时，后面的访存指令可以先执行，以便从缓存中取数。因此即使是从汇编上看顺序正确的指令，其执行的顺序也是不可预知的。\n\n更多执行乱序的细节，参考：[https://chonghw.github.io/blog/2016/09/19/sourcecontrol/](https://chonghw.github.io/blog/2016/09/19/sourcecontrol/)\n\n## 中断屏蔽\n\n在单 CPU 范围内避免竞态的一种简单而有效的方法是在进入临界区之前屏蔽系统的中断，但在驱动编程中不值得推荐，驱动通常需要考虑跨平台特点而不假定自己在单核上运行。CPU 一般都具备屏蔽中断和打开中断的功能，这项功能可以保证正在执行的内核执行路径不被中断处理程序所抢占，防止某些竞态条件的发生。具体而言，**中断屏蔽将使得中断与进程之间的并发不再发生**，并且由于 Linux 内核的进程调度等操作都依赖中断来实现，内核抢占进程之间的并发也得以避免了。\n\n**中断屏蔽的底层原理是让 CPU 本身不响应中断**，使用方法如下：\n\n```c\nlocal_irq_disable(); // 屏蔽中断\n. . .\ncritical section // 临界区操作\n. . .\nlocal_irq_enable(); // 开中断\n```\n\n长时间屏蔽中断是很危险的，这有可能造成数据丢失乃至系统崩溃等后果。因此在屏蔽了中断之后，当前的内核执行路径应当尽快地执行完毕临界区的代码。\n\nlocal_irq_disable() 和 local_irq_enable() 都只能禁止和激活本 CPU 内的中断，故并不能解决 SMP 多 CPU 引发的竞态。因此，单独使用中断屏蔽不是值得推荐的方法，它适合与自旋锁结合起来使用。\n\n与 local_irq_disable() 不同的是，local_irq_save(flags) 除了进行禁止中断的操作以外，还保存目前 CPU 的中断位信息，local_irq_restore(flags) 进行的是与 local_irq_save(flags) 相反的操作。如果只是想禁止中断的底半部，应使用 local_bh_disable()，激活对应 local_bh_enable()。\n\n## 原子操作\n\n**原子操作可以保证对一个整型数据的修改是排他性的。**Linux 内核提供了一系列函数实现，分为两类，分别针对**位和整型变量**进行原子操作。它们都依赖于底层 CPU 的原子操作，与 CPU 架构密切相关。\n\n### 整型原子操作\n\n1. 设置原子变量的值\n\n```c\nvoid atomic_set(atomic_t *v, int i); // 设置原子变量的值为 i\natomic_t v = ATOMIC_INIT(0); // 定义原子变量 v 并初始化为 0\n```\n\n2. 获取原子变量的值\n\n```c\natomic_read(const atomic_t *v); // 返回原子变量的值\n```\n\n3. 原子变量加/减\n\n```c\nvoid atomic_add(int i, atomic_t *v); // 原子变量增加 i\nvoid atomic_sub(int i, atomic_t *v); // 原子变量减少 i\n```\n\n4. 原子变量自增/自减\n\n```c\nvoid atomic_inc(atomic_t *v); // 原子变量增加 1\nvoid atomic_dec(atomic_t *v); // 原子变量减少 1\n```\n\n5. 操作并测试\n\n这些操作对原子变量执行自增、自减和减操作后（**注意没有加**），测试其是否为 0，为 0 返回 true，否则返回 false。\n\n```c\nint atomic_inc_and_test(atomic_t *v);\nint atomic_dec_and_test(atomic_t *v);\nint atomic_sub_and_test(int i, atomic_t *v);\n```\n\n6. 操作并返回\n\n这些操作对原子变量进行加/减和自增/自减操作，并返回新的值。\n\n```c\nint atomic_add_return(int i, atomic_t *v);\nint atomic_sub_return(int i, atomic_t *v);\nint atomic_inc_return(atomic_t *v);\nint atomic_dec_return(atomic_t *v);\n```\n\n### 位原子操作\n\n1. 设置位\n\n```c\nvoid set_bit(int nr, void *addr); // 设置 addr 地址的第 nr 位，所谓设置位即是将位写为 1\n```\n\n2. 清除位\n\n```c\nvoid clear_bit(int nr, void *addr); // 清除 addr 地址的第 nr 位，所谓设置位即是将位写为 0\n```\n\n3. 改变位\n\n```c\nvoid change_bit(int nr, void *addr); // 将 addr 地址的第 nr 位进行反置\n```\n\n4. 测试位\n\n```c\nint change_bit(int nr, void *addr); // 返回 addr 地址的第 nr 位\n```\n\n5. 测试并操作位\n\n`test_and_xxx_bit(int nr，void *addr)` 操作等同于执行 `test_bit(int nr，void *addr)` 后再执行 `xxx_bit(int nr，void *addr)`。\n\n```c\nint test_and_set_bit(int nr, void *addr);\nint test_and_clear_bit(int nr, void *addr);\nint test_and_change_bit(int nr, void *addr);\n```\n\n## 自旋锁\n\n### 自旋锁的使用\n\n自旋锁是一种典型的对临界资源进行互斥访问的手段。为了获得一个自旋锁，进程需先进行一个原子操作，该操作测试并设置（Test-And-Set）一个内存变量。由于是原子操作，所以在该操作完成之前其他执行单元不可能访问这个内存变量。如果测试结果表明锁已经空闲，则程序获得这个自旋锁并继续执行；如果测试结果表明锁仍被占用，程序将在一个小的循环内重复这个“测试并设置”操作，即进行所谓的“自旋”，通俗地说就是“在原地打转”。当自旋锁的持有者通过重置该变量释放这个自旋锁后，某个等待的“测试并设置”操作 向其调用者报告锁已释放。\n\n自旋锁可理解为一个变量。它把一个临界区标记为“我当前在运行，请稍等一会”或“我当前不在运行，可以被使用”。如果 A 执行单元首先进入例程，它将持有自旋锁。当 B 执行单元试图进入同一个例程时，将获知自旋锁已被持有，需等到 A 执行单元释放后才能进入。\n\n自旋锁涉及的操作如下：\n\n1. 定义自旋锁\n\n```c\nspinlock_t lock;\n```\n\n2. 初始化自旋锁\n\n```c\nspin_lock_init(lock); // 动态初始化自旋锁 lock。\n```\n\n3. 获得自旋锁\n\n```c\nspin_lock(lock); // 用于获得自旋锁 lock。如果能够立即获得，就马上返回。否则，将在那里自旋，直到该自旋锁的保持者释放。\nspin_trylock(lock); // 尝试获得自旋锁 lock。如果能立即获得，它获得锁并返回 true，否则立即返回 false，实际上不再“在原地打转”。\n```\n\n4. 释放自旋锁\n\n```c\nspin_unlock(lock); // 释放自旋锁 lock，它与 spin_trylock() 或 spin_lock() 配对使用。\n```\n\n自旋锁主要针对 SMP 或单 CPU（内核可抢占）的情况，对于单 CPU（内核不支持抢占）的系统，自旋锁退化为空操作，因为此时不会出现并发和竞态。在单 CPU（内核可抢占）的系统中，自旋锁持有期间中内核的抢占将被禁止。由于单 CPU（内核可抢占）系统的行为实际上很类似于 SMP 系统，因此在这样的单 CPU 系统中使用自旋锁仍十分必要。另外，在多核 SMP 的情况下，任何一个核拿到了自旋锁，**该核**上的抢占调度也暂时禁止了，但是**没有禁止**另外一个核的抢占调度。\n\n尽管自旋锁可以保证临界区不受别的 CPU 和本 CPU 内的抢占进程打扰，但是得到锁的代码路径在执行临界区的时候，还可能受到中断和底半部（BH）的影响。因此，需要用到自旋锁的衍生。这些函数为自旋锁的使用提供保障，防止突如其来的中断对系统造成伤害。\n\n```c\nspin_lock_irq() = spin_lock() + local_irq_disable()\nspin_unlock_irq() = spin_unlock() + local_irq_enable()\nspin_lock_irqsave() = spin_lock() + local_irq_save()\nspin_unlock_irqrestore() = spin_unlock() + local_irq_restore()\nspin_lock_bh() = spin_lock() + local_bh_disable()\nspin_unlock_bh() = spin_unlock() + local_bh_enable()\n```\n\n在多核编程的时候，如果进程和中断可能访问同一片临界资源，**我们一般需要在进程上下文中调用 spin_lock_irqsave() 和 spin_unlock_irqrestore()，在中断上下文中调用 spin_lock() 和 spin_unlock()。**这样能避免一切核内和核间并发的可能性。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241112094336501.png\" alt=\"image-20241112094336501\" style=\"zoom:75%;\" />\n\n这样考虑以后，自旋锁一般这样使用：\n\n```c\nspinlock_t lock; // 定义一个自旋锁\nspin_lock_init(&lock); // 初始化自旋锁\n\n// 进程上下文\nspin_lock_irqsave(&lock); // 获取自旋锁，保护临界区\n... // 临界区\nspin_unlock_irqrestore(&lock); // 解锁\n\n// 中断上下文\nspin_lock(&lock);\n... // 临界区\nspin_unlock(&lock);\n```\n\n在使用自旋锁的时候还需注意以下几个问题：\n\n1. **自旋锁实际上是忙等锁。**当锁不可用时，CPU 一直循环执行“测试并设置”该锁直到可用而取得该锁，CPU 在等待自旋锁时不做任何有用的工作，仅仅是等待。因此，**只有在占用锁的时间极短的情况下，使用自旋锁才是合理的。**当临界区很大，或有共享设备的时候，需要较长时间占用锁，使用自旋锁会降低系统的性能。\n2. **自旋锁可能导致系统死锁。**引发这个问题最常见的情况是递归使用一个自旋锁，即如果一个已经拥有某个自旋锁的 CPU 想第二次获得这个自旋锁，则该 CPU 将死锁。\n3. **在自旋锁锁定期间不能调用可能引起进程调度的函数。**如果进程获得自旋锁之后再阻塞，如调用 copy_from_user()、copy_to_user()、kmalloc() 和 msleep() 等函数，则可能导致内核的崩溃。\n4. **在单核情况下编程的时候，也应该认为自己的 CPU 是多核的。**在单 CPU 的情况下，中断中不调用 spin_lock() 也没有问题，因为进程中的 spin_lock_irqsave() 能保证同 CPU 的中断服务程序不可能执行，但如果是多核则无法屏蔽另一个核的中断，可能出现问题。因为无论如何在中断服务程序中都应加上 spin_lock()，同时也是为了编程的统一。\n\n### 读写自旋锁\n\n自旋锁对读写操作一视同仁。但对于读操作，多个执行单元同时读取是不会有问题的。因此衍生了读写自旋锁，它是一种比自旋锁粒度更小的锁机制。它保留了“自旋”的概念，但是在写操作方面，只能最多有 1 个写进程，在读操作方面，同时可以有多个读执行单元。当然，读和写也不能同时进行。\n\n读写自旋锁涉及的操作如下：\n\n1. 定义和初始化读写自旋锁\n\n```c\nrwlock_t my_rwlock;\nrwlock_init(&my_rwlock); // 动态初始化\n```\n\n2. 读锁定\n\n```c\nvoid read_lock(rwlock_t *lock);\nvoid read_lock_irqsave(rwlock_t *lock, unsigned long flags);\nvoid read_lock_irq(rwlock_t *lock);\nvoid read_lock_bh(rwlock_t *lock);\n```\n\n3. 读解锁\n\n```c\nvoid read_unlock(rwlock_t *lock);\nvoid read_unlock_irqrestore(rwlock_t *lock, unsigned long flags);\nvoid read_unlock_irq(rwlock_t *lock);\nvoid read_unlock_bh(rwlock_t *lock);\n```\n\n4. 写锁定\n\n```c\nvoid write_lock(rwlock_t *lock);\nvoid write_lock_irqsave(rwlock_t *lock, unsigned long flags);\nvoid write_lock_irq(rwlock_t *lock);\nvoid write_lock_bh(rwlock_t *lock);\nint write_trylock(rwlock_t *lock);\n```\n\n5. 写解锁\n\n```c\nvoid write_unlock(rwlock_t *lock);\nvoid write_unlock_irqrestore(rwlock_t *lock, unsigned long flags);\nvoid write_unlock_irq(rwlock_t *lock);\nvoid write_unlock_bh(rwlock_t *lock);\n```\n\n这些接口的含义类似于自旋锁，一般这样使用：\n\n```c\nrwlock_t lock; // 定义rwlock\nrwlock_init(&lock); // 初始化rwlock\n\nread_lock(&lock); // 读时获取锁\n... // 临界资源\nread_unlock(&lock); // 读后释放锁\n\nwrite_lock_irqsave(&lock, flags);// 写时获取锁\n... // 临界资源\nwrite_unlock_irqrestore(&lock, flags); // 写后释放锁\n```\n\n### 顺序锁\n\n顺序锁（seqlock）是对读写锁的一种优化。若使用顺序锁，**读执行单元不会被写执行单元阻塞**。读执行单元在写执行单元对被顺序锁保护的共享资源进行写操作时仍然可以继续读，而不必等待写执行单元完成写操作。同样写执行单元也不需要等待所有读执行单元完成读操作才去进行写操作。但是，写执行单元与写执行单元之间仍然是互斥的。如果有写执行单元在进行写操作，其他写执行单元必须自旋在那里，直到写执行单元释放了顺序锁。\n\n但这样很容易衍生出一个问题。**尽管读写之间不互相排斥，但是如果读执行单元在读操作期间，写执行单元已经发生了写操作，那么，读执行单元必须重新读取数据，以便确保得到的数据是完整的。**在这种情况下，读端可能反复读多次同样的区域才能读到有效的数据。\n\n由此可见，顺序锁的操作分为写执行单元和读执行单元，二者分别由不同的接口。\n\n写执行单元涉及的操作如下：\n\n1. 获得顺序锁\n\n```c\nvoid write_seqlock(seqlock_t *sl);\nint write_tryseqlock(seqlock_t *sl);\nwrite_seqlock_irqsave(lock, flags);\nwrite_seqlock_irq(lock);\nwrite_seqlock_bh(lock);\n```\n\n2. 释放顺序锁\n\n```c\nvoid write_sequnlock(seqlock_t *sl);\nwrite_sequnlock_irqrestore(lock, flags);\nwrite_sequnlock_irq(lock);\nwrite_sequnlock_bh(lock);\n```\n\n使用写执行单元的模式如下：\n\n```c\nwrite_seqlock_irqsave(&seqlock_a, flags);\n.../* 写操作代码块 */\nwrite_sequnlock_irqrestore(&seqlock_a, flags);\n```\n\n读执行单元涉及的操作如下：\n\n1. 读开始\n\n读执行单元在对被顺序锁 s 保护的共享资源进行访问前需要调用该函数，该函数返回顺序锁 s 的当前顺序号。\n\n```c\nunsigned read_seqbegin(const seqlock_t *sl);\nread_seqbegin_irqsave(lock, flags) = local_irq_save() + read_seqbegin()\n```\n\n2. 重读\n\n读执行单元在访问完被顺序锁 s 保护的共享资源后需要调用该函数来检查，在读访问期间是否有写操作。如果有写操作，读执行单元就需要重新进行读操作，以保证读取的数据是最新的。\n\n```c\nint read_seqretry(const seqlock_t *sl, unsigned iv);\nread_seqretry_irqrestore(lock, iv, flags) = read_seqretry() + local_irq_restore()\n```\n\n使用读执行单元的模式如下：\n\n```c\ndo {\n// 读操作代码块\nseqnum = read_seqbegin(&seqlock_a);\n...\n} while (read_seqretry(&seqlock_a, seqnum))\n```\n\n### RCU\n\nRCU，Read-Copy-Update，读-复制-更新。于 Linux 2.6 后正式包含在内核中。社区文档参考：[https://www.kernel.org/doc/ols/2001/read-copy.pdf](https://www.kernel.org/doc/ols/2001/read-copy.pdf)\n\nRCU（Read-Copy-Update），是 Linux 中比较重要的一种同步机制。顾名思义就是“读，拷贝更新”，再直白点是**“随意读，但更新数据的时候，需要先复制一份副本，在副本上完成修改，再一次性地替换旧数据”**。这是 Linux 内核实现的一种针对**“读多写少”**的共享数据的同步机制。\n\n**使用 RCU 的读端没有锁、内存屏障、原子指令类的开销，几乎可以认为是直接读（只是简单地标明读开始和读结束），而 RCU 的写执行单元在访问它的共享资源前首先复制一个副本，然后对副本进行修改，最后使用一个回调机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的 CPU 都退出对共享数据读操作的时候。等待适当时机的这一时期称为宽限期（Grace Period）。**\n\nRCU 可以看作读写锁的高性能版本。相比读写锁，RCU 的优点在于既允许多个读执行单元同时访问被保护的数据，又允许多个读执行单元和多个写执行单元同时访问被保护的数据。但 RCU 不能替代读写锁，因为如果写比较多时，对读执行单元的性能提高不能弥补写执行单元同步导致的损失。因为使用 RCU 时，写执行单元之间的同步开销会比较大，它需要延迟数据结构的释放，复制被修改的数据结构，也必须使用某种锁机制来同步并发的其他写执行单元的修改操作。\n\n**读者在访问被 RCU 保护的共享数据期间不能被阻塞，这是 RCU 机制得以实现的一个基本前提。**也就说当读者在引用被 RCU 保护的共享数据期间，读者所在的 CPU 不能发生上下文切换，spinlock 和 rwlock 都需要这样的前提。写者在访问被 RCU 保护的共享数据时不需要和读者竞争任何锁，只有在有多于一个写者的情况下需要获得某种锁以与其他写者同步。\n\nRCU 涉及的操作如下：\n\n1. 读锁定\n\n```c\nrcu_read_lock();\nrcu_read_lock_bh();\n```\n\n2. 读解锁\n\n```c\nrcu_read_unlock();\nrcu_read_unlock_bh();\n```\n\n使用 RCU 读的模式如下：\n\n```c\nrcu_read_lock();\n... // 读临界区\nrcu_read_unlock();\n```\n\n3. 同步 RCU\n\n```c\nsynchronize_rcu();\n```\n\n该函数由 RCU 写执行单元调用，它将阻塞写执行单元，直到当前 CPU 上所有的已经存在的读执行单元完成读临界区，写执行单元才可以继续下一步操作。synchronize_rcu() 并不需要等待后续读临界区的完成。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241112104436256.png\" alt=\"image-20241112104436256\" style=\"zoom:80%;\" />\n\n4. 挂接回调\n\n```c\nvoid call_rcu(struct rcu_head *head, void (*func)(struct rcu_head *rcu));\n```\n\n该函数也由 RCU 写执行单元调用，与 synchronize_rcu() 不同的是，它不会使写执行单元阻塞，因而可以在中断上下文或软中断中使用。该函数把函数 func() 挂接到 RCU 回调函数链上，然后立即返回。挂接的回调函数会在一个宽限期结束（即所有已经存在的 RCU 读临界区完成）后被执行。\n\n下列的函数用于实现内存屏障的作用。\n\n给 RCU 保护的指针赋一个新的值：\n\n```c\nrcu_assign_pointer(p, v);// p 是被赋值指针，v 是赋值指针\n```\n\n读端使用 rcu_dereference() 获取一个 RCU 保护的指针，之后既可以安全地引用它（访问它指向的区域）。\n\n```c\nrcu_dereference(p);\n```\n\n读端使用 rcu_access_pointer() 获取一个 RCU 保护的指针，之后并不引用它。这种情况下，我们只关心指针本身的值，而不关心指针指向的内容。比如我们可以使用该 API 来判断指针是否为 NULL。\n\n```c\nrcu_access_pointer(p);\n```\n\n对于链表数据结构而言，Linux 内核专门增加了 RCU 保护的链表操作 API：\n\n```c\n// 把链表元素 new 插入 RCU 保护的链表 head 的开头。\nstatic inline void list_add_rcu(struct list_head *new, struct list_head *head);\n\n// 把链表元素 new 添加到被 RCU 保护的链表的末尾。\nstatic inline void list_add_tail_rcu(struct list_head *new, struct list_head *head);\n\n// 从 RCU 保护的链表中删除指定的链表元素 entry。\nstatic inline void list_del_rcu(struct list_head *entry);\n\n// 使用新的链表元素 new 取代旧的链表元素 old。\nstatic inline void list_replace_rcu(struct list_head *old, struct list_head *new);\n\n// 该宏用于遍历由 RCU 保护的链表 head。只要在读执行单元临界区使用该函数，它就可以安全地和其他 RCU 保护的链表操作函数（如 list_add_rcu() 等）并发运行。\nlist_for_each_entry_rcu(pos, head)\n```\n\n更多细节和原理，请参考：[https://www.cnblogs.com/schips/p/linux_cru.html](https://www.cnblogs.com/schips/p/linux_cru.html)\n\n## 信号量\n\n信号量（Semaphore）是操作系统中最典型的用于同步和互斥的手段，信号量的值可以是 0、1 或者 n。信号量与操作系统中的经典概念 PV 操作对应。\n\nP(S)：\n\n1. 将信号量 S 的值减 1，即 S=S-1。\n2. 如果 S>=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。\n\nV(S)：\n\n1. 将信号量 S 的值加 1，即 S=S+1。\n2. 如果 S>0，唤醒队列中等待信号量的进程。\n\n信号量涉及的操作如下：\n\n1. 定义信号量\n\n```c\nstruct semaphore\n{\n    raw_spinlock_t lock;\n    unsigned int count;\n    struct list_head wait_list;\n};\n```\n\n2. 初始化信号量\n\n```c\nvoid sema_init(struct semaphore *sem, int val); // 初始化信号量 sem 并设置为值 val。\n```\n\n3. 获得信号量\n\n```c\n// 获得信号量 sem，会导致睡眠，因此不能在中断上下文中使用。\nvoid down(struct semaphore *sem);\n\n// 功能与 down() 类似，不同之处为：down() 进入睡眠状态的进程不能被信号打断，down_interruptible() 进入睡眠状态的进程能被信号打断，信号也会导致该函数返回，这时候函数的返回值非 0。\n// 使用 down_interruptible() 时，对返回值一般会进行检查。如果返回的非 0，通常立即返回 -ERESTARTSYS。\nint down_interruptible(struct semaphore *sem); \n\n// 尝试获得信号量 sem，如果能够立刻获得，它就获得该信号量并返回 0，否则返回非 0 值。它不会导致调用者睡眠，可以在中断上下文中使用。\nint down_trylock(struct semaphore *sem);\n```\n\n4. 释放信号量\n\n```c\n// 释放信号量 sem，唤醒等待者。\nvoid up(struct semaphore *sem);\n```\n\n信号量可以保护临界区，它的使用方式和自旋锁类似。与自旋锁相同，只有得到信号量的进程才能执行临界区代码。但与自旋锁不同的是，**当获取不到信号量时，进程不会原地打转而是进入休眠等待状态。**\n\n用作互斥时，信号量一般这样被使用：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241112141145150.png\" alt=\"image-20241112141145150\" style=\"zoom:75%;\" />\n\n关心具体数值的生产者/消费者问题，使用信号量较为合适。生产者/消费者问题也是一种同步问题。\n\n## 互斥体\n\n新的 Linux 内核倾向于直接使用互斥体 mutex 作为互斥手段，信号量作互斥不再被推荐使用，尽管信号量可以实现互斥的功能。\n\n互斥体涉及的操作如下：\n\n1. 定义互斥体\n\n```c\nstruct mutex my_mutex;\nmutex_init(&my_mutex);\n```\n\n2. 初始化互斥体\n\n```c\n// mutex_lock() 不可以被信号打断，mutex_lock_interruptible() 可以。\nvoid mutex_lock(struct mutex *lock);\nint mutex_lock_interruptible(struct mutex *lock); \nint mutex_trylock(struct mutex *lock);\n```\n\n3. 释放互斥体\n\n```c\nvoid mutex_unlock(struct mutex *lock);\n```\n\n互斥体 mutex 使用的模式如下：\n\n```c\nstruct mutex my_mutex; // 定义 mutex\nmutex_init(&my_mutex); // 初始化 mutex\nmutex_lock(&my_mutex); // 获取 mutex\n... // 临界资源\nmutex_unlock(&my_mutex); // 释放 mutex\n```\n\n## 如何选择自旋锁和互斥体\n\n自旋锁和互斥体都是解决互斥问题的基本手段，面对特定的情况，如何取舍这两种手段呢？选择的依据是临界区的性质和系统的特点。\n\n从严格意义上说，**互斥体和自旋锁属于不同层次的互斥手段，前者的实现依赖于后者**。在互斥体本身的实现上，为了保证互斥体结构存取的原子性，需要自旋锁来互斥。所以自旋锁属于更底层的手段。\n\n互斥体是进程级的，用于多个进程之间对资源的互斥，虽然也是在内核中，但是该内核执行路径是以进程的身份，代表进程来争夺资源的。如果竞争失败，会发生进程上下文切换，当前进程进入睡眠状态，CPU 将运行其他进程。鉴于进程上下文切换的开销也很大，因此，只有当进程占用资源时间较长时，用互斥体才是较好的选择。\n\n当所要保护的临界区访问时间比较短时，用自旋锁是非常方便的，因为它可节省上下文切换的时间。但 CPU 得不到自旋锁会在那里空转直到其他执行单元解锁为止，所以要求锁不能在临界区里长时间停留，否则会降低系统的效率。\n\n因此，可以总结出三大原则：\n\n1. 当锁不能被获取到时，使用互斥体的开销是进程上下文切换时间，使用自旋锁的开销是等待获取自旋锁（由临界区执行时间决定）。**若临界区比较小，宜使用自旋锁，若临界区很大，应使用互斥体。**\n2. 互斥体所保护的临界区可包含可能引起阻塞的代码，而**自旋锁则绝对要避免用来保护包含可能引起阻塞代码的临界区**。因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一个进程企图获取本自旋锁，死锁就会发生。\n3. 互斥体存在于进程上下文，因此，如果被保护的共享资源需要在中断或软中断情况下使用，则在互斥体和自旋锁之间只能选择自旋锁。当然，如果一定要使用互斥体，则只能通过 mutex_trylock() 方式 进行，不能获取就立即返回以避免阻塞。\n\n## 完成量\n\nLinux 提供了完成量（completion），用于一个执行单元等待另一个执行单元执行完某事。\n\n完成量涉及的操作如下：\n\n1. 定义完成量\n\n```c\nstruct completion my_completion;\n```\n\n2. 初始化完成量\n\n```c\ninit_completion(&my_completion); // 初始化完成量的值为 0（未完成的状态）\nreinit_completion(&my_completion); // 重新初始化\n```\n\n3. 等待完成量\n\n```c\nvoid wait_for_completion(struct completion *c);\n```\n\n4. 唤醒完成量\n\n```c\nvoid complete(struct completion *c); // 唤醒一个等待的执行单元。\nvoid complete_all(struct completion *c); // 唤醒所有等待同一完成量的执行单元。\n```\n\n完成量用于同步的流程如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241112143006097.png\" alt=\"image-20241112143006097\" style=\"zoom:75%;\" />\n\n## 支持并发控制的 globalmem 设备驱动\n\nTODO\n\n## 小结\n\nLinux 内核优化了自旋锁、信号量、互斥体、完成量等的管理，**并不需要显式销毁，在数据结构生命周期结束时自动释放**。因此只有初始化的相关接口，没有销毁的相关接口。\n\n并发和竞态广泛存在，中断屏蔽、原子操作、自旋锁和互斥体都是解决并发问题的机制。中断屏蔽很少单独被使用，原子操作只能针对整数进行，因此自旋锁和互斥体应用最为广泛。\n\n**自旋锁会导致死循环，锁定期间不允许阻塞，因此要求锁定的临界区小。互斥体允许临界区阻塞，可以适用于临界区大的情况。**\n\n# 设备驱动中的阻塞与非阻塞 I/O\n\n阻塞和非阻塞 I/O 是设备访问的两种不同模式，驱动程序可以灵活地支持这两种用户空间对设备的访问方式。\n\n## 阻塞与非阻塞 I/O\n\n阻塞操作是指在执行设备操作时，若不能获得资源，则挂起进程直到满足可操作的条件后再进行操作。被挂起的进程进入睡眠状态，被从调度器的运行队列移走，直到等待的条件被满足。而非阻塞操作的进程在不能进行设备操作时，并不挂起，它要么放弃，要么不停地查询（轮询），直至可以进行操作为止。\n\n驱动程序应当提供阻塞与非阻塞的能力。当应用程序阻塞 read()、write() 的时候，若资源无法获取，驱动程序的 xxx_read()、xxx_write() 需要阻塞进程知道资源可以获取。同理，应用程序非阻塞的时候且资源无法获取的时候，驱动程序的 xxx_read()、xxx_write() 操作应立即返回，系统调用也随即返回，应用程序收到 -EAGAIN 返回值。\n\n在阻塞访问时，不能获取资源的进程将进入休眠，它将 CPU 资源让给其他进程。由于阻塞的进程会进入休眠状态，所以必须确保有一个地方能够唤醒休眠的进程，否则，进程就真的醒不过来了。唤醒进程的地方最大可能发生在**中断**里面，因为在硬件资源获得的同时往往伴随着一个中断。而非阻塞的进程则不断尝试，直到可以进行 I/O。如图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241112155206531.png\" alt=\"image-20241112155206531\" style=\"zoom:70%;\" />\n\n### 等待队列\n\n在 Linux 驱动程序中，**可以使用等待队列（Wait Queue）来实现阻塞进程的唤醒**。它以队列为基础数据结构，与进程调度机制紧密结合，可以用来同步对系统资源的访问。\n\n等待队列涉及的操作如下：\n\n1. 定义等待队列头部\n\n```c\nstruct wait_queue_head {\n\tspinlock_t\t\tlock;\n\tstruct list_head\thead;\n};\ntypedef struct wait_queue_head wait_queue_head_t;\n\nwait_queue_head_t my_queue;\n```\n\n2. 初始化等待队列头部\n\n```c\ninit_waitqueue_head(&my_queue);\n```\n\nDECLARE_WAIT_QUEUE_HEAD() 宏可作为定义并初始化等待队列头部的快捷方式。\n\n```c\nDECLARE_WAIT_QUEUE_HEAD(my_queue);\n// 相当于\n{ wait_queue_head_t my_queue; init_waitqueue_head(&my_queue); }\n```\n\n3. 定义等待队列元素\n\n```c\nDECLARE_WAITQUEUE(name, tsk); // 定义并初始化一个名为 name 的等待队列元素。\n```\n\n4. 添加/移除等待队列\n\n```c\nvoid add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);\nvoid remove_wait_queue(wait_queue_head_t *q, wait_queue_t *wait);\n```\n\n5. 等待事件\n\n```c\nwait_event(queue, condition); // 阻塞等待队列，直到满足条件 condition。\nwait_event_interruptible(queue, condition); // 与上面的区别是可以被信号打断，上面不行。\nwait_event_timeout(queue, condition, timeout); // timeout 是阻塞的超时时间，超时后不管 condition 是否满足，都返回。\nwait_event_interruptible_timeout(queue, condition, timeout);\n```\n\n6. 唤醒队列\n\n该函数会唤醒 queue 为头部的等待队列中的所有进程。\n\n```c\nvoid wake_up(wait_queue_head_t *queue);\nvoid wake_up_interruptible(wait_queue_head_t *queue);\n```\n\nwake_up() 应该与 wait_event() 或 wait_event_timeout() 成对使用，而 wake_up_interruptible() 应与 wait_event_interruptible() 或 wait_event_interruptible_timeout() 成对使用。wake_up() 可唤醒处于 TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE 的进程，而 wake_up_interruptible() 只能唤醒处于 TASK_INTERRUPTIBLE 的进程。\n\n7. 在等待队列上睡眠（已废弃）\n\n老版本的接口，作用和 wait_event() 系列函数类似，因此使用前者即可。\n\n```c\n/*\n * These are the old interfaces to sleep waiting for an event.\n * They are racy.  DO NOT use them, use the wait_event* interfaces above.\n * We plan to remove these interfaces.\n */\nextern void sleep_on(wait_queue_head_t *q);\nextern long sleep_on_timeout(wait_queue_head_t *q, signed long timeout);\nextern void interruptible_sleep_on(wait_queue_head_t *q);\nextern long interruptible_sleep_on_timeout(wait_queue_head_t *q, signed long timeout);\n```\n\n以下是一个使用等待队列的模板，在写 I/O 的时候，检查设备是否可写。如果不可写，对于非阻塞 I/O，直接返回 -EAGAIN；对于阻塞 I/O，将进程睡眠并挂起至等待队列。\n\n```c\nstatic ssize_t xxx_write(struct file *file, const char *buffer, size_t count, loff_t *ppos)\n{\n    ...\n\n    DECLARE_WAITQUEUE(wait, current); // 定义等待队列元素\n    add_wait_queue(&xxx_wait, &wait); // 添加元素到等待队列\n\n    // 等待设备缓冲区可写\n    do\n    {\n        avail = device_writable(...);\n        if (avail < 0)\n        {\n            if (file->f_flags & O_NONBLOCK)\n            { // 非阻塞\n                res = -EAGAIN;\n                goto out;\n            }\n\n            __set_current_state(TASK_INTERRUPTIBLE); // 改变进程状态\n            schedule();                              // 调度其他进程执行\n\n            if (signal_pending(current)) // 如果是因为信号唤醒\n            {\n\n                res = -ERESTARTSYS;\n                goto out;\n            }\n        }\n    } while (avail < 0);\n\n    // 写设备缓冲区\n    device_write(...);\n\nout:\n    remove_wait_queue(&xxx_wait, &wait); // 将元素移出 xxx_wait 指引的队列\n    set_current_state(TASK_RUNNING);     // 设置进程状态为 TASK_RUNNING\n\n\n    return res;\n}\n```\n\n这段代码里面有几个注意的点：\n\n1. 对于非阻塞 I/O（O_NONBLOCK 标志位），设备忙时，返回 -EAGAIN。\n2. 对于阻塞 I/O，设备忙时，调用 `__set_current_state(TASK_INTERRUPTIBLE)` 切换进程状态并使用 `schedule()` 调度其他进程执行。但由于使用的是 TASK_INTERRUPTIBLE，因此唤醒进程的可能是信号。需通过 `signal_pending(current)` 判断是否为信号唤醒，如果是，立即返回 -ERESTARTSYS。\n\nDECLARE_WAITQUEUE()、add_wait_queue() 这两个动作加起来完成的效果如图所示。在 wait_queue_head_t 指向的链表上，新定义的 wait_queue 元素被插入，而这个新插入的元素绑定了一个 task_struct（当前做 xxx_write 的 current，这也是 DECLARE_WAITQUEUE 使用 current 作为参数的原因）。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241114100236690.png\" alt=\"image-20241114100236690\" style=\"zoom:70%;\" />\n\n### 支持阻塞操作的 globalfifo 设备驱动\n\nTODO\n\n## 轮询操作\n\n在用户程序中，使用非阻塞 I/O 的程序通常会使用 select() 和 poll() 函数来进行 I/O 多路复用的操作，从而达到对设备非阻塞的忙轮询的优化，即用户将查询过程托管给内核，内核负责通知用户时机，从而达到对用户进程的优化，并且能在一个进程中同时监听多个文件描述符。\n\nselect() 和 poll() 系统调用最终会使设备驱动中的 poll() 函数被执行，在 Linux 2.5.45 内核中还引入了 epoll()，即扩展的 poll()。\n\n### 应用程序中的轮询编程\n\n此部分请参考博客 [https://blog.davidingplus.cn/posts/2adb5565.html](https://blog.davidingplus.cn/posts/2adb5565.html) 的第四章网络编程中 I/O 多路复用技术的部分。\n\n### 设备驱动中的轮询编程\n\n内核中 poll() 的定义为：\n\n```c\n// 第一个参数是 file 结构体指针，第二个是轮询表指针。\n__poll_t (*poll) (struct file *, struct poll_table_struct *);\n```\n\n该 poll() 函数进行两项工作：\n\n1. 对可能引起设备文件状态变化的等待队列调用 poll_wait() 函数。\n2. 返回表示是否能对设备进行无阻塞读、写访问的掩码。\n\n向 poll_table 注册等待队列的 poll_wait() 函数定义如下：\n\n```c\nvoid poll_wait(struct file *filp, wait_queue_head_t *wait_address, poll_table *p);\n```\n\n> poll_wait() 函数的名称非常容易让人产生误会，以为它和 wait_event() 等一样，会阻塞地等待某事件的发生，但其实这个函数并不会引起阻塞。poll_wait() 函数所做的工作是把当前进程添加到 p 参数指定的等待列表（poll_table）中，实际作用是让唤醒参数 wait_address 对应的等待队列可以唤醒用户层因 select()/poll()/epoll() 而睡眠的进程。\n\n上面这段是书本上的原话，我个人不是特别理解，参考了博客 [https://blog.csdn.net/weixin_42462202/article/details/100017339](https://blog.csdn.net/weixin_42462202/article/details/100017339)，总结 poll 机制如下。\n\n实际上 select()、poll()、epoll() 的实现都是利用等待队列机制，将执行这些函数的进程挂到每一个驱动程序的等待队列中，然后睡眠等待，直到被唤醒。\n\n驱动程序的 poll() 函数至少会被这些系统调用给**调用两次**。\n\n1. **第一次是 select()、poll()、epoll() 所在的进程调用驱动程序的 poll() 函数，将自己挂到驱动程序的等待队列中，通过内核函数 poll_wait() 实现。这也是驱动 poll() 函数的一个作用，当等待队列就能在满足条件 condition 的时候唤醒本进程。**\n\n2. **第二次是 select()、poll()、epoll() 所在的进程被驱动程序唤醒，再次驱动程序的 poll() 函数，获取驱动程序满足的条件（可读或可写），返回对应的 mask，与用户进程对接起来，用户进程根据 mask 进行针对处理。**\n\n驱动程序的 poll() 函数应该返回设备资源的可获取状态，即 POLLIN、POLLOUT、POLLPRI、POLLERR、POLLNVAL 等宏的位“或”结果。每个宏的含义都表明设备的一种状态，如 POLLIN（定义为 0x0001）意味着设备可以无阻塞地读，POLLOUT（定义为0x0004）意味着设备可以无阻塞地写。\n\n因此，结合上述，在驱动中使用 poll() 函数的模板如下：\n\n```c\nstatic unsigned int xxx_poll(struct file *filp, poll_table *wait)\n{\n    unsigned int mask = 0;\n    struct xxx_dev *dev = filp->private_data; // 获得设备结构体指针\n\n    ...\n\n    // 第一次被调用时，将调用 select()、poll()、epoll() 的进程加入驱动的等待队列中。\n    poll_wait(filp, &dev->r_wait, wait); // 加入读等待队列\n    poll_wait(filp, &dev->w_wait, wait); // 加入写等待队列\n\n    // 第二次被调用时，如果条件满足，返回状态，之后 poll() 会返回。\n    if (...)                         // 可读\n        mask |= POLLIN | POLLRDNORM; // 标示数据可获得（对用户可读）\n\n    if (...)                          // 可写\n        mask |= POLLOUT | POLLWRNORM; // 标示数据可写入\n\n    ...\n\n\n    return mask;\n}\n```\n\n> 代码中看到了状态 POLLIN 和 POLLRDNORM，这二者都是表示可读。区别在于 POLLIN 适用于所有的可读数据情况，不仅包括普通数据，还包括优先级数据，而 POLLRDNORM 只适用于普通数据的可读情况，不包括任何优先级数据。\n>\n> POLLOUT 和 POLLWRNORM 同理。\n\n### 支持轮询操作的 globalfifo 设备驱动\n\nTODO\n\n## 小结\n\n阻塞与非阻塞访问是 I/O 操作的两种不同模式，前者在暂时不可进行I/O操作时会让进程睡眠，后者则不然。\n\n在设备驱动中阻塞 I/O 一般基于等待队列或者基于等待队列的其他 Linux 内核 API 来实现，等待队列可用于同步驱动中事件发生的先后顺序。使用非阻塞 I/O 的应用程序也可借助轮询函数来查询设备是否能立即被访问，用户空间调用 select()、poll() 或 epoll() 接口，设备驱动提供 poll() 函数。设备驱动的 poll() 本身不会阻塞，但是与 select()、poll() 和 epoll() 相关的系统调用则会阻塞地等待至少一个文件描述符集合，直到可访问或超时。\n\n# 设备驱动中的异步通知与异步 I/O\n\n异步通知的意思是：一旦设备就绪，则主动通知应用程序，这样应用程序根本就不需要查询设备状态，这一点非常类似于硬件上“中断”的概念，比较准确的称谓是“**信号驱动的异步 I/O**”。**信号是在软件层次上对中断机制的一种模拟。**在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。\n\n**阻塞 I/O 意味着一直等待设备可访问后再访问，非阻塞 I/O 中使用 poll() 意味着查询设备是否可访问，而异步通知则意味着设备通知用户自身可访问，之后用户再进行 I/O 处理。**\n\n三种方式的示意图如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241118152443949.png\" alt=\"image-20241118152443949\" style=\"zoom:75%;\" />\n\n## 异步通知编程\n\n### 关于信号\n\n在 Linux 中，异步通信使用信号实现。同时，信号也是 Linux 进程间通信 IPC 的一种方式。Linux 常用信号如下表：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241118154442574.png\" alt=\"image-20241118154442574\" style=\"zoom:75%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241118154452629.png\" alt=\"image-20241118154452629\" style=\"zoom:75%;\" />\n\n除了 SIGSTOP 和 SIGKILL 两个信号外，进程能够忽略或捕获其他的全部信号。一个信号被捕获的意思是当一个信号到达时有相应的代码处理它。如果一个信号没有被这个进程所捕获，内核将采用默认行为处理。\n\n### 信号的接收\n\n在用户程序当中进行捕获信号。可使用 signal() 或 sigaction() 函数捕获信号。这两个函数的具体使用见博客 [https://blog.davidingplus.cn/posts/2adb5565.html](https://blog.davidingplus.cn/posts/2adb5565.html) 的第二章进程间通信的信号部分。\n\n使用信号实现异步通知的用户层代码示例如下：\n\n```cpp\n#include <iostream>\n\n#include <unistd.h>\n#include <signal.h>\n#include <fcntl.h>\n\n\n#define MAX_SIZE BUFSIZ\n\n\nvoid doIt(int num)\n{\n    char data[MAX_SIZE] = {0};\n\n    // 读取并输出 STDIN_FILENO 上的输入\n    int len = read(STDIN_FILENO, &data, MAX_SIZE);\n\n    std::cout << \"input data: \" << data << std::endl;\n}\n\n\nint main()\n{\n    // 启动信号驱动机制\n    struct sigaction act;\n    act.sa_flags = 0;\n    act.sa_handler = doIt;\n    sigemptyset(&act.sa_mask);\n\n    sigaction(SIGIO, &act, nullptr);\n\n    // TODO 下面代码的含义是让当前进程设置为接受 SIGIO 信号，并且告诉内核是通过异步的方式接受。在这个程序中异步的感观不明显，但确实是这样用的。想办法让其感观明显一点。\n\n    // 设置将接收 SIGIO 和 SIGURG 信号的进程 id 或进程组 id\n    fcntl(STDIN_FILENO, F_SETOWN, getpid());\n    // 修改为异步通知模式\n    int flag = fcntl(STDIN_FILENO, F_GETFL);\n    fcntl(STDIN_FILENO, F_SETFL, flag | FASYNC);\n\n    // 最后进入一个死循环，仅为保持进程不终止，如果程序中没有这个死循会立即执行完毕\n    for (;;)\n    {\n    }\n\n\n    return 0;\n}\n```\n\n由此可见，为了在用户空间中处理一个设备释放的信号，需要完成 3 项工作：\n\n1. **通过 F_SETOWN IO 控制命令设置设备文件的拥有者为本进程，这样从设备驱动发出的信号才能被本进程接收到。**\n2. **通过 F_SETFL IO 控制命令设置设备文件以支持 FASYNC，即异步通知模式。**\n3. **通过 signal() 或者 sigaction() 函数连接信号和信号处理函数。**\n\n### 信号的释放\n\n在设备驱动和应用程序的异步通知交互中，仅仅在应用程序端捕获信号是不够的，因为信号的源头在设备驱动端。因此，应该在合适的时机让设备驱动释放信号，**在设备驱动程序中增加信号释放的相关代码**。\n\n与用户程序对应的，驱动程序也涉及 3 项工作：\n\n1. **支持 F_SETOWN 命令，能在这个控制命令处理中设置 filp->f_owner 为对应进程 ID。但此项工作已由内核完成，设备驱动无须处理。**\n2. **支持 F_SETFL 命令的处理，每当 FASYNC 标志改变时，驱动程序中的 fasync() 函数将得以执行。因此，驱动中应该实现 fasync() 函数。**\n3. **在设备资源可获得时，调用 kill_fasync() 函数激发相应的信号。**\n\n这些与用户层的 3 项工作是一一对应的，关系图如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241120095605894.png\" alt=\"image-20241120095605894\" style=\"zoom:80%;\" />\n\n设备驱动中的异步通知编程涉及到一个数据结构和两个函数，具体如下：\n\n1. 结构体 fasync_struct。\n\n```c\nstruct fasync_struct {\n\trwlock_t\t\tfa_lock;\n\tint\t\t\tmagic;\n\tint\t\t\tfa_fd;\n\tstruct fasync_struct\t*fa_next; /* singly linked list */\n\tstruct file\t\t*fa_file;\n\tstruct rcu_head\t\tfa_rcu;\n};\n```\n\n2. 处理 FASYNC 标志变更的函数。\n\nfasync_helper() 的作用是**将一个 fasync_struct 的对象注册进内核**，应用层执行 fcntl(fd, F_SETFL, oflags | FASYNC) 时会回调驱动的 fops.fasync()，所以通常将 fasync_helper() 放到 fasync() 的实现中。\n\n```c\nint fasync_helper(int fd, struct file *filp, int mode, struct fasync_struct **fa);\n```\n\n3. 产生信号用的函数。\n\n```c\nvoid kill_fasync(struct fasync_struct **fa, int sig, int band);\n```\n\n## 支持异步通知的 globalfifo 驱动\n\nTODO\n\n## 异步 IO\n\n### 用户层 GNU C 库 AIO\n\nLinux 中最常用的输入/输出（I/O）模型是同步 I/O。当请求发出之后，应用程序就会阻塞，直到请求满足为止。这是一种很好的解决方案，调用应用程序在等待 I/O 请求完成时不需要占用 CPU。但是在许多应用场景中，I/O 请求可能需要与 CPU 消耗产生交叠，以充分利用 CPU 和 I/O 提高吞吐率。\n\n异步 I/O 的时序图如下。应用程序发起 I/O 动作以后，并不等待 I/O 结束，而是接着执行。它要么过一段时间来查询之前的 I/O 请求完成情况，要么 I/O 请求完成后自动被调用与 I/O 完成绑定的回调函数。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241120111926095.png\" alt=\"image-20241120111926095\" style=\"zoom:75%;\" />\n\nLinux 的 AIO 有多种实现。其中一种是**在用户空间的 glibc 库中实现的**。**它本质上是借用了多线程模型，用开启新的线程以同步的方法来做 I/O，新的 AIO 辅助线程与发起 AIO 的线程以 pthread_cond_signal() 的形式进行线程间的同步。**\n\n其主要接口如下：\n\n1. aio_read()\n\naio_read() 函数请求对一个有效的文件描述符进行异步读操作。这个文件描述符可以表示一个文件、套接字，甚至管道。\n\n此函数在请求排队后就会立即返回，尽管读操作并未完成。如果执行成功，返回 0；如果出现错误，返回 -1，并设置 errno。\n\n参数 aiocb（AIO I/O Control Block）结构体包含了传输的所有信息，以及为 AIO 操作准备的用户空间缓冲区。在产生 I/O 完成通知时，aiocb 结构就被用来唯一标识所完成的 I/O 操作。\n\n```c\nint aio_read(struct aiocb *aiocbp);\n```\n\n更进一步的，aiocb 结构体的定义如下：\n\n```c\nstruct aiocb\n{\n    int aio_fildes;               // 文件描述符\n    __off_t aio_offset;           // 文件偏移\n    volatile void *aio_buf;       // 缓冲区地址\n    size_t aio_nbytes;            // 传输的数据长度\n    int aio_reqprio;              // 请求优先级\n    struct sigevent aio_sigevent; // 通知方法\n    int aio_lio_opcode;           // 仅被 lio_listio() 函数使用\n\n\t...\n};\n```\n\n2. aio_write()\n\n同 aio_read()，aio_write() 进行一个异步写操作。同样在请求排队后就会立即返回，返回值同上。\n\n```c\nint aio_write(struct aiocb *aiocbp);\n```\n\n3. aio_error()\n\naio_error() 函数用于确认请求的状态。\n\n```c\nint aio_error(const struct aiocb *aiocbp);\n```\n\n这个函数可以返回以下内容：\n\n- EINPROGRESS：说明请求尚未完成。\n- ECANCELED：说明请求被应用程序取消了。\n- -1：说明发生了错误，具体错误原因由 errno 记录。\n\n4. aio_return()\n\n异步 I/O 和同步阻塞 I/O 方式之间的一个区别是不能立即访问这个函数的返回状态，因为异步 I/O 并没有阻塞在 aio_read() 调用上。在标准的同步阻塞 read() 调用中，返回状态是在该函数返回时提供的。但是在异步 I/O 中，我们要使用 aio_return() 函数，手动获取返回值。\n\n```c\nssize_t aio_return(struct aiocb *aiocbp);\n```\n\n在实际使用的时候，只有在 aio_error() 调用确定请求已经完成（可能成功，也可能发生了错误）之后，才会调用这个函数。aio_return() 的返回值就等价于同步情况中 read() 或 write() 系统调用的返回值，即所传输的字节数。如果发生错误，返回值为负数。\n\n下面是一个例子，展示了上面 API 的使用方法。注意使用的时候链接系统库 `rt`（见 man 文档）。\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n#include <aio.h>\n#include <fcntl.h>\n\n\n#define PERROR(func)  \\\n    do                \\\n    {                 \\\n        perror(func); \\\n        return -1;    \\\n    } while (0)\n\n\nint main()\n{\n    FILE *pFile = fopen(\"file.txt\", \"w\");\n    if (!pFile) PERROR(\"fopen\");\n\n    fputs(\"hello globalfifo module.\", pFile);\n\n    fclose(pFile);\n\n    // 使用 AIO 读\n\n    int fd = open(\"file.txt\", O_RDONLY);\n    if (-1 == fd) PERROR(\"open\");\n\n    struct aiocb aio;\n    bzero(&aio, sizeof(aio));\n\n    aio.aio_buf = malloc(BUFSIZ + 1);\n    if (!aio.aio_buf) PERROR(\"malloc\");\n\n    aio.aio_fildes = fd;\n    aio.aio_nbytes = BUFSIZ;\n    aio.aio_offset = 0;\n\n    int res = aio_read(&aio);\n    if (-1 == res) PERROR(\"aio_read\");\n\n    while (aio_error(&aio) == EINPROGRESS) continue;\n\n    res = aio_return(&aio);\n    if (res < 0) PERROR(\"aio_return\");\n\n    std::cout << \"res: \" << res << std::endl;\n    std::cout << \"aio_read: \" << (char *)aio.aio_buf << std::endl;\n\n    remove(\"file.txt\");\n\n\n    return 0;\n}\n```\n\n5. aio_suspend()\n\n用户可以使用 aio_suspend() 函数来阻塞调用进程，直到异步请求完成为止。用户可以在参数中提供一个 aiocb 引用数组，其中任何一个完成都会导致 aio_suspend() 返回。\n\n注意，第一个参数是**存放 aiocb 结构体指针的数组**，第二个参数是数组的大小，第三个参数是阻塞超时时长（nullptr 表示阻塞，非阻塞给超时时长）。\n\n```c\nint aio_suspend(const struct aiocb *const aiocb_list[], int nitems, const struct timespec *timeout);\n```\n\n当然，在 glibc 实现的 AIO 中，除了上述同步的等待方式以外，也可以使用信号或者回调机制来异步地标明 AIO 的完成。\n\n经过修改后的示例程序如下：\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n#include <aio.h>\n#include <fcntl.h>\n\n\n#define PERROR(func)  \\\n    do                \\\n    {                 \\\n        perror(func); \\\n        return -1;    \\\n    } while (0)\n\n\nint main()\n{\n    FILE *pFile = fopen(\"file.txt\", \"w\");\n    if (!pFile) PERROR(\"fopen\");\n\n    fputs(\"hello globalfifo module.\", pFile);\n\n    fclose(pFile);\n\n    int fd = open(\"file.txt\", O_RDONLY);\n    if (-1 == fd) PERROR(\"open\");\n\n    struct aiocb aio;\n    std::memset(&aio, 0, sizeof(aio));\n\n    struct aiocb *aioArr[1] = {&aio};\n\n    aio.aio_buf = malloc(BUFSIZ + 1);\n    if (!aio.aio_buf) PERROR(\"malloc\");\n\n    aio.aio_fildes = fd;\n    aio.aio_nbytes = BUFSIZ;\n    aio.aio_offset = 0;\n\n    int res = aio_read(&aio);\n    if (-1 == res) PERROR(\"aio_read\");\n\n    res = aio_suspend(aioArr, sizeof(aioArr) / sizeof(aioArr[0]), nullptr);\n    if (-1 == res) PERROR(\"aio_suspend\");\n\n    res = aio_return(&aio);\n    if (-1 == res) PERROR(\"aio_return\");\n\n    std::cout << \"res: \" << res << std::endl;\n    std::cout << \"aio_read: \" << (char *)aio.aio_buf << std::endl;\n\n    remove(\"file.txt\");\n\n\n    return 0;\n}\n```\n\n6. aio_cancel()\n\naio_cancel() 函数允许用户取消对某个文件描述符执行的一个或所有 I/O 请求。\n\n如果是**取消一个请求**，需提供 fd 和 aiocb 指针。如果请求被成功取消，会返回 AIO_CANCELED。如果请求已完成即取消失败，会返回 AIO_NOTCANCELED。\n\n如果是取消对某个 fd 的**所有请求**。需提供这个 fd，并将 aiocb 参数设置为 NULL。如果所有的请求都取消了，会返回 AIO_CANCELED；如果至少有一个请求没有被取消，会返回 AIO_NOT_CANCELED；如果没有一个请求可以被取消，那么这个函数就会返回 AIO_ALLDONE。然后，可以使用 aio_error() 来验证每个 AIO 请求。如果某请求已经被取消了，那么 aio_error() 就会返回 -1，并且 errno 会被设置为 ECANCELED。\n\n```c\nint aio_cancel(int fd, struct aiocb *aiocbp);\n```\n\n7. lio_listio()\n\n**lio_listio() 函数可用于同时发起多个传输，使得用户可以在一个系统调用中启动大量的 I/O 操作。**\n\nmode 参数可以是 LIO_WAIT 或 LIO_NOWAIT。LIO_WAIT 会阻塞这个调用，直到所有的 I/O 都完成为止。但是若是 LIO_NOWAIT 模型，在 I/O 操作进行排队之后，该函数就会返回。list 是一个 aiocb 引用的指针的列表，最大元素的个数是由 nitems 定义的。如果 list 的元素为 nullptr，lio_listio() 会将其忽略。最后一个参数 sevp 暂时不用考虑，直接设置为 nullptr 即可。\n\n```c\nint lio_listio(int mode, struct aiocb *const aiocb_list[], int nitems, struct sigevent *sevp);\n```\n\n当使用这个函数的时候，aiocb 结构体中的成员 aio_lio_opcode 需要被设置。因为批量执行 I/O 的缘故，没有办法单独调用 aio_read() 或者 aio_write() 这些，因此需要设置标志以后托管给 lio_listio() 执行。aio_lio_opcode 值如下表：\n\n|    值     |      含义      |\n| :-------: | :------------: |\n| LIO_READ  | 发起异步读操作 |\n| LIO_WRITE | 发起异步写操作 |\n|  LIO_NOP  |  忽略该 aiocb  |\n\n经过修改后的示例程序如下：\n\n```cpp\n#include <iostream>\n#include <cstring>\n\n#include <aio.h>\n#include <fcntl.h>\n\n\n#define ERR_EXIT(func) \\\n    do                 \\\n    {                  \\\n        perror(func);  \\\n        exit(1);       \\\n    } while (0)\n\n\nint main()\n{\n    FILE *pFile = fopen(\"file.txt\", \"w\");\n    if (!pFile) ERR_EXIT(\"fopen\");\n\n    fputs(\"hello globalfifo module.\", pFile);\n\n    fclose(pFile);\n\n    int fd = open(\"file.txt\", O_RDONLY);\n    if (-1 == fd) ERR_EXIT(\"open\");\n\n    struct aiocb aio;\n    std::memset(&aio, 0, sizeof(aio));\n\n    aio.aio_buf = malloc(BUFSIZ + 1);\n    if (!aio.aio_buf) ERR_EXIT(\"malloc\");\n\n    aio.aio_fildes = fd;\n    aio.aio_nbytes = BUFSIZ;\n    aio.aio_offset = 0;\n    aio.aio_lio_opcode = LIO_READ; // 使用 lio_listio() 需要额外添加的一项。\n\n    struct aiocb *aioArr[5] = {nullptr};\n    aioArr[3] = &aio;\n\n    int res = lio_listio(LIO_WAIT, aioArr, sizeof(aioArr) / sizeof(aioArr[0]), nullptr);\n    if (-1 == res) ERR_EXIT(\"lio_listio\");\n\n    res = aio_return(&aio);\n    if (-1 == res) ERR_EXIT(\"aio_return\");\n\n    std::cout << \"res: \" << res << std::endl;\n    std::cout << \"aio_read: \" << (char *)aio.aio_buf << std::endl;\n\n    remove(\"file.txt\");\n\n\n    return 0;\n}\n```\n\n### 内核 AIO 与 libaio\n\nLinux AIO 也可以**由内核空间实现**。异步 I/O 是 Linux 2.6 以后版本内核的一个标准特性。对于块设备而言，AIO 可以一次性发出大量的 read/write 调用并且通过通用块层的 I/O 调度来获得更好的性能，用户程序也可以减少过多的同步负载，还可以在业务逻辑中更灵活地进行并发控制和负载均衡。相较于 glibc 的用户空间多线程同步等实现也减少了线程的负载和上下文切换等。对于网络设备而言，在 socket 层面上，也可以使用 AIO，让 CPU 和网卡的收发动作充分交叠以改善吞吐性能。\n\n在用户空间中，需要结合 libaio 库进行内核 AIO 的系统调用。首先需要安装 libaio 库：\n\n```bash\nsudo apt install libaio-dev\n```\n\nlibaio 提供的内核 AIO 的 API 主要包括：\n\n```c\nint io_setup(int maxevents, io_context_t *ctxp);\nint io_destroy(io_context_t ctx);\nint io_submit(io_context_t ctx, long nr, struct iocb *ios[]);\nint io_cancel(io_context_t ctx, struct iocb *iocb, struct io_event *evt);\nint io_getevents(io_context_t ctx, long min_nr, long nr, struct io_event *events, struct timespec *timeout);\nvoid io_set_callback(struct iocb *iocb, io_callback_t cb);\nvoid io_prep_pread(struct iocb *iocb, int fd, void *buf, size_t count, long long offset);\nvoid io_prep_pwrite(struct iocb *iocb, int fd, void *buf, size_t count, long long offset);\nvoid io_prep_preadv(struct iocb *iocb, int fd, const struct iovec *iov, int iovcnt, long long offset);\nvoid io_prep_pwritev(struct iocb *iocb, int fd, const struct iovec *iov, int iovcnt, long long offset);\n```\n\nAIO 的读写请求都用 io_submit() 下发。下发前通过 io_prep_pwrite() 和 io_prep_pread() 生成 iocb 的结构体。作为 io_submit() 的参数。这个结构体指定了读写类型、起始地址、长度和设备标志符等信息。读写请求下发之后，使用 io_getevents() 函数等待 I/O 完成事件。io_set_callback() 则可设置一个 AIO 完成的回调函数。\n\n示例程序见：[https://github.com/DavidingPlus/linux-kernel-learning/tree/globalfifo/snippet/LibAioTest](https://github.com/DavidingPlus/linux-kernel-learning/tree/globalfifo/snippet/LibAioTest)\n\n### AIO 与设备驱动\n\n在 Linux 4.0 版本下，用户空间调用 io_submit() 后，对应于用户传递的每一个 iocb 结构，内核会生成一个与之对应的 kiocb 结构。file_operations 包含 3 个与 AIO 相关的成员函数。\n\nio_submit() 系统调用间接引起了 file_operations 中的 aio_read() 和 aio_write() 的调用。\n\n```c\nssize_t (*aio_read) (struct kiocb *iocb, const struct iovec *iov, unsigned long nr_segs, loff_t pos);\nssize_t (*aio_write) (struct kiocb *iocb, const struct iovec *iov, unsigned long nr_segs, loff_t pos);\nint (*aio_fsync) (struct kiocb *iocb, int datasync);\n```\n\nLinux 5.0 版本之后的这三个接口可能已经改名（或删除并重新实现了一套逻辑），可能的对应关系如下。暂不用深究。\n\n```c\nssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\nssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\nint (*iopoll)(struct kiocb *kiocb, bool spin);\n```\n\n**AIO 一般由内核空间的通用代码处理，对于块设备和网络设备而言，一般在Linux核心层的代码已经解决。字符设备驱动一般不需要实现 AIO 支持。**Linux 内核中对字符设备驱动实现 AIO 的特例包括 drivers/char/mem.c 里实现的 null、zero 等，由于 zero 这样的虚拟设备其实也不存在在要去读的时候读不到东西的情况，所以 aio_read_zero() 本质上也不包含异步操作。\n\n## 小结\n\nLinux 中的异步 I/O 使得应用程序在等待 I/O 操作的同时进行其他操作。\n\n使用信号可以实现设备驱动与用户程序之间的异步通知。总体而言，设备驱动和用户空间要分别完成 3 项对应的工作，用户空间设置文件的拥有者、FASYNC 标志及捕获信号。内核空间响应对文件的拥有者、FASYNC 标志的设置并在资源可获得时释放信号。\n\nLinux 2.6 以后的内核包含对 AIO 的支持，它为用户空间提供了统一的异步 I/O 接口。另外，glibc 也提供了一个不依赖于内核的，位于用户空间的 AIO 支持。\n\n# 中断与时钟\n\n**由于中断服务程序的执行并不存在于进程上下文中，所以要求中断服务程序的时间要尽量短。**故 Linux 在中断处理中引入了**顶半部和底半部分离**的机制。另外，内核对时钟的处理也采用中断方式，而内核软件定时器最终依赖于时钟中断。\n\n## 中断与定时器\n\n中断是指 CPU 在执行程序的过程中，出现了某些突发事件急待处理，CPU 必须暂停当前程序的执行，转去处理突发事件，处理完毕后又返回原程序被中断的位置继续执行。\n\n根据中断的来源，中断可分为**内部中断和外部中断**。内部中断的中断源来自 CPU 内部（软件中断指令、溢出、除法错误，操作系统从用户态切换到内核态需借助 CPU 内部的软件中断等）。外部中断的中断源来自 CPU 外部，由外设提出请求。\n\n根据中断是否可以屏蔽，中断可分为**可屏蔽中断与不可屏蔽中断**（NMI）。可屏蔽中断可以通过设置中断控制器寄存器等方法被屏蔽，屏蔽后，该中断不再得到响应。不可屏蔽中断不能被屏蔽。\n\n根据中断入口跳转方法的不同，中断可分为**向量中断和非向量中断**。采用向量中断的 CPU 通常为不同的中断分配不同的中断号。当检测到某中断号的中断到来后，就自动跳转到与该中断号对应的地址执行。不同中断号的中断有不同的入口地址。非向量中断的多个中断共享一个入口地址，进入该入口地址后，再通过软件判断中断标志来识别具体是哪个中断。也就是说，**向量中断由硬件提供中断服务程序入口地址，非向量中断由软件提供中断服务程序入口地址。**\n\n## 中断处理程序架构\n\n设备的中断会打断内核进程中的正常调度和运行，系统对更高吞吐率的追求势必要求中断服务程序尽量短小精悍。但在大多数真实的系统中，当中断到来时，要完成的工作往往并不会是短小的，它可能要进行较大量的耗时处理。\n\n为了在**中断执行时间尽量短和中断处理需完成的工作尽量大**之间找到一个平衡点，Linux 将中断处理程序分解为两个半部：顶半部（Top Half）和底半部（Bottom Half）。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241125093035072.png\" alt=\"image-20241125093035072\" style=\"zoom:75%;\" />\n\n**顶半部用于完成尽量少的比较紧急的功能。**它往往只是简单地读取寄存器中的中断状态，并在清除中断标志后就进行“登记中断”的工作。“登记中断”意味着将底半部处理程序挂到该设备的底半部执行队列中去。这样，顶半部执行的速度就会很快，从而可以服务更多的中断请求。\n\n因此，**中断处理工作的重心就落在了底半部的头上，需用它来完成中断事件的绝大多数任务。**底半部几乎做了中断处理程序所有的事情，而且可以被新的中断打断，这也是底半部和顶半部的最大不同。顶半部往往被设计成不可中断。底半部相对来说并不是非常紧急的，而且相对比较耗时，不在硬件中断服务程序中执行。\n\n但设计是这样，现实是灵活的。如果中断要处理的工作本身很少，完全可以直接在顶半部中全部完成。**真正的硬件中断服务程序都应该 尽量短。**许多操作系统都提供了中断上下文和非中断上下文相结合的机制，将中断的耗时工作保留到非中断上下文去执行。\n\n在 Linux 中，查看 `/proc/interrupts` 文件可以获得系统中断的统计信息，知道每个中断号在 CPU 上发生的次数。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241125094233332.png\" alt=\"image-20241125094233332\" style=\"zoom:60%;\" />\n\n## 中断编程\n\n### 申请和释放中断\n\n1. 申请 irq\n\n申请 irq 使用接口 request_irq()。\n\n```c\n// irq 是要申请的硬件中断号。\n// handler 是向系统登记的顶半部的中断处理函数，是一个回调函数。中断发生时，系统调用这个函数，dev 参数将被传递给它。\n// flags 是中断处理的属性，可以指定中断的触发方式以及处理方式。在触发方式上，可以是 IRQF_TRIGGER_RISING、IRQF_TRIGGER_FALLING、IRQF_TRIGGER_HIGH、IRQF_TRIGGER_LOW 等。在处理方式上，若设置了 IRQF_SHARED，则表示多个设备共享中断。\n// 此函数返回 0 表示成功，返回 -EINVAL 表示中断号无效或处理函数指针为 NULL，返回 -EBUSY 表示中断已被占用且不能共享。\nint request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);\n```\n\n当然，还有另一个接口 devm_request_irq()。与 request_irq() 的区别是 `devm_` 开头的 API 申请的是内核 managed 的资源，一般不需要在出错处理和 remove() 接口里再显式的释放。有点类似 Java 的垃圾回收机制。\n\n顶半部 hander 类型 irq_handler_t 的定义为：\n\n```c\ntypedef irqreturn_t (*irq_handler_t)(int, void *);\n\nenum irqreturn {\n\tIRQ_NONE\t\t= (0 << 0),\n\tIRQ_HANDLED\t\t= (1 << 0),\n\tIRQ_WAKE_THREAD\t\t= (1 << 1),\n};\n\ntypedef enum irqreturn irqreturn_t;\n```\n\n2. 释放 irq\n\n释放 irq 使用接口 free_irq()。\n\n```c\nconst void *free_irq(unsigned int irq, void *dev);\n```\n\n### 使能和屏蔽中断\n\n下面函数用于使能和屏蔽一个中断源。\n\n如果在 n 号中断的顶半部调用 disable_irq(n)，会引起系统的死锁，这种情况下，只能调用 disable_irq_nosync(n)。\n\n```c\nvoid enable_irq(unsigned int irq);\nvoid disable_irq(unsigned int irq);\nvoid disable_irq_nosync(unsigned int irq); // 与上面的区别在于本函数会立即返回，disable_irq() 会等待目前的中断完成。\n```\n\n下面函数用于屏蔽本 CPU 内的所有中断。\n\n区别在于 local_irq_save(flags) 会将目前的中断状态保存在 flags 中（注意 flags 为 unsigned long 类型，被直接传递，而不是通过指针）。后者禁止中断而不保存状态。\n\n```c\n#define local_irq_disable()                      \\\n    do                                           \\\n    {                                            \\\n        bool was_disabled = raw_irqs_disabled(); \\\n        raw_local_irq_disable();                 \\\n        if (!was_disabled)                       \\\n            trace_hardirqs_off();                \\\n    } while (0)\n\n#define local_irq_save(flags)                \\\n    do                                       \\\n    {                                        \\\n        raw_local_irq_save(flags);           \\\n        if (!raw_irqs_disabled_flags(flags)) \\\n            trace_hardirqs_off();            \\\n    } while (0)\n```\n\n与上面对应的使能函数如下。\n\n```c\n#define local_irq_enable()      \\\n    do                          \\\n    {                           \\\n        trace_hardirqs_on();    \\\n        raw_local_irq_enable(); \\\n    } while (0)\n\n#define local_irq_restore(flags)             \\\n    do                                       \\\n    {                                        \\\n        if (!raw_irqs_disabled_flags(flags)) \\\n            trace_hardirqs_on();             \\\n        raw_local_irq_restore(flags);        \\\n    } while (0)\n```\n\n**前缀 `local_` 表示作用范围在本 CPU 内。**\n\n### 底半部机制\n\nLinux 底半部机制主要涉及 tasklet、工作队列、软中断和线程化 irq。\n\n#### tasklet\n\n**tasklet 的执行上下文是软中断，执行时机通常是顶半部返回的时候。**我们只需定义 tasklet 及其处理函数，并关联二者即可。\n\n```c\nvoid my_tasklet_func(unsigned long);                // 定义一个处理函数\nDECLARE_TASKLET(my_tasklet, my_tasklet_func, data); // 定义一个 tasklet 结构 my_tasklet，与 my_tasklet_func(data) 函数相关联\n```\n\nDECLARE_TASKLET(my_tasklet，my_tasklet_func，data) 实现了定义名称为 my_tasklet 的 tasklet，并将其与 my_tasklet_func() 这个函数绑定，并且传入函数的参数为 data。\n\n需要调度 tasklet 时使用 tasklet_schedule() 函数就能使系统在适当的时候（例如在顶半部的代码中）进行调度运行。\n\n```c\ntasklet_schedule(&my_tasklet);\n```\n\n使用 tasklet 作为底半部处理中断的设备驱动程序代码模板如下：\n\n```c\n// 定义 tasklet 和底半部函数并将它们关联\nvoid xxx_do_tasklet(unsigned long);\nDECLARE_TASKLET(xxx_tasklet, xxx_do_tasklet, 0);\n\n// 中断处理底半部\nvoid xxx_do_tasklet(unsigned long)\n{\n    ...\n}\n\n// 中断处理顶半部\nirqreturn_t xxx_interrupt(int irq, void *dev_id)\n{\n    ... \n\n    tasklet_schedule(&xxx_tasklet);\n\n    ...\n}\n\n// 设备驱动模块加载函数\nint __init xxx_init(void)\n{\n    ...\n\n    // 申请中断\n    result = request_irq(xxx_irq, xxx_interrupt, 0, \"xxx\", NULL);\n\n    ...\n\n    return IRQ_HANDLED;\n}\n\n// 设备驱动模块卸载函数\nvoid __exit xxx_exit(void)\n{\n    ...\n\n    // 释放中断\n    free_irq(xxx_irq, xxx_interrupt);\n\n    ...\n}\n```\n\n上述程序在模块加载函数中申请中断，并在模块卸载函数中释放它。对应于 xxx_irq 的顶半部的中断处理程序被设置为 xxx_interrupt() 函数。在这个函数中，tasklet_schedule(&xxx_tasklet) 调度 tasklet 的函数 xxx_do_tasklet()，会在适当的时候执行，用于处理底半部。\n\n#### 工作队列\n\n工作队列的使用方法和 tasklet 很相似，但**工作队列的执行上下文是内核线程，因此可以调度和睡眠**。\n\n与 tasklet 类似，下面用于定义工作队列和底半部执行函数：\n\n```c\nstruct work_struct {\n\tatomic_long_t data;\n\tstruct list_head entry;\n\twork_func_t func;\n#ifdef CONFIG_LOCKDEP\n\tstruct lockdep_map lockdep_map;\n#endif\n};\n\nstruct work_struct my_wq; // 定义一个工作队列\nvoid my_wq_func(struct work_struct *work); // 定义一个处理函数\n```\n\n通过 INIT_WORK() 初始化工作队列并与处理函数绑定。\n\n```c\nINIT_WORK(&my_wq, my_wq_func); // 初始化工作队列并将其与处理函数绑定\n```\n\n与 tasklet_schedule() 对应的用于调度工作队列执行的函数为 schedule_work()。\n\n```c\nschedule_work(&my_wq); // 调度工作队列执行\n```\n\n同理可总结代码模板如下：\n\n```c\n// 定义工作队列和关联函数\nstruct work_struct xxx_wq;\nvoid xxx_do_work(struct work_struct *work);\n\n// 中断处理底半部\nvoid xxx_do_work(struct work_struct *work)\n{\n    ...\n}\n\n// 中断处理顶半部\nirqreturn_t xxx_interrupt(int irq, void *dev_id)\n{\n    ...\n\n    schedule_work(&xxx_wq);\n    \n    ...\n\n    return IRQ_HANDLED;\n}\n\n// 设备驱动模块加载函数\nint xxx_init(void)\n{\n    ...\n\n    // 申请中断\n    result = request_irq(xxx_irq, xxx_interrupt, 0, \"xxx\", NULL);\n\n    ...\n\n    // 初始化工作队列\n    INIT_WORK(&xxx_wq, xxx_do_work);\n\n    ...\n}\n\n// 设备驱动模块卸载函数\nvoid xxx_exit(void)\n{\n    ...\n\n    // 释放中断\n    free_irq(xxx_irq, xxx_interrupt);\n\n    ...\n}\n```\n\n与 tasklet 不同的是，在驱动模块加载函数中加入了初始化工作队列的部分。\n\n工作队列早期的实现是在每个 CPU 核上创建一个 worker 内核线程，所有在这个核上调度的工作都在该 worker 线程中执行，其并发性显然差强人意。在 Linux 2.6 以后，转而实现了 Concurrency-managed workqueues，简称 cmwq。它会自动维护工作队列的线程池以提高并发性，同时保持了 API 的向后兼容。\n\n#### 软中断\n\n**软中断（softirq）也是一种传统的底半部处理机制，执行时机通常是顶半部返回的时候。tasklet 是基于软中断实现的，因此也运行于软中断上下文。**\n\n在 Linux 内核中，用 softirq_action 结构体表示一个软中断，包含软中断处理函数指针和传递给该函数的参数。使用 open_softirq() 函数可以注册软中断对应的处理函数，而 raise_softirq() 函数可以触发一个软中断。\n\n```c\nstruct softirq_action\n{\n    void (*action)(struct softirq_action *);\n};\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *));\nvoid raise_softirq(unsigned int nr);\n```\n\n**软中断和 tasklet 运行于软中断上下文，仍属于原子上下文的一种，而工作队列则运行于进程上下文，即内核线程。故在软中断和 tasklet 处理函数中不允许睡眠，在工作队列处理函数中允许睡眠。**\n\n内核中用于禁止和使能软中断及 tasklet 底半部机制的函数如下：\n\n```c\nvoid local_bh_disable(void);\nvoid local_bh_enable(void)\n```\n\n内核中采用 softirq 的地方包括 HI_SOFTIRQ、TIMER_SOFTIRQ、NET_TX_SOFTIRQ、NET_RX_SOFTIRQ、SCSI_SOFTIRQ、TASKLET_SOFTIRQ 等。一般来说，驱动的编写者不会也不宜直接使用 softirq。因此，软中断稍微了解即可。\n\n总结一下硬中断、软中断和信号的区别。**硬中断是外部设备对 CPU 的中断，软中断（softirq）是中断底半部的一种处理机制，而信号则是由内核或其他进程对某个进程的中断。在涉及系统调用的场合，人们也常说通过软中断陷入内核（其实就是计组里面背的那个软中断），此时软中断的概念是指由软件指令引发的中断，和这里的 softirq 是两个完全不同的概念。**\n\n软中断以及基于软中断的 tasklet 如果在某段时间内大量出现的话，内核会把后续软中断放入 ksoftirqd 内核线程中执行。总的来说，**中断优先级高于软中断，软中断又高于任何一个线程**。软中断适度线程化，可以缓解高负载情况下系统的响应。\n\n#### threaded_irq\n\n在 Linux 内核中，除了可以通过 request_irq()、devm_request_irq() 申请中断以外，还可以通过 request_threaded_irq() 和 devm_request_threaded_irq() 申请。\n\n这两个函数比上面函数多一个参数 thread_fn。用这两个 API 申请中断的时候，内核会为相应的中断号分配一个对应的内核线程，来执行一些东西。这个线程只针对这个中断号，如果其他中断也通过 request_threaded_irq() 申请，会得到新的内核线程。\n\n```c\nint request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long flags, const char *name, void *dev);\n\nint devm_request_threaded_irq(struct device *dev, unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id);\n```\n\n**参数 handler 对应的函数执行于中断上下文，thread_fn 参数对应的函数则执行于内核线程。**如果顶半部 handler 结束的时候，返回值是 IRQ_WAKE_THREAD，内核会调度对应线程执行底半部 thread_fn 对应的函数。\n\n我个人理解而言，handler 是处理顶半部机制的函数，thread_fn 是处理底半部机制的函数。二者要求传入的都是回调函数的函数指针。与工作队列相比，尽管二者的底层实现可能不一样，但给使用者的感受就是 threaded_irq 是对用户封装了一层的工作队列。\n\nrequest_threaded_irq() 和 devm_request_threaded_irq() 支持在 irqflags 中设置 IRQF_ONESHOT 标记， 这样内核会自动帮助我们在中断上下文中屏蔽对应的中断号。在内核调度 thread_fn 执行后，重新使能该中断号。对于我们无法在上半部清除中断的情况，IRQF_ONESHOT 特别有用，避免了中断服务程序一退出，中断就洪泛的情况。\n\nhandler 参数可以设置为 NULL，这样内核会使用默认的 irq_default_primary_handler() 代替 handler，并会使用 IRQF_ONESHOT 标记。\n\n```c\n/*\n * Default primary interrupt handler for threaded interrupts. Is\n * assigned as primary handler when request_threaded_irq is called\n * with handler == NULL. Useful for oneshot interrupts.\n */\nstatic irqreturn_t irq_default_primary_handler(int irq, void *dev_id)\n{\n\treturn IRQ_WAKE_THREAD;\n}\n```\n\n## 中断共享\n\n多个设备共享一根硬件中断线的情况在实际的硬件系统中广泛存在。Linux 也支持这种共享方法。\n\n1. 共享中断的多个设备在申请中断时，都应该使用 IRQF_SHARED 标志，而且一个设备以 IRQF_SHARED 申请某中断成功的前提是该中断未被申请，或该中断虽然被申请了，但是之前申请该中断的所有设备也都以 IRQF_SHARED 标志申请该中断。\n2. 尽管内核模块可访问的全局地址都可以作为 request_irq(..., void *dev) 的最后一个参数 dev，但是设备结构体指针显然是可传入的最佳参数。\n3. 在中断到来时，会遍历执行共享此中断的所有中断处理程序，直到某一个函数返回 IRQ_HANDLED。在中断处理程序顶半部中，应根据硬件寄存器中的信息比照传入的 dev 参数迅速地判断是否为本设备的中断，若不是，应迅速返回 IRQ_NONE。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241125184336914.png\" alt=\"image-20241125184336914\" style=\"zoom:75%;\" />\n\n以下是使用共享中断的设备驱动程序模板：\n\n```c\n// 中断处理顶半部\nirqreturn_t xxx_interrupt(int irq, void *dev_id)\n{\n    ...\n\n    int status = read_int_status(); // 获知中断源\n    if (!is_myint(dev_id, status))      // 判断是否为本设备中断\n        return IRQ_NONE;                // 不是本设备中断，立即返回\n\n    // 是本设备中断，进行处理\n    ...\n\n    return IRQ_HANDLED; // 返回IRQ_HANDLED表明中断已被处理\n}\n\n// 设备驱动模块加载函数\nint xxx_init(void)\n{\n    ...\n\n    // 申请共享中断\n    result = request_irq(sh_irq, xxx_interrupt, IRQF_SHARED, \"xxx\", xxx_dev);\n\n    ...\n}\n\n// 设备驱动模块卸载函数\nvoid xxx_exit(void)\n{\n    ...\n\n    // 释放中断\n    free_irq(xxx_irq, xxx_interrupt);\n\n    ...\n}\n```\n\n## 内核定时器\n\n### 内核定时器编程\n\n软件意义上的定时器最终依赖硬件定时器来实现，内核在时钟中断发生后检测各定时器是否到期，到期后的定时器处理函数将作为软中断在底半部执行。实质上，**时钟中断处理程序会唤起 TIMER_SOFTIRQ 软中断，运行当前处理器上到期的所有定时器。**\n\nLinux 内核提供了一组函数和数据结构用于定时触发工作和完成某周期性的任务。编程者在多数情况无需关心具体的内核和硬件行为。\n\n书中内容基于 Linux 4.0 版本，在 Linux 5 中 API 已发生变动，参照文章 [https://blog.csdn.net/ZHONGCAI0901/article/details/120484815](https://blog.csdn.net/ZHONGCAI0901/article/details/120484815) 一同学习。\n\n1. timer_list\n\ntimer_list 结构体的实例对应一个定时器。当定时器期满以后，function() 函数将被执行，expires 是定时器到期的时间。\n\n```c\nstruct timer_list\n{\n    /*\n     * All fields that change during normal runtime grouped to the\n     * same cacheline\n     */\n    struct hlist_node entry;\n    unsigned long expires;\n    void (*function)(struct timer_list *);\n    u32 flags;\n\n#ifdef CONFIG_LOCKDEP\n    struct lockdep_map lockdep_map;\n#endif\n};\n```\n\n2. 初始化定时器\n\n`__init_timer` 是一个宏函数。用于初始化 timer_list 结构体，并设置其中的函数、flags。\n\n```c\n#define __init_timer(_timer, _fn, _flags)\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\t\\\n\t\tinit_timer_key((_timer), (_fn), (_flags), #_timer, &__key);\\\n\t} while (0)\n\n#define __init_timer_on_stack(_timer, _fn, _flags)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstatic struct lock_class_key __key;\t\t\t\\\n\t\tinit_timer_on_stack_key((_timer), (_fn), (_flags),\t\\\n\t\t\t\t\t#_timer, &__key);\t\t \\\n\t} while (0)\n```\n\ntimer_setup 看定义应该是 `__init_timer` 的别名。\n\n```c\n#define timer_setup(timer, callback, flags)\t\t\t\\\n\t__init_timer((timer), (callback), (flags))\n\n#define timer_setup_on_stack(timer, callback, flags)\t\t\\\n\t__init_timer_on_stack((timer), (callback), (flags))\n```\n\n`__TIMER_INITIALIZER(_function, _flags)` 宏用于赋值定时器结构体的 function、flags 成员。\n\nDEFINE_TIMER 是定义并初始化名为 _name 的定时器快捷方式，从宏定义而知显而易见。\n\n```c\n#define __TIMER_INITIALIZER(_function, _flags) {\t\t\\\n\t\t.entry = { .next = TIMER_ENTRY_STATIC },\t\\\n\t\t.function = (_function),\t\t\t\\\n\t\t.flags = (_flags),\t\t\t\t\\\n\t\t__TIMER_LOCKDEP_MAP_INITIALIZER(\t\t\\\n\t\t\t__FILE__ \":\" __stringify(__LINE__))\t\\\n\t}\n\n#define DEFINE_TIMER(_name, _function)\t\t\t\t\\\n\tstruct timer_list _name =\t\t\t\t\\\n\t\t__TIMER_INITIALIZER(_function, 0)\n```\n\n3. 添加定时器\n\n此函数用于注册内核定时器，将定时器加入到内核动态定时器链表中。\n\n```c\nvoid add_timer(struct timer_list *timer);\n```\n\n4. 删除定时器\n\ndel_timer_sync() 是 del_timer() 的同步版，在删除一个定时器时需等待其被处理完，故其调用不能发生在中断上下文。\n\n```c\nint del_timer(struct timer_list * timer);\nint del_timer_sync(struct timer_list *timer)\n```\n\n5. 修改定时器的到期时间 expires\n\n此函数用于修改定时器的到期时间，在新的被传入的 expires 到来后才会执行定时器函数。\n\n```c\nint mod_timer(struct timer_list *timer, unsigned long expires);\n```\n\n定时器的时间基于 jiffies，在修改超时时间时，一般使用 2 种方法。\n\n从下面的示例可以看出，**expires 的含义是过期的时间点，而非经过多少时间过期，故需要加上基准时间 jiffies。**\n\n```c\nmod_timer(&timer, jiffies + xxx); // xxx 表示多少个滴答后超时，也就是 xxx * 10ms\nmod_timer(&timer, jiffies + 2 * HZ); // HZ 等于 CONFIG_HZ，2 * HZ 就相当于 2 秒\n```\n\n在 Linux 5 版本以后，**mod_timer() 的含义不仅仅是更改定时器的到期时间，同时会将其添加到内核动态定时器链表中。**与 add_timer() 不同的是 add_timer() 使用的到期时间是其结构体自己内部预先设置的时间，mod_timer() 相当于做了赋值操作后再添加。关于 mod_timer() 新的含义，通过源码也可以猜到：\n\n```c\nvoid add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\t__mod_timer(timer, timer->expires, MOD_TIMER_NOTPENDING);\n}\nEXPORT_SYMBOL(add_timer);\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}\nEXPORT_SYMBOL(mod_timer);\n```\n\n另外，**当定时器到期以后，执行完回调函数后，会从内核动态定时器链表中删除。如果需要周期性地执行，需要手动每次在过期以后重新添加。**从下面的模板中也可见一斑。\n\n6. 使用模板\n\n以下是一个使用内核定时器的模板：\n\n```c\n// xxx 设备结构体\nstruct xxx_dev\n{\n    struct cdev cdev;\n\n    ...\n\n    timer_list xxx_timer; // 设备要使用的定时器\n};\n\n// xxx 驱动中的加载函数\nxxx_init(…)\n{\n    struct xxx_dev *dev = filp->private_data;\n    ...\n\n    // 初始化定时器\n    timer_setup(&dev->xxx_timer, xxx_do_timer, 0);\n    // 设备结构体指针作为定时器处理函数参数\n    dev->xxx_timer.expires = jiffies + delay;\n    // 添加（注册）定时器\n    add_timer(&dev->xxx_timer);\n\n    ...\n}\n\n// xxx 驱动中的卸载函数\nxxx_exit(…)\n{\n    ...\n\n    // 删除定时器\n    del_timer(&dev->xxx_timer);\n\n    ...\n}\n\n// 定时器处理函数\nstatic void xxx_do_timer(unsigned long arg)\n{\n    struct xxx_device *dev = (struct xxx_device *)(arg);\n\n    ...\n\n    // 调度定时器再执行\n    // 在实际使用中，定时器的到期时间往往是在目前 jiffies 的基础上添加一个时延，若为 Hz，则表示延迟 1s。\n    dev->xxx_timer.expires = jiffies + delay;\n    // 在定时器处理函数中，在完成相应的工作后，往往会延后 expires 并将定时器再次添加到内核定时器链表中，以便定时器能再次被触发。\n    add_timer(&dev->xxx_timer);\n\n    ...\n}\n```\n\nLinux 内核在支持 tickless 和 NO_HZ 模式后，内核也包含对 hrtimer（高精度定时器）的支持，它可以支持到微秒级别的精度。内核也定义了 hrtimer 结构体，hrtimer_set_expires()、hrtimer_start_expires()、hrtimer_forward_now()、hrtimer_restart() 等类似的 API 来完成 hrtimer 的设置、时间推移以及到期回调。\n\n### delayed_work\n\n对于周期性的任务，除定时器以外，还可利用一套封装得很好的快捷机制，本质是利用工作队列和定时器实现，即 delayed_work。\n\n```c\nstruct delayed_work {\n\tstruct work_struct work;\n\tstruct timer_list timer;\n\n\t/* target workqueue and CPU ->timer uses to queue ->work */\n\tstruct workqueue_struct *wq;\n\tint cpu;\n};\n\nstruct work_struct {\n\tatomic_long_t data;\n\tstruct list_head entry;\n\twork_func_t func;\n#ifdef CONFIG_LOCKDEP\n\tstruct lockdep_map lockdep_map;\n#endif\n};\n```\n\n可以通过如下函数调度一个 delayed_work 在指定的延时以后运行：\n\n```c\nbool schedule_delayed_work(struct delayed_work *dwork, unsigned long delay);\n```\n\n当延时 delay 到来以后，delayed_work 结构体的 work_struct 类型成员 dwork 的 work_func_t 类型成员 func() 函数会被执行，work_func_t 定义为：\n\n```c\nvoid (*work_func_t)(struct work_struct *work);\n```\n\n另外，delay 参数的单位是 jiffies，一种常见的用法如下：\n\n```c\n// msecs_to_jiffies() 用于将毫秒转化为 jiffies。\nschedule_delayed_work(&work, msecs_to_jiffies(poll_interval));\n```\n\n同定时器，如果需要周期性的执行任务，一般需要手动在工作函数再次调用 schedule_delayed_work()，周而复始。\n\n以下函数用于取消 delay_work：\n\n```c\nbool cancel_delayed_work(struct delayed_work *dwork);\nbool cancel_delayed_work_sync(struct delayed_work *dwork);\n```\n\n### 秒字符设备\n\n编写一个字符设备 second（即“秒”）的驱动。它被打开的时候初始化一个定时器，并添加到内核定时器链表中，每秒在内核日志中输出一次当前的 jiffies，读取该字符设备的时候返回当前定时器的秒数。\n\n自己实现的版本：[https://github.com/DavidingPlus/linux-kernel-learning/tree/second](https://github.com/DavidingPlus/linux-kernel-learning/tree/second)\n\n## 内核延时\n\n参考文章：\n\n- [https://blog.csdn.net/liangzc1124/article/details/120835795](https://blog.csdn.net/liangzc1124/article/details/120835795)\n- [https://www.cnblogs.com/xihong2014/p/6740876.html](https://www.cnblogs.com/xihong2014/p/6740876.html)\n\n注：这两篇文章设计的 API 都不是 Linux 5 及其以后的，所以建议参考原理而非照搬 API。\n\n1. 短延时\n\nLinux 内核提供了三个函数分别进行纳秒、微妙和毫秒延迟，在 Linux 5 以后已改为宏函数。\n\n这几个短延时的本质是**忙等待**，根据 CPU 频率进行一定次数的循环。\n\n```c\n#define ndelay(n) { ... }\n#define udelay(n) { ... }\n#define mdelay(n) { ... }\n```\n\n2. 中等延时\n\n毫秒时延（以及更大的秒时延）已经比较大了。在内核中，最好不要直接使用 mdelay() 函数，因为忙等将耗费 CPU 资源。对于毫秒级以上的时延，内核提供了下述函数。\n\n这几个中等延时期间，**程序进入睡眠状态**。并且受系统 Hz 以及进程调度的影响，msleep() 类似函数的精度是有限的。\n\n```c\nvoid msleep(unsigned int msecs); // 延时 msecs 毫秒，程序进入睡眠，且不可被打断。\nunsigned long msleep_interruptible(unsigned int msecs); // 延时 msecs 毫秒，程序进入睡眠，但可以被打断。\nvoid ssleep(unsigned int seconds); // 延时 seconds 秒，程序进入睡眠，且不可被打断。\n```\n\n3. 长延时\n\n内核中延时的一个很直观的方法是比较当前的 jiffies 和目标 jiffies，直到未来的 jiffies 达到目标 jiffies。\n\n从下面的使用方法看出，很类似于内核定时器的 expires，delay 也是表示延时到期的时间点。\n\n```c\n// 延时 100 个滴答\nunsigned long delay = jiffies + 100;\nwhile (time_before(jiffies, delay)) { }\n\n// 延时 2s\nunsigned long delay = jiffies + 2 * Hz;\nwhile (time_before(jiffies, delay)) { }\n```\n\n长延时使用的宏函数 time_before() 和 time_after() 的定义如下，可见仅仅是对两个值做了一个大小比较。\n\ntime_before() 的第一个参数是当前 jiffies，第二个参数是目标 jiffies，time_after() 相反。\n\n```c\n#define time_after(a,b)\t\t\\\n\t(typecheck(unsigned long, a) && \\\n\t typecheck(unsigned long, b) && \\\n\t ((long)((b) - (a)) < 0))\n\n#define time_before(a,b)\ttime_after(b,a)\n```\n\n结合上述可以发现，这样使用长延时是一个**忙等待**的过程。\n\n4. 睡着延时\n\n睡着延迟显然是比忙等待更好的方式，睡着延迟是在等待的时间到来之前进程处于睡眠状态，CPU 资源被其他进程使用。\n\nschedule_timeout() 可以使当前任务休眠至指定的 jiffies 之后再重新被调度执行，msleep() 和 msleep_interruptible() 在本质上都是依靠包含了 schedule_timeout() 的 schedule_timeout_uninterruptible() 和 schedule_timeout_interruptible() 实现的。\n\nschedule_timeout() 的原理是**向系统添加一个定时器，在定时器处理函数中唤醒与参数对应的进程**。\n\n```c\nvoid msleep(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout)\n\t\ttimeout = schedule_timeout_uninterruptible(timeout);\n}\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}\n```\n\n另外，schedule_timeout_uninterruptible() 和 schedule_timeout_interruptible() 的定义如下，均使用 `__set_current_state` 设置进程状态。\n\n```c\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}\n```\n\n## 小结\n\nLinux 的中断处理分为两个半部，顶半部处理紧急的硬件操作，底半部处理不紧急的耗时操作。tasklet 和工作队列都是调度中断底半部的良好机制。tasklet 基于软中断实现。内核定时器也依靠软中断实现。\n\n内核中的延时可以采用忙等待或睡眠等待，为了充分利用 CPU 资源，使系统有更好的吞吐性能。在对延迟时间的要求并不是很精确的情况下，睡眠等待通常是值得推荐的，而 ndelay()、udelay() 忙等待机制在驱动中通常是为了配合硬件上的短时延迟要求。\n\n# 内存与 I/O 访问\n\n## CPU 与内存、I/O\n\n### 内存空间与 I/O 空间\n\n在 X86 处理器中存在着 I/O 空间的概念。I/O 空间是相对于内存空间而言的，它通过特定的指令 in、out 来访问。端口号标识了外设的寄存器地址。Intel 语法中的 in、out 指令格式如下：\n\n```asm\nIN 累加器, {端口号 │ DX}\nOUT {端口号 │ DX}, 累加器\n```\n\n目前，大多数嵌入式微控制器（如 ARM、PowerPC 等）中并不提供 I/O 空间，而仅存在内存空间。**内存空间可以直接通过地址、指针来访问，程序及在程序运行中使用的变量和其他数据都存在于内存空间中。**\n\n在 X86 处理器中，虽然提供了 I/O 空间，外设仍然可以只挂接在内存空间中。此时，CPU 可以像访问一个内存单元那样访问外设 I/O 端口，而不需要设立专门的 I/O 指令。**内存空间是必需的，而 I/O 空间是可选的。**如图是内存空间和 I/O 空间的对比。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241127111734557.png\" alt=\"image-20241127111734557\" style=\"zoom:75%;\" />\n\n在下面这段程序中，没有定义任何一个函数实体，但是程序却执行了函数调用 lpReset()。它实际上起到了“软重启”的作用，跳转到 CPU 启动后第一条要执行的指令的位置。因此，可以通过函数指针调用一个没有函数体的“函数”，本质上只是换一个地址开始执行。\n\n```c\ntypedef void (*lpFunction)();                // 定义一个无参数、无返回类型的函数指针类型\nlpFunction lpReset = (lpFunction)0xF000FFF0; // 定义一个函数指针，指向 CPU 启动后所执行的第一条指令的位置\nlpReset();                                   // 调用函数\n```\n\n### 内存管理单元 MMU\n\n高性能处理器一般会提供一个内存管理单元 MMU。**MMU 辅助操作系统进行内存管理，提供虚拟地址和物理地址的映射、内存访问权限保护和 Cache 缓存控制等硬件支持。**内核借助 MMU 可以让用户感觉到程序好像可以使用非常大的内存空间，从而使得编程人员在写程序时不用考虑计算机中物理内存的实际容量。\n\n首先需明确几个概念：\n\n1. **TLB（Translation Lookaside Buffer）：即转换旁路缓存。TLB 是 MMU 的核心部件，它缓存少量的虚拟地址与物理地址的转换关系，是转换表的 Cache，也经常被称为“快表”。**\n2. **TTW（Translation Table walk）：即转换表漫游。当 TLB 中没有缓冲对应的地址转换关系时，需要通过对内存中转换表（大多数为多级页表）的访问来获得虚拟地址和物理地址的对应关系。TTW 成功后，结果应写入 TLB 中。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241127112853842.png\" alt=\"image-20241127112853842\" style=\"zoom:75%;\" />\n\n不同架构的 CPU 访问数据的流程有区别，但大致流程基本如下所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241127142844768.png\" alt=\"image-20241127142844768\" style=\"zoom:80%;\" />\n\nMMU 具有虚拟地址和物理地址转换、内存访问权限保护等功能，使得 Linux 操作系统能单独为系统的每个用户进程分配独立的内存空间，并保证用户空间不能访问内核空间的地址，为操作系统的虚拟内存管理模块提供硬件基础。\n\n在 Linux 2.6 之前，Linux 内核硬件无关层使用了三级页表 PGD、PMD 和 PTE。从 Linux 2.6 开始，为了配合 64 位 CPU 的体系结构，硬件无关层则使用了 4 级页表目录管理的方式，即 PGD、PUD、PMD 和 PTE。这仅仅是一种软件意义上的抽象，实际硬件的页表级数可能少于 4。\n\n直到 Linux 5.0 的时候，都是如上的 4 级页表的结构。但在 Linux 5.15 版本中，在源代码中出现了一个叫 P4D 的东西，经查阅发现这是 5 级页表才需要的东西。源码如下：\n\n```c\nstatic int\npin_page_for_write(const void __user *_addr, pte_t **ptep, spinlock_t **ptlp)\n{\n\tunsigned long addr = (unsigned long)_addr;\n\tpgd_t *pgd;\n\tp4d_t *p4d;\n\tpmd_t *pmd;\n\tpte_t *pte;\n\tpud_t *pud;\n\tspinlock_t *ptl;\n\n\tpgd = pgd_offset(current->mm, addr);\n\tif (unlikely(pgd_none(*pgd) || pgd_bad(*pgd)))\n\t\treturn 0;\n\n\tp4d = p4d_offset(pgd, addr);\n\tif (unlikely(p4d_none(*p4d) || p4d_bad(*p4d)))\n\t\treturn 0;\n\n\tpud = pud_offset(p4d, addr);\n\tif (unlikely(pud_none(*pud) || pud_bad(*pud)))\n\t\treturn 0;\n\n\tpmd = pmd_offset(pud, addr);\n\tif (unlikely(pmd_none(*pmd)))\n\t\treturn 0;\n\n\t/*\n\t * A pmd can be bad if it refers to a HugeTLB or THP page.\n\t *\n\t * Both THP and HugeTLB pages have the same pmd layout\n\t * and should not be manipulated by the pte functions.\n\t *\n\t * Lock the page table for the destination and check\n\t * to see that it's still huge and whether or not we will\n\t * need to fault on write.\n\t */\n\tif (unlikely(pmd_thp_or_huge(*pmd))) {\n\t\tptl = &current->mm->page_table_lock;\n\t\tspin_lock(ptl);\n\t\tif (unlikely(!pmd_thp_or_huge(*pmd)\n\t\t\t|| pmd_hugewillfault(*pmd))) {\n\t\t\tspin_unlock(ptl);\n\t\t\treturn 0;\n\t\t}\n\n\t\t*ptep = NULL;\n\t\t*ptlp = ptl;\n\t\treturn 1;\n\t}\n\n\tif (unlikely(pmd_bad(*pmd)))\n\t\treturn 0;\n\n\tpte = pte_offset_map_lock(current->mm, pmd, addr, &ptl);\n\tif (unlikely(!pte_present(*pte) || !pte_young(*pte) ||\n\t    !pte_write(*pte) || !pte_dirty(*pte))) {\n\t\tpte_unmap_unlock(pte, ptl);\n\t\treturn 0;\n\t}\n\n\t*ptep = pte;\n\t*ptlp = ptl;\n\n\treturn 1;\n}\n```\n\n为什么会出现 p4d 呢？参考了文章 [https://zhuanlan.zhihu.com/p/641479824](https://zhuanlan.zhihu.com/p/641479824) 才明白为什么。这里只做总结提炼，具体请参考原文。更多关于 Linux 内核页表管理的机制，请自行查阅资料。\n\nLinux 修改了这部分代码，保证了目前的 4 级页表可用，又能对 5 级页表兼容。在 4 级页表索引中，虽然添加了 p4d，但是其对 p4d 实际上并未做任何有效操作，相当于将 p4d 折叠和忽略了。而 5 级页表需要的 p4d 就能正常工作，做到了设计统一。虽然 4 级页表能支持 256 TB 的地址空间，目前看来用不完。但大数据时代已经来临，未雨绸缪的考虑是值得肯定的。这样以来，针对使用 5 级页表的系统无需大量修改代码，直接可以使用现有的内核代码。\n\nMMU 并不是对所有的处理器都是必需的。Linux 2.6 以后也支持不带 MMU 的处理器。Linux 为了更广泛地应用于嵌入式系统，融合了 mClinux，以支持这些无 MMU 系统。\n\n## 内存管理\n\n内核空间和用户空间的内存映射关系请参考文章 [https://blog.csdn.net/Luckiers/article/details/141750008](https://blog.csdn.net/Luckiers/article/details/141750008)\n\n**每个进程的用户空间是完全独立、互不相干的，用户进程各自有不同的页表。而内核空间是由内核负责映射，它并不会跟着进程改变，是固定的。内核空间的虚拟地址到物理地址映射是被所有进程共享的，内核的虚拟空间独立于其他程序。**\n\n通常 32 位 Linux 的内核地址空间划分为 0~3 G（3 G 的位置为 PAGE_OFFSET）的用户空间，3~4 G 的内核空间。\n\n![image-20250201002213404](https://cdn.davidingplus.cn/images/2025/02/01/image-20250201002213404.png)\n\n通常 64 位 Linux 系统的内核地址空间分为三个部分，256 TB 的用户空间、非规范区域和 256 TB 的内核空间。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20250201002304708.png\" alt=\"image-20250201002304708\" style=\"zoom:65%;\" />\n\n关于映射空间解析的部分，书中讲的甚是繁杂，没怎么看懂。参考上面文章以及其他资料吧。\n\n## 内存存取\n\n### 用户空间内存申请\n\n在用户态中动态申请内存的函数是标准 C 库函数 malloc()，与之对应的释放函数是 free()。**对 Linux 而言，malloc() 一般通过 brk() 和 mmap() 两个系统调用从内核申请内存。**\n\n**用户空间 C 库的 malloc 算法实际上具备一个二次管理能力，并不是每次申请和释放内存都一定伴随着对内核的系统调用。**下面的代码展示了这点，下面进行解释。\n\n应用程序从内核拿到内存后，立即调用 free()，但由于 free() 之前调用了 mallopt(M_TRIM_THRESHOLD, -1) 和 mallopt(M_MMAP_MAX, 0)。\n\nmallopt(M_TRIM_THRESHOLD, -1) 设置 M_TRIM_THRESHOLD 为 -1，关闭内存修剪功能，即使释放的内存块超过一定阈值，也不会通过 brk 归还给内核，而是保留在进程的地址空间中供分配器复用。\n\nmallopt(M_MMAP_MAX, 0) 设置 M_MMAP_MAX 为 0，禁止分配器使用 mmap 分配内存，所有分配强制通过进程堆（sbrk）完成。释放的内存不会通过 munmap 归还给内核，而是由分配器管理。\n\n如此以来，这个 free() 并不会把内存还给内核，而只是还给了 C 库的分配算法，内存仍然属于这个进程。后续的 malloc 调用会优先使用这块已经分配好的内存，而不需要进行系统调用（brk 或 mmap）。\n\n```c\n#include <malloc.h>\n#include <sys/mman.h>\n\n#define SOMESIZE (100 * 1024 * 1024) // 100MB\n\nint main(int argc, char *argv[])\n{\n    unsigned char *buffer;\n    int i;\n\n    if (mlockall(MCL_CURRENT | MCL_FUTURE))\n        mallopt(M_TRIM_THRESHOLD, -1);\n    mallopt(M_MMAP_MAX, 0);\n\n    buffer = malloc(SOMESIZE);\n    if (!buffer)\n        exit(-1);\n\n    /*\n     * Touch each page in this piece of memory to get it\n     * mapped into RAM\n     */\n    for (i = 0; i < SOMESIZE; i += page_size)\n        buffer[i] = 0;\n    free(buffer);\n    /* <do your RT-thing> */\n\n    return 0;\n}\n```\n\n另外，**Linux 内核总是按需调页（Demand Paging）**。当 malloc() 返回的时候，虽然是成功返回，但内核并没有真正给这个进程内存，这个时候如果去读申请的内存，内容全部是 0，并且这个页面的映射是只读的。只有当写到某个页面的时候，内核才会在页错误后，真正把这个页面给这个进程。\n\n### 内核空间内存申请\n\n在 Linux 内核空间中动态申请内存主要涉及 kmalloc()、`__get_free_pages()` 和 vmalloc() 等。\n\n**kmalloc() 和 `__get_free_pages()`申请的内存位于 DMA 和常规区域的映射区，在物理上也是连续的，它们与真实的物理地址只有一个固定的偏移，存在较简单的转换关系。**\n\n**vmalloc() 在虚拟内存空间给出一块连续的内存区。实质上，这片连续的虚拟内存在物理内存中并不一定连续，vmalloc() 申请的虚拟内存和物理内存之间也没有简单的换算关系。**\n\n#### kmalloc()\n\n```c\n// 第一个参数是要分配的块的大小；第二个参数为分配标志，用于控制 kmalloc() 的行为。\nvoid *kmalloc(size_t size, gfp_t flags)\n```\n\n**最常用的分配标志是 GFP_KERNEL，含义是在内核空间的进程中申请内存。kmalloc() 的底层是依赖 `__get_free_pages()` 实现的。使用 GFP_KERNEL 标志申请内存时，若暂时不能满足，进程会睡眠等待，即会引起阻塞，因此不能在中断上下文或持有自旋锁的时候使用 GFP_KERNEL 申请内存。**\n\n**在中断处理函数、tasklet 和内核定时器等非进程上下文中不能阻塞，应当使用 GFP_ATOMIC 标志申请内存。**当使用 GFP_ATOMIC 标志申请内存时，若不存在空闲页，则不等待，直接返回，避免了睡眠阻塞的问题。\n\n其他的申请标志包括：\n\n- GFP_USER：用来为用户空间页分配内存，可能阻塞。\n- GFP_HIGHUSER：类似 GFP_USER，但是它从高端内存分配。\n- GFP_DMA：从 DMA 区域分配内存。\n- GFP_NOIO：不允许任何 I/O 初始化。\n- GFP_NOFS：不允许进行任何文件系统调用。\n- `__GFP_HIGHMEM`：指示分配的内存可以位于高端内存。\n- `__GFP_COLD`：请求一个较长时间不访问的页。\n- `__GFP_NOWARN`：当一个分配无法满足时，阻止内核发出警告。\n- `__GFP_HIGH`：高优先级请求，允许获得被内核保留给紧急状况使用的最后的内存页。\n- `__GFP_REPEAT`：分配失败，则尽力重复尝试。\n- `__GFP_NOFAIL`：标志只许申请成功，不推荐。\n- `__GFP_NORETRY`：若申请不到，则立即放弃。\n\nkmalloc() 申请的内存应使用 kfree() 函数释放，类似用户空间的标准 C 库函数 malloc() 和 free() 的关系。\n\n#### __get_free_pages() 系列函数\n\n**`__get_free_pages()` 系列函数/宏本质上是 Linux 内核最底层用于获取空闲内存的方法。底层的 buddy 算法以 2n 页为单位管理空闲内存，故最底层的内存申请总是以 2n 页为单位的。**\n\n`__get_free_pages()` 系列函数/宏包括 get_zeroed_page()、`__get_free_page()` 和 `__get_free_pages()`。\n\n```c\n// 该函数返回一个指向新页的指针并且将该页清零。\n// 注意这里的指针使用 unsigned long 类型表示，类似 LarkSDK 中 LLog 对指针的处理。\nunsigned long get_zeroed_page(gfp_t gfp_mask);\n\n// 该宏返回一个指向新页的指针但是该页不清零。\n#define __get_free_page(gfp_mask) \\\n\t\t__get_free_pages((gfp_mask), 0)\n\n// 该函数可分配多个页并返回分配内存的首地址，分配的页数为 2 的 order 次方，分配的页不清零。order 允许的最大值是 10（1024 页）或者11（2048 页），这取决于具体的硬件平台。\nunsigned long __get_free_pages(gfp_t gfp_mask, unsigned int order);\n```\n\n`__get_free_pages()` 和 get_zeroed_page() 在实现中调用了 alloc_pages() 函数。**alloc_pages() 既可以在内核空间分配，也可以在用户空间分配。**\n\n```c\n// 参数含义与 __get_free_pages() 类似，但它返回分配的第一个页的描述符而非首地址（前面的 unsigned long）。\n// 这里的描述符使用 struct page * 指针描述的。\nstruct page *alloc_pages(gfp_t gfp_mask, unsigned int order);\n```\n\n该系列函数使用如下接口释放：\n\n```c\nvoid free_pages(unsigned long addr, unsigned int order);\n#define free_page(addr) free_pages((addr), 0)\n```\n\n`__get_free_pages()` 系列函数在使用时，申请标志的值与 kmalloc() 完全一致，各标志的含义也与完全一致。显而易见，因为 kmalloc() 底层是基于 `__get_free_pages()` 实现的。\n\n#### vmalloc()\n\n**vmalloc() 一般只为存在于软件中（没有对应的硬件意义）的较大的顺序缓冲区分配内存，vmalloc() 远大于 `__get_free_pages()` 的开销。**为了完成 vmalloc()，新的页表项需要被建立。因此，调用 vmalloc() 来分配少量的内存（如 1 页以内的内存）是不妥的。\n\n类似的，分配使用 vmalloc()，释放使用 vfree()。\n\n```c\nvoid *vmalloc(unsigned long size);\nvoid vfree(const void *addr);\n```\n\n**vmalloc() 不能用在原子上下文中，因为内部实现使用了标志为 GFP_KERNEL 的 kmalloc()。**\n\n**vmalloc() 在申请内存时，会进行内存的映射，改变页表项，不像 kmalloc() 实际用的是开机过程中就映射好的 DMA 和常规区域的页表项。**故 vmalloc() 的虚拟地址和物理地址不是一个简单的线性映射。\n\n#### slab\n\n**完全使用页为单元申请和释放内存容易导致浪费（若要申请少量字节，也需要用 1 页）。另外在操作系统的运作过程中，经常会涉及大量对象的重复生成、使用和释放内存问题。**在 Linux 系统中所用到的对象，比较典型的例子是 inode、task_struct 等。**若能用合适的方法使得对象在前后两次被使用时分配在同一块内存或同一类内存空间且保留了基本的数据结构，就可以大大提高效率。**slab 算法就是针对上述特点设计的。**实际上 kmalloc() 就是使用 slab 机制实现的。**\n\n**slab 是建立在 buddy 算法之上的，它从 buddy 算法拿到 2n 页面后再次进行二次管理**，和用户空间的 C 库很像。slab 申请的内存以及基于 slab 的 kmalloc() 申请的内存，与物理内存之间也是一个简单的线性偏移。\n\n1. 创建 slab 缓存\n\nkmem_cache_create() 用于创建一个缓存，是一个可以保留任意数目且全部同样大小的后备缓存。\n\n```c\n// size：要分配的每个数据结构的大小。\n// flags：控制如何进行分配的位掩码，如 SLAB_HWCACHE_ALIGN（每个数据对象被对齐到一个缓存行）、SLAB_CACHE_DMA（要求数据对象在 DMA 区域中分配）等。\nstruct kmem_cache *kmem_cache_create(const char *name, unsigned int size, unsigned int align, slab_flags_t flags, void (*ctor)(void *));\n```\n\n2. 分配 slab 缓存\n\nkmem_cache_alloc() 在创建的 slab 后备缓存中分配一块并返回首地址指针。\n\n```c\nvoid *kmem_cache_alloc(struct kmem_cache *, gfp_t flags) __assume_slab_alignment __malloc;\n```\n\n3. 释放 slab 缓存\n\n```c\nvoid kmem_cache_free(struct kmem_cache *, void *);\n```\n\n4. 收回 slab 缓存\n\n```c\nvoid kmem_cache_destroy(struct kmem_cache *);\n```\n\n5. 使用模板\n\n```c\n// 创建 slab 缓存\nstatic kmem_cache_t *xxx_cachep;\nxxx_cachep = kmem_cache_create(\"xxx\", sizeof(struct xxx), 0, SLAB_HWCACHE_ALIGN | SLAB_PANIC, NULL, NULL);\n\n// 分配 slab 缓存\nstruct xxx *ctx;\nctx = kmem_cache_alloc(xxx_cachep, GFP_KERNEL);\n\n// 使用 slab 缓存\n...\n\n// 释放 slab 缓存\nkmem_cache_free(xxx_cachep, ctx);\n\n// 收回 slab 缓存\nkmem_cache_destroy(xxx_cachep);\n```\n\n系统中通过查看 /proc/slabinfo 可查看当前 slab 的分配和使用情况，结果可能如下：\n\n```bash\ncat /proc/slabinfo\n\n# slabinfo - version: 2.1\n# # name            <active_objs> <num_objs> <objsize> <objperslab> <pagesperslab> : tunables <limit> <batchcount> <sharedfactor> : slabdata <active_slabs> <num_slabs> <sharedavail>\n# AF_VSOCK              50     50   1280   25    8 : tunables    0    0    0 : slabdata      2      2      0\n# ext4_groupinfo_4k    420    420    192   21    1 : tunables    0    0    0 : slabdata     20     20      0\n# btrfs_delayed_node      0      0    312   26    2 : tunables    0    0    0 : slabdata      0      0      0\n# btrfs_ordered_extent      0      0    424   19    2 : tunables    0    0    0 : slabdata      0      0      0\n# btrfs_extent_map       0      0    144   28    1 : tunables    0    0    0 : slabdata      0      0      0\n# btrfs_trans_handle      0      0    112   36    1 : tunables    0    0    0 : slabdata      0      0      0\n# btrfs_inode            0      0   1208   27    8 : tunables    0    0    0 : slabdata      0      0      0\n# fsverity_info          0      0    256   16    1 : tunables    0    0    0 : slabdata      0      0      0\n# fscrypt_info           0      0    128   32    1 : tunables    0    0    0 : slabdata      0      0      0\n# ip6-frags              0      0    184   22    1 : tunables    0    0    0 : slabdata      0      0      0\n# PINGv6                 0      0   1216   26    8 : tunables    0    0    0 : slabdata      0      0      0\n# RAWv6                288    416   1216   26    8 : tunables    0    0    0 : slabdata     16     16      0\n# UDPv6                 96     96   1344   24    8 : tunables    0    0    0 : slabdata      4      4      0\n# tw_sock_TCPv6          0      0    248   16    1 : tunables    0    0    0 : slabdata      0      0      0\n# ...\n```\n\n> 注：slab 不是要代替 `__get_free_pages()`，其最底层仍然依赖于 `__get_free_pages()`，slab 在底层每次申请 1 页或多页，之后再分隔这些页为更小的单元进行管理，从而节省了内存，也提高了 slab 缓冲对象的访问效率。\n\n#### 内存池\n\n除 slab 以外，内存池也是一种非常经典的分配大量小对象的技术。\n\n1. 创建内存池\n\n```c\n// min_nr：预分配对象的数目。\n// alloc_fn：指向内存池机制提供的标准对象分配函数的指针。\n// free_fn：指向内存池机制提供的标准对象回收函数的指针。\nmempool_t *mempool_create(int min_nr, mempool_alloc_t *alloc_fn, mempool_free_t *free_fn, void *pool_data);\n```\n\n这两个函数指针定义如下：\n\n```c\n// pool_data：分配函数用到的指针。\n// gfp_mask：分配标记。只有当 __GFP_WAIT 被指定时，分配函数才会休眠。\ntypedef void * (mempool_alloc_t)(gfp_t gfp_mask, void *pool_data);\n\n// pool_data：回收函数用到的指针。\ntypedef void (mempool_free_t)(void *element, void *pool_data);\n```\n\n2. 分配和回收对象\n\nmempool_alloc() 用于分配对象。若内存池分配器无法提供内存，可以使用预分配的池。mempool_free() 用于回收对象。\n\n```c\nvoid *mempool_alloc(mempool_t *pool, gfp_t gfp_mask) __malloc;\nvoid mempool_free(void *element, mempool_t *pool);\n```\n\n3. 回收内存池\n\n```c\nvoid mempool_destroy(mempool_t *pool);\n```\n\n## 设备 I/O 端口与 I/O 内存的访问\n\n**设备通常会提供一组寄存器来控制设备、读写设备和获取设备状态，即控制寄存器、数据寄存器和状态寄存器。**这些寄存器可能位于 I/O 空间中，也可能位于内存空间中。**当位于 I/O 空间时，通常被称为 I/O 端口；当位于内存空间时，对应的内存空间被称为 I/O 内存。二者的操作有非常多的相似之处。**\n\n### I/O 端口和 I/O 内存访问接口\n\n#### I/O 端口\n\nLinux 内核提供了函数访问 I/O 空间的端口，具体如下：\n\n1. 读写字节端口（8 位宽）。\n\n```c\nu8 inb(unsigned long port)\n{\n\treturn ioread8(ioport_map(port, 1));\n}\n\nvoid outb(u8 b, unsigned long port)\n{\n\tiowrite8(b, ioport_map(port, 1));\n}\n```\n\n2. 读写字端口（16 位宽）。\n\n```c\nu16 inw(unsigned long port)\n{\n\treturn ioread16(ioport_map(port, 2));\n}\n\nvoid outw(u16 b, unsigned long port)\n{\n\tiowrite16(b, ioport_map(port, 2));\n}\n```\n\n3. 读写长字节端口（32 位宽）。\n\n```c\nu32 inl(unsigned long port)\n{\n\treturn ioread32(ioport_map(port, 4));\n}\n\nvoid outl(u32 b, unsigned long port)\n{\n\tiowrite32(b, ioport_map(port, 4));\n}\n```\n\n4. 读写一串字节。\n\ninsb() 从端口 port 开始读 count 个字节端口，并将读取结果写入 dst 指向的内存；outsb() 将 addr 指向的内存中的 count 个字节连续写入以 port 开始的端口。\n\n```c\nvoid insb (unsigned long port, void *dst, unsigned long count);\nvoid outsb (unsigned long port, const void *src, unsigned long count);\n```\n\n5. 读写一串字。\n\n```c\nvoid insw (unsigned long port, void *dst, unsigned long count);\nvoid outsw (unsigned long port, const void *src, unsigned long count);\n```\n\n6. 读写一串长字。\n\n```c\nvoid insl (unsigned long port, void *dst, unsigned long count);\nvoid outsl (unsigned long port, const void *src, unsigned long count);\n```\n\n上述函数 I/O 端口号 port 的类型高度依赖于具体的硬件平台，因此只写出了 unsigned。\n\n#### I/O 内存\n\nI/O 内存通常是芯片内部的各个 I2C、SPI、USB 等控制器的寄存器或者外部内存总线上的设备。**在内核中访问 I/O 内存之前，需首先使用 ioremap() 函数将设备的物理地址映射到虚拟地址上。**\n\n```c\nvoid __iomem *ioremap(unsigned long port, unsigned long size);\n```\n\nioremap() 与 vmalloc() 类似，也需建立新的页表，**但并不进行 vmalloc() 中所执行的内存分配行为，类似于 reservation**。ioremap() 返回一个特殊的虚拟地址，该地址可用来存取特定的物理地址范围，这个虚拟地址位于 vmalloc 映射区域。\n\nioremap() 获得的虚拟地址用 iounmap() 函数释放。\n\n```c\nvoid iounmap(volatile void __iomem *addr);\n```\n\nioremap() 有个变体 devm_ioremap()，类似其他以 devm_ 开头的函数，通过 devm_ioremap() 进行的映射通常不需要在驱动退出和出错处理的时候进行 iounmap()。\n\n```c\nvoid __iomem *devm_ioremap(struct device *dev, resource_size_t offset, resource_size_t size)\n{\n\treturn __devm_ioremap(dev, offset, size, DEVM_IOREMAP);\n}\nEXPORT_SYMBOL(devm_ioremap);\n```\n\n**在设备物理地址（一般都是寄存器）被映射到虚拟地址之后，尽管可以直接通过指针访问这些地址，但还是推荐用一组标准的 API 来完成这个虚拟地址的读写。**\n\n读寄存器用 readb_relaxed()、readw_relaxed()、readl_relaxed()、readb()、readw()、readl() 这组 API，分别读 8 bit、16 bit、32 bit 的寄存器。有无 `_relaxed` 后缀的区别是没有 `_relaxed` 后缀的函数包含一个内存屏障。\n\n```c\n#define readb(c)\t\t({ u8  __v = readb_relaxed(c); __iormb(); __v; })\n#define readw(c)\t\t({ u16 __v = readw_relaxed(c); __iormb(); __v; })\n#define readl(c)\t\t({ u32 __v = readl_relaxed(c); __iormb(); __v; })\n// similar functions\n#define readsb(p,d,l)\t\t({ __raw_readsb(p,d,l); __iormb(); })\n#define readsw(p,d,l)\t\t({ __raw_readsw(p,d,l); __iormb(); })\n#define readsl(p,d,l)\t\t({ __raw_readsl(p,d,l); __iormb(); })\n```\n\n同理写操作如下：\n\n```c\n#define writeb(v,c)\t\t({ __iowmb(); writeb_relaxed(v,c); })\n#define writew(v,c)\t\t({ __iowmb(); writew_relaxed(v,c); })\n#define writel(v,c)\t\t({ __iowmb(); writel_relaxed(v,c); })\n// similar functions\n#define writesb(p,d,l)\t\t({ __iowmb(); __raw_writesb(p,d,l); })\n#define writesw(p,d,l)\t\t({ __iowmb(); __raw_writesw(p,d,l); })\n#define writesl(p,d,l)\t\t({ __iowmb(); __raw_writesl(p,d,l); })\n```\n\n### 申请与释放设备的 I/O 端口和 I/O 内存\n\n#### I/O 端口申请\n\nLinux 内核提供了函数用于申请和释放 I/O 端口，表明该驱动要访问这片区域。\n\n```c\n#define request_region(start,n,name)\t\t__request_region(&ioport_resource, (start), (n), (name), 0)\n\n// 函数向内核申请 n 个端口，这些端口从 start 开始，name 为设备的名称。若分配成功，返回值不是 NULL，若返回 NULL，意味着申请端口失败。\nstruct resource *__request_region(struct resource *parent, resource_size_t start, resource_size_t n, const char *name, int flags);\n```\n\n使用 request_region() 申请的 I/O 端口使用完毕后，通过 release_region() 归还给系统。\n\n```c\n#define release_region(start,n)\t__release_region(&ioport_resource, (start), (n))\n\nvoid __release_region(struct resource *parent, resource_size_t start, resource_size_t n);\n```\n\nrequest_region() 有变体，即不用考虑释放问题的 devm_request_region()。\n\n```c\n#define devm_request_region(dev,start,n,name) \\\n\t__devm_request_region(dev, &ioport_resource, (start), (n), (name))\n\nstruct resource *__devm_request_region(struct device *dev, struct resource *parent, resource_size_t start, resource_size_t n, const char *name);\n```\n\n#### I/O 内存申请\n\n同理，Linux 内核提供了函数用于申请和释放 I/O 内存。这里的申请代表该驱动要访问这片区域，但不会做任何内存映射的动作，类似于 reservation 的概念。\n\n从源码中可以发现，不管是 I/O 端口还是 I/O 内存，底层都调用 __request_region() 函数，只是 parent 参数不同。这也恰好反映了二者操作上的类似和语义上的不同。\n\n```c\n#define request_mem_region(start,n,name) __request_region(&iomem_resource, (start), (n), (name), 0)\n```\n\n同理，使用 release_mem_region() 归还给系统。\n\n```c\n#define release_mem_region(start,n)\t__release_region(&iomem_resource, (start), (n))\n```\n\n同理，存在变体 devm_request_mem_region()。\n\n```c\n#define devm_request_mem_region(dev,start,n,name) \\\n\t__devm_request_region(dev, &iomem_resource, (start), (n), (name))\n```\n\n### 设备 I/O 端口和 I/O 内存访问流程\n\n关于 I/O 端口的访问，在设备打开或驱动模块加载时申请 I/O 端口，之后使用 inb()、outb() 等进行端口访问，最后在设备关闭或驱动被卸载时释放 I/O 端口。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241209112015738.png\" alt=\"image-20241209112015738\" style=\"zoom:75%;\" />\n\n关于 I/O 内存的访问，首先调用 request_mem_region() 申请资源，接着将寄存器地址通过 ioremap() 映射到内核空间虚拟地址，之后通过 Linux 设备访问编程接口访问这些设备的寄存器。访问完成后，对 ioremap() 申请的虚拟地址进行释放，并释放 release_mem_region() 申请的 I/O 内存资源。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241209112025950.png\" alt=\"image-20241209112025950\" style=\"zoom:75%;\" />\n\n### 映射设备地址到内存空间\n\n#### 内存映射与 VMA\n\n**一般情况下，用户空间是不可能也不应该直接访问设备的，但设备驱动程序可实现 mmap() 函数，可使得用户空间能直接访问设备的物理地址。**实际上 mmap() 实现了这样的一个映射过程：**它将用户空间的一段内存与设备内存关联，当用户访问用户空间的这段地址范围时，实际上会转化为对设备的访问。**\n\n这种能力对于显示适配器一类的设备非常有意义，若用户空间可直接通过内存映射访问显存的话，屏幕帧的各点像素不再需要一个从用户空间到内核空间复制的过程。\n\n驱动的 mmap() 函数通过 file_operations 结构体注册。**mmap（）必须以 PAGE_SIZE 为单位进行映射。实际上，内存只能以页为单位进行映射，若要映射非 PAGE_SIZE 整数倍的地址范围，要先进行页对齐，强行以 PAGE_SIZE 的倍数大小进行映射。**\n\n```c\n// kernel space\nstruct file_operations\n{\n    ...\n\nint (*mmap) (struct file *, struct vm_area_struct *);\n\n    ...\n};\n```\n\n用户空间进行系统调用 mmap() 的时候，最终会走到驱动的 mmap() 函数中。系统调用 mmap() 原型如下：\n\n```c\n// user space\n// fd 为文件描述符，一般由 open() 返回。fd 可指定为 -1，此时需指定 flags 参数中的 MAP_ANON，表明是匿名映射。\n// len 是映射到调用用户空间的字节数，从被映射文件开头 offset 个字节开始算起。offset 参数一般设为 0，表示从文件头开始映射。\n// prot 参数指定访问权限，可取如下几个值的 \"|\"：PROT_READ（可读）、PROT_WRITE（可写）、PROT_EXEC（可执行）和 PROT_NONE（不可访问）。\n// addr 指定文件应被映射到用户空间的起始地址，一般指定为 NULL，这样选择起始地址的任务将由内核完成，函数的返回值就是映射到用户空间的地址。\nvoid *mmap(void *__addr, size_t __len, int __prot, int __flags, int __fd, __off_t __offset);\n```\n\n进行系统调用 mmap() 的时候，内核会如下处理：\n\n1. **在进程的虚拟空间查找一块 VMA。**\n2. **将这块 VMA 进行映射。**\n3. **如果设备驱动程序或文件系统的 file_operations 定义了 mmap()，调用此函数。**\n4. **将这个 VMA 插入进程的 VMA 链表中。**\n\nfile_operations 的 mmap() 的参数 struct vm_area_struct * 就是第一步找到的 VMA。\n\n系统 mmap() 映射的内存通过 munmap() 解除映射。\n\n```c\nint munmap(void *__addr, size_t __len);\n```\n\n**驱动程序中 mmap() 的实现机制是建立页表，并填充 VMA 结构体的 vm_operations_struct 指针。VMA 就是 vm_area_struct，用于描述一个虚拟内存区域。**\n\n```c\n/*\n * This struct describes a virtual memory area. There is one of these\n * per VM-area/task. A VM area is any part of the process virtual memory\n * space that has a special rule for the page-fault handlers (ie a shared\n * library, the executable area etc).\n */\nstruct vm_area_struct {\n\t/* The first cache line has the info for VMA tree walking. */\n\n\tunsigned long vm_start;\t\t/* Our start address within vm_mm. */\n\tunsigned long vm_end;\t\t/* The first byte after our end address\n\t\t\t\t\t   within vm_mm. */\n\n\t/* linked list of VM areas per task, sorted by address */\n\tstruct vm_area_struct *vm_next, *vm_prev;\n\n\tstruct rb_node vm_rb;\n\n\t/*\n\t * Largest free memory gap in bytes to the left of this VMA.\n\t * Either between this VMA and vma->vm_prev, or between one of the\n\t * VMAs below us in the VMA rbtree and its ->vm_prev. This helps\n\t * get_unmapped_area find a free area of the right size.\n\t */\n\tunsigned long rb_subtree_gap;\n\n\t/* Second cache line starts here. */\n\n\tstruct mm_struct *vm_mm;\t/* The address space we belong to. */\n\n\t/*\n\t * Access permissions of this VMA.\n\t * See vmf_insert_mixed_prot() for discussion.\n\t */\n\tpgprot_t vm_page_prot;\n\tunsigned long vm_flags;\t\t/* Flags, see mm.h. */\n\n\t/*\n\t * For areas with an address space and backing store,\n\t * linkage into the address_space->i_mmap interval tree.\n\t */\n\tstruct {\n\t\tstruct rb_node rb;\n\t\tunsigned long rb_subtree_last;\n\t} shared;\n\n\t/*\n\t * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma\n\t * list, after a COW of one of the file pages.\tA MAP_SHARED vma\n\t * can only be in the i_mmap tree.  An anonymous MAP_PRIVATE, stack\n\t * or brk vma (with NULL file) can only be in an anon_vma list.\n\t */\n\tstruct list_head anon_vma_chain; /* Serialized by mmap_lock &\n\t\t\t\t\t  * page_table_lock */\n\tstruct anon_vma *anon_vma;\t/* Serialized by page_table_lock */\n\n\t/* Function pointers to deal with this struct. */\n\tconst struct vm_operations_struct *vm_ops;\n\n\t/* Information about our backing store: */\n\tunsigned long vm_pgoff;\t\t/* Offset (within vm_file) in PAGE_SIZE\n\t\t\t\t\t   units */\n\tstruct file * vm_file;\t\t/* File we map to (can be NULL). */\n\tvoid * vm_private_data;\t\t/* was vm_pte (shared mem) */\n\n#ifdef CONFIG_SWAP\n\tatomic_long_t swap_readahead_info;\n#endif\n#ifndef CONFIG_MMU\n\tstruct vm_region *vm_region;\t/* NOMMU mapping region */\n#endif\n#ifdef CONFIG_NUMA\n\tstruct mempolicy *vm_policy;\t/* NUMA policy for the VMA */\n#endif\n\tstruct vm_userfaultfd_ctx vm_userfaultfd_ctx;\n} __randomize_layout;\n```\n\nVMA 结构体描述的虚地址介于 vm_start 和 vm_end 之间。vm_ops 成员指向这个 VMA 的操作集。针对 VMA 的操作都被包含在 vm_operations_struct 结构体中。\n\n```c\n/*\n * These are the virtual MM functions - opening of an area, closing and\n * unmapping it (needed to keep files on disk up-to-date etc), pointer\n * to the functions called when a no-page or a wp-page exception occurs.\n */\nstruct vm_operations_struct {\n\tvoid (*open)(struct vm_area_struct * area);\n\tvoid (*close)(struct vm_area_struct * area);\n\t/* Called any time before splitting to check if it's allowed */\n\tint (*may_split)(struct vm_area_struct *area, unsigned long addr);\n\tint (*mremap)(struct vm_area_struct *area);\n\t/*\n\t * Called by mprotect() to make driver-specific permission\n\t * checks before mprotect() is finalised.   The VMA must not\n\t * be modified.  Returns 0 if eprotect() can proceed.\n\t */\n\tint (*mprotect)(struct vm_area_struct *vma, unsigned long start,\n\t\t\tunsigned long end, unsigned long newflags);\n\tvm_fault_t (*fault)(struct vm_fault *vmf);\n\tvm_fault_t (*huge_fault)(struct vm_fault *vmf,\n\t\t\tenum page_entry_size pe_size);\n\tvm_fault_t (*map_pages)(struct vm_fault *vmf,\n\t\t\tpgoff_t start_pgoff, pgoff_t end_pgoff);\n\tunsigned long (*pagesize)(struct vm_area_struct * area);\n\n\t/* notification that a previously read-only page is about to become\n\t * writable, if an error is returned it will cause a SIGBUS */\n\tvm_fault_t (*page_mkwrite)(struct vm_fault *vmf);\n\n\t/* same as page_mkwrite when using VM_PFNMAP|VM_MIXEDMAP */\n\tvm_fault_t (*pfn_mkwrite)(struct vm_fault *vmf);\n\n\t/* called by access_process_vm when get_user_pages() fails, typically\n\t * for use by special VMAs. See also generic_access_phys() for a generic\n\t * implementation useful for any iomem mapping.\n\t */\n\tint (*access)(struct vm_area_struct *vma, unsigned long addr,\n\t\t      void *buf, int len, int write);\n\n\t/* Called by the /proc/PID/maps code to ask the vma whether it\n\t * has a special name.  Returning non-NULL will also cause this\n\t * vma to be dumped unconditionally. */\n\tconst char *(*name)(struct vm_area_struct *vma);\n\n#ifdef CONFIG_NUMA\n\t/*\n\t * set_policy() op must add a reference to any non-NULL @new mempolicy\n\t * to hold the policy upon return.  Caller should pass NULL @new to\n\t * remove a policy and fall back to surrounding context--i.e. do not\n\t * install a MPOL_DEFAULT policy, nor the task or system default\n\t * mempolicy.\n\t */\n\tint (*set_policy)(struct vm_area_struct *vma, struct mempolicy *new);\n\n\t/*\n\t * get_policy() op must add reference [mpol_get()] to any policy at\n\t * (vma,addr) marked as MPOL_SHARED.  The shared policy infrastructure\n\t * in mm/mempolicy.c will do this automatically.\n\t * get_policy() must NOT add a ref if the policy at (vma,addr) is not\n\t * marked as MPOL_SHARED. vma policies are protected by the mmap_lock.\n\t * If no [shared/vma] mempolicy exists at the addr, get_policy() op\n\t * must return NULL--i.e., do not \"fallback\" to task or system default\n\t * policy.\n\t */\n\tstruct mempolicy *(*get_policy)(struct vm_area_struct *vma,\n\t\t\t\t\tunsigned long addr);\n#endif\n\t/*\n\t * Called by vm_normal_page() for special PTEs to find the\n\t * page for @addr.  This is useful if the default behavior\n\t * (using pte_page()) would not find the correct page.\n\t */\n\tstruct page *(*find_special_page)(struct vm_area_struct *vma,\n\t\t\t\t\t  unsigned long addr);\n};\n```\n\nvm_operations_struct 结构体的实体会在 file_operations 的 mmap() 成员函数里被赋值给相应的 vm_ops。上述 open() 函数通常在驱动的 mmap() 里调用，close() 函数通常会在 munmap() 的时候被调用到。\n\n一个 vm_operations_struct 的使用示例如下：\n\n```c\nstatic int xxx_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n    // 创建页表项，以 VMA 结构体的成员作为 remap_pfn_range() 的参数，映射的虚拟地址范围是 vma->vm_start 至 vma->vm_end。\n    if (remap_pfn_range(vma, vma->vm_start, vm->vm_pgoff, vma->vm_end - vma->vm_start, vma->vm_page_prot)) return -EAGAIN;\n\n    vma->vm_ops = &xxx_remap_vm_ops;\n    xxx_vma_open(vma);\n\n\n    return 0;\n}\n\n// VMA 打开函数\nstatic void xxx_vma_open(struct vm_area_struct *vma)\n{\n    ...\n\n    printk(KERN_NOTICE \"xxx VMA open, virt %lx, phys %lx\\n\", vma->vm_start, vma->vm_pgoff << PAGE_SHIFT);\n}\n\n// VMA 关闭函数\nstatic void xxx_vma_close(struct vm_area_struct *vma)\n{\n    ...\n\n    printk(KERN_NOTICE \"xxx VMA close.\\n\");\n}\n\n// VMA 操作结构体\nstatic struct vm_operations_struct xxx_remap_vm_ops = {\n    .open = xxx_vma_open,\n    .close = xxx_vma_close,\n    ...\n};\n```\n\nremap_pfn_range() 函数的原型如下：\n\n```c\n// addr：内存映射开始处的虚拟地址，虚拟地址范围是 [addr, addr + size]\n// pfn：虚拟地址应该映射到的物理地址的页帧号。实际上是物理地址右移 PAGE_SHIFT 位。若 PAGE_SIZE 为 4 KB，则 PAGE_SHIFT 为 12，因为 PAGE_SIZE 等于 1 << PAGE_SHIFT。\n// prot：新页所要求的保护属性。\nint remap_pfn_range(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn, unsigned long size, pgprot_t prot);\n```\n\n在驱动程序中，使用 remap_pfn_range() 能映射内存中的保留页、设备 I/O、framebuffer、camera 等内存。在此函数基础上可封装 io_remap_pfn_range()、vm_iomap_memory() 等 API。\n\n```c\nint io_remap_pfn_range(struct vm_area_struct *vma, unsigned long addr, unsigned long pfn, unsigned long size, pgprot_t prot)\n{\n\treturn remap_pfn_range(vma, addr, pfn, size, pgprot_decrypted(prot));\n}\n\nint vm_iomap_memory(struct vm_area_struct *vma, phys_addr_t start, unsigned long len);\n```\n\n**通常 I/O 内存被映射时是需要 nocache 的。这时应该设置 vma->vm_page_prot 为 nocache 标志再映射。**\n\n```c\nstatic int xxx_nocache_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n    // 设置 nocache 标志\n    vma->vm_page_prot = pgprot_noncached(vma->vm_page_prot);\n    vma->vm_pgoff = ((u32)map_start >> PAGE_SHIFT);\n\n    // 映射\n    if (remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff, vma->vm_end - vma->vm_start, vma->vm_page_prot)) return -EAGAIN;\n\n\n    return 0;\n}\n```\n\npgprot_noncached() 是一个宏函数，实现高度依赖于 CPU 架构，另一个限制少一点的宏是 pgprot_writecombine()。pgprot_noncached() 实际禁止了相关页的 Cache 和写缓冲，pgprot_writecombine() 则没有禁止写缓冲。\n\n#### fault() 函数\n\n除 remap_pfn_range() 以外，在驱动程序中实现 VMA 的 fault() 函数可以为设备提供更加灵活的内存映射途径。当访问的页不在内存里，即发生缺页异常时，fault() 会被内核自动调用，而 fault() 的具体行为可以自定义。\n\n当发生缺页异常的时候，系统会如下处理：\n\n1. 找到缺页的虚拟地址所在的 VMA。\n2. 如果必要，分配中间页目录表和页表。\n3. 如果页表项对应的物理页面不存在，调用这个 VMA 的 fault() 方法，它返回物理页面的页描迏符。\n4. 将物理页面的地址填充到页表中。\n\n一个使用示例如下：\n\n```c\nstatic int xxx_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n    unsigned long paddr;\n    unsigned long pfn;\n    pgoff_t index = vmf->pgoff;\n    struct vma_data *vdata = vma->vm_private_data;\n\n    ...\n\n    pfn = paddr >> PAGE_SHIFT;\n\n    vm_insert_pfn(vma, (unsigned long)vmf->virtual_address, pfn);\n\n    return VM_FAULT_NOPAGE;\n}\n```\n\n> 大多数设备驱动其实都不需要提供设备内存到用户空间的映射能力。因为对于串口等面向流的设备而言，实现这种映射毫无意义。而对于显示、视频等设备，建立映射可减少用户空间和内核空间之间的内存复制，这种情形下的映射是有意义的。\n\n## DMA\n\n**DMA 是一种无需 CPU 的参与就可以让外设与系统内存之间进行双向数据传输的硬件机制。DMA 使系统 CPU 从实际的 I/O 数据传输过程中摆脱出来，大大提高系统的吞吐率。**DMA 通常与硬件体系结构，特别是外设的总线技术密切相关。\n\nDMA 的数据传输由 DMA 控制器（DMAC）控制，在传输期间，CPU 可以并发地执行其他任务。当 DMA 结束后，DMAC 通过中断通知 CPU 数据传输已经结束，然后由 CPU 执行相应的中断服务程序进行后处理。\n\n### DMA 与 Cache 一致性\n\nCache 和 DMA 本身似乎是两个毫不相关的事物。Cache 被用作 CPU 针对内存的缓存，利用程序的空间和时间的局部性原理，达到较高的命中率，从而避免 CPU 每次都必须要与相对慢速的内存交互数据来提高数据的访问速率。DMA 可以作为内存与外设之间传输数据的方式，在这种传输方式之下，数据并不需要经过 CPU 中转。\n\n若 DMA 针对内存的目的地址与 Cache 缓存的对象没有重叠区域，DMA 和 Cache 将相安无事。**若 DMA 的目的地址与 Cache 所缓存的内存地址有重叠，经过 DMA 操作，目的地址的内存已被修改，而 CPU 并不知道，它仍然认为 Cache 中的老数据就是内存中的数据，那在以后访问 Cache 映射的内存时，它仍然使用陈旧的 Cache 数据。这样就会发生 Cache 与内存之间数据“不一致性”的错误。**所谓 Cache 数据与内存数据的不一致性，是指在采用 Cache 的系统中，同样一个数据可能既存在于 Cache 中，也存在于主存中，Cache 与主存中的数据一样则具有一致性，数据若不一样则具有不一致性。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20241209172643859.png\" alt=\"image-20241209172643859\" style=\"zoom:65%;\" />\n\n> Cache 与内存的一致性问题经常被遗忘。在发生 Cache 与内存不一致性错误后，驱动将无法正常运行。Cache 的不一致性问题并不是只发生在 DMA 的情况下，实际上，还存在于 Cache 使能和关闭的时刻。\n\n### DMA 编程\n\n**DMA 本身不属于一种等同于字符设备、块设备和网络设备的外设，它只是一种外设与内存交互数据的方式。**故更合理的称呼方式是 DMA 编程而非 DMA 驱动。\n\n**内存中用于与外设交互数据的区域称为 DMA 缓冲区。**在设备不支持 scatter/gather（分散/聚集，简称 SG）操作的情况下，DMA 缓冲区在物理上必须是连续的。\n\n#### DMA 区域\n\n对于 x86 架构的 ISA 设备而言，其 DMA 操作只能在 16 MB 以下的内存中进行，因此，在使用 kmalloc()、`__get_free_pages()` 及其类似函数申请 DMA 缓冲区时应使用 GFP_DMA 标志，这样能保证获得的内存位于 DMA 区域中，并具备 DMA 能力。\n\n关于 ISA、PCI、PCIE 等总线协议的了解，参考：[https://blog.csdn.net/yinqiusheng/article/details/140387774](https://blog.csdn.net/yinqiusheng/article/details/140387774)\n\n内核中定义了使用 GFP_DMA 标志的申请 DMA 缓冲区的快捷函数 `__get_dma_pages()`，定义如下：\n\n```c\n#define __get_dma_pages(gfp_mask, order) \\\n\t\t__get_free_pages((gfp_mask) | GFP_DMA, (order))\n```\n\n如果不想使用参数 order 申请 DMA 内存，可使用另一个函数 dma_mem_alloc()，定义如下：\n\n```c\nstatic unsigned long dma_mem_alloc(unsigned long size)\n{\n    // get_order()：order = log2(size)\n\treturn __get_dma_pages(GFP_KERNEL, get_order(size));\n}\n```\n\n#### 虚拟地址、物理地址和总线地址\n\n基于 DMA 的硬件使用的是总线地址而不是物理地址，总线地址是从设备角度上看到的内存地址，物理地址则是从 CPU MMU 控制器外围角度上看到的内存地址（从 CPU 核角度看到的是虚拟地址）。虽然在 PC 上，对于 ISA 和 PCI 而言，总线地址即为物理地址，但并不是每个平台都是如此。因为有时候接口总线通过桥接电路连接，桥接电路会将 I/O 地址映射为不同的物理地址。\n\n内核提供了如下函数进行简单的虚拟地址/总线地址转换：\n\n```c\nunsigned long virt_to_bus(void *address)\n{\n\treturn (unsigned long)address;\n}\n\nvoid *bus_to_virt(unsigned long address)\n{\n\treturn (void *)address;\n}\n```\n\n#### DMA 地址掩码\n\n设备不一定能在所有的内存地址上执行 DMA 操作，在这种情况下应该通过下列函数执行 DMA 地址掩码：\n\n```c\nint dma_set_mask(struct device *dev, u64 mask);\n```\n\n这个函数的本质是修改 device 结构体中的 dma_mask 成员。在 device 结构体中，除了 dma_mask 以外，还有 coherent_dma_mask 成员。dma_mask 是设备 DMA 可寻址的范围，coherent_dma_mask 用作申请一致性 DMA 缓冲区。\n\n```c\nstruct device {\n\n    ...\n\n\tu64\t\t*dma_mask;\t/* dma mask (if dma'able device) */\n\tu64\t\tcoherent_dma_mask;/* Like dma_mask, but for\n\t\t\t\t\t     alloc_coherent mappings as\n\t\t\t\t\t     not all hardware supports\n\t\t\t\t\t     64 bit addresses for consistent\n\t\t\t\t\t     allocations such descriptors. */\n\n    ...\n};\n```\n\n#### 一致性 DMA 缓冲区\n\n**DMA 映射包括两部分工作：分配一片 DMA 缓冲区；为这片缓冲区产生设备可访问的地址。**同时 DMA 映射也必须考虑 Cache 一致性问题。内核中提供了如下函数以分配一个 DMA 一致性的内存区域：\n\n```c\n// 返回申请到的 DMA 缓冲区的虚拟地址。\n// 通过参数 dma_handle 返回 DMA 缓冲区的总线地址。\nvoid *dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t gfp)\n{\n\treturn dma_alloc_attrs(dev, size, dma_handle, gfp,\n\t\t\t(gfp & __GFP_NOWARN) ? DMA_ATTR_NO_WARN : 0);\n}\n```\n\ndma_alloc_coherent() 申请一片 DMA 缓冲区，进行地址映射并保证该缓冲区的 Cache 一致性。对应的释放函数为 dma_free_coherent()。\n\n```c\nvoid dma_free_coherent(struct device *dev, size_t size, void *cpu_addr, dma_addr_t dma_handle)\n{\n\treturn dma_free_attrs(dev, size, cpu_addr, dma_handle, 0);\n}\n```\n\n使用函数 dma_alloc_writecombine() 分配一个写合并（Writecombining）的 DMA 缓冲区，释放函数是 dma_free_coherent()。这两个接口在 Linux 5.15 以后已移除。\n\nLinux 内核还提供了 PCI 设备申请 DMA 缓冲区的函数 pci_alloc_consistent()，释放函数是 pci_free_consistent()。\n\n```c\nvoid *pci_alloc_consistent(struct pci_dev *hwdev, size_t size, dma_addr_t *dma_handle)\n{\n\treturn dma_alloc_coherent(&hwdev->dev, size, dma_handle, GFP_ATOMIC);\n}\n\nvoid pci_free_consistent(struct pci_dev *hwdev, size_t size, void *vaddr, dma_addr_t dma_handle)\n{\n\tdma_free_coherent(&hwdev->dev, size, vaddr, dma_handle);\n}\n```\n\n> dma_alloc_xxx() 函数虽然以 `dma_alloc_` 开头，但是申请的区域不一定在 DMA 区域里。以 32 位 ARM 处理器为例，当 coherent_dma_mask 小于 0xffffffff 时，才会设置 GFP_DMA 标记，并从 DMA 区域申请内存。\n\n#### 流式 DMA 映射\n\n**并不是所有的 DMA 缓冲区都是驱动申请的，如果是驱动申请的，用一致性 DMA 缓冲区自然最方便，这直接考虑了 Cache 一致性问题。**但在许多情况下，缓冲区来自内核的较上层（如网卡驱动中的网络报文、块设备驱动中要写入设备的数据等），上层很可能用普通的 kmalloc()、`__get_free_pages()` 等方法申请，这时就要使用流式 DMA 映射。使用步骤一般如下：\n\n1. 进行流式 DMA 映射。\n2. 执行 DMA 操作。\n3. 进行流式 DMA 去映射（去掉映射）。\n\n**流式 DMA 映射操作本质上大多是进行 Cache 的使无效或清除操作，以解决 Cache 一致性问题。**\n\n##### 单一缓冲区下的流式 DMA 映射\n\n对于单个已经分配的缓冲区而言，使用 dma_map_single() 可实现流式 DMA 映射。\n\n```c\n#define dma_map_single(d, a, s, r) dma_map_single_attrs(d, a, s, r, 0)\n\n// 映射成功返回总线地址，失败返回 NULL。\n// dir：DMA 的方向，包括 DMA_TO_DEVICE、DMA_FROM_DEVICE、DMA_BIDIRECTIONAL 和 DMA_NONE 等。\ndma_addr_t dma_map_single_attrs(struct device *dev, void *ptr, size_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\t/* DMA must never operate on areas that might be remapped. */\n\tif (dev_WARN_ONCE(dev, is_vmalloc_addr(ptr),\n\t\t\t  \"rejecting DMA map of vmalloc memory\\n\"))\n\t\treturn DMA_MAPPING_ERROR;\n\tdebug_dma_map_single(dev, ptr, size);\n\treturn dma_map_page_attrs(dev, virt_to_page(ptr), offset_in_page(ptr),\n\t\t\tsize, dir, attrs);\n}\n```\n\ndma_map_single() 对应的去映射函数是 dma_unmap_single()。\n\n```c\n#define dma_unmap_single(d, a, s, r) dma_unmap_single_attrs(d, a, s, r, 0)\n\nvoid dma_unmap_single_attrs(struct device *dev, dma_addr_t addr,\n\t\tsize_t size, enum dma_data_direction dir, unsigned long attrs)\n{\n\treturn dma_unmap_page_attrs(dev, addr, size, dir, attrs);\n}\n```\n\n通常情况下，设备驱动不应访问未映射的流式 DMA 缓冲区。如果一定要这么做，可使用如下函数获得 DMA 缓冲区的拥有权。\n\n```c\nvoid dma_sync_single_for_cpu(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir);\n```\n\n在驱动访问完 DMA 缓冲区后，使用如下函数将其所有权返还给设备。\n\n```c\nvoid dma_sync_single_for_device(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir);\n```\n\n##### SG 映射\n\n如果设备要求较大的 DMA 缓冲区，在其支持 SG 模式的情况下，申请多个相对较小不连续的 DMA 缓冲区通常是防止申请太大的连续物理空间的方法。使用函数 dma_map_sg() 申请，对应的释放函数是 dma_unmap_sg()。\n\n```c\n#define dma_map_sg(d, s, n, r) dma_map_sg_attrs(d, s, n, r, 0)\n\n// 函数返回 DMA 缓冲区的数量，可能小于 nents。\n// nents：散列表（scatterlist）入口的数量。\n// 对于 scatterlist 的每个项目，dma_map_sg() 为设备产生恰当的总线地址，它会合并物理上临近的内存区域。\nunsigned int dma_map_sg_attrs(struct device *dev, struct scatterlist *sg, int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tint ret;\n\n\tret = __dma_map_sg_attrs(dev, sg, nents, dir, attrs);\n\tif (ret < 0)\n\t\treturn 0;\n\treturn ret;\n}\nEXPORT_SYMBOL(dma_map_sg_attrs);\n\n#define dma_unmap_sg(d, s, n, r) dma_unmap_sg_attrs(d, s, n, r, 0)\n\nvoid dma_unmap_sg_attrs(struct device *dev, struct scatterlist *sg, int nents, enum dma_data_direction dir, unsigned long attrs)\n{\n\tconst struct dma_map_ops *ops = get_dma_ops(dev);\n\n\tBUG_ON(!valid_dma_direction(dir));\n\tdebug_dma_unmap_sg(dev, sg, nents, dir);\n\tif (dma_map_direct(dev, ops) ||\n\t    arch_dma_unmap_sg_direct(dev, sg, nents))\n\t\tdma_direct_unmap_sg(dev, sg, nents, dir, attrs);\n\telse if (ops->unmap_sg)\n\t\tops->unmap_sg(dev, sg, nents, dir, attrs);\n}\nEXPORT_SYMBOL(dma_unmap_sg_attrs);\n```\n\nscatterlist 结构体定义如下，包含与 scatterlist 对应的页结构体指针、缓冲区在页中的偏移 offset、缓冲区长度 length 以及总线地址 dma_address。\n\n```c\nstruct scatterlist {\n\tunsigned long\tpage_link;\n\tunsigned int\toffset;\n\tunsigned int\tlength;\n\tdma_addr_t\tdma_address;\n#ifdef CONFIG_NEED_SG_DMA_LENGTH\n\tunsigned int\tdma_length;\n#endif\n};\n```\n\n执行 dma_map_sg() 后，通过 sg_dma_address() 返回 scatterlist 对应缓冲区的总线地址，sg_dma_len() 返回 scatterlist 对应缓冲区的长度。\n\n```c\n#define sg_dma_address(sg)\t((sg)->dma_address)\n\n#define sg_dma_len(sg)\t\t((sg)->dma_length)\n```\n\n同单一缓冲区的情况，如果设备驱动一定要访问未映射的 SG 缓冲区，应先调用函数 dma_sync_sg_for_cpu()，归还所有权的函数是 dma_sync_sg_for_device()。\n\n```c\nvoid dma_sync_sg_for_cpu(struct device *dev, struct scatterlist *sg, int nelems, enum dma_data_direction dir);\n\nvoid dma_sync_sg_for_device(struct device *dev, struct scatterlist *sg, int nelems, enum dma_data_direction dir);\n```\n\n#### dmaengine 标准 API\n\n推荐使用 dmaengine 的驱动架构来编写 DMA 控制器的驱动，外设的驱动使用标准的 dmaengine API 进行 DMA 的准备、发起和完成时的回调工作。\n\n和中断一样，在使用 DMA 前，设备驱动程序需首先向 dmaengine 系统申请 DMA 通道，申请 DMA 通道的函数如下：\n\n```c\n/* Deprecated, please use dma_request_chan() directly */\nstruct dma_chan * __deprecated dma_request_slave_channel(struct device *dev, const char *name)\n{\n\tstruct dma_chan *ch = dma_request_chan(dev, name);\n\n\treturn IS_ERR(ch) ? NULL : ch;\n}\n\nstruct dma_chan *dma_request_chan(struct device *dev, const char *name);\n```\n\n对应的释放通道的函数是 dma_release_channel()。\n\n```c\nvoid dma_release_channel(struct dma_chan *chan);\n```\n\n下面是利用 dmaengine API 发起一次 DMA 操作的示例：\n\n```c\nstatic void xxx_dma_fini_callback(void *data)\n{\n    struct completion *dma_complete = data;\n\n    complete(dma_complete);\n}\n\nissue_xxx_dma(...)\n{\n    // 通过 dmaengine_prep_slave_single() 准备好一些 DMA 描述符。\n    rx_desc = dmaengine_prep_slave_single(xxx->rx_chan, xxx->dst_start, t->len, DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT | DMA_CTRL_ACK);\n\n    // 填充完成回调为 xxx_dma_fini_callback()。\n    rx_desc->callback = xxx_dma_fini_callback;\n    rx_desc->callback_param = &xxx->rx_done;\n\n    // 通过 dmaengine_submit() 把这个描述符插入队列。\n    dmaengine_submit(rx_desc);\n\n    // 通过 dma_async_issue_pending() 发起这次 DMA 动作。完成后 xxx_dma_fini_callback() 函数会被 dmaengine 驱动自动调用。\n    dma_async_issue_pending(xxx->rx_chan);\n}\n```\n\n## 小结\n\n外设可处于 CPU 的内存空间和 I/O 空间。除 x86 外，嵌入式处理器一般只存在内存空间。Linux 为 I/O 内存和 I/O 端口的访问提高了一套统一的方法，访问流程一般为**申请资源->映射->访问->去映射->释放资源**。\n\n对于有 MMU 的处理器而言，Linux 的内部布局比较复杂，可直接映射的物理内存称为常规内存，超出部分为高端内存。kmalloc() 和 `__get_free_pages()` 申请的内存在物理上连续，vmalloc() 申请的内存在物理上不连续。\n\nDMA 操作可能导致 Cache 不一致性的问题，故对于 DMA 缓冲，应使用 dma_alloc_coherent() 等方法申请。在 DMA 操作中涉及总线地址、物理地址和虚拟地址等概念，区分这 3 类地址非常重要。\n\n# 块设备驱动\n\n见文章 [https://blog.davidingplus.cn/posts/69869e7f.html](https://blog.davidingplus.cn/posts/69869e7f.html)。\n\n","categories":["Linux 学习","内核层"]},{"title":"搭建自己的 teamspeak 服务器","url":"/posts/eb8579d8.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 前言\n\nteamspeak 是一款开源、轻量的语音软件，这是它的[官网](https://teamspeak.com/en/)。在官网可以下载客户端 client 和服务端 server，国内客户端下载推荐地址 [https://ts3.com.cn/downloads/teamspeak](https://ts3.com.cn/downloads/teamspeak)，后续的下载安装都是针对服务端。为了方便，后文简称 teamspeak 为 ts。\n\n为什么要用 ts 呢？有人会说，用 yy 啊，用 qq、微信啊。qq 和微信语音的质量没法说， yy 很吃电脑配置和带宽，我的电脑比较垃圾，所以想要一个比较轻量的语音软件。这时候 ts 就是一个非常好的选择了。\n\n> 其实 [kook](https://www.kookapp.cn/) 也不错，但是 ts 更轻量，我个人感觉用起来也更舒服。\n>\n> 啊？你问为什么不用 [discord](https://discord.com/) 。你说为什么，谁打个游戏聊个天还需要翻墙才行？\n\n<!-- more -->\n\nts 官方提供了服务器租赁的服务，根据租赁时间和服务器最大人数设有不同的价位，国内的话具体[点击这里](https://ts3.com.cn/price)进行查看。但是作为一个码农，既然 ts 是开源的，并且我可以自己下载 server 部署，那我为什么不自己搭建一个 ts 服务器呢？将其搭建在自己的服务器上，不就可以和朋友们一起愉快的玩耍了吗？\n\n> 注意：\n>\n> 本文需要读者有一台带有公网的机器，最好是 Linux。这里我以我的云服务器 Ubuntu 20.04 为例。我的云服务器通过 [1Panel](https://1panel.cn) 进行管理，所以后续的部分操作会通过 1Panel 面板直接进行，关于命令行或者其他的操作请自行查阅资料。\n\n# 搭建部署\n\nts 服务端也是一个程序，所以显而易见，部署 ts 服务端的本质就是让服务端程序跑起来。这一点不管是对于本地还是公网都是一样的，唯一区别就在于一个只能本地访问，一个能进入公网访问。\n\n关于部署形式，有很多种。可以直接下载 ts 服务端，配置好运行环境，调好运行参数，然后在云服务器后台挂着跑；也可以通过 docker 进行隔离化部署。当然，这里我们选择通过方便的 docker 进行部署。\n\n## 通过 docker 部署\n\n安装 docker 不是本文重点，可以参考文章 [https://www.cnblogs.com/Liyuting/p/17022739.html](https://www.cnblogs.com/Liyuting/p/17022739.html) 或者自行查阅资料。当然有些可视化面板例如宝塔或者 1Panel 是可以通过面板操作的，这里也不详细阐述。\n\ndocker 安装成功以后，通过以下命令部署 ts 服务端：\n\n```bash\ndocker run -p 9987:9987/udp -p 10011:10011 -p 10022:10022 -p 10080:10080 -p 10443:10443 -p 30033:30033 -p 41144:41144 -e TS3SERVER_LICENSE=accept -e TS3SERVER_SERVERADMIN_PASSWORD=<your_password> --name=\"teamspeak-server\" -d teamspeak\n```\n\n关于这些 `-xxx` 参数的含义和规则，可以参考文章[https://blog.csdn.net/weixin_39998006/article/details/99680522](https://blog.csdn.net/weixin_39998006/article/details/99680522)，这里只进行简单的阐述：\n\n- -p：**主机端口:容器内部端口**，代表程序需要用到的端口，当然云服务器需要放开公网端口的防火墙。关于主机端口和容器内部端口，后续会做解释。\n- -e：运行程序配置的环境变量，这里非常推荐加上 `TS3SERVER_SERVERADMIN_PASSWORD=<your_password>`，`<your_password>` 改为读者自己想要设置的密码，这个在后续找回 ts 服务器权限 token 的时候非常有用，后文会解释这一点。\n- --name：容器名称，方便我们自己管理。\n- -d：在后台运行，退出终端也不会结束进程，相当于 nohup 命令。\n\n## docker 被墙了\n\n有人问，现在 docker hub 以及镜像全被墙了，怎么办？本地其实很简单，科学上网就行了。但是云服务器呢？哥们，我咋给云服务器开代理？\n\n网上有很多解决方案，有搭建自己的镜像源的，也有一些可用的镜像源，例如我正在用的 [https://docker.1panel.live](https://docker.1panel.live)，好用爱用。\n\n具体请参考文章 [https://mixuying.com/archives/1719753069678](https://mixuying.com/archives/1719753069678)，详细介绍了如何修改 docker 镜像源。\n\n## 开放防火墙端口\n\nts 服务器是需要几个 tcp 协议的端口和一个 udp 协议的端口的，具体如下：\n\n这里有一点需要强调的是，docker 容器应用具有容器内端口，通过容器内端口转发到云服务器的主机端口，再对外通信。因为 docker 的本质是一个具有运行环境的轻量隔离化容器，显然具有自己的容器内端口。为了避免可能发生的错误，最好保持这两个端口一致。\n\n|       服务        | 协议 | 主机端口 | 是否必要 |\n| :---------------: | :--: | :------: | :------: |\n|     语音服务      | UDP  |   9987   |    是    |\n|     文件传输      | TCP  |  30033   |    是    |\n| 服务器查询（raw） | TCP  |  10011   |   可选   |\n| 服务器查询（SSH） | TCP  |  10022   |   可选   |\n| 网络查询（http）  | TCP  |  10080   |   可选   |\n| 网络查询（https） | TCP  |  10443   |   可选   |\n|       TSDNS       | TCP  |  41144   |   可选   |\n\n通过云服务器的安全组策略放开对应的防火墙端口即可。具体如何操作不进行赘述。\n\n值得注意的是，如果你的服务器安装了可视化面板，除了云服务器厂商需要放行一次端口以外，面板可能也需要放行一次。\n\n这样操作以后，整个 ts 服务器就算是搭建成功了，后续进行初始化配置就可以正常使用了。\n\n# 初始化服务器\n\n## 获取管理员 token\n\n当 ts 服务端第一次初始化的时候，会自动生成一个 token 用作管理员权限的激活。查看日志即可获得：\n\n```markdown\n------------------------------------------------------------------\n                      I M P O R T A N T                           \n------------------------------------------------------------------\n               Server Query Admin Account created                 \n         loginname= \"serveradmin\", password= \"your_password\"\n         apikey= \"xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n------------------------------------------------------------------\n\n...\n\n------------------------------------------------------------------\n                      I M P O R T A N T                           \n------------------------------------------------------------------\n      ServerAdmin privilege key created, please use it to gain \n      serveradmin rights for your virtualserver. please\n      also check the doc/privilegekey_guide.txt for details.\n\n       token=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n------------------------------------------------------------------\n```\n\n`token=` 后面的东西就是激活码了。\n\n值得注意的是，上面一条重要的信息中，给出了一个 loginname 和 password ，这是用作服务器查询的管理员账号，这里的 password 正好是我们安装时候指定的 password ，而不是默认随机生成的，而 loginname 是统一的 serveradmin 。这样对后续的服务器维护操作，特别是需要迁移的时候提供了极大的方便。apikey 我目前没有需要会用到，因此忽略即可。\n\n## 第一次进入服务器\n\n获得 token 以后，就可以通过客户端连接进入 ts 服务器了。连接地址输入自己的服务器公网 IP 即可，如图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240816192530057.png\" alt=\"image-20240816192530057\" style=\"zoom:67%;\" />\n\n连接成功以后，会弹出提示，输入 token 激活获得管理员权限即可。\n\n# 维护服务器\n\nts 客户端使用 Qt 开发的，功能齐全也非常好用。关于客户端的具体教程可参考[官方文档](https://www.teamspeak3.com/teamspeak-server-support.php)，包含了频道管理、用户管理、个性化服务器、调整自己的设备等。\n\n以上都是关于客户端的一些使用方法，下面主要想讨论关于服务端的一些维护技巧。\n\n## 给服务器绑定域名\n\n众所周知，IP 非常难记，并且随意暴露自己的公网 IP 还有被攻击的风险（虽然我的服务器绑定了域名但是没套 cdn 来隐藏 IP）。因此，可以考虑给 ts 服务器绑定一个域名。\n\n首先需要一个属于自己的域名，国内和国外的服务商都可以考虑。例如你的域名是 abc.com，你想把子级域名 ts.abc.com 绑定在 ts 服务器上。\n\n我们需要添加一条 A 记录和一条 SRV 记录，域名 DNS 解析记录的具体含义请参考文档 [https://zhuoyun233.com/2022/05/10/TeamSpeakGuide/](https://zhuoyun233.com/2022/05/10/TeamSpeakGuide/)。\n\n### A 记录\n\n1. 主机名（Hostname）处填写子域名，如我使用 ts.abc.com 作为服务器的域名，则填写 ts。\n2. 地址/值（Address/Value）处填写 ts 服务器的 IP 地址。\n3. TTL 设置为 600 秒即可，这是 ts 服务器刷新的时长。我的默认就是 600 秒。\n\n### SRV 记录\n\n1. 以 `_ts3` 作为服务，以 `_udp` 作为协议，以上一条填写的子域名为名称，在主机名（Hostname）处填写 `_ts3._udp.ts`。\n2. 在目标主机名（Target Hostname）处填写完整的域名，如 ts.abc.com。\n3. 端口（Port）处填写 ts 语音服务端口（默认为 9987）。\n4. 权重（Weight）处填写 5。\n5. 优先级（Distance/Priority）处填写 0（或 1）。\n6. TTL 同上设置为 600 秒即可。\n\n### 结果\n\n设置完毕以后，两条 DNS 解析记录的情况应该类似于这样：\n\n| 类型 | 名称           | 内容/值             | TTL    |\n| ---- | -------------- | ------------------- | ------ |\n| A    | ts             | 服务器的 IP 地址    | 600 秒 |\n| SRV  | `_ts3._udp.ts` | 0 5 9987 ts.abc.com | 600 秒 |\n\n这样等待 DNS 刷新以后就能使用域名进入服务器了。\n\n## server query 查询服务\n\n如果我想要生成一个新的管理员 token 权限码，应该怎么办呢？\n\n首先，如果你本身是具有管理员权限的话，你可以在 ts 客户端直接生成备用 token 权限码，并且可以针对不同的权限生成对应权限的 token。具体教程可以查看官方文档：[TEAMSPEAK SUPPORT :: HOW TO USE A PRIVILEGE KEY IN TEAMSPEAK 3](https://www.teamspeak3.com/support/teamspeak-3-privilege-keys.php)\n\n但是问题来了，假设某一天你的 ts 服务器的 admin 管理员权限莫名其妙的丢了（不排除某位 admin 因为某些原因给你下了，但是联系不上他了），现在你需要重新找回管理员权限，该怎么办呢？\n\n好，现在如果你作为服主，你的管理员权限丢了，不用担心。我们可以通过 ts 服务器 10011 端口的查询服务 server query 以管理员身份登录，生成新的管理员 token 或者重置所有人的权限。当然里面还有更多其他的操作，官方也给出了 [issue](https://community.teamspeak.com/t/how-to-use-the-server-query/25386) 进行讨论，有兴趣请自行查阅。\n\n### 登录\n\n第一步，通过命令行登入 ts 服务器 server query 后台，此处需要使用 telnet 命令。Linux 下可以通过 apt/yum 包管理器安装，Windows 下可以推荐使用 Scoop 包管理器安装。\n\n```bash\ntelnet 服务器的 IP 地址 10011\n```\n\n出现这样的输出信息，代表连接成功：\n\n![image-20240820100020844](https://cdn.davidingplus.cn/images/2025/02/01/image-20240820100020844.png)\n\n输入 `help` 命令可以看到所有的命令列表，肉眼可见，可以干非常多的事情：\n\n```bash\nhelp\n\n# TeamSpeak 3 Server :: ServerQuery\n# (c) TeamSpeak Systems GmbH\n\n# ServerQuery is a command-line interface built into the TeamSpeak 3 Server which\n# allows powerful scripting and automation tools to be built based on the exact\n# same instruction set and functionality provided by the TeamSpeak 3 Client. For\n# example, you can use scripts to automate the management of virtual servers or\n# nightly backups. In short, you can perform operations more efficiently by using\n# ServerQuery scripts than you can by using a user interface.\n\n# Command Overview:\n#    apikeyadd                   | create a apikey\n#    apikeydel                   | delete a apikey\n#    apikeylist                  | list apikeys\n#    banadd                      | create a ban rule\n#    banclient                   | ban a client\n#    bandel                      | delete a ban rule\n#    bandelall                   | delete all ban rules\n#    banlist                     | list ban rules on a virtual server\n#    bindinglist                 | list IP addresses used by the server instance\n#    channeladdperm              | assign permission to channel\n#    channelclientaddperm        | assign permission to channel-client combi\n#    channelclientdelperm        | remove permission from channel-client combi\n#    channelclientpermlist       | list channel-client specific permissions\n#    channelcreate               | create a channel\n#    channeldelete               | delete a channel\n#    channeldelperm              | remove permission from channel\n#    channeledit                 | change channel properties\n#    channelfind                 | find channel by name\n#    channelgroupadd             | create a channel group\n#    channelgroupaddperm         | assign permission to channel group\n#    channelgroupclientlist      | find channel groups by client ID\n#    channelgroupcopy            | copy a channel group\n#    channelgroupdel             | delete a channel group\n#    channelgroupdelperm         | remove permission from channel group\n#    channelgrouplist            | list channel groups\n#    channelgrouppermlist        | list channel group permissions\n#    channelgrouprename          | rename a channel group\n#    channelinfo                 | display channel properties\n#    channellist                 | list channels on a virtual server\n#    channelmove                 | move channel to new parent\n#    channelpermlist             | list channel specific permissions\n#    clientaddperm               | assign permission to client\n#    clientdbdelete              | delete client database properties\n#    clientdbedit                | change client database properties\n#    clientdbfind                | find client database ID by nickname or UID\n#    clientdbinfo                | display client database properties\n#    clientdblist                | list known client UIDs\n#    clientdelperm               | remove permission from client\n#    clientedit                  | change client properties\n#    clientfind                  | find client by nickname\n#    clientgetdbidfromuid        | find client database ID by UID\n#    clientgetids                | find client IDs by UID\n#    clientgetnamefromdbid       | find client nickname by database ID\n#    clientgetnamefromuid        | find client nickname by UID\n#    clientgetuidfromclid        | find client UID by client ID\n#    clientinfo                  | display client properties\n#    clientkick                  | kick a client\n#    clientlist                  | list clients online on a virtual server\n#    clientmove                  | move a client\n#    clientpermlist              | list client specific permissions\n#    clientpoke                  | poke a client\n#    clientsetserverquerylogin   | set own login credentials\n#    clientupdate                | set own properties\n#    complainadd                 | create a client complaint\n#    complaindel                 | delete a client complaint\n#    complaindelall              | delete all client complaints\n#    complainlist                | list client complaints on a virtual server\n#    custominfo                  | display custom client properties\n#    customsearch                | search for custom client properties\n#    customset                   | add or update a custom client property.\n#    customdelete                | remove a custom client property.\n#    ftcreatedir                 | create a directory\n#    ftdeletefile                | delete a file\n#    ftgetfileinfo               | display details about a file\n#    ftgetfilelist               | list files stored in a channel filebase\n#    ftinitdownload              | init a file download\n#    ftinitupload                | init a file upload\n#    ftlist                      | list active file transfers\n#    ftrenamefile                | rename a file\n#    ftstop                      | stop a file transfer\n#    gm                          | send global text message\n#    help                        | read help files\n#    hostinfo                    | display server instance connection info\n#    instanceedit                | change server instance properties\n#    instanceinfo                | display server instance properties\n#    logadd                      | add custom entry to log\n#    login                       | authenticate with the server\n#    logout                      | deselect virtual server and log out\n#    logview                     | list recent log entries\n#    messageadd                  | send an offline message\n#    messagedel                  | delete an offline message from your inbox\n#    messageget                  | display an offline message from your inbox\n#    messagelist                 | list offline messages from your inbox\n#    messageupdateflag           | mark an offline message as read\n#    permfind                    | find permission assignments by ID\n#    permget                     | display client permission value for yourself\n#    permidgetbyname             | find permission ID by name\n#    permissionlist              | list permissions available\n#    permoverview                | display client permission overview\n#    permreset                   | delete all server and channel groups and\n#                                | restore default permissions\n#    privilegekeyadd             | creates a new privilege key\n#    privilegekeydelete          | delete an existing privilege key\n#    privilegekeylist            | list all existing privilege keys on this server\n#    privilegekeyuse             | use a privilege key\n#    queryloginadd               | add a query client login\n#    querylogindel               | remove a query client login\n#    queryloginlist              | list all query client logins\n#    quit                        | close connection\n#    sendtextmessage             | send text message\n#    servercreate                | create a virtual server\n#    serverdelete                | delete a virtual server\n#    serveredit                  | change virtual server properties\n#    servergroupadd              | create a server group\n#    servergroupaddclient        | add client to server group\n#    servergroupaddperm          | assign permissions to server group\n#    servergroupautoaddperm      | globally assign permissions to server groups\n#    servergroupautodelperm      | globally remove permissions from server group\n#    servergroupclientlist       | list clients in a server group\n#    servergroupcopy             | create a copy of an existing server group\n#    servergroupdel              | delete a server group\n#    servergroupdelclient        | remove client from server group\n#    servergroupdelperm          | remove permissions from server group\n#    servergrouplist             | list server groups\n#    servergrouppermlist         | list server group permissions\n#    servergrouprename           | rename a server group\n#    servergroupsbyclientid      | get all server groups of specified client\n#    serveridgetbyport           | find database ID by virtual server port\n#    serverinfo                  | display virtual server properties\n#    serverlist                  | list virtual servers\n#    servernotifyregister        | register for event notifications\n#    servernotifyunregister      | unregister from event notifications\n#    serverprocessstop           | shutdown server process\n#    serverrequestconnectioninfo | display virtual server connection info\n#    serversnapshotcreate        | create snapshot of a virtual server\n#    serversnapshotdeploy        | deploy snapshot of a virtual server\n#    serverstart                 | start a virtual server\n#    serverstop                  | stop a virtual server\n#    servertemppasswordadd       | create a new temporary server password\n#    servertemppassworddel       | delete an existing temporary server password\n#    servertemppasswordlist      | list all existing temporary server passwords\n#    setclientchannelgroup       | set a clients channel group\n#    tokenadd                    | alias for privilegekeyadd\n#    tokendelete                 | alias for privilegekeydelete\n#    tokenlist                   | alias for privilegekeylist\n#    tokenuse                    | alias for privilegekeyuse\n#    use                         | select virtual server\n#    version                     | display version information\n#    whoami                      | display current session info\n\n\n# error id=0 msg=ok\n```\n\n留意最下面的一行，代表了你输入命令的执行状态，`error id=0 msg=ok` 代表没有任何问题，即执行成功。\n\n现在让我们为自己生成一个新的管理员 token。首先需要通过账号密码登录，管理员账号是 `serveradmin`，密码是部署服务器一开始我千叮咛万嘱咐让你配置的密码环境变量。看，在这里就发挥作用了。如果使用默认的密码，又长又难记，并且只会在日志最开头展示一次。如果忘记备份并且日志丢失或损坏，那就完蛋了。\n\n输入以下命令进行登录，如果不出意外，会得到 ok 的结果：\n\n```bash\nlogin serveradmin <your_password>\n# error id=0 msg=ok\n```\n\n### 找回管理员 token\n\n登录成功以后，需要选择 teamspeak instance 实例。按照前面的流程走下来，我们的 ts 服务端的实例应该就是默认值 1。\n\n```bash\nuse 1\n# error id=0 msg=ok\n```\n\n之后就可以生成新的 token 了，输入如下命令：\n\n```bash\ntokenadd tokentype=0 tokenid1=6 tokenid2=0\n# token=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n```\n\n如果不输入 `use 1`，可能会出现如下的错误：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240820101616202.png\" alt=\"image-20240820101616202\" style=\"zoom:70%;\" />\n\n### 重置服务器的权限\n\n当然，前面的命令是可能出现问题的，并且还不好解决。那么有没有什么办法可以重置权限呢？\n\n是可以的，通过命令 `permreset`，这样会重置服务器的权限组为默认并重新为你生成一个管理员 token。注意，是权限组的重置，所以服务器的文件或者频道并不会收到任何影响。同时这个命令一般不会出现什么问题，这也是我的下下策。\n\n```bash\npermreset\n# token=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n# error id=0 msg=ok\n```\n\n## 迁移服务器\n\n### 官网的迁移教程\n\n对于我们这些抠门的码农而言，云服务器基本上是一年一换的。哪家有羊毛就薅哪家，所以 ts 服务器的迁移是非常必要的需求。如果每次都重新配置频道和权限，那未免也太麻烦了。当然，ts 服务器当然是支持迁移的。\n\n官网的教程请参考：[I WANT TO MOVE MY SERVER TO ANOTHER MACHINE, WHICH FILES SHOULD I COPY?](https://support.teamspeak.com/hc/en-us/articles/360002713038-I-want-to-move-my-server-to-another-machine-which-files-should-I-copy)\n\n翻译总结一下如下：\n\n1. licensekey.dat：此文件包含你的许可证。你可能没有此文件，在这种情况下，你无需复制它。\n2. query_ip_whitelist.txt：查询接口的白名单 IP。\n3. query_ip_blacklist.txt：查询接口的黑名单 IP。\n4. files/：上传到服务器的任何图标、头像和文件。请务必复制整个文件夹，包括任何子文件夹和其中的文件。\n5. ts3server.sqlitedb：数据库此文件最为重要，包含有关虚拟服务器、用户、权限、频道和组等的所有信息。服务器实例及其虚拟服务器的所有设置都包含在此文件中。\n6. *.ini：可能存在的包含启动参数和数据库配置的文件。默认情况下不存在这些文件。\n7. tsdns/tsdns_settings.ini：TSDNS 服务的配置。仅在你实际使用 TSDNS 时需要此配置。\n\n### 对于我自己和大部分人的情况\n\n对于我个人而言，服务端没有配置什么 TSDNS 服务配置，也没有写入什么 ini 文件。同时我是通过 docker 部署，通过 1Panel 进行管理的。所以上面官网的教程可能不一定适用，因此我做了一定的尝试，摸索出了适合我自己的迁移方法。\n\n让我们查看 docker 中 ts 服务器对应的存储卷的内容，经过验证，除了 logs/ 日志目录的文件不是必要的，其他都需要拷贝到新机器对应的位置。注意这里数据库的文件似乎与官网提到的有冲突。我个人尝试过只拷贝第一个，但是备份失败，因此全部拷过去覆盖即可。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240820103802807.png\" alt=\"image-20240820103802807\" style=\"zoom:55%;\" />\n\n> 最后，再次回到前面设置密码环境变量的伏笔。这里我们的日志是没有同步的，当然如果你也可以选择直接覆盖日志进行同步。但是问题是，如果不手动设置密码，将服务器做了迁移以后，日志中的密码就不一定正确了，这一点我也不知道为什么，试验出来的结果是这样的。因此将密码牢牢掌握在自己手中，才是最终的解决方案。\n\n做好迁移以后，再次进入服务器，如果不出意外的话，所有的频道和权限都会保留，又可以和朋友继续开心的玩耍了。\n\n# 参考文档\n\n1. [TEAMSPEAK SERVER SUPPORT](https://www.teamspeak3.com/teamspeak-server-support.php)\n\n2. [使用 Docker 搭建属于自己的 TeamSpeak 服务器](https://www.bilibili.com/read/cv22920320/)\n\n3. [Teamspeak 服务器搭建、绑定域名、迁移](https://www.bilibili.com/read/cv36119499/)\n\n4. [TeamSpeak 3 服务器管理员权限丢失了怎么办？7 步帮你找回！](https://www.bilibili.com/read/cv4893931/)\n\n","categories":["一些技巧"]},{"title":"合迅科技 实习感悟","url":"/posts/3277d86d.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n本来不想写这篇文章的，但是看到实习报告的总结部分需要写一个收获及体会，还是码一篇文章大致谈谈实习的感悟吧。\n\n# 学院的实习政策\n\n我是电子科技大学信息与软件工程学院`2021`级的一名普通本科生。按照学院的培养方案，大三下的这段时间是需要出去实习半年的。在以往，除了正常在企业上班，还可以选择在校内或者校外的实验室工作来抵实习。并且以往的时候，实习是不计入保研成绩的。在这样的情况下，水实习的情况大有人在，以我大二下到大三上所在的实验室为例，不会写代码但是进去充数的人比比皆是。这样的“实习”不是一个让我们学习和进步的选择，反而是在浪费学校和企业的资源和时间。\n\n<!-- more -->\n\n在这样的背景下，学院今年做出了改革。首次将实习纳入保研评分。实习这门课程有`8`个学分，比计算机组成原理还多`1`个学分。因此对于保研线边缘的同学来讲，这极可能成为翻身的绝佳机会，也可能成为压死骆驼的最后一根稻草。今年学院不允许在本校的实验室工作来抵实习，也一定程序上减少了在本校实验室水实习的情况吧，毕竟外校实验室肯定比本校实验室难进。所以绝大多数同学，包括我，都是选择在企业进行实习。然后学院对整个实习指定了各种杂七杂八的评分规则，这些我都无所谓，我把公司和学校的事情做好就完事了。\n\n# 很重要的一个问题\n\n这样的实习政策本身是没有问题的。让同学们真正到企业去实习，见见世面，学学技术，提升自己。这是完全`ok`的。但问题就处在我们是第一届实行这个政策的，加上学院的通知非常迟，不管是消息还是文件通知。我从大三学期开始隐隐约约直到实习**可能**会计入保研，当时是去年`9`月。然后一直到`11`月底，没有任何消息。然后很突然的召集年级同学开会，说实习计入保研，并且只能去企业或者校外实验室实习，然后把仓促弄出来的实习政策公布给我们这群小白鼠的事情。\n\n我的天，当时已经`12`月了。按照至少半年的说法，`1`月初考完试就马上要去实习，才能保证暑假回来，然后有时间准备`9`月的实习答辩。哦对，我们实习是需要全员答辩的。就给不到一个月的时间，如何找到适合自己的企业或者实验室呢？难，难如登天。我们宿舍还是提前得知了小道消息（那时候大概也`11`月了），所有人才勉强找到实习单位的。那大部分的同学呢？别人在复习马原毛概的时候你来一句考完试立马要出去上班，现在的工作尤其是互联网行业的工作，真的是这么好找的吗？其次，学院的确也给了很多和学校合作的企业选择，但是还是那个问题，这么短的时间真的能选出双向匹配的企业吗？这就导致很多同学在今年`2`月过了年以后都没有实习岗位。有人可能会说，哦，你自己能力不行，没有找到实习是你自己的问题。拜托，现在互联网行业形势这么烂，简历投出去能不能被别人正眼看都不知道，这么短的时间所有人都找到实习是不现实的。\n\n另外，这严重打乱了同学们的规划。以我为例，我去年`10`月联系了一个计算机学院的导师，互相交流以后想跟着他学习。当时我的分数是保研边缘，我个人的想法就是大三下冲一把竞赛，同时跟着导师学习。当然我还不知道实习会计入保研。然后后面我才突然知道实习计入保研。好好好，实习`8`个学分，我保研边缘的水平，我敢放？因此只有跟导师说明情况，然后去弄分数，弄排名。不过我现在有蓝桥杯国二，保研这边是问题不大了，也到现场和学长和导师聊过，有希望冲刺进去。不过这只是我个人的个例，我觉得里面有相当大的运气成分，例如蓝桥杯运气比较好，导师的实验室刚好有我感兴趣的方向。如果再来一次，这些事情真的很难能再次做到，这其中背负的心理压力是巨大的。我那段时间都快抑郁了，甚至可能已经抑郁了。这是我个人的例子，那对于大多数同学呢？对于保研的同学，尤其是我这种保研边缘的同学，极可能成为翻身的绝佳机会，也可能成为压死骆驼的最后一根稻草。对于考研的同学，复习的时间大大减少了（以前很多同学是借着实习的名义在实验室复习考研），那必然会更苦、更累。对于就业的同学，这没什么好说的，因为不管在哪种政策下，大概率都是去企业实习，因此他们总是会提前准备。但是大部分的同学是考研、保研的人啊。我个人认为，打乱规划这些都是小事，但是你在某个关键的时间点打乱规划，那就很恶心了。如果这个实习政策提前半年公布，那没有任何问题，这是个非常好的实习政策，但是问题就是太匆忙。给我们的感受就是，我们是小白鼠，这些事情发生的真的太仓促了。\n\n# 合迅科技\n\n不过，吐槽归吐槽。抱着既来之则安之的想法，我尝试去和我实验室合作的公司上班。公司领导也是非常愉快的同意了，也开始了让我受益匪浅的半年实习经历。\n\n我这半年实习的公司叫[成都中科合迅科技有限公司](https://www.sinux.com.cn/)。我对公司整体的业务了解不是很深，但是我知道我们部门的工作基本分为两个板块，交付和研发。交付就是使用`Qt`，根据客户的需求，很多都是一些军工企业和研究所，去做一些项目。研发就是领导带领我们一起做`Lark5`产品，主要是[LarkSDK](http://caiyi.tech/larksdk/)的相关工作（`LarkSDK`是`Lark5`中最基础和重要的，其他东西都是基于`LarkSDK`开发的）。而我参与的就是研发工作，也是非常有意思和有意义的工作。\n\n在进入公司之前，在实验室的时候，我就一直就有疑惑，为什么我们需要做一个自己的国产的`C++`通用开发框架呢？当时对于本科学生的我而言，我只把它当作是一门提升`C/C++`代码水平的途径。所以，当我的同学问我，哎，公司费时费力做这个的意义是什么呢？我答不上来。现实情况也的确如此，业界对于跨平台的`C++`图形开发框架，业界第一反应都是`Qt`。是啊，我在进入实验室以前都一直以为实验室是在做`Qt`外包开发，甚至我还专门写了一个[扫雷](https://github.com/DavidingPlus/mine-sweeper)来准备面试（写的不好请见谅）。`Qt`在这个领域似乎是垄断的存在。并且公司的交付项目都是使用`Qt`框架开发的，包括另个组在进行的[合迅智灵插件框架](https://www.sinux.com.cn/product1.html)的开发，也是基于`Qt`框架做的二次加工。说白了，我们是拿着别人写好的东西去做开发。至于`Qt`内部是怎么实现的，我们作为用户不用关心，只需要知道这样能解决问题就行。\n\n那么问题来了，这样的工作真的是我想要的吗？我是一个本科在校实习生，我不用过多考虑赚钱的事情。当然，只要我不乱花钱，每个月能存一些钱，那就是好的。其次，既然我是一个本科在校实习生，我离本科毕业还有一年多的时间，并且我之后还要继续读研，甚至读博，我应该做的是提升自己，那我为什么不选择做像`Lark5`产品的研发呢？学到的知识和技术不管以后对我的深造和就业，都有帮助啊。抱着这样的想法，我加入了`Lark5`研发组。同时，在这个过程中，我逐渐明白了上面问题的答案。\n\n和`Qt Framework`一样，`LarkSDK`是一款跨平台`C++`开发框架。它使得用户无需花费精力在操作系统的特性和底层调用细节，从而更专注于业务需求开发。`LarkSDK`并非是任何其他框架的套壳产品，这意味着，除了引用一些不得不使用的基础轮子之外，`LarkSDK`的所有代码都是完全自研的。这就是我们这个产品`LarkSDK`的概述。更多细节请参见[合迅智灵 LarkSDK 用户手册](http://caiyi.tech/larksdk/)。好，还是那个问题，既然`Qt`都有成熟的框架了，为什么我们还要费尽心思做一款国产的`LarkSDK`呢？\n\n为了国产生态。目前，国内在软件开发平台领域的缺失，导致国内软件行业在开发软件时不得不大量使用国外厂商的开发平台，从而遭遇信息安全存在隐患、国产操作系统环境适配性差、维护服务没有支持、版权使用存在风险等重要问题，没有国产软件开发平台支持，软件开发环节效率低、软件开发成果不稳定也成为国内软件行业普遍存在的问题。对标到我们的`LarkSDK`产品上，虽然`Qt`是开源的，它的源代码就摆在那，但是它毕竟是老外写的，不受国人完全掌控，当然也没有哪个神仙去一行一行扒`Qt`的源码看有没有埋雷。有人说，用大模型啊，行啊，那你去用大模型写一个`QtBase`出来，写一个`Linux`内核出来。在这样的背景下，我们无法预测未来的某一天会不会出现类似被卡脖子的问题。像华为芯片事件和微软蓝屏事件就是最好的印证。更不用说`Qt`还有社区版和商用版的区别了。万一某些东西就是只能通过商用版得到，那后续的一切都受制于别人。尤其我们公司还是一个军工企业，这样的问题就更应该得到重视。还是那句话，技术只有掌握在我们自己手中，国家发展的命脉才不会被别人牵着走。我可以不用，但我不能没有。这一点国家已经开始意识到了，例如国产操作系统银河麒麟、华为鸿蒙等等。而我们致力于在基础软件开发平台这一赛道，制作出一款属于我们国人自己的，更懂国产生态的`LarkSDK`。这条路并不容易，但我们坚信这是一条正确的路，难而正确的路。\n\n# 实习收获\n\n很幸运，我在实习期间遇到了一位非常好的组长和领导，[钟采奕](http://caiyi.tech/cv/)，我一般称呼为钟老师。我们做的是跨平台的`C++`基础开发框架，自然需要涉及到大量底层的知识，包括但不限于基础事件驱动框架、常用数据结构支持、多线程支持、图形框架支持等等。这些东西单拎出来都是不太容易弄明白的，现在还要合理的把它们组合到框架当中，可想而知难度有多大。钟老师作为我的领导，为人和蔼大方，技术专业过硬，会非常合理的根据需求规划设计和调整进度，并身先士卒，自己负责最困难的部分，遇到问题会和我们一起讨论方案，分享技术细节，最终完成某个需求乃至模块的研发。当然我是程序员，语文不好（高考只有`109`），语言无法直观的表达我内心的感受，写多了篇幅过长，我只能简单的一句话概括：**世间再难遇到这样的领导**。\n\n在合迅实习了半年，我学到了太多大学课程设计不到的知识和技术。这不是重点，因此我不想在这里赘述，有兴趣可以与我交流。除了学习到技术层面的知识以外，更多是程序员职业素养的一些思考。我总结了三点。\n\n首先是重视设计和思考。由于`LarkSDK`产品是完全从头开始，独立自研的，我们的目标是对标`Qt`，甚至是替代乃至超越`Qt`。不可否认我们参照了行业巨头`Qt`的很多思路，但是人无完人，强如`Qt`的设计也存在很多不合理，有缺漏的地方。当然`Qt`自己也在后续的版本中自己在努力修改，但是`Qt`毕竟是一个完整的产业链产品，有些东西久了是改不掉的。而`LarkSDK`作为一个新鲜血液的产品，目前非常轻量。我们有必要，并且是必须在搭建底层地基的时候就考虑好整体的架构和设计，例如如何设计窗口和组件的关系，如何设计跨平台的统一管理调度等。这些功能不仅需要稳定可用，还需要为后续研发的上层功能留出口子。当然这个过程是一个非常复杂、繁琐并且困难的过程。在这个过程中，设计花费的时间远大于真正写代码的时间。但事实证明，这样的策略是行得通的。\n\n其次是多阅读，多记录。我的老板曾经讲过，提升代码水平的最好办法就是阅读代码。在我个人看来，不仅是多阅读代码，更需要多阅读文档，同时多做好记录。单打独斗是成不了气候的，每个人都存在知识的盲区，因此需要不断学习，不断提升自己，当然在当今社会也是为了不被淘汰。同时，最好做好知识的记录，就像初高中在课本上做笔记一样，知识太多，难免会忘记，因此需要做好记录，后续方便复习回顾。我个人一直有写博客的习惯，后续回顾以前知识的时候能很快回想起来，同时这样也能增加心中的成就感，为自己的前进提供动力。在我调研标准库`std::string`的`sso`优化的时候，查询了很多博客和技术文档，最终才把具体`sso`优化的细节，它具体的内存模型是怎样的等问题研究明白。这样清楚以后应用到我们的`LarkSDK`中，问题自然就迎刃而解了。\n\n最后，也是我觉得最重要的一点，端正态度，脚踏实地。没有解不出来的问题，有的只是半途而废的人。钟老师完美诠释了这一点。他对组员很有信心，愿意给我们安排各种各样的需求工作，培养我们的技术和能力，当然，他自己也以身作则，带头完成项目中最困难的部分。我觉得有这样的领导和前辈，是我的幸运，甚至我认为以后真正工作以后都很难再遇到这样的领导了。同时，从他身上我也看出了，问题并不是不可战胜的，只要不断探索，肯下功夫，并且团队协作，一起努力，问题就一定能迎刃而解。在这个过程中，技术和能力也就自然而然的提升了。\n\n# 总结\n\n每个人的生活都是充满着矛盾的。小时候我因为不想考试而想快快长大，长大了我不想进入社会而想回到从前。在外面实习了半年，我发现竞争是激烈的，社会是残酷的。我无法知道我旁边的同事是否在第二天就会离职，我也无法知道我是否会在第二天被派去做其他的工作。我无法预知到产品的前景和公司的未来，我只是一个朝九晚六的码农。幸运的是，我的工作内容还算稳定，上面提到的残酷现实都没有发生在我身上。但我无法预知将来，无法知道几年以后，自己会在哪里上班，自己会做什么。校园的确是美好的，它是稚嫩懵懂的孩童进入社会最后的港湾。\n\n这半年时间，说长也长，说短也短。无论如何，它给我的学习和生活带来了新的认知，注定是我人生履历上浓墨重彩的一笔。做好当下吧，朝着新未来出发。\n\n最后，感谢实习期间所有同事和领导的帮助，感谢学校老师的栽培，感谢家人的支持。祝合迅科技越来越好，祝`LarkSDK`越来越好。\n\n","categories":["实习","合迅科技","实习感悟"]},{"title":"编译缓存工具 CCache 介绍与基本使用","url":"/posts/2f8a8633.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n编译时间过长是影响大型项目研发效率的一大难题。就市面上被普遍使用的构建系统，其确实存在一定的编译缓存机制，使得用户在重复进行编译操作时（例如修改了一个`Bug`），尽可能复用之前的编译成果以节省编译时间。例如`CMake`使用`CMakeCache.txt`来对编译缓存项进行追踪。但类似的机制存在一些限制，如`CMakeCache.txt`只能管理它自己所在项目的构建目录，如果用户因为一些原因清空了整个构建目录，构建缓存也将被一同清理；又如果多人协作同一个代码项目，他们各自都有属于自己的用户目录和工作目录（甚至自己的工作电脑），自然不可能指望他们可以共享编译缓存，即使这些缓存实质上确实是完全相同的，毕竟是同一份源码编译出的同样的东西。\n\n为了解决这个问题，我们可以引入专业的编译缓存管理工具：`CCache`。\n\n<!-- more -->\n\n# CCache简介\n\n> CCache is a compiler cache. It speeds up recompilation by catching the result of previous compilations and detecting when the same compilation is being done again.\n\n你可以把`CCache`理解为编译缓存的共享存储空间。它管理一个目录`cache_dir`，这个目录负责存放和记录你编译产生的所有缓存项。当你每次进行编译时，若`CCache`在缓存中发现（缓存命中）了你将要编译的某个项目（比如你没有改某个`.cpp`文件从而生成的完全相同的`.cpp.o`文件），将会跳过真正的编译流程，而直接从缓存中将命中的项目提取出来“假装”完成了编译。这对于大型项目增量编译而言，意义非凡。这保证了我们每一次对项目代码进行修改并编译的时候，几乎总是能做到严格的增量编译，从而不去浪费时间在一遍又一遍的编译那些重复的东西上。\n\n总体来说，编译缓存是一种“空间换时间”的思路：利用空余的磁盘空间存储尽可能多的编译缓存项目，并用专门的工具和缓存命中算法加以管理的策略。更进一步思考，编译缓存的存储位置不一定在本机，完全可以放在某个网络服务器上（为保证速度，通常用局域网服务器搭建），工作在同一个局域网的机器可以一起利用服务器来获取编译缓存，机器自身在编译产生成果的同时同时还可以反过来向服务器贡献编译缓存。这样的工作流程有时会被成为编译农场（`Compiling Farm`）。\n\n# CCache安装与配置\n\n> 参考：[官网 4.10.2 版本完整使用说明书](https://ccache.dev/manual/4.10.2.html)\n\n以下操作的默认都在`Linux`系统进行。`Windows`系统类似，区别会在后面额外说明。\n\n## 下载\n\n`CCache`的安装非常简单。其最新版`4.10.2`可以[在官网上直接下载](https://ccache.dev/download.html)。推荐直接下载二进制发布版（`binary release`），当然愿意的话也可以下载源码编译。\n\n> 注：不推荐用 apt 安装，上面只有较老旧的 3.x 版本。\n\n下载后解压，目录内只需要关注唯一一个可执行文件`ccache`。为执行方便，可以将其复制到`PATH`所包含的目录中。官网推荐复制到`/usr/local/bin`目录：\n\n```bash\n# 先解压并进入 CCache 安装包目录\nsudo cp ccache /usr/local/bin/\n```\n\n需要的话重新载入终端，测试“安装”结果：\n\n```bash\nccache -V\n\n# ccache version 4.10.1\n# Features: avx2 file-storage http-storage redis+unix-storage redis-storage\n\n# Copyright (C) 2002-2007 Andrew Tridgell\n# Copyright (C) 2009-2024 Joel Rosdahl and other contributors\n\n# See <https://ccache.dev/credits.html> for a complete list of contributors.\n\n# This program is free software; you can redistribute it and/or modify it under\n# the terms of the GNU General Public License as published by the Free Software\n# Foundation; either version 3 of the License, or (at your option) any later version.\n```\n\n## 配置\n\n通过`-p`或`--show-config`参数，可以查看`CCache`的配置：\n\n```bash\nccache -p\n\n# (default) absolute_paths_in_stderr = false\n# (default) base_dir =\n# (default) cache_dir = /home/lzx0626/.cache/ccache\n# (default) compiler =\n# (default) compiler_check = mtime\n# (default) compiler_type = auto\n# (default) compression = true\n# (default) compression_level = 0\n# (default) cpp_extension =\n# (default) debug = false\n# (default) debug_dir =\n# (default) debug_level = 2\n# (default) depend_mode = false\n# (default) direct_mode = true\n# (default) disable = false\n# (default) extra_files_to_hash =\n# (default) file_clone = false\n# (default) hard_link = false\n# (default) hash_dir = true\n# (default) ignore_headers_in_manifest =\n# (default) ignore_options =\n# (default) inode_cache = true\n# (default) keep_comments_cpp = false\n# (default) log_file =\n# (default) max_files = 0\n# (/home/lzx0626/.config/ccache/ccache.conf) max_size = 10.0 GiB\n# (default) msvc_dep_prefix = Note: including file:\n# (default) namespace =\n# (default) path =\n# (default) pch_external_checksum = false\n# (default) prefix_command =\n# (default) prefix_command_cpp =\n# (default) read_only = false\n# (default) read_only_direct = false\n# (default) recache = false\n# (default) remote_only = false\n# (default) remote_storage =\n# (default) reshare = false\n# (default) run_second_cpp = true\n# (default) sloppiness =\n# (default) stats = true\n# (default) stats_log =\n# (default) temporary_dir = /run/user/1000/ccache-tmp\n# (default) umask =\n```\n\n默认配置一般已经可以满足大部分情况下使用。目前需要关注的可能有：\n\n- `max_size`：描述`CCache`将预留多少磁盘空间用于存放编译缓存。默认`5GB`。如果编译较大的项目且磁盘空间富余，可以适当考虑预留多一些空间。\n- `cache_dir`：`CCache`存放编译缓存的目录位置。可以看到这个目录位于当前的用户目录下，也就是说，如果不同的用户使用同一台机器，他们将使用不同的缓存目录，需注意。\n\n若需修改配置，可以使用`-M`或`--max-size`参数，例如将`max_size`设置为`10GB`：\n\n```bash\nccache -M 10\n# Set cache size limit to GiB\n```\n\n检查是否设置成功：\n\n```bash\nccache -p | grep max_size\n# (/home/lzx0626/.config/ccache/ccache.conf) max_size = 10.0 GiB\n```\n\n注意这里对`max_size`的配置已经被写入了自动建立的配置文件中。\n\n> 关于配置项的完整说明，参见[官网手册](https://ccache.dev/manual/4.10.2.html#_configuration_options)\n\n## 使用\n\n`CCache`通常有两种使用方式：\n\n1. 直接使用：通过`ccache`命令直接调用，编译命令本身统统接在`ccache`后面作为其参数。例如：`ccache gcc -c example.c`\n2. 通过“劫持”`gcc、g++`等命令使用。这样当每次调用`gcc`等命令时，实际已经通过了`ccache`的处理。\n\n第一种方式一般仅仅在测试`CCache`功能等场合时使用。实际工作中因为我们通常都是使用`Makefile`等手段完成编译，配置编译工具链来调用`ccache`既麻烦又不现实，所以一般使用第二种方式。官网推荐构建软链接的方式完成“劫持”：\n\n```bash\nsudo ln -s ccache /usr/local/bin/gcc\nsudo ln -s ccache /usr/local/bin/g++\nsudo ln -s ccache /usr/local/bin/cc\nsudo ln -s ccache /usr/local/bin/c++\n```\n\n这样就把`gcc、g++、cc、c++`四个命令通过软链接指向了`ccache`。验证如下：\n\n```bash\nll /usr/local/bin/gcc\n# lrwxrwxrwx 1 root root 6 7月  12 22:51 /usr/local/bin/gcc -> ccache\n```\n\n通常安装好`gcc`后，`gcc`等命令本身位于`/usr/bin/gcc`，命令本身是指向实际`gcc`版本的软链接，再通过多重软连接等手段指向实际的`gcc`可执行文件。这个在每台机器上可能都有所不同，例如：\n\n```bash\nll /usr/bin/gcc\n# lrwxrwxrwx 1 root root 21 7月  12 22:39 /usr/bin/gcc -> /etc/alternatives/gcc\n\nll /usr/bin/gcc-9\n# lrwxrwxrwx 1 root root 22 10月 24  2022 /usr/bin/gcc-9 -> x86_64-linux-gnu-gcc-9\n\nwhich x86_64-linux-gnu-gcc-9\n# /usr/bin/x86_64-linux-gnu-gcc-9\n```\n\n因此我们选择不覆盖原本`/usr/bin`里面的软链接，而把我们指向`ccache`的软链接放在更高执行优先的`/usr/local/bin`之中。这样既可以使`gcc`等命令完美优先指向`ccache`，同时也尽可能不去破坏原有环境。\n\n## 整合到CMake\n\n如果现在我们直接使用`make`编译，可能会发现编译缓存并没有起到作用。原因在于`CMake`默认告诉`Makefile`的编译命令，可能直接是`/usr/bin`下面的软链接，这样便绕开了我们定义在`/usr/local/bin`下面的软链接。可以用`make`命令的`VERBOSE`参数验证如下：\n\n```bash\ncmake ..\nmake VERBOSE=1\n```\n\n通过输出可以检查`make`实际调用的命令：\n\n```markdown\n...\n...\n[ 75%] Building CXX object CMakeFiles/larkgui.dir/src/lark-gui/component/lbutton.cpp /usr/bin/g++ ...\n...\n...\n```\n\n如果证实了上述情况，我们可以借助设置`CMake`的`CMAKE_<LANG>_COMPILER`变量来控制`make`具体使用的编译器命令。例如我们分别设置用于`C`和`C++`语言的编译器命令。经测试，注意这里一定要加上引号，否则可能失效。\n\n```bash\nset (CMAKE_C_COMPILER \"gcc\")\nset (CMAKE_CXX_COMPILER \"g++\")\n```\n\n# Windows平台适配\n\n`CCache`当然在`Windows`上使用，只是配置稍微有些麻烦。\n\n在`Windows`中安装`C/C++`编译环境有几种选择。可以安装微软提供的`VS`全家桶，也就是`MSVC`编译器。也可以安装跨平台编译器`gcc`，当然大部分情况是服务于`linux`的。或者安装`GNU`项目专门为了在`Windows`上使用以`gcc`为核心组件的`GNU`工具链而研发的`Mingw`工具。这几个的区别和联系可以参考文章：[https://blog.csdn.net/qq_29495615/article/details/133365562](https://blog.csdn.net/qq_29495615/article/details/133365562)\n\n安装`MSVC`推荐去[微软官方](https://visualstudio.microsoft.com/vs/)下载，安装`gcc`或者`Mingw`推荐使用`Scoop`包管理器进行安装，具体请自行研究。\n\n前面在`Linux`上配置`CCache`的时候，我们配置软链接对`gcc`和`g++`命令做了劫持。在`Windows`上不太好做到这一点，我也没有具体尝试过，因此这里将以`MSVC`编译器为例进行配置。在`github`上有相关文章介绍：[https://github.com/ccache/ccache/wiki/MS-Visual-Studio](https://github.com/ccache/ccache/wiki/MS-Visual-Studio)，以下均基于此文章进行总结。\n\n## 配置环境变量\n\n在官网下载下来的`CCache`压缩包，例如`ccache-4.10.2-windows-x86_64.zip`，解压下来以后默认是不具有环境变量的性质的。也就是没有办法直接在命令行使用`CCache`命令，因此需要配置用户变量或者系统变量。具体配置请自行查阅资料。\n\n配置环境变量也是为了能正确被`VS`或者`CMake`找到可执行文件的位置，方便后续的操作。配置好以后，像前面一样，输入`ccache -p`或者其他命令应该会得到预期结果。\n\n> 注意，如果你使用了 Scoop 或者 Chocolatey 等 Windows 上的包管理器，请不要使用它们安装 CCache，后文会提到原因。请从官网下载压缩包解压，并且配置环境变量。\n\n## 选择方案\n\n文章中给出了两个方案，一个是**伪装成编译器**，一个是**编写包装脚本**，如图所示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240819160359910.png\" alt=\"image-20240819160359910\" style=\"zoom: 60%;\" />\n\n一般我们的`C/C++`项目都是使用`CMake`进行管理的，因此伪装成编译器的可行性更大一些，也和前面的劫持`gcc/g++`命令似乎有着异曲同工之妙。\n\n> 留意第一个方案，文章提到使用包管理安装的 CCache ，没有配置环境变量，但是使用命令行能正常使用，原因就是因为包管理器能找到其可执行文件对应的**符号链接**，这也是原文提到的 shim executable，更深入可以参考文章[https://docs.chocolatey.org/en-us/features/shim/](https://docs.chocolatey.org/en-us/features/shim/)。在这种情况下，拷贝下来的是一个符号链接而不是可执行文件本体，在后续的使用中会出现问题。如果手动配置的话也可能出现环境变量冲突的问题。这也就解释了前文提到的一定要手动去官网下载而不使用包管理器。\n\n## 在CMake中配置\n\n文章中给出了在`VS`和`CMake`的两种配置方法，当然这里采用`CMake`的方式，官网也给出了代码：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240819160710904.png\" alt=\"image-20240819160710904\" style=\"zoom:60%;\" />\n\n这个配置的含义和方案一是一样的，将`CCache`可执行文件拷贝到`CMake`的构建目录，即`build`，然后将`ccache.exe`重命名为`cl.exe`。`cl.exe`即为`MSVC`编译器的可执行文件的名称，即做到了伪装编译器的功能。\n\n留意到原文中注释的提醒，打开`/Z7`编译参数并做了一些小修改，最终的`CMake`配置应该是这样的，这样无论有无`CCache`，配置都能正常进行。\n\n```cmake\n# configure compiler MSVC with Ccache\nadd_compile_options (\"/Z7\")\n\nfind_program (CCACHE_EXECUTABLE ccache)\nif (CCACHE_EXECUTABLE)\n    message (\"-- Ccache executable found at: ${CCACHE_EXECUTABLE}\")\n    file (COPY \"${CCACHE_EXECUTABLE}\" DESTINATION \"${PROJECT_BINARY_DIR}\")\n    file (RENAME \"${PROJECT_BINARY_DIR}/ccache.exe\" \"${PROJECT_BINARY_DIR}/cl.exe\")\n    set (CMAKE_MSVC_DEBUG_INFORMATION_FORMAT \"$<$<CONFIG:Debug,RelWithDebInfo>:Embedded>\")\n    set (CMAKE_VS_GLOBALS\n        \"CLToolExe=cl.exe\"\n        \"CLToolPath=${PROJECT_BINARY_DIR}\"\n        \"TrackFileAccess=false\"\n        \"UseMultiToolTask=true\"\n        \"DebugInformationFormat=OldStyle\"\n    )\n\nelse ()\n    message (\"-- CCache not found.\")\n\nendif ()\n```\n\n# 体验CCache编译缓存\n\n`CCache`提供了`-s`或`--show-stats`命令参数对缓存使用情况进行统计，我们可以借助其来监控`CCache`的使用情况。例如：\n\n```bash\nccache -s\n\n# Cacheable calls:    3936 / 4719 (83.41%)\n#   Hits:             2522 / 3936 (64.08%)\n#     Direct:         2505 / 2522 (99.33%)\n#     Preprocessed:     17 / 2522 ( 0.67%)\n#   Misses:           1414 / 3936 (35.92%)\n# Uncacheable calls:   783 / 4719 (16.59%)\n# Local storage:\n#   Cache size (GiB):  0.1 / 10.0 ( 1.13%)\n#   Hits:             2522 / 3936 (64.08%)\n#   Misses:           1414 / 3936 (35.92%)\n```\n\n在刚配置好`CCache`的机器上进行初次构建，由于缓存尚未建立，编译速度并未有所提升，但此时编译缓存已经慢慢建立。第一次执行`ccache -s`可能看见`Cacheable calls`为零，但随着后续的编译操作进行，将产生越来越多的缓存命中，再执行`ccache -s`就可看见变化，同时可以明显感知到编译速度的提升。\n\n由于编译缓存归于`CCache`管理，因此即使你完全删除了构建目录（在`build`里面`rm -rf *`之类的），下一次`make`的时候同样可以享受编译缓存带来的加速体验。以上便是`CCache`基本的本地使用方式。事实上`CCache`还支持网络使用、跨用户共享等高级功能，这超出了本文的介绍范围。关于`CCache`的高级使用，还请参阅官方文档。\n\n# 参考文档\n\n1. [CCache 官网](https://ccache.dev/)\n\n2. [MS-Visual-Studio](https://github.com/ccache/ccache/wiki/MS-Visual-Studio)\n\n3. [Executable shimming (like symlinks but better)](https://docs.chocolatey.org/en-us/features/shim/)\n\n","categories":["一些技巧"]},{"title":"Qt Graphics View Framework 预研","url":"/posts/e2c22a62.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n该架构涉及到的最主要的三个类是`QGraphicsScene`、`QGraphicsView`和`QGraphicsItem`。\n\n# 整体流程\n\n1. 绘制流程（`QGraphicsItem`->`QGraphicsScene`->`QGraphicsView`）\n\n   `QGraphicsItem`当中保存了自身的“场景坐标”供`QGraphicsScene`进行管理。在绘制时，由`QGraphicsView`对象调用渲染方法，根据自身所设置的可视化相关属性，基于“视图坐标”确定将要绘制的`QGraphicsScene`当中有哪一部分“场景坐标”内的图元需要渲染，随后通过`QGraphicsScene`提供的方法，将属于这部分“场景坐标”内的图元(也就是`QGraphicsItem`)全部找出，并渲染这些图元到可视化`viewport`中。\n\n<!-- more -->\n\n2. 事件流转（`QGraphicsView`->`QGraphicsScene`->`QGraphicsItem`）\n\n   由`QGraphicsView`绘制出的`viewport`是与用户直接交互的对象，用户发起的`UI`事件都由`QGraphicsView`首先接收，它在接收到事件以后对其中的部分参数进行适当的处理(如鼠标事件的坐标进行转换)，随后将事件转发给`QGraphicsScene`对象，由`QGraphicsScene`确定事件发送到哪个具体的图元(如鼠标事件发送到符合坐标位置的图元，键盘事件发送到当前焦点所在的图元)，图元在接收到事件以后作自行处理。\n\n3. `QGraphicsScene`的查询图元的`BSP`树相关算法\n\n   在实际的工程场景中，极有可能会出现一个`QGraphicsScene`管理非常多个`QGraphicsItem`，例如几百万个，当用户与`QGraphicsView`交互的时候，需要经过`QGraphicsScene`将本事件传递到某个或者某些具体的图元，如果挨个遍历每个图元，并且判断是否触发事件，那么耗费的代价就太大了。我们希望做到的效率是几百万条数据在几毫秒以内能够确定目标图元，因此需要上相应的算法。\n\n4. 图元实现优先级以及顺序和事件实现优先级以及顺序\n\n   `QGraphicsItem`本质上是一个抽象父类，为子类规定了各种需要覆写的方法，子类通过重写这些方法能够很好的被`QGraphicsScene`所管理，最终呈现出来。因此不仅支持官方提供的矩形、椭圆、文本框等，还能处理自定义类型的图元。\n\n   在现阶段，先不考虑纯虚的抽象类，先把`QGraphicsItem`当成矩形框来做，先和`QGraphicsScene`把流程跑通，后续在扩展的时候也能非常快就完成工作。\n\n   事件处理是一个大块。经讨论，事件处理的优先级是鼠标事件大于键盘事件大于拖拽事件。因此第一步实现的时候，先实现最基本的`handleMousePressEvent`，当这个流程通了以后，后续的所有操作都是一模一样的了。\n\n5. 整体实现顺序\n\n   先把`QGraphicsView`剔出来，`QGraphicsView`实际上只负责可视化的绘制，真正做处理的操作在`QGraphicsScene`这一层，因此管理类`QGraphicsScene`和图元类`QGraphicsItem`是第一步需要实现的。\n\n   目前的工作计划经商讨以后，决定先调研`QGraphicsScene`和`QGraphicsItem`的源码，明确如何以最小的代价实现我们目前需要的功能，包括事件转发、绘制逻辑、坐标系统等，这样明确需求和设计以后再实现初版，搭好整体架构。\n\n# 重要功能总结\n\n## QGraphicsScene\n\n`QGraphicsScene`类提供了一个管理大量`QGraphicsItem`的容器。\n\n`QGraphicsScene`类只管理所有的图元，若想要可视化场景，需要配合`QGraphicsView`。\n\n`QGraphicsItem`作为`QGraphicsScene`类的图元，自然有很多接口都是围绕着`QGraphicsItem`来的，例如：\n\n1. 添加图元：除了最基本的`addItem()`，还有更多针对特殊类型图元的`add*()`函数\n\n   ![image-20240719141156412](https://cdn.davidingplus.cn/images/2025/02/01/image-20240719141156412.png)\n\n2. 查找图元：在大规模数据的情况下保证在极短的时间内查询到对应的图元，`Qt`使用的是索引算法，使用的是`BSP`（二进制空间分区）树。能够在极短的时间内在极大的数据规模中确定某个图元的位置，这也是`QGraphicsScene`的最大优势之一。\n\n3. 移除图元：`removeItem()`\n\n4. 管理图元状态，处理图元选择和焦点处理等\n\n   - `setSelectionArea()`：可以传递一个形状范围来选择图元项目\n   - `clearSelection()`：清除当前选择\n   - `selectedItems()`：获取被选择的图元的列表\n   - `setFocusItem()、setFocus()`：设置图元获取焦点\n   - `focusItem()`：获取当前焦点\n\n5. 接受事件：用户通过`QGraphicsView`触发事件，并通过`QGraphicsScene`将事件转发到对应的图元：例如鼠标按下、移动、释放和双击事件，鼠标悬停（`LarkSDK`目前好像没有）、滚轮事件，键盘输入焦点和按键事件，拖拽事件等\n\n   ![image-20240719141220363](https://cdn.davidingplus.cn/images/2025/02/01/image-20240719141220363.png)\n\n   `QGraphicsScene`另一个重要的功能就是转发`QGraphicsView`的事件，通过一系列操作，例如通过鼠标点击的坐标计算出到底是选中了哪个图元，键盘事件对应的哪些图元具有焦点等，能够将这些事件转发给对应的图元，最后进入真正的事件循环进行处理。\n\n## QGraphicsView\n\n`QGraphicsView`类真正提供可视化`QGraphicsScene`的内容的功能，它在一个可滚动的`viewport`之内将一个`QGraphicsScene`中的内容实现可视化。\n\n`QGraphicsView`主要功能包括但不限于：\n\n1. 设置可视化操作的属性：`QGraphicsView`中提供了大量可设置的属性用以指示在实现可视化操作时的各种具体事项，如`RenderHints`提供参数初始化用于绘制的`QPainter`，`Alignment`提供当前视图中所绘制的场景的对齐方式。\n\n   ![image-20240719141236742](https://cdn.davidingplus.cn/images/2025/02/01/image-20240719141236742.png)\n\n2. 对场景（`Scene`）进行可视化与视觉效果调整：`QGraphicsView`对象的成员方法render对场景进行可视化的绘制呈现在`viewport`中，并提供了一系列方法对`viewport`整体的视觉效果进行调整，如`centerOn`方法将滚动`viewport`中的内容以确保场景坐标`pos`在视图居中，`fitInView`方法将缩放并滚动`viewport`中的内容使得场景内的矩形区域`rect`铺满当前`viewport`。\n\n   ![image-20240719141250017](https://cdn.davidingplus.cn/images/2025/02/01/image-20240719141250017.png)\n\n3. 管理“场景（`Scene`）坐标”与“视图（`View`）坐标”之间的数学关系，并提供方法对视图内容施行各种坐标变换。`QGraphicsScene`对象当中的各个图元有其在`QGraphicsScene`中的坐标即“场景坐标”，它们代表了各个图元在`QGraphicsScene`中的位置信息；而`QGraphicsView`对各个图元进行绘制以及调整变换时则是通过由自身管理的“视图坐标”，它们代表了各个要绘制的图形在`viewport`中的位置信息。`QGraphicsView`可以由用户设置“场景坐标”向“视图坐标”变换的方式，对`viewport`实现旋转、伸缩等坐标变换，同时由于`QGraphicsView`的绘图使用“视图坐标”，因此这个过程不会干扰图元自身的“场景坐标”。此外还提供`mapToScene`/`mapFromScene`方法供用户调用实现这两种坐标之间的数学换算。\n\n4. 接受鼠标和键盘的事件，并通过处理传递给`QGraphicsScene`对象，进而通过索引算法转发给对应的图元。\n\n## QGraphicsItem\n\n`QGraphicsItem`是所有图元的基类，可以派生出各种典型的形状（例如矩形、椭圆、文本等）和自定义的形状。\n\n`QGraphicsItem`主要功能包括但不限于：\n\n1. 接受`QGraphicsScene`传递的事件：进行事件处理，例如鼠标按下、移动、释放和双击事件，鼠标悬停、滚轮事件，键盘输入焦点和按键事件，拖拽事件等。\n\n   ![image-20240719141308564](https://cdn.davidingplus.cn/images/2025/02/01/image-20240719141308564.png)\n\n2. 坐标系统\n\n   每个`Item`都有自己的本地坐标系，一般以自身的中心为`(0, 0)`，自身的方向作为基准方向建立，多个`Item`的情况就如图。因此需要通过某些机制将不同`Item`的坐标联系在一起。\n\n   为了统一方便的管理，引入`parent-child`的关系。每个对象的变换都依赖于其父对象的坐标。子对象的`pos()`接口返回的是其在父对象坐标系统中的坐标。子对象的坐标处理是首先通过父对象不断向上传递，最终得到一个真实的坐标。同理，父对象的坐标变换也会同理影响到子对象的真实位置（批量处理），但是注意子对象存储的坐标没有变化，这样就非常好维护了。\n\n   ![image-20240719141330634](https://cdn.davidingplus.cn/images/2025/02/01/image-20240719141330634.png)\n\n3. 坐标变换\n\n   `QGraphicsItem`除了提供基本位置`pos()`以外，还支持坐标变换，例如`setRotation()`旋转，`setScale()`缩放等。\n\n   同理，父对象的变换会影响子对象，例如父对象顺时针转`90`度，子对象会跟着一起转`90`度。\n\n4. 提供分组功能（调研是否需要当前考虑）\n\n   通过前面的坐标系统可以知道，每个`QGraphicsItem`都有一个父对象，也可以有一系列子对象，这是类似于对象树机制的在构造的时候确定的关系。 当然也可以手动分组。`QGraphicsItemGroup`是一个特殊的派生类，该类记录了一系列的图元为一个组，在该组的所有图元通过`Group`调用的时候移动、事件处理等都会进行批量处理。\n\n5. 提供编写自定义图元的接口（后续考虑）\n\n   创建一个`QGraphicsItem`的子类，然后覆写两个纯虚函数`boundingRect()`返回该图元项目所绘制区域的估计值，`paint()`实现实际绘图。\n\n   `boundingRect()`返回的是一个`QRectF`类型，将该图元的外部估计边界定义为矩形，这个方法也可以为不同`Item`的范围做大致的估算，可以被其他的方法所调用，省去一些暴力查找的过程。当然对于真正的矩形`boundingRect()`可以返回精确的范围，对于其他的曲线或者不规则的形状只能做大致的范围。\n\n6. 碰撞检测（后续考虑）\n\n   通过`shape()`函数和`collidesWith()`这两个虚拟函数，可以支持碰撞检测。`shape()`函数返回一个局部的坐标`QPainterPath`。目前没有细节调研`QPainterPath`，只知道`QPainterPath`记录了绘图的路径，比如`2D`图形的形状是由某些直线、曲线等构成的，通过这个能够确定图形的形状。\n\n   `QGraphicsItem`会根据默认的`shape()`函数自动处理碰撞检测，实现合理的效果，比如在碰撞区域应该如何进行绘制。如果用户想要定义自己的碰撞检测，可以通过`collidesWith()`实现。\n\n7. 图元顺序（后续考虑）\n\n   难免会发生两个图元的范围出现重叠的情况。合理处理顺序决定了鼠标点击的时候哪些场景会接受鼠标事件。一个比较合理的想法是子对象位于父对象的顶部，而同级对象之间按照定义的顺序进行堆叠。例如添加对象`A、B`，那么对象`B`位于`A`的顶部。这是比较符合自然逻辑的，`Qt`也是这样做的。\n\n   `Qt`提供了一些可以更改项目的排序方式的接口。例如可以在一个图元项目上调用 `setZValue()`，以将其显式堆叠在其他同级项目之上或之下。项的默认`Z`值为`0`，具有相同`Z`值的项按插入顺序堆叠。还可以设置`ItemStacksBehindParent`标志以将子项堆叠在其父项之后。\n\n# 2D BSP 树在 QGraphicsScene 中的应用\n\n`BSP`树构造一个`n`维空间到凸子空间的分层细分（`a BSP tree is a heirarchical subdivisions of n dimensional space into convex subspaces`）。每个节点都有一个前叶子节点和后叶子节点。从根节点开始，所有后续插入都由当前节点的超平面划分。在二维空间中，超平面是一条线。 在`3`维空间中，超平面是一个平面。`BSP`树的最终目标是让超平面的分布情况满足“每个叶节点都在父节点超平面的前面或后面”（`The end goal of a BSP tree if for the hyperplanes of the leaf nodes to be trivially \"behind\" or \"infront\" of the parent hyperplane.`）。\n\n`BSP`树对于与静态图像的显示进行实时交互非常有用。 在渲染静态场景之前，需要计算`BSP`树。 可以非常快地（线性时间）遍历`BSP`树，以去除隐藏的表面和投射阴影。 通过一些工作，可以修改`BSP`树以处理场景中的动态事件。\n\n下面是在对象空间构建`BSP`树的过程：\n\n1. 首先，确定要划分的世界区域以及其中包含的所有多边形。为了方便讨论，我们将使用一个二维世界。\n\n2. 创建一个根节点`L`，该节点本身对应一个分区超平面(在二维世界中，分区超平面就是直线)；同时这个节点维护一个多边形列表，在节点刚刚创建时，多边形列表中保存着它对应的超平面所划分的目标区域(对 L 而言，它对应的直线所划分的目标区域就是整个二维世界)当中的所有多边形。\n\n3. 使用`L`对世界进行分区，假设分为了两个区域`A`和`B`。在根节点上创建两个叶子节点分别对应`A`和`B`，并将世界中的所有多边形移动到`A`或`B`的多边形列表中。遵循以下规则：\n\n   对于世界中的每个多边形：\n\n   - 如果该多边形完全位于`A`区域，请将该多边形移动到`A`区域的节点列表中。\n   - 如果该多边形完全位于`B`区域，请将该多边形移动到`B`区域的节点列表中。\n   - 如果该多边形与`L`相交，则将其拆分为两个多边形，并将它们移动到`A`和`B`的相应多边形列表中。这种情况下，算法必须找到多边形与分割线`L`的交点，以确定多边形的哪一部分位于哪个区域。\n   - 如果该多边形与`L`重合(也就是说，恰好是一条位于`L`上的线段)，请保持其仍位于节点`L`处的多边形列表中。\n\n   在上述步骤完成后，节点`A`和`B`的多边形列表已经生成，但是`A`和`B`尚未完成创建分区超平面并划分的步骤，也就是说，对于当前的节点`A`，它的状态与步骤`1`中的“整个二维世界”一致(区域确定，包含的多边形确定)，只不过区域大小有差别，`B`同理。\n\n4. 在`A`和`B`上继续划分其所对应的二维区域，并将上述算法递归地应用于`A`和`B`的多边形列表。\n\n   ![image-20240719113430085](https://cdn.davidingplus.cn/images/2025/02/01/image-20240719113430085.png)\n\n更多细节和代码实现请参考博客：[一些关于空间数据结构的简单研究与实现 | GilbertNewtonLewis](https://gilbertnewtonlewis.github.io/2024/06/21/SpaticalData/)\n\n# 参考文档\n\n1. [https://doc.qt.io/qt-6/graphicsview.html](https://doc.qt.io/qt-6/graphicsview.html)\n2. [https://www.cnblogs.com/q735613050/p/13413866.html](https://www.cnblogs.com/q735613050/p/13413866.html)\n3. [https://blog.csdn.net/keilert/category_12595359.html](https://blog.csdn.net/keilert/category_12595359.html)\n4. [https://blog.csdn.net/weixin_43925768/article/details/129138298](https://blog.csdn.net/weixin_43925768/article/details/129138298)\n5. [https://blog.csdn.net/ZJU_fish1996/article/details/52554620](https://blog.csdn.net/ZJU_fish1996/article/details/52554620)\n6. [https://blog.csdn.net/packdge_black/article/details/114681992](https://blog.csdn.net/packdge_black/article/details/114681992)\n\n","categories":["实习","合迅科技","课题研究"]},{"title":"使用 Woboq CodeBrowser 搭建源代码网站","url":"/posts/a98e1d5b.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 背景\n\n在日常学习工作中，我们不免需要浏览一些库的源码。在本地浏览源代码，例如使用`Source Insight`，当然是可以的，但问题是一是不方便，二是很多库下载下来是以头文件配合静态库或动态库的形式存在的，看不到`cpp`代码，因此阅读会受限。现在`Web`技术高速发展，有没有办法用网页直接查看源代码，并且还有类似于`Code`的代码跳转功能呢？换句话说，如何把`C/C++`代码转化为前端页面，并且最好是静态的前端页面，就是一个难题了。\n\n幸运的是，`github`上有人提前考虑到了这件事情，并且有了具体的[项目](https://github.com/KDAB/codebrowser)，已经有`1k`多的`star`。并且原作者还基于这个框架弄出了一个在线的[源代码网站](https://codebrowser.dev/)，方便开发者查看各个`C/C++`库的源代码，例如`Qt`、`GCC`、`Linux Kernel`、`GNU C Library`等。\n\n<!-- more -->\n\n那么问题来了，都有在线的网站了为什么还要自己搭建一个呢？原因就是这个网站在国内被墙了。有人会说？开梯子啊，不是每个节点都能上，我嫌他烦，因此决定自己搭建一个源代码网站一劳永逸。我的源码网站地址：[https://davidingplus.github.io/code-browser/](https://davidingplus.github.io/code-browser/)\n\n# 工作原理简介\n\n`Woboq CodeBrowser`是基于`LLVM/Clang`实现的一个命令行工具。它通过深度解析`C/C++`源码生成最终我们需要的静态`HTML`文件。`Woboq CodeBrowser`包含`codebrowser_generator`和`codebrowser_indexgenerator`两个子命令。生成`HTML`文件到最终可以通过浏览器阅读代码，整体分三个步骤：\n\n1. 先通过`codebrowser_generator`解析`.h`和`.cpp`生成对应的`.h.html`和`.cpp.html`。\n2. 然后通过`codebrowser_indexgenerator`为所有目录生成 `index.html`。\n3. 最后我们可以把这些`HTML`文件拷贝到某个`Web`服务器上，就可以在浏览器里愉快地浏览`C/C++`项目的源码了。\n\n# 安装Woboq CodeBrowser工具\n\n我们通过源码编译安装这个工具。\n\n首先将该[项目](https://github.com/KDAB/codebrowser)克隆到本地，由于需要用`LLVM/Clang`工具链，强烈建议在`Linux`下操作。\n\n```bash\ngit clone https://github.com/KDAB/codebrowser.git\n```\n\n克隆下的项目中有三个目录比较重要，一是`data`目录，这是一些前端的资源文件，例如`png`、`css`、`js`等；二是`generator`目录，这是可执行文件`codebrowser_generator`的源码目录；三是`indexgenerator`，这是可执行文件`codebrowser_indexgenerator`的源码目录。\n\n前面提到，编译这个工具需要用到`LLVM/Clang`工具链，结合`github`上的[issue#119](https://github.com/KDAB/codebrowser/issues/119)，使用`llvm-14`和`clang-14`的版本比较合适。以`Ubuntu`为例：\n\n```bash\nsudo apt install llvm-14 clang-14 libclang-14-dev\n```\n\n但是在`Ubuntu20.04`及以下的版本上会出现**定位不到软件包**的问题，官方提供了一个解决方案，参见博客[https://blog.csdn.net/weixin_50749380/article/details/128319851](https://blog.csdn.net/weixin_50749380/article/details/128319851)\n\n这样我们的编译环境就安装好了，紧接着我们需要构建这个项目并且将编译后的文件安装到本地。项目受`CMake`管理，同时参考[官方文档](https://github.com/KDAB/codebrowser/blob/master/README.md)，构建流程就很简单了。\n\n```bash\nmkdir -p build\ncd build\n\ncmake -DCMAKE_C_COMPILER=clang-14 -DCMAKE_CXX_COMPILER=clang++-14 -DCMAKE_BUILD_TYPE=Release .. # 除了 clang 还可能安装了 gcc 等其他的编译器，所以指定一下；同时指定编译选项为 Release ，这个在 Linux 下没有影响\nmake\nsudo make install # 必要加上 sudo\n```\n\n安装完毕以后`data`目录，两个可执行文件`codebrowser_generator`和`codebrowser_indexgenerator`就成功安装到本地了。\n\n![image-20240718105543595](https://cdn.davidingplus.cn/images/2025/02/01/image-20240718105543595.png)\n\n# 如何使用\n\n接下来以`googletest-1.12.1`为例，展示如何使用这个工具构建静态的源代码网站。\n\n## 生成compile_commands.json\n\n`compile_commands.json`文件是一种特定格式的[compilation database](https://sarcasm.github.io/notes/dev/compilation-database.html)文件，而所谓`compilation database`其实很简单，它里面记录的是每一个源码文件在编译时详细的信息（包括文件路径，文件名，编译选项等等）。而`compile_commands.json`文件是[LibTooling](https://clang.llvm.org/docs/LibTooling.html)需要的以`json`格式呈现的`compilation database`文件，以下截取的是`compile_commands.json`中的一个`entry`：\n\n```json\n[\n...\n    {\n        \"arguments\": [\n            \"c++\",\n            \"-c\",\n            \"-g\",\n            \"-O2\",\n            \"-Werror\",\n            \"-std=c++0x\",\n            \"-Wall\",\n            \"-fPIC\",\n            \"-o\",\n            \"attrs.o\",\n            \"attrs.cc\"\n        ],\n        \"directory\": \"/home/astrol/libelfin/dwarf\",\n        \"file\": \"attrs.cc\"\n    },\n...\n]\n```\n\n`Woboq Codebrowser`是基于`LLVM/Clang`实现的工具，也是基于`compile_commands.json`来分析源码关系的。\n\n换句话说，要想使用`Woboq Codebrowser`，必须首先生成`compile_commands.json`文件。如果项目是由`cmake`构建的，那么恭喜你，只需加上`-DCMAKE_EXPORT_COMPILE_COMMANDS=ON`即可。如果是传统的`make build system`也不要担心，`Bear`和`compdb`工具可以帮我们生成`compile_commands.json`文件。\n\n现在让我们一起生成`googletest-1.12.1`项目对应的`compile_commands.json`。首先我们拉取[googletest](https://github.com/google/googletest)的源码到本地。源码采用`CMake`工具的管理，这样正好很方便的能帮我们生成`compile_commands.json`。之所以这么推荐`CMake`是因为使用其他的工具可能需要编译整个工程才能生成该文件，费事费力。\n\n因为我是`C++11`标准的环境，因此需要使用的版本是`1.12.1`，切换到对应的`tag`。当然直接下载对应的`release`源码也行。\n\n```bash\ngit checkout release-1.12.1 # target tag\n```\n\n然后我们使用`CMake`工具生成`compile_commands.json`文件，个人建议使用`gcc/g++`编译器。\n\n```bash\nmkdir -p build\ncd build\n\ncmake -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=\"gcc\" -DCMAKE_CXX_COMPILER=\"g++\" -DCMAKE_EXPORT_COMPILE_COMMANDS=ON ..\n```\n\n在`build`目录下看到`compile_commands.json`文件正确生成即为成功。\n\n## 使用codebrowser_generator生成html\n\n`codebrowser_generator`是一个可执行文件，有各种执行参数，说明如下：\n\n- `-a`：处理`compile_commands.json`中的所有文件。如果没有传递这个参数，那么就需要传递要处理的文件列表\n- `-o`：指定文件输出目录\n- `-b`：是指包含`compile_commands.json`的构建目录。如果没有传递这个参数，编译参数可以在`--`后通过命令行传递\n- `-p`：（一个或多个）用于项目规范。即项目的名称、源代码的绝对路径和用冒号分隔的版本信息。示例：`-p projectname:/path/to/source/code:0.3beta`\n- `-d`：指定包含所有`JavaScript`和`CSS`文件的数据`URL`。默认为相对于输出目录的`../data`。示例：`-d https://codebrowser.dev/data/`\n- `-e`：是对外部项目的引用。示例： `-e clang/include/clang:/opt/llvm/include/clang/:https://codebrowser.dev/llvm`\n\n例如，对于当前`googletest-1.12.1`项目，一条合适的命令可能是这样的：\n\n```bash\ncodebrowser_generator -b ./compile_commands.json -a -p googletest-1.12.1:\"${PWD}/..\":1.12.1 -o ./docs -d ../data\n```\n\n执行完的结果是这样的：\n\n![image-20240730153744964](https://cdn.davidingplus.cn/images/2025/02/01/image-20240730153744964.png)\n\n需要注意的是，上面的操作都是在根目录的`build`构建目录执行的，这也是`CMake`用户的构建习惯。\n\n同时，`-o ./docs`代表文件输出在`build/docs`中，`-d ../data`是指定资源文件的相对路径，代表资源文件位于生成目录`docs`的父级目录。至于为什么是`../data`，后面会详细解释。安装好`Woboq CodeBrowser`工具以后`data`目录会被安装在`/usr/local/share/woboq/data`，将其拷贝为`build/data`即可。\n\n## 使用codebrowser_indexgenerator为每个目录生成index.html\n\n`codebrowser_indexgenerator`同样有很多执行参数，说明如下：\n\n- `-p`：（一个或多个）用于项目规范。即项目的名称、源代码的绝对路径和用冒号分隔的版本信息。示例：`-p projectname:/path/to/source/code:0.3beta`\n- `-d`：指定包含所有`JavaScript`和`CSS`文件的数据`URL`。默认为相对于输出目录的 `../data`。示例：`-d https://codebrowser.dev/data/`\n\n同样执行类似命令：\n\n```bash\ncodebrowser_indexgenerator ./docs -d ../data\n```\n\n类似执行结果如下，可以看到每个目录对应都有了`index.html`。\n\n![image-20240730154020528](https://cdn.davidingplus.cn/images/2025/02/01/image-20240730154020528.png)\n\n## 关于-d参数以及资源文件\n\n上面提到，为什么我使用的是`-d ../data`呢？我们先弄清楚`data`目录是干嘛的。\n\n`data`目录存放着前端代码需要的资源文件，例如`CSS`、`JS`和图片资源等。因此需要指明这个目录的路径，绝对路径或者相对路径。由于我的[code-browser](https://github.com/DavidingPlus/code-browser/)项目需要存放很多库的源代码，因此我将`data`目录统一在根目录中，每个库的源代码对应一个自己的子目录，因此最终的结果是这样的：\n\n![image-20240730154929638](https://cdn.davidingplus.cn/images/2025/02/01/image-20240730154929638.png)\n\n这样就能正确定位到资源文件的路径了，`codebrowser_generator`生成的`html`文件同理。用户使用自己的习惯和方式即可。\n\n# 参考文档\n\n1. [https://blog.csdn.net/astrotycoon/article/details/104831055](https://blog.csdn.net/astrotycoon/article/details/104831055)\n2. [https://blog.csdn.net/weixin_42148156/article/details/121727163](https://blog.csdn.net/weixin_42148156/article/details/121727163)\n3. [https://blduan.top/post/工具使用/codebrowser之从浏览器阅读源码](https://blduan.top/post/工具使用/codebrowser之从浏览器阅读源码/)\n\n","categories":["实习","合迅科技","课题研究"]},{"title":"在 X11 下使用 cairo 引擎绘制图形","url":"/posts/70513923.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n`cairo`是一个方便和高性能的第三方`C`库。它可以作为绘制引擎，帮助我们绘制各种图形，并且提供多种输出方式。本文将在`Linux`下结合`X11`图形显示协议绘制简单的图形。\n\n这是效果图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/59cb53826fcba1602fd3769171f5f127.png\" alt=\"59cb53826fcba1602fd3769171f5f127\" style=\"zoom:67%;\" />\n\n<!-- more -->\n\n# 安装Cairo库\n\n`cairo`的官方网站是[https://cairographics.org](https://cairographics.org/)。上面对`cairo`图形库做了一个完整的介绍，包括如何下载、`API`接口、示例等等。\n\n## 通过包管理器安装\n\n通过官方文档知道，在`Linux`下可以直接通过包管理器进行下载，以`Ubuntu`为例。\n\n```bash\nsudo apt install libcairo2-dev\n```\n\n下载好以后头文件和动态库就安装好了。头文件安装在`/usr/include/cairo/`中，静态库和动态库分别位于`/usr/lib/x86_64-linux-gnu/libcairo.a`和`/usr/lib/x86_64-linux-gnu/libcairo.so`。因此能直接被系统识别，直接引入头文件，编译的时候链接`cairo`库即可。\n\n## 通过Conan安装\n\n对于个人而言，`apt`安装自然是非常友好的。但是对于`LarkSDK`这样一个面向用户的基础框架而言，除非最基本的系统库例如`X`窗口系统`libx11-dev`，`Wayland`窗口系统`libwayland-dev`和`Wayland`键盘处理`libxkbcommon-dev`等，其他的第三方库均最好不以`apt`包的方式引入。鉴于`C++`没有自己的包管理器，因此需要借助第三方的包管理器，例如`conan`，`cpm`等。本项目使用`conan`管理第三方包。\n\n`conan`是一个`python`语言编写的`C++`的包管理器，官方网址是[https://conan.io/](https://conan.io/)。`conan`管理了众多第三方的`C++`库，通过命令行操作就能方便的在自己的项目中引入`conan`包。需要通过`conanfile.py`或者`conanfile.txt`进行配置，当然这不是本文的重点，具体见文档[https://docs.conan.io/2/](https://docs.conan.io/2/)。\n\n`conan`官方提供了自己的`conan`仓库，[https://conan.io/center](https://conan.io/center)。在上面能找到很多我们熟知的第三方库，例如`gtest`，`qt`，`boost`，`fmt`等。当然还有一些更基础的工具库，这里不赘述。当然[cairo](https://conan.io/center/recipes/cairo)库也在其中。\n\n### 尝试安装Cairo\n\n现在让我们尝试安装`cairo`库并尝试用`CMake`将其引入。在新开的项目中创建`conanfile.txt`，引入项目依赖`cairo`。使用`conanfile.py`主要用于生成和发布自己的`conan`包，`conan`提供了丰富的选项供用户操作。这里只是为了测试，因此使用最简单的`conanfile.txt`即可。\n\n```ini\n[requires]\ncairo/1.18.0\n\n[generators]\ncmake\n```\n\n编写自己的`CMakeLists.txt`，配置项目的相关信息，引入`conan`的部分类似如下：\n\n```cmake\n...\n\ninclude (${PROJECT_BINARY_DIR}/conanbuildinfo.cmake)\nconan_basic_setup (NO_OUTPUT_DIRS)\n\n...\n\nadd_executable (xxx\n    ...\n)\ntarget_link_libraries (xxx ${CONAN_LIBS})\n```\n\n之后执行一般的构建流程即可。\n\n```bash\nconan install ..\ncmake ..\nmake # windows 下默认没有 make 命令，使用 cmake --build ./ 代替\n```\n\n`conan`官方的包很多，很全，但是`conan`本身还有很多`bug`，单就`cairo`包的使用过程中就有很多问题。最典型的，执行`conan install ..`可能会失败，并且遇到很多错误。因此我们需要了解`conan`包是个什么东西，才能明确问题是如何形成的。\n\n### 关于Conan包\n\n现在对`conan`包做一个简述。对于`C++`库而言，为了让用户方便的使用，把`.h`和`.cpp`代码全部打包出去是不合适的，这些代码不应该在用户的机器上再被编译一次，而应该在需要用的时候被直接使用。因此需要通过库的方式进行发布，也就是使用静态库和动态库。在发布的包中，最重要的文件就是头文件和库文件。当然可能会携带一些其他必要的文件，例如资源文件、版本说明文件等。\n\n我们都知道，编译`C/C++`的代码需要依赖于`C++`和编译器的版本。进一步的，由于`C/C++`是非常接近底层的代码，虽然标准库是跨平台的，但是如果需要写平台相关的程序，还需要注意操作系统的版本。因此，对于同一个版本的`conan`包，不同的系统，不同的编译环境，是静态库还是动态库，是`Debug`包还是`Release`包，甚至依赖包的版本，都可能对最后的编译造成一定影响。在本地的`conan`配置中会保存相关的这些信息，在`conan`拉包的时候会匹配本地的配置拉取合适的包。配置文件默认位于`~/.conan/profile/default`中。\n\n在`Linux`下的配置类似于这样，看其参数很明显就能知道对应的含义。\n\n```ini\n[settings]\nos=Linux\nos_build=Linux\narch=x86_64\narch_build=x86_64\ncompiler=gcc\ncompiler.version=9\ncompiler.libcxx=libstdc++11\nbuild_type=Release\n[options]\n[build_requires]\n[env]\n```\n\n在`Windows`下类似于这样：\n\n```ini\n[settings]\nos=Windows\nos_build=Windows\narch=x86_64\narch_build=x86_64\ncompiler=Visual Studio\ncompiler.version=16\nbuild_type=Release\n[options]\n[build_requires]\n[env]\n```\n\n现在我们以`cairo/1.18.0@`包为例，使用`conan`命令查看其远端的包的列表。\n\n```bash\nconan search cairo/1.18.0@ -r conancenter\n```\n\n得到的结果大致是这样：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240715163723130.png\" alt=\"image-20240715163723130\" style=\"zoom:55%;\" />\n\n我们发现`settings`中的内容和我们的`profiles/default`中的内容对应，这就是前面提到的匹配。例如图中是一个`Mac`下的`apple-clang`的`13.0`版本的`静态库`的`Debug`包。每个包的`options`，`settings`和`requires`都会对最前面的`Package_ID`产生影响，这是一个哈希计算值，具体如何影响和生成请参考[https://docs.conan.io/2/reference/binary_model/package_id.html](https://docs.conan.io/2/reference/binary_model/package_id.html)。当然这其中也有令人费解的地方，请见下文。\n\n### 解决错误（并吐槽）\n\n前面提到，`conan`官方的包有问题，会导致在安装的时候出现错误。例如，我在安装的出现的错误如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240715165238889.png\" alt=\"image-20240715165238889\" style=\"zoom:55%;\" />\n\n错误信息告诉我`fontconfig`的`2.15.0`的版本需要`conan 1.60.4`以上才能安装。由于公司使用的是`conan 1.60.1`，首先我想到的是`conan`版本不正确。深入研究后，我发现的问题出乎我的意料。\n\n由于公司实际开发的`conan`版本不可能从`1.60.1`升到`1.60.4`，要升肯定一步到位到`conan 2.0`了。首先查看`conancenter`中`cairo/1.18.0@`远端的包，检索符合当前系统和编译环境的。我发现了三个长的几乎一样的包：\n\n```ini\n; package 1\nPackage_ID: 703bcc640002869a53960c4449d3825ff8a103e6\n    [options]\n        fPIC: True\n        shared: False\n        tee: False\n        with_fontconfig: True\n        with_freetype: True\n        with_glib: True\n        with_lzo: True\n        with_png: True\n        with_symbol_lookup: False\n        with_xcb: True\n        with_xlib: True\n        with_xlib_xrender: True\n        with_zlib: True\n    [settings]\n        arch: x86_64\n        build_type: Release\n        compiler: gcc\n        compiler.version: 9\n        os: Linux\n    [requires]\n        brotli/1.1.0:b21556a366bf52552d3a00ce381b508d0563e081\n        bzip2/1.0.8:da606cf731e334010b0bf6e85a2a6f891b9f36b0\n        expat/2.6.0:c215f67ac7fc6a34d9d0fb90b0450016be569d86\n        fontconfig/2.15.0:b172ac37518ca059ccac0be9c3eb29e5179ecf1e\n        freetype/2.13.2:f1014dc4f9380132c471ceb778980949abf136d3\n        glib/2.78.3:06c63123a2bb8b6d3ea5dcae501525df32efb7b5\n        libelf/0.8.13:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libffi/3.4.4:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libmount/2.39:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libpng/1.6.43:7929d8ecf29c60d74fd3c1f6cb78bbb3cb49c0c7\n        libselinux/3.5:6b0384e3aaa343ede5d2bd125e37a0198206de42\n        lzo/2.10:6af9cc7cb931c5ad942174fd7838eb655717c709\n        pcre2/10.42:647f8233073b10c84d51b1833c74f5a1cb8e8604\n        pixman/0.43.4:6af9cc7cb931c5ad942174fd7838eb655717c709\n        util-linux-libuuid/2.39.2:6af9cc7cb931c5ad942174fd7838eb655717c709\n        xorg/system:5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9\n        zlib/1.3.1:6af9cc7cb931c5ad942174fd7838eb655717c709\n    Outdated from recipe: True\n\n; package 2\nPackage_ID: 8098347825649d9fd3e21c49992446a2a2193ad4\n    [options]\n        fPIC: True\n        shared: False\n        tee: False\n        with_fontconfig: True\n        with_freetype: True\n        with_glib: True\n        with_lzo: True\n        with_png: True\n        with_symbol_lookup: False\n        with_xcb: True\n        with_xlib: True\n        with_xlib_xrender: True\n        with_zlib: True\n    [settings]\n        arch: x86_64\n        build_type: Release\n        compiler: gcc\n        compiler.version: 9\n        os: Linux\n    [requires]\n        brotli/1.1.0:b21556a366bf52552d3a00ce381b508d0563e081\n        bzip2/1.0.8:da606cf731e334010b0bf6e85a2a6f891b9f36b0\n        expat/2.5.0:c215f67ac7fc6a34d9d0fb90b0450016be569d86\n        fontconfig/2.14.2:b172ac37518ca059ccac0be9c3eb29e5179ecf1e\n        freetype/2.13.0:f1014dc4f9380132c471ceb778980949abf136d3\n        glib/2.78.0:06c63123a2bb8b6d3ea5dcae501525df32efb7b5\n        libelf/0.8.13:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libffi/3.4.4:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libmount/2.39:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libpng/1.6.40:7929d8ecf29c60d74fd3c1f6cb78bbb3cb49c0c7\n        libselinux/3.5:6b0384e3aaa343ede5d2bd125e37a0198206de42\n        lzo/2.10:6af9cc7cb931c5ad942174fd7838eb655717c709\n        pcre2/10.42:647f8233073b10c84d51b1833c74f5a1cb8e8604\n        pixman/0.40.0:6af9cc7cb931c5ad942174fd7838eb655717c709\n        util-linux-libuuid/2.39:6af9cc7cb931c5ad942174fd7838eb655717c709\n        xorg/system:5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9\n        zlib/1.3:6af9cc7cb931c5ad942174fd7838eb655717c709\n    Outdated from recipe: True\n        \n; package 3\nPackage_ID: a336bac291d8ec6a55c6257f3266f9a8760c7403\n    [options]\n        fPIC: True\n        shared: False\n        tee: False\n        with_fontconfig: True\n        with_freetype: True\n        with_glib: True\n        with_lzo: True\n        with_png: True\n        with_symbol_lookup: False\n        with_xcb: True\n        with_xlib: True\n        with_xlib_xrender: True\n        with_zlib: True\n    [settings]\n        arch: x86_64\n        build_type: Release\n        compiler: gcc\n        compiler.version: 9\n        os: Linux\n    [requires]\n        brotli/1.1.0:b21556a366bf52552d3a00ce381b508d0563e081\n        bzip2/1.0.8:da606cf731e334010b0bf6e85a2a6f891b9f36b0\n        expat/2.5.0:c215f67ac7fc6a34d9d0fb90b0450016be569d86\n        fontconfig/2.14.2:b172ac37518ca059ccac0be9c3eb29e5179ecf1e\n        freetype/2.13.2:f1014dc4f9380132c471ceb778980949abf136d3\n        glib/2.78.1:06c63123a2bb8b6d3ea5dcae501525df32efb7b5\n        libelf/0.8.13:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libffi/3.4.4:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libmount/2.39:6af9cc7cb931c5ad942174fd7838eb655717c709\n        libpng/1.6.40:7929d8ecf29c60d74fd3c1f6cb78bbb3cb49c0c7\n        libselinux/3.5:6b0384e3aaa343ede5d2bd125e37a0198206de42\n        lzo/2.10:6af9cc7cb931c5ad942174fd7838eb655717c709\n        pcre2/10.42:647f8233073b10c84d51b1833c74f5a1cb8e8604\n        pixman/0.42.2:6af9cc7cb931c5ad942174fd7838eb655717c709\n        util-linux-libuuid/2.39.2:6af9cc7cb931c5ad942174fd7838eb655717c709\n        xorg/system:5ab84d6acfe1f23c4fae0ab88f26e3a396351ac9\n        zlib/1.3:6af9cc7cb931c5ad942174fd7838eb655717c709\n    Outdated from recipe: True\n```\n\n这三个包的唯一区别在于`requires`不同，第一个包需要`expat/2.6.0`，第二个和第三个包需要`expat/2.5.0`。第二个包需要`freetype/2.13.0`，第三个包`freetype/2.13.2`。这就是唯一区别，然后生成了三个不同的哈希值，对应不同的`package`。\n\n那么问题来了，`conan install`默认会读取本地的配置，但是本地配置不可能指定`requires`啊。不同的项目可能用的版本不同，这是很正常的事情，也不应该是由用户承担责任的地方。其次，`conan install`不能指定`package_id`下载，因此下载的是哪一个包，完全就看他怎么想了。非常不幸运的是，我需要第二个包，但是下载只能下载到第一个包。\n\n那么如何解决这个问题呢？幸运的是，`conan`提供了`conan download`的方法，这个东西可以指定`package_id`进行下载。那就简单了，先把`cairo`本包下载到本地，然后再指定这一套流程，由于本地有缓存，会跳过去远端拉取`cairo`包的这一步，这样所有本包和所有依赖不就顺利拉取下来了吗？说干就干。\n\n```bash\nconan download cairo/1.18.0@:8098347825649d9fd3e21c49992446a2a2193ad4 -r conancenter\n```\n\n成功下载下来以后，再次执行`conan install ..`，又出问题了。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240715172400074.png\" alt=\"image-20240715172400074\" style=\"zoom:58%;\" />\n\n不对啊，这个包依赖的`fontconfig`的版本是`2.14.2`啊，为什么这里还是下载的`2.15.0`啊？为了解决这个问题，我打开了对应的`conanfile.py`，阅读到`requirements()`函数的时候，豁然开朗。\n\n```python\ndef requirements(self):\n    self.requires(\"pixman/0.43.4\")\n    if self.options.with_zlib and self.options.with_png:\n        self.requires(\"expat/[>=2.6.2 <3]\")\n    if self.options.with_lzo:\n        self.requires(\"lzo/2.10\")\n    if self.options.with_zlib:\n        self.requires(\"zlib/[>=1.2.11 <2]\")\n    if self.options.with_freetype:\n        self.requires(\"freetype/2.13.2\", transitive_headers=True, transitive_libs=True)\n    if self.options.with_fontconfig:\n        self.requires(\"fontconfig/2.15.0\", transitive_headers=True, transitive_libs=True)\n    if self.options.with_png:\n        self.requires(\"libpng/[>=1.6 <2]\")\n    if self.options.with_glib:\n        self.requires(\"glib/2.78.3\")\n    if self.settings.os in [\"Linux\", \"FreeBSD\"]:\n        if self.options.with_xlib or self.options.with_xlib_xrender or self.options.with_xcb:\n            self.requires(\"xorg/system\", transitive_headers=True, transitive_libs=True)\n    if self.options.get_safe(\"with_opengl\") == \"desktop\":\n        self.requires(\"opengl/system\", transitive_headers=True, transitive_libs=True)\n        if self.settings.os == \"Windows\":\n            self.requires(\"glext/cci.20210420\")\n            self.requires(\"wglext/cci.20200813\")\n            self.requires(\"khrplatform/cci.20200529\")\n    if self.options.get_safe(\"with_opengl\") and self.settings.os in [\"Linux\", \"FreeBSD\"]:\n        self.requires(\"egl/system\", transitive_headers=True, transitive_libs=True)\n```\n\n不是哥们，`expat`需要的是`2.5.0`，但是你规定依赖的包是`>=2.6.2 and <3`。哈？这不前后矛盾吗？对于`freetype`和`fontconfig`也是相同的问题。同时，我们再浏览一下`cairo`包拉下来以后的整体结构。奥，原来同一个版本的所有包的`conanfile.py`都是同一个文件。好，这没有任何问题，这是`conan`的设计。但是你自己不更新依赖版本的限制是什么意思，如果硬要不改的话，发布不同的版本也是`ok`的啊。这样一套流程下来，导致`conan`拉包就出现了问题。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240715172916780.png\" alt=\"image-20240715172916780\" style=\"zoom:67%;\" />\n\n那么如何解决呢？公司这边的解决方式是将该版本的`cairo`包上传到公司的`conan`服务器上，并手动修改`conanfile.py`使其版本匹配，并将所有的依赖以及穿透依赖全部拷贝到公司服务器上。至此，`cairo`终于成功通过`conan`安装。\n\n`Windows`那边也是同样的问题，同样操作即可。\n\n### 补充\n\n在`Linux`下的`Cairo`包中，有一个依赖项值得看一下，即`xorg/system`。这个包的版本是`system`，意思是和系统相关的包，这里是`Linux`下`X`图形协议相关的依赖。众所周知，系统包是通过`apt`或者`yum`进行安装的，意思是`conan`能够调用这些包命令来帮我们自动安装对应的包吗？\n\n答案是可以的，参见文档[https://docs.conan.io/2/reference/tools/system/package_manager.html](https://docs.conan.io/2/reference/tools/system/package_manager.html)。留意这段代码：\n\n```python\ndef system_requirements(self):\n    apt = package_manager.Apt(self)\n    apt.install([\"libx11-dev\", \"libx11-xcb-dev\", \"libfontenc-dev\", \"libice-dev\", \"libsm-dev\", \"libxau-dev\", \"libxaw7-dev\",\n                 \"libxcomposite-dev\", \"libxcursor-dev\", \"libxdamage-dev\", \"libxdmcp-dev\", \"libxext-dev\", \"libxfixes-dev\",\n                 \"libxi-dev\", \"libxinerama-dev\", \"libxkbfile-dev\", \"libxmu-dev\", \"libxmuu-dev\",\n                 \"libxpm-dev\", \"libxrandr-dev\", \"libxrender-dev\", \"libxres-dev\", \"libxss-dev\", \"libxt-dev\", \"libxtst-dev\",\n                 \"libxv-dev\", \"libxxf86vm-dev\", \"libxcb-glx0-dev\", \"libxcb-render0-dev\",\n                 \"libxcb-render-util0-dev\", \"libxcb-xkb-dev\", \"libxcb-icccm4-dev\", \"libxcb-image0-dev\",\n                 \"libxcb-keysyms1-dev\", \"libxcb-randr0-dev\", \"libxcb-shape0-dev\", \"libxcb-sync-dev\", \"libxcb-xfixes0-dev\",\n                 \"libxcb-xinerama0-dev\", \"libxcb-dri3-dev\", \"uuid-dev\", \"libxcb-cursor-dev\", \"libxcb-dri2-0-dev\",\n                 \"libxcb-dri3-dev\", \"libxcb-present-dev\", \"libxcb-composite0-dev\", \"libxcb-ewmh-dev\",\n                 \"libxcb-res0-dev\"], update=True, check=True)\n    apt.install_substitutes(\n        [\"libxcb-util-dev\"], [\"libxcb-util0-dev\"], update=True, check=True)\n\n    yum = package_manager.Yum(self)\n    yum.install([\"libxcb-devel\", \"libfontenc-devel\", \"libXaw-devel\", \"libXcomposite-devel\",\n                       \"libXcursor-devel\", \"libXdmcp-devel\", \"libXtst-devel\", \"libXinerama-devel\",\n                       \"libxkbfile-devel\", \"libXrandr-devel\", \"libXres-devel\", \"libXScrnSaver-devel\",\n                       \"xcb-util-wm-devel\", \"xcb-util-image-devel\", \"xcb-util-keysyms-devel\",\n                       \"xcb-util-renderutil-devel\", \"libXdamage-devel\", \"libXxf86vm-devel\", \"libXv-devel\",\n                       \"xcb-util-devel\", \"libuuid-devel\", \"xcb-util-cursor-devel\"], update=True, check=True)\n\n    dnf = package_manager.Dnf(self)\n    dnf.install([\"libxcb-devel\", \"libfontenc-devel\", \"libXaw-devel\", \"libXcomposite-devel\",\n                       \"libXcursor-devel\", \"libXdmcp-devel\", \"libXtst-devel\", \"libXinerama-devel\",\n                       \"libxkbfile-devel\", \"libXrandr-devel\", \"libXres-devel\", \"libXScrnSaver-devel\",\n                       \"xcb-util-wm-devel\", \"xcb-util-image-devel\", \"xcb-util-keysyms-devel\",\n                       \"xcb-util-renderutil-devel\", \"libXdamage-devel\", \"libXxf86vm-devel\", \"libXv-devel\",\n                       \"xcb-util-devel\", \"libuuid-devel\", \"xcb-util-cursor-devel\"], update=True, check=True)\n\n    zypper = package_manager.Zypper(self)\n    zypper.install([\"libxcb-devel\", \"libfontenc-devel\", \"libXaw-devel\", \"libXcomposite-devel\",\n                          \"libXcursor-devel\", \"libXdmcp-devel\", \"libXtst-devel\", \"libXinerama-devel\",\n                          \"libxkbfile-devel\", \"libXrandr-devel\", \"libXres-devel\", \"libXss-devel\",\n                          \"xcb-util-wm-devel\", \"xcb-util-image-devel\", \"xcb-util-keysyms-devel\",\n                          \"xcb-util-renderutil-devel\", \"libXdamage-devel\", \"libXxf86vm-devel\", \"libXv-devel\",\n                          \"xcb-util-devel\", \"libuuid-devel\", \"xcb-util-cursor-devel\"], update=True, check=True)\n\n    pacman = package_manager.PacMan(self)\n    pacman.install([\"libxcb\", \"libfontenc\", \"libice\", \"libsm\", \"libxaw\", \"libxcomposite\", \"libxcursor\",\n                          \"libxdamage\", \"libxdmcp\", \"libxtst\", \"libxinerama\", \"libxkbfile\", \"libxrandr\", \"libxres\",\n                          \"libxss\", \"xcb-util-wm\", \"xcb-util-image\", \"xcb-util-keysyms\", \"xcb-util-renderutil\",\n                          \"libxxf86vm\", \"libxv\", \"xcb-util\", \"util-linux-libs\", \"xcb-util-cursor\"], update=True, check=True)\n\n    package_manager.Pkg(self).install([\"libX11\", \"libfontenc\", \"libice\", \"libsm\", \"libxaw\", \"libxcomposite\", \"libxcursor\",\n                       \"libxdamage\", \"libxdmcp\", \"libxtst\", \"libxinerama\", \"libxkbfile\", \"libxrandr\", \"libxres\",\n                       \"libXScrnSaver\", \"xcb-util-wm\", \"xcb-util-image\", \"xcb-util-keysyms\", \"xcb-util-renderutil\",\n                       \"libxxf86vm\", \"libxv\", \"xkeyboard-config\", \"xcb-util\", \"xcb-util-cursor\"], update=True, check=True)\n```\n\n对于`Ubuntu`来讲，`conan`能手动帮我们调用`apt`安装所需要的系统依赖。需要注意一点，需要在配置文件中加上两句，来指明开启这个功能和使用`sudo`。所以最终的配置文件类似如下：\n\n```ini\n[settings]\nos=Linux\nos_build=Linux\narch=x86_64\narch_build=x86_64\ncompiler=gcc\ncompiler.version=9\ncompiler.libcxx=libstdc++11\nbuild_type=Release\n[options]\n[build_requires]\n[env]\n[conf]\ntools.system.package_manager:mode=install\ntools.system.package_manager:sudo=True\n```\n\n至此，我们成功通过`conan`安装下来了`cairo`，看到成功的结果，我的内心无比兴奋。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240715175839407.png\" alt=\"image-20240715175839407\" style=\"zoom:60%;\" />\n\n# 使用Cairo库绘制图形\n\n安装完`cairo`库，是时候使用它绘制一些简单的图形了。\n\n## Linux GUI背景简述\n\n`Linux`本身是不带有图形界面的，真正原生的`Linux`系统只是一个基于命令行的操作系统。但是我们目前所使用的`Linux`发行版，例如`Ubuntu`、`Centos`等，都是有图形界面的啊。这是因为这些图形界面是`Linux`下的一个应用程序而已，是通过程序和协议模拟和实现出来的，或者说图形界面并不属于`Linux`内核的一部分。这一点和`Windows`系统完全不一样，`Windows`的命令行在我看来完全不如`Linux`这么好用，甚至有时候我会爆粗口喷他，但是`Windows`的用户的依然最多。为什么呢？就是因为`GUI`好看。`Windows`的图形界面是操作系统的一部分，并且做的确实好看和丝滑。这样变相的降低了用户的学习和使用成本，对大多数的人而言是件好事。但是对于程序员特别是偏向底层的程序员来讲，却真不一定。\n\n在`Linux`下，需要通过应用程序实现图形界面，那就需要设计一个合适的协议。目前市面上比较流行的有两种协议，`X`协议和`Wayland`协议。这两种协议都是基于网络通信的思想，将图形显示分为了客户端（即你的应用程序）和服务端通信的过程。输入设备和显示设备不是同一个设备，而且他们需要相互配合，进行画面显示，所以需要一个交互协议，建立他们直接的沟通桥梁。当然`X`协议和`Wayland`协议的细节有所区别，粗略的讲是`server`和`compositor`的设计不同，具体可见[https://www.secjuice.com/wayland-vs-xorg/](https://www.secjuice.com/wayland-vs-xorg/)。\n\n本文以及后续以`X`协议为例展开，并以`XClient`和`XServer`分别代指客户端和服务端。例如现在我需要画一个圆，`XClient`需要告诉`XServer`在屏幕的什么地方，使用什么颜色，画多大的一个圆。至于这个圆如何生成，如何使用硬件真正绘制图形等等这些操作，都是由`XServer`完成的。当然更进一步的，`XServer`还可以捕捉鼠标和键盘的动作，会触发相应的事件。`XClient`可以接受相应的事件并且完成相应的逻辑。这就是整个`X`协议以及绘制逻辑的简要概括。\n\n`X`协议有很多实现。目前用的最多的是`XOrg`，对应的`XClient`有`Xlib`和`XCB`的两种实现，提供了和`XServer`对接的`API`。（`At the bottom level of the X client library stack are Xlib and XCB, two helper libraries (really sets of libraries) that provide API for talking to the X server.`）本文的背景是`X11`，也是`Xlib`库的一个特殊版本。\n\n上面只是非常粗略的说明了一下基本思路，更多文档请参考：\n\n1. [X.Org](https://www.x.org/wiki/)\n2. [Wayland](https://wayland.freedesktop.org/)\n3. [The X New Developer’s Guide: Xlib and XCB](https://www.x.org/wiki/guide/xlib-and-xcb/)\n\n## 安装X11并编写GUI程序\n\n强烈建议在虚拟机下进行，因为`Wsl`需要内核更新到`2.2.4`以后才能使用最新功能的`GUI`，而且体验还不是很好。\n\n以`Ubuntu`为例，系统默认是未安装`X11`库的（`XServer`肯定是有的，不然你怎么看得到图形界面呢？安装`X11`只是提供了窗口系统的开发支持）。因此我们使用如下命令手动安装。值得一提的是，由于`X11`是系统库，因此使用`apt`包安装即可。同理对于`Wayland`也是一样。\n\n```bash\nsudo apt install libx11-dev\n```\n\n安装完成以后，使用`CMake`就能很方便的引入`X11`支持了。\n\n```cmake\nadd_executable (xxx\n    ...\n)\ntarget_link_libraries (xxx X11)\n```\n\n现在我们编写一个样例程序，用于在`X11`下绘制一个图形窗口。这里面涉及到很多的`X11`的`API`，本文只做简单介绍，具体请参考文档[https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html](https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html)\n\n```cpp\n#include <X11/Xlib.h>\n\n#include <iostream>\n\n\nint main()\n{\n    // 用于和 XServer 建立连接，dpy 指针全局只有一份\n    Display *dpy = XOpenDisplay(nullptr);\n    if (!dpy)\n    {\n        std::cerr << \"Unable to open X display!\" << std::endl;\n        throw;\n    }\n\n    int screen = DefaultScreen(dpy);\n    // 创建一个顶层窗口\n    Window w = XCreateSimpleWindow(\n        dpy,\n        RootWindow(dpy, DefaultScreen(dpy)),\n        100, 100, 400, 300, 0,\n        BlackPixel(dpy, screen),\n        BlackPixel(dpy, screen)\n    );\n    // 将需要检测的事件绑定在窗口上\n    XSelectInput(dpy, w, ExposureMask);\n    // 展示这个窗口\n    XMapWindow(dpy, w);\n\n    std::cout << \"Entering loop ...\" << std::endl;\n\n    // 进入事件循环\n    XEvent e;\n    while (1)\n    {\n        XNextEvent(dpy, &e);\n        switch (e.type)\n        {\n            case Expose:\n                std::cout << \"event: Expose\" << std::endl;\n                break;\n            default:\n                std::cout << \"event: \" << e.type << std::endl;\n                break;\n        }\n    }\n\n    return 0;\n}\n```\n\n接口的大致功能以在代码注释中体现。注意到整个程序最重要的架构是最后的这个事件循环，当`XClient`窗口成功创建出来以后，`XServer`需要不断监听`XClient`发送的事件并予以处理，这样才能实现`GUI`程序的功能。因此事件循环的存在就自然而然了。有点类似于`IO`多路复用中`epoll`技术的框架。在这里监听的是`Expose`事件，不用具体关心这个语义是什么意思，在窗口创建和窗口大小发生改变的时候会触发`Expose`事件，这里也是用作信息打印测试。\n\n程序的运行结果如下，可以发现窗口创建和改变窗口大小的时候在不断打印`Expose`的信息。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240716111623175.png\" alt=\"image-20240716111623175\" style=\"zoom:67%;\" />\n\n对于事件循环这个概念，不管是`Qt`，还是`LarkSDK`，还是对于一个跨平台的`GUI`框架，事件循环显然是必不可少的。问题在于跨平台需要统一不同平台下的窗体系统和事件处理等逻辑，最终抽象出跨平台的接口，这就是这些框架正在做最重要的一件事情。以`LarkSDK`为例，虽然最简单的跨平台的程序是四行就能搞定，但是其中涉及到的知识和背景是非常庞大的。\n\n```cpp\n#include <lwindowapplication.h>\n#include <lwindow.h>\n\nint main()\n{\n    LWindowApplication app; // 创建窗体程序主框架实例\n    LWindow w; // 创建顶层窗体\n    w.show(); // 让窗体可见\n    return app.exec(); // 进入主事件循环\n}\n```\n\n## 尝试引入Cairo\n\n`cairo`将输出和绘制的概念做了严格区分。`cairo surface`是一个抽象出来的概念，与其对接的是多种输出方式，例如`PDF`、`PNG`、`SVG`、`Win32`、`XLib`、`XCB`等，如图所示。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240716141915019.png\" alt=\"image-20240716141915019\" style=\"zoom:75%;\" />\n\n接着我们查看`cairo`官方提供的[samples](https://cairographics.org/samples/)，可以发现，官方提供的样例好像完全和`surface`没有关系，换句话说没有反映输出的方式。例如这段代码：\n\n```cpp\ndouble xc = 128.0;\ndouble yc = 128.0;\ndouble radius = 100.0;\ndouble angle1 = 45.0  * (M_PI/180.0);  /* angles are specified */\ndouble angle2 = 180.0 * (M_PI/180.0);  /* in radians           */\n\ncairo_set_line_width (cr, 10.0);\ncairo_arc (cr, xc, yc, radius, angle1, angle2);\ncairo_stroke (cr);\n\n/* draw helping lines */\ncairo_set_source_rgba (cr, 1, 0.2, 0.2, 0.6);\ncairo_set_line_width (cr, 6.0);\n\ncairo_arc (cr, xc, yc, 10.0, 0, 2*M_PI);\ncairo_fill (cr);\n\ncairo_arc (cr, xc, yc, radius, angle1, angle1);\ncairo_line_to (cr, xc, yc);\ncairo_arc (cr, xc, yc, radius, angle2, angle2);\ncairo_line_to (cr, xc, yc);\ncairo_stroke (cr);\n```\n\n它的绘制结果是这样的：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240716142350311.png\" alt=\"image-20240716142350311\" style=\"zoom:85%;\" />\n\n这个图样可以被输出到前面提到的任意一种`surface`中。同时这也是我想说的，`cairo`将输出和绘制的概念做了完整区分，同样这也是我们容易想到和愿意看到的。所以，如果想要创建一个输出到`PNG`中的实例，代码应该类似如下：\n\n```cpp\n// 创建 surface\ncairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 640, 480);\n// 创建绘图上下文 context\ncairo_t *cr = cairo_create(surface);\n\n// 绘制逻辑，只和 context 相关，与 surface 无关\n...\n\n// 输出到 png 格式中\ncairo_surface_write_to_png(surface, \"xxx.png\");\n```\n\n至此，我们用`surface`和`context`来代指输出和绘制的概念，也明白了`cario`是如何区分这两个概念的了。`surface`用作指明绘制的图形输出到哪里，`context`则用于进行绘制。读者可以尝试编写一个完整的程序输出上面的图案到一张图片文件中。\n\n## Cairo和X11相结合\n\n使用`cairo`成功输出到图片文件中以后，试着想想如何与`X11`窗口系统结合了。提前声明，用到的`surface`只有`XLib Surface`和`Image Surface`，其他的`API`请自行查询[文档](https://cairographics.org/manual/)。\n\n### XLib Surface\n\n首先想到的肯定是`XLib Surface`。这代表`cairo`帮我做好了与`X11`平台的对接工作，我只需要按部就班地使用`cairo`的`API`即可。所有的`surface`基本上只有在创建的时候会有区别，在`context`那一层的绘制几乎没有区别。例如下面就是`XLib Surface`的创建`API`，参数具体含义请参考[官方文档](https://cairographics.org/manual/cairo-XLib-Surfaces.html)。\n\n```cpp\ncairo_surface_t *\ncairo_xlib_surface_create (Display *dpy,\n                           Drawable drawable,\n                           Visual *visual,\n                           int width,\n                           int height);\n```\n\n查询该方法需要的接口如何获取以后，编写出如下的代码：\n\n```cpp\n#include <iostream>\n#include <exception>\n\n#include <X11/Xlib.h>\n\n#include \"cairo.h\"\n#include \"cairo/cairo-xlib.h\"\n\n\nint main()\n{\n    Display *dpy = XOpenDisplay(nullptr);\n    if (!dpy)\n    {\n        throw std::runtime_error(\"Failed to open X display\");\n    }\n\n    int screen = DefaultScreen(dpy);\n    Window w = XCreateSimpleWindow(\n        dpy,\n        RootWindow(dpy, DefaultScreen(dpy)),\n        100, 100, 640, 480, 0,\n        BlackPixel(dpy, screen),\n        BlackPixel(dpy, screen));\n    XSelectInput(dpy, w, ExposureMask);\n\n    XMapWindow(dpy, w);\n\n    std::cout << \"Entering loop ...\" << std::endl;\n\n    // 根据 window id 获取该窗口的信息\n    XWindowAttributes attr;\n    XGetWindowAttributes(dpy, w, &attr);\n\n    // 创建 XLib Surface\n    cairo_surface_t *surface = cairo_xlib_surface_create(dpy, w, attr.visual, attr.width, attr.height);\n    cairo_t *cr = cairo_create(surface);\n\n    XEvent e;\n    while (true)\n    {\n        XNextEvent(dpy, &e);\n\n        switch (e.type)\n        {\n            case Expose:\n            {\n                std::cout << \"event: Expose\" << std::endl;\n\n                // 绘制操作\n                cairo_set_source_rgb(cr, 1.0, 1.0, 0.5);\n                cairo_paint(cr);\n\n                cairo_set_source_rgb(cr, 1.0, 0.0, 1.0);\n                cairo_move_to(cr, 100, 100);\n                cairo_line_to(cr, 200, 200);\n                cairo_stroke(cr);\n\n                break;\n            }\n            default:\n                std::cout << \"event: \" << e.type << std::endl;\n                break;\n        }\n    }\n\n    cairo_destroy(cr);\n    cairo_surface_destroy(surface);\n\n    XDestroyWindow(dpy, w);\n    XCloseDisplay(dpy);\n\n\n    return 0;\n}\n```\n\n这样能在`Expose`事件触发的时候成功绘制出文章开始时候展示的图样。\n\n### Image Surface\n\n`XLib Surface`的代码结构看着很像自动挡的感觉，创建`surface`，在事件循环中用`context`进行绘制，最终得到想要的图案。\n\n我们深入思考一下，图形是如何被绘制到屏幕上的呢？前面举了个例子，画一个圆，告诉`XServer`在哪里，用什么颜色，画多大、多宽的圆。至于如何用硬件画不是`XClient`关心的事情，但是如何表示这些信息呢？显然需要用合适的`data`进行存储。进一步讲，`context`调用各种方法的实际过程，其实就是往数据缓冲区`data`中写数据的过程。当类似`flush`操作的被调用以后，这些数据才会真正反映在屏幕上，形成我们观看的效果。\n\n在这样的语义下，我们进一步思考`surface`的概念，其实用**可绘制表面**的概念好像更加贴切（本概念借鉴于`LarkSDK`的`LSurface`）。绘图的数据缓冲区记录了图形的数据，类型是`unsigned char *`，这些数据和不同的输出方式对接就能达到不同的输出效果。至于为什么是`unsigned char *`（我猜测大概是字节流）以及如何对接，这不是本文的重点，有兴趣请自己查询资料。\n\n知道这个过程以后，回到`Image Surface`本身，为什么要使用这个东西，是因为它为我们提供了获取数据的接口。也就是当我用`context`绘制以后，调用这个方法就能立刻拿到缓冲区的数据。\n\n```cpp\nunsigned char *\ncairo_image_surface_get_data (cairo_surface_t *surface);\n```\n\n然后让我们思考一下绘制效率。不同引擎的效率的区别根本上就是在于如何快速的把这些数据计算出来，或者换句话讲，如何快速地让缓冲区的内存填充为指定的数据。比如对于最基本的暴力软渲染和`cairo`引擎，他们的效率差距显然是非常大的。这里有一个例子可以参考，是`LarkSDK`原生软渲染和`cairo`引擎同样绘制`10000`条斜线的效率差距，以下是结果，保守估计至少差了几百到一千倍。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240716155335456.png\" alt=\"image-20240716155335456\" style=\"zoom:80%;\" />\n\n回到正题，再结合`X11`的`API`，我们可以给出使用`Image Surface`的代码：\n\n```cpp\n#include <iostream>\n#include <exception>\n\n#include <X11/Xlib.h>\n\n#include \"cairo.h\"\n\n\nint main()\n{\n    Display *dpy = XOpenDisplay(nullptr);\n    if (!dpy)\n    {\n        throw std::runtime_error(\"Failed to open X display\");\n    }\n\n    int screen = DefaultScreen(dpy);\n    Window w = XCreateSimpleWindow(\n        dpy,\n        RootWindow(dpy, DefaultScreen(dpy)),\n        100, 100, 640, 480, 0,\n        BlackPixel(dpy, screen),\n        BlackPixel(dpy, screen));\n    XSelectInput(dpy, w, ExposureMask);\n\n    unsigned long mask = 0;\n    XGCValues values;\n    GC gc = XCreateGC(dpy, w, mask, &values);\n\n    XMapWindow(dpy, w);\n\n    // 创建 Image Surface\n    cairo_surface_t *surface = cairo_image_surface_create(CAIRO_FORMAT_ARGB32, 640, 480);\n    cairo_t *cr = cairo_create(surface);\n\n    // 获得 Cairo 管理的绘图数据的指针\n    unsigned char *pData = cairo_image_surface_get_data(surface);\n    // 创建 X11 下的 Image Buffer ，将其中的数据替换为 Cairo 的数据指针\n    XImage *pBackBuffer = XCreateImage(\n        dpy,\n        DefaultVisual(dpy, screen),\n        DefaultDepth(dpy, screen),\n        ZPixmap,\n        0,\n        (char *)pData,\n        640, 480,\n        8,\n        0);\n\n    std::cout << \"Entering loop ...\" << std::endl;\n\n    XEvent e;\n    while (true)\n    {\n        XNextEvent(dpy, &e);\n\n        switch (e.type)\n        {\n            case Expose:\n            {\n                std::cout << \"event: Expose\" << std::endl;\n\n                cairo_set_source_rgb(cr, 1.0, 1.0, 0.5);\n                cairo_paint(cr);\n\n                cairo_set_source_rgb(cr, 1.0, 0.0, 1.0);\n                cairo_move_to(cr, 100, 100);\n                cairo_line_to(cr, 200, 200);\n                cairo_stroke(cr);\n\n                // flush 操作，刷新缓冲区，更新数据\n                cairo_surface_flush(surface);\n                \n                // X11 下真正绘制图形的方法，用到了外面定义的 X11 Image Buffer，而其内部的数据就是 Cairo 管理的缓冲区数据\n                XPutImage(\n                    dpy,\n                    w,\n                    gc,\n                    pBackBuffer,\n                    0, 0,\n                    0, 0,\n                    640, 480);\n\n                break;\n            }\n            default:\n                std::cout << \"event: \" << e.type << std::endl;\n                break;\n        }\n    }\n\n\n    cairo_destroy(cr);\n    cairo_surface_destroy(surface);\n\n    XDestroyWindow(dpy, w);\n    XCloseDisplay(dpy);\n\n\n    return 0;\n}\n```\n\n至此，我们完成了在`X11`下使用`Cairo`引擎绘制图形的全部过程。`Windows`的程序架构和事件循环有所区别，但思路是相同的。当然，这仅仅是阐述了基本过程，还有更多的细节值得研究和探讨。\n\n","categories":["实习","合迅科技","课题研究"]},{"title":"tips","url":"/posts/642c4108.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n本文总结了工作过程中可能遇到的各种问题的解决方法的链接。\n\n- typora破解版下载链接：[https://blog.csdn.net/weixin_43580824/article/details/131371951](https://blog.csdn.net/weixin_43580824/article/details/131371951)\n\n- code的c++的代码规范格式\n\n  - c++插件设置搜索format，C_Cpp: Clang_format_fallback Style中填入，详见clang-format-fallback-style目录的config.json\n\n  - 参考文档：\n\n    - [https://blog.csdn.net/weixin_43717839/article/details/129382657](https://blog.csdn.net/weixin_43717839/article/details/129382657)\n\n    - [https://blog.csdn.net/qq_29856169/article/details/119617736](https://blog.csdn.net/qq_29856169/article/details/119617736)\n\n<!-- more -->\n\n```json\n{\n    \"BasedOnStyle\": \"LLVM\",\n    \"UseTab\": \"Never\",\n    \"IndentWidth\": 4,\n    \"TabWidth\": 4,\n    \"BreakBeforeBraces\": \"Allman\",\n    \"AllowShortIfStatementsOnASingleLine\": true,\n    \"AllowShortLoopsOnASingleLine\": true,\n    \"IndentCaseLabels\": true,\n    \"ColumnLimit\": 0,\n    \"AccessModifierOffset\": -4,\n    \"NamespaceIndentation\": \"All\",\n    \"FixNamespaceComments\": false,\n    \"MaxEmptyLinesToKeep\": 2,\n    \"EmptyLineBeforeAccessModifier\": \"Always\",\n    \"EmptyLineAfterAccessModifier\": \"Always\",\n    \"SortIncludes\": \"Never\"\n}\n```\n\n- code中列出所有的插件列表：`code --list-extensions`\n\n  - 以下的`VS Code`插件都不适合升到最高版本，可能会出现各种各样的问题，下面是推荐的版本：\n    - `C++`：`1.18.5`\n    - `CMake Tools`：`1.16.32`\n\n- gcc不同版本的切换：[https://www.jianshu.com/p/f66eed3a3a25](https://www.jianshu.com/p/f66eed3a3a25)\n\n- Ubuntu 20.04 安装高版本的 gcc（如 gcc-11）：[https://blog.csdn.net/tiansyun/article/details/136592258](https://blog.csdn.net/tiansyun/article/details/136592258)\n\n- 彻底卸载计算机中的python：[https://blog.csdn.net/qq_38463737/article/details/107205696](https://blog.csdn.net/qq_38463737/article/details/107205696)\n\n- pip 相关\n\n  - 清除下载缓存：\n  \n  ```bash\n  pip cache purge\n  ```\n\n  - pip 换源：[https://blog.csdn.net/JineD/article/details/125090904](https://blog.csdn.net/JineD/article/details/125090904)\n\n  - pip 无法从清华源下载，报错 ERROR HTTP error 403：[https://blog.csdn.net/qq_21386397/article/details/136964624](https://blog.csdn.net/qq_21386397/article/details/136964624)\n\n  - 直接使用阿里云的源即可：\n  \n  ```bash\n  pip config set global.index-url https://mirrors.aliyun.com/pypi/simple/\n  ```\n\n- windows下的包管理器scoop\n\n  - 如何安装：\n    - [https://blog.csdn.net/Apple_Coco/article/details/113281197](https://blog.csdn.net/Apple_Coco/article/details/113281197)\n    - [https://blog.dejavu.moe/posts/windows-scoop](https://blog.dejavu.moe/posts/windows-scoop)\n    - 推荐使用第二个，使用管理员打开powershell，注意区分开**用户本身和全局安装的路径**\n    - 若最后一步提示管理员权限失败，参考：[https://stackoverflow.com/questions/74763204/installing-scoop-fails-running-the-installer-as-administrator-is-disabled-by-d](https://stackoverflow.com/questions/74763204/installing-scoop-fails-running-the-installer-as-administrator-is-disabled-by-d)\n  - 关于`Hash Check Failed`问题：加`-s`参数，详见[https://github.com/lzwme/scoop-proxy-cn/blob/main/README.md#关于-hash-check-failed-的问题](https://github.com/lzwme/scoop-proxy-cn/blob/main/README.md#关于-hash-check-failed-的问题)\n  - 换国内的`scoop`更新源\n    - `scoop config SCOOP_REPO https://gitee.com/scoop-bucket/scoop.git`\n  - 换国内`bucket`的`scoop-cn`源\n    - 参照两个`github`仓库链接配置即可，推荐使用第一个，数量更齐全\n    - [https://github.com/lzwme/scoop-proxy-cn](https://github.com/lzwme/scoop-proxy-cn)\n      - 仓库提供的镜像被墙了，可使用 gitee 镜像：[https://gitee.com/mybasegy/scoopcn](https://gitee.com/mybasegy/scoopcn)。个人建议使用原 github 仓库的 ssh 链接：[git@github.com:lzwme/scoop-proxy-cn.git](git@github.com:lzwme/scoop-proxy-cn.git)，请注意自己为 github 配个 ssh 密钥。\n    - [https://github.com/duzyn/scoop-cn](https://github.com/duzyn/scoop-cn)\n    - 为了保险，将这个`bucket`的名字设置为`main`，防止`update`的时候报`no bucket main`的错误\n  - 用`scoop`安装`oh-my-posh`：[https://sspai.com/post/69911](https://sspai.com/post/69911)\n  - `scoop`可以安装`aria2`加快下载速度，但是不建议自定义其配置，用默认就行\n    - 关闭警告可以开：`scoop config aria2-warning-enabled False`\n    - 删除`config`使用`scoop config rm <...>`\n  - 清理命令（其他的请自行搜索）\n    - 清理软件的旧版本：`scoop cleanup *`\n    - 清理下载缓存：`scoop cache rm *`\n    - 更新scoop本身：`scoop update`\n    - 更新某些app：`scoop update <appName>`\n    - 禁用某些程序更新：`scoop hold <appName>`\n    - 允许某些程序更新：`scoop unhold <appName>`\n\n- powshell增强，自动补全、主题美化、Git扩展：[https://cloud.tencent.com/developer/article/2317806](https://cloud.tencent.com/developer/article/2317806)\n\n  - 相关powershell配置文件见`.\\oh-my-posh-theme\\Microsoft.PowerShell_profile.ps1`，将其拷贝到`~\\Documents\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1`\n  - 在windows中添加alias命令别名：[https://zhuanlan.zhihu.com/p/74881435](https://zhuanlan.zhihu.com/p/74881435)\n\n- bandizip安装\n\n  - 6.25绿色专业版，有右键菜单：[https://www.52pojie.cn/thread-1477693-1-1.html](https://www.52pojie.cn/thread-1477693-1-1.html)\n  - 不推荐使用Scoop包管理器安装，因为是便携版，没有右键菜单\n\n- pip安装报错\n\n  - https://www.cnblogs.com/GrnLeaf/p/17201957.html\n\n  - [https://www.yaolong.net/article/pip-externally-managed-environment](https://www.yaolong.net/article/pip-externally-managed-environment)\n\n- Linux应用层编程可以开发的一些项目：https://blog.csdn.net/sinat_16643223/article/details/105761275\n\n- typora实现页内链接：https://blog.csdn.net/Manchester__united/article/details/113257595\n\n- Linux下配置github：https://blog.csdn.net/qq_33975041/article/details/104275499\n\n- Linux下安装python2(2.7.9)(可靠回答)：https://ubuntuforums.org/showthread.php?t=2486174\n\n- 清理wsl2占据空间的问题(虚拟空间，会吃磁盘)：https://zhuanlan.zhihu.com/p/614993276\n\n  ~~~powershell\n  diskpart\n\n  # 在新开的终端里面\n  select vdisk file=\"D:\\Wsl\\Ubuntu\\ext4.vhdx\"\n  compact vdisk\n  ~~~\n\n- cmake编译器选择指定的版本：https://www.cnblogs.com/lidabo/p/15400964.html\n\n- 搭建自己的博客：\n\n  - [https://yushuaigee.gitee.io/](https://yushuaigee.gitee.io/)\n  - [https://blog.csdn.net/qq_42893625/article/details/100852221](https://blog.csdn.net/qq_42893625/article/details/100852221)\n  - [http://yearito.cn/posts/hexo-theme-beautify.html](http://yearito.cn/posts/hexo-theme-beautify.html)\n  - [https://blog.csdn.net/qq_41461536/article/details/126127819](https://blog.csdn.net/qq_41461536/article/details/126127819)\n\n- 解决博客网络图片加载不出来：https://blog.csdn.net/mqdxiaoxiao/article/details/96770756\n  (在md文章正文前面添加：`<meta name=\"referrer\" content=\"no-referrer\"/>`)\n\n- .gitignore不起作用：https://blog.csdn.net/Saintmm/article/details/120847019\n\n- hexo给主页设置分页：https://blog.csdn.net/qq_39181839/article/details/109477431\n\n- hexo访客数和访问次数统计：https://echowinde.github.io/2022/06/08/hexo-diary-1/\n\n- Git使用分支管理不同的项目：https://blog.csdn.net/Jone_hui/article/details/114068497\n\n- Git删除分支：https://www.freecodecamp.org/chinese/news/how-to-delete-a-git-branch-both-locally-and-remotely/\n\n- Git分支重命名：https://blog.csdn.net/qq_37148270/article/details/107106392\n\n- Linux下离线安装python：https://blog.csdn.net/m0_37711292/article/details/131593577\n\n- 利用SCP协议将本地文件传输到云服务器：\"scp 本地文件路径 Linux云服务器用户名@云服务器实例公网IP地址:Linux云服务器文件路径\"\n  如果传文件夹可以打tar包，也可以加上-r参数，一定放在scp和本地文件路径之间\n\n- 腾讯云Centos升级gcc：https://blog.csdn.net/higer2008/article/details/123322867\n\n- json-server，伪造一些json数据挂到服务器上：\n\n  - [https://blog.csdn.net/qq_43780023/article/details/121670691](https://blog.csdn.net/qq_43780023/article/details/121670691)\n  - [https://blog.csdn.net/weixin_48299611/article/details/120709995](https://blog.csdn.net/weixin_48299611/article/details/120709995)\n\n- 将静态网页挂载到服务器上：https://blog.csdn.net/weixin_51563198/article/details/119673234\n\n- wsl下载更新网络错误：[https://zhuanlan.zhihu.com/p/661429025](https://zhuanlan.zhihu.com/p/661429025)\n\n- wsl登录`getpwnam(username) failed 0`：[https://github.com/microsoft/WSL/issues/9340](https://github.com/microsoft/WSL/issues/9340)\n\n- wsl永久修改hostname：\n\n  - [https://blog.csdn.net/qq_19922839/article/details/120697210](https://blog.csdn.net/qq_19922839/article/details/120697210)\n\n  - [https://blog.csdn.net/ichenglin/article/details/124963918](https://blog.csdn.net/ichenglin/article/details/124963918)\n\n- wsl 安装出现 Installing, this may take a few minutes... 时间长。且重新打开进入 root 用户的问题的解决：[https://www.cnblogs.com/ziyulab/p/18446092](https://www.cnblogs.com/ziyulab/p/18446092)\n\n- wsl安装微软雅黑字体（解决窗体title乱码问题）\n\n  - [https://blog.csdn.net/qq_30712797/article/details/128885517](https://blog.csdn.net/qq_30712797/article/details/128885517)\n\n  - `8.3`节\n\n  - 显示器类型选择`LCD`\n\n- 离线安装pip：\n\n  - [https://zhuanlan.zhihu.com/p/37473690](https://zhuanlan.zhihu.com/p/37473690)\n  - [https://www.cnblogs.com/geoffreyone/p/10332737.html](https://www.cnblogs.com/geoffreyone/p/10332737.html)\n\n- Zenity，在Shell下迈向图形化的GUI工具：[https://blog.csdn.net/DarlingTeng/article/details/106266964](https://blog.csdn.net/DarlingTeng/article/details/106266964)\n\n- Linux配置git：https://blog.csdn.net/qq_26620783/article/details/97265409\n\n- Docker搭建httpbin服务：https://blog.csdn.net/DahlinSky/article/details/104369657\n  (配置好了在面板上就可以方便的管理)\n\n- 给自己的博客添加网易云音乐：https://music.163.com/#/outchain/0/8897180109/m/use/html\n\n- Hexo 每天自动提交网站url到搜索引擎、百度、必应、谷歌：https://blog.csdn.net/Lott0419/article/details/113564110\n  这个是部署之后也不立刻提交，而是在一个固定的时间点提交，点击star就可以提交一次url，非常好用\n\n- Github博客配置CDN加速(不是域名)：https://zhuanlan.zhihu.com/p/97389072，还有自己去看B站视频\n\n- 使用Cloudflare进行CDN加速之后“网站重定向次数过多”：将SSL/TLS加密模式从 灵活 改为 完全\n\n- 在自己的服务器上配置teamspeak服务器并且绑定域名：https://bambovc.com/index.php/archives/30/\n\n- 使用MCSM非常方便的搭建我的世界服务器：https://mcsmanager.com/\n\n- 给自己的mc服务器绑定域名：[https://tutujanjan.com/如何给minecraft服务器绑定域名](https://tutujanjan.com/如何给minecraft服务器绑定域名)\n\n- 在docker上部署个人云盘nextcloud：https://zhuanlan.zhihu.com/p/108301496/\n\n- github的ssh连接超时：[https://blog.csdn.net/the__future/article/details/130038818](https://blog.csdn.net/the__future/article/details/130038818)\n\n- 解决Qt（从5.15以后只能在线安装）在线安装过慢：[https://zhuanlan.zhihu.com/p/645793252](https://zhuanlan.zhihu.com/p/645793252)\n\n- vscode的CMake-tools插件kits的json文件位置：`~/.local/share/CMakeTools`\n\n- ccache清除缓存文件夹：使用命令`ccache -s -v`查看缓存的位置，删除即可\n\n- windows 下安装 npm 和 cnpm：[https://blog.csdn.net/qq_40323256/article/details/100825982](https://blog.csdn.net/qq_40323256/article/details/100825982)\n\n- npm 配置环境变量：[https://blog.csdn.net/InOneStep/article/details/110235287](https://blog.csdn.net/InOneStep/article/details/110235287)\n\n  - 注意：Scoop 安装的 nodejs 最好也按照文章配置环境变量。不过有一点需要注意，node_global 和 node_cache 目录最好放在 Scoop 的 persist 目录下的对应位置。否则更新 nodejs 以后，对应的目录会被清除，导致使用出现问题。\n\n- 在 npm 官方发布自己的包\n\n  - [https://blog.csdn.net/Angsts/article/details/116307509](https://blog.csdn.net/Angsts/article/details/116307509)\n  - [https://blog.csdn.net/to_the_Future/article/details/122949610](https://blog.csdn.net/to_the_Future/article/details/122949610)\n\n- npm 换源\n\n  - 官方源\n\n    ```bash\n    npm config set registry https://registry.npmjs.org\n    ```\n\n  - 镜像源\n\n    ```bash\n    npm config set registry https://registry.npmmirror.com\n    ```\n\n- 在windows的git-bash中使用tree命令：[https://blog.csdn.net/qq_33154343/article/details/100064726](https://blog.csdn.net/qq_33154343/article/details/100064726)\n\n- 我的世界通过forge核心进行服务器搭建：[https://www.mintimate.cn/2020/02/08/Minecraft-Mod服务器搭建)](https://www.mintimate.cn/2020/02/08/Minecraft-Mod服务器搭建)\n\n- 安装配置zsh(linux下推荐，windows下建议使用posh)\n\n  - [https://zhuanlan.zhihu.com/p/35283688](https://zhuanlan.zhihu.com/p/35283688)\n  - [https://zhuanlan.zhihu.com/p/265525597](https://zhuanlan.zhihu.com/p/265525597)\n\n- oh-my-zsh 安装使用镜像：[https://www.cnblogs.com/chencarl/p/16824387.html](https://www.cnblogs.com/chencarl/p/16824387.html)\n\n- zsh推荐字体：[https://gitee.com/keyboardkiller/MesloLGS_NF](https://gitee.com/keyboardkiller/MesloLGS_NF)\n\n- zsh安装好用插件\n\n  - [https://blog.csdn.net/qq_41996454/article/details/102640653](https://blog.csdn.net/qq_41996454/article/details/102640653)\n  - [https://blog.csdn.net/qq_36835255/article/details/128096616](https://blog.csdn.net/qq_36835255/article/details/128096616)\n\n- 修复zsh历史错误：[https://blog.csdn.net/henryhu712/article/details/123836534](https://blog.csdn.net/henryhu712/article/details/123836534)\n\n  ```bash\n  cd ~\n  mv .zsh_history .zsh_history_bad\n  strings -eS .zsh_history_bad > .zsh_history\n  fc -R .zsh_history\n  ```\n\n- python项目的requirements.txt：[https://blog.csdn.net/pearl8899/article/details/113877334](https://blog.csdn.net/pearl8899/article/details/113877334)\n\n  - `python`一次性删除所有的第三方包：使用`pip freeze > log`将第三方包的内容导入到`log`文件中，然后通过`pip uninstall -r log`即可删除，如果不想输入`y`可以加上`-y`参数\n\n- python执行报错SyntaxError：[https://blog.csdn.net/flyfish1986/article/details/114702706](https://blog.csdn.net/flyfish1986/article/details/114702706)\n\n- 使用gulp压缩hexo博客文件（兼容ES6标准）：[https://blog.inkuang.com/2021/405](https://blog.inkuang.com/2021/405)\n\n- windows下cmd的命令大全（cmd不是powershell，可以在C程序中的system()函数调用）：[https://zhuanlan.zhihu.com/p/468515490(https://zhuanlan.zhihu.com/p/468515490)](https://zhuanlan.zhihu.com/p/468515490(https://zhuanlan.zhihu.com/p/468515490))\n\n  - 创建目录：`md ...`\n  - 删除目录：`rd ...`\n  - 创建文件（没有直接的命令，利用重定向）：`echo > ...`\n  - 删除文件：`del ...`\n\n- vscode通过ssh连接远程服务器：[https://blog.csdn.net/qq_29856169/article/details/115489702](https://blog.csdn.net/qq_29856169/article/details/115489702)\n\n- linux编译并且安装内核：[https://blog.csdn.net/weixin_43567188/article/details/119407019](https://blog.csdn.net/weixin_43567188/article/details/119407019)\n\n- linux删除多余的内核版本：[https://blog.csdn.net/jays_/article/details/90738580](https://blog.csdn.net/jays_/article/details/90738580)\n\n- linux下使用tar压缩或者解压：[https://blog.csdn.net/stf1065716904/article/details/81909320](https://blog.csdn.net/stf1065716904/article/details/81909320)\n\n- linux下使用zip压缩或者解压：[https://blog.csdn.net/soback00/article/details/132853862](https://blog.csdn.net/soback00/article/details/132853862)\n\n- windows下使用tar压缩或者解压：[https://blog.csdn.net/weixin_42672685/article/details/132900030](https://blog.csdn.net/weixin_42672685/article/details/132900030)\n\n- 在linux下如何使用tar和zip命令压缩、解压、分割、合并文件（分割和合并的操作对于`tar`和`zip`是一样的）：[https://blog.csdn.net/qq_41979513/article/details/98763608](https://blog.csdn.net/qq_41979513/article/details/98763608)\n\n- cmake的build和install命令，不使用make\n\n  - build：`cmake --build ./`\n  - install：`cmake --build ./ --target install`\n\n- oh-my-zsh更新换源\n\n  - 更新命令：`omz update`\n  - 进入`oh-my-zsh`安装目录：`cd ~/.oh-my-zsh`\n  - `git config --edit`\n  - 将`url`改为`https://gitee.com/mirrors/oh-my-zsh.git`\n\n- ubuntu重启后进入initramfs导致无法开机：[https://blog.csdn.net/weixin_44002151/article/details/134212707](https://blog.csdn.net/weixin_44002151/article/details/134212707)\n\n- windows下powershell中类似find命令的替代：[https://blog.csdn.net/yao_zhuang/article/details/115645435](https://blog.csdn.net/yao_zhuang/article/details/115645435)\n\n- windows下配置临时变量：[https://blog.csdn.net/qq_23212697/article/details/69177654](https://blog.csdn.net/qq_23212697/article/details/69177654)\n\n- 虚拟机网卡掉了，没网：[https://blog.csdn.net/qq_40344790/article/details/120645806](https://blog.csdn.net/qq_40344790/article/details/120645806)\n\n- wps绿色版：[https://www.52pojie.cn/thread-1263670-1-1.html](https://www.52pojie.cn/thread-1263670-1-1.html)\n\n- Office tool plus下载：[https://otp.landian.vip/zh-cn/](https://otp.landian.vip/zh-cn/)\n\n- Office 2021专业（增强版）安装教程：[https://www.mrdadong.com/archives/office-2021](https://www.mrdadong.com/archives/office-2021)\n\n- Office从C盘迁移到其他盘：[https://www.bilibili.com/video/BV1LT411g7Ae/](https://www.bilibili.com/video/BV1LT411g7Ae/)\n\n- 按照上一条视频内容以后报错\"**操作系统当前的配置不能运行此应用程序**\"\n\n  - [https://blog.csdn.net/m0_57941956/article/details/125575736](https://blog.csdn.net/m0_57941956/article/details/125575736)\n  - 看到最后面，发现目录需要匹配，也就是需要创建在`Program Files/`目录下面，而不能直接放在`D`盘根目录下\n\n  ```powershell\n  mklink /j \"C:\\Program Files\\Microsoft Office\" \"D:\\Program Files\\Microsoft Office\"\n  ```\n\n- idm绿色版下载：[https://www.bilibili.com/read/cv35705140/](https://www.bilibili.com/read/cv35705140/)\n\n- windows配置命令别名alias：[https://segmentfault.com/a/1190000015928399](https://segmentfault.com/a/1190000015928399)\n\n- vmware workstation pro个人版安装：[https://blogs.vmware.com/workstation/2024/05/vmware-workstation-pro-now-available-free-for-personal-use.html](https://blogs.vmware.com/workstation/2024/05/vmware-workstation-pro-now-available-free-for-personal-use.html)\n\n- Linux 下安装 docker 教程（不建议在 Wsl2 上安装，极可能会出问题）：[https://www.cnblogs.com/Liyuting/p/17022739.html](https://www.cnblogs.com/Liyuting/p/17022739.html)\n\n- ubuntu 完全卸载 docker 及再次安装：[https://blog.csdn.net/qq_45495857/article/details/113743109](https://blog.csdn.net/qq_45495857/article/details/113743109)\n\n- docker 无法删除镜像 hello-world 等的解决办法：[https://blog.csdn.net/yyj108317/article/details/105875836](https://blog.csdn.net/yyj108317/article/details/105875836)\n\n- Linux 系统配置 clash-gui 界面：[https://chh3213.github.io/2023/11/12/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AEclash-gui%E7%95%8C%E9%9D%A2/](https://chh3213.github.io/2023/11/12/linux%E7%B3%BB%E7%BB%9F%E9%85%8D%E7%BD%AEclash-gui%E7%95%8C%E9%9D%A2/)\n\n- 在低版本 Ubuntu 22.04|20.04|18.04 上安装 Node.js 20：[https://cn.linux-console.net/?p=20486](https://cn.linux-console.net/?p=20486)\n\n- Docker Hub Search：[https://docker.fxxk.dedyn.io/](https://docker.fxxk.dedyn.io/)\n\n- Docker 国内镜像源下架的解决办法（推荐 1Panel 镜像）：[https://mixuying.com/archives/1719753069678](https://mixuying.com/archives/1719753069678)\n\n- conan 更改安装的包的路径（主要用于 Windows）\n\n  - conan 1：修改 `~\\.conan\\conan.conf` 文件，参考：[https://www.cnblogs.com/bibo/p/15712445.html](https://www.cnblogs.com/bibo/p/15712445.html)\n  \n  ```ini\n  [storage]\n  path = <target path>\n  ```\n\n  - conan 2：修改 `~\\.conan2\\global.conf` 文件，在末尾添加下面这句，参考：[https://docs.conan.io/2/reference/commands/config.html](https://docs.conan.io/2/reference/commands/config.html)\n\n  ```ini\n  # Absolute path where the packages and database are stored\n  core.cache:storage_path = <target path>\n  ```\n\n- 安装思维导图软件 MindManager 2022 破解版：[https://www.zwnblog.com/archives/mindmanager2022-an-zhuang-yu-po-jie--bao-mu-jiao-cheng-](https://www.zwnblog.com/archives/mindmanager2022-an-zhuang-yu-po-jie--bao-mu-jiao-cheng-)\n\n  - 注意安装的时候不要自定义路径，选择默认的 C 盘路径，否则程序可能无法正常启动。\n\n  - 推荐使用 mklink 作符号链接，这样既能正常启动也能节省 C 盘空间，建议目录结构保持一致（使用管理员打开 CMD）：\n\n  ```cmd\n  mklink /j \"C:\\Program Files\\MindManager 22\" \"D:\\Program Files\\MindManager 22\"\n  ```\n\n- 编译调试 Linux 内核方法：[https://ignotusjee.github.io/2024/10/18/Linux-Debug/](https://ignotusjee.github.io/2024/10/18/Linux-Debug/)\n\n- 安装完 Wsl 以后，解决检测到 localhost 代理配置，但未镜像到 WSL，NAT 模式下的 WSL 不支持 localhost 代理的问题：[https://jasminides.com/posts/wsl_error1/](https://jasminides.com/posts/wsl_error1/)\n\n- 禁用/删除 Windows Defender，推荐使用 [windows-defender-remover](https://github.com/ionuttbara/windows-defender-remover)。推荐选择 Remove Windows Defender Antivirus (A) 而不是 Remove Windows Defender Antivirus + Disable All Security Mitigations (Y)。全删了会删除用户账户控制的功能，就是打开程序的时候有一个确认弹窗，这个我自己比较喜欢，不想删掉。\n\n- 安装 Nvidia 精简显卡驱动（只安装 Display Driver，不安装 GeForce Experience 以及其他组件）：[https://www.techpowerup.com/nvcleanstall/](https://www.techpowerup.com/nvcleanstall/)\n\n- OBS 及时回放的详细设置：[https://www.bilibili.com/video/BV1kXDVYkE2t/](https://www.bilibili.com/video/BV1kXDVYkE2t/)\n\n  - obs-notifier 插件无法向 N 卡一样在全屏的进程中进行提醒的显示，issue 见：[https://github.com/DmitriySalnikov/OBSNotifier/issues/9](https://github.com/DmitriySalnikov/OBSNotifier/issues/9)\n\n  - 上面插件的该功能是 enhancement 的状态，为了目前使用，个人写了一个声音提醒的脚本，仅作暂时使用：[https://github.com/DavidingPlus/obs-audio-notifier](https://github.com/DavidingPlus/obs-audio-notifier)\n\n- Windows 在默认打开方式中去掉已失效或者已删除的应用选项：[https://blog.csdn.net/qq_58995684/article/details/142319248](https://blog.csdn.net/qq_58995684/article/details/142319248)\n\n- Windows 截屏工具：[https://zh.snipaste.com/](https://zh.snipaste.com/)\n\n  - 通过 Scoop 安装：`scoop install snipaste-beta`\n\n- Windows 照片/视频查看工具：[https://github.com/easymodo/qimgv](https://github.com/easymodo/qimgv)\n\n  - 通过 Scoop 安装：`scoop install qimgv-video`\n\n- Windows PDF 阅读器：\n\n  - [PDF24 Creator](https://tools.pdf24.org/en/creator)（推荐），通过 Scoop 安装：`scoop install pdf24-creator-np`\n  - [sumatrapdf](https://github.com/sumatrapdfreader/sumatrapdf)，通过 Scoop 安装：`scoop install sumatrapdf`\n\n- 使用 1Panel 自动申请和续签证书：[https://hin.cool/posts/sslfor1panel.html](https://hin.cool/posts/sslfor1panel.html)\n\n  - 截止 2025.04.15，由于我将域名迁移到了 Cloudflare，使用腾讯云的 DNS 账户续签一直卡住，最终失败，可能和 DNS 域名解析服务器有关。解决办法是使用 Cloudflare 的 DNS 账户。\n\n- 腾讯云服务器 root 远程登陆被 ssh 服务器拒绝密码（即使密码正确）：[https://blog.csdn.net/COCO56/article/details/123770645](https://blog.csdn.net/COCO56/article/details/123770645)\n\n- Github Action ssh-deploy 的配置注意事项（如何让 Github 工作流把文件自动推送到我们自己的云服务器）：[https://github.com/easingthemes/ssh-deploy/issues/143#issuecomment-2490116974](https://github.com/easingthemes/ssh-deploy/issues/143#issuecomment-2490116974)\n\n- 解决 Linux /dev/mapper/ubuntu--vg-ubuntu--lv 磁盘空间不足的问题：[https://blog.csdn.net/Fly_1213/article/details/105142427](https://blog.csdn.net/Fly_1213/article/details/105142427)\n\n- Linux 安装 Anaconda：[https://blog.csdn.net/feng8403000/article/details/127814067](https://blog.csdn.net/feng8403000/article/details/127814067)\n\n- 使用 Deno 部署静态网页，可使用 Deno Deploy 作为静态网页的托管平台，无缝衔接：[https://deno.org.cn/blog/hugo-blog-with-deno-deploy](https://deno.org.cn/blog/hugo-blog-with-deno-deploy)\n\n- 使用 GitHub Proxy 加快 scoop bucket 的访问：[https://ghproxy.link/](https://ghproxy.link/)\n\n  - 使用方法：如代理地址是 https://proxy.top，bucket 仓库地址是 https://github.com/abc/bucket，则最后的地址是 https://proxy.top/github.com/abc/bucket。\n\n  - 如果实在无法访问，使用 ssh 地址即可，例如上面则是 git@github.com:abc/bucket\n\n- 自带 Cloudflare R2 对象存储上传的 picgo 升级版工具 PicList：[https://github.com/Kuingsmile/PicList](https://github.com/Kuingsmile/PicList)\n\n- 使用 Cloudflare R2 和 PicList 搭建图床：[https://blog.xingchencloud.top/p/e613c591.html](https://blog.xingchencloud.top/p/e613c591.html)\n\n- 1Panel 搭建 frp 服务端并使用 Openresty 反向代理：[https://www.cnblogs.com/drcode/p/18455476/panel-frps-reverse-proxy-https](https://www.cnblogs.com/drcode/p/18455476/panel-frps-reverse-proxy-https)\n\n- Frp 安全连接远程桌面，简单、安全、可视化（安全穿透）：[https://www.bilibili.com/video/BV1hZtme2Esu/](https://www.bilibili.com/video/BV1hZtme2Esu/)\n\n- Windows 将虚拟内存文件 pagefile.sys 移动到其他盘符：[https://www.xitongzhijia.net/xtjc/20230807/293331.html](https://www.xitongzhijia.net/xtjc/20230807/293331.html)\n\n","categories":["一些技巧"]},{"title":"C++ Primer","url":"/posts/d23e5b67.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 第一章 开始\n\n## 编写一个简单的C++程序\n\n```\nint main()\n{\nreturn 0;\n}\n```\n\n每个C++程序都包含一个或多个函数，其中一个必须命名为main.\n\n<!-- more -->\n\n## 初识输入输出\n\n| 对象 | 用途                   |\n| :--- | :--------------------- |\n| cin  | 标准输入               |\n| cout | 标准输出               |\n| cerr | 标准错误               |\n| clog | 输出运行时的一般性消息 |\n\n## 注释简介\n\n两种：\n\n单行注释：//\n\n界定符：/* 和 */\n\n## 控制流\n\nwhile;for;if;\n\n# 第二章 变量和基本类型\n\nP30-P71\n\n数据类型是程序的基础。C++语言支持广泛的数据类型。\n\n## 基本内置类型\n\n### 算术类型\n\n| 类型        | 最小尺寸     |\n| :---------- | :----------- |\n| bool        | 未定义       |\n| char        | 8位          |\n| w_char_t    | 16位         |\n| char16_t    | 16位         |\n| char32_t    | 32位         |\n| short       | 16位         |\n| int         | 16位         |\n| long        | 32位         |\n| long long   | 64位         |\n| float       | 6位有效数字  |\n| double      | 10位有效数字 |\n| long double | 10位有效数字 |\n\n### 类型转换\n\n不要混用符号类型和无符号类型。\n\n## 变量\n\n### 变量定义\n\n（1）基本形式：\n\n类型说明符，随后紧跟着一个或者多个变量名组成的列表，其中变量名以逗号分隔，最后以分号结束。\n\n（2）初始值\n\n在C++中，初始化和赋值是2个完全不同的操作。初始化的含义是创建变量的时候赋予一个初始值，而赋值的含义是把对象的当前值擦除，用一个新值来替代。两者区别很小。\n\n（3）列表初始化\n\n用花括号来初始化变量的方式，称为列表初始化。\n\n（4）默认初始化\n\n如果定义变量没有指定初始值，则变量被默认初始化。\n\n::: tip\n\n例外情况：\n\n定义在函数体内部的内置类型变量将不被初始化，其值未定义。\n\n建议初始化每个内置类型的变量。:::\n\n### 变量声明和定义的关系\n\n变量声明：规定了变量的类型和名字。\n\n变量定义：除声明之外，还需要申请存储空间。\n\n如果想声明一个变量，而非定义它，需要使用extern关键词。\n\n```\nextern int i;    // 声明i而非定义i\nint j;           // 声明并定义j\n```\n\n::: tip变量只能被定义一次，但可以被多次声明。:::\n\n### 名字的作用域\n\n作用域：C++中大多数作用域都用花括号分隔。\n\n作用域中一旦声明了某个名字，它所嵌套的所有作用域都能访问该名字。同时，允许在内层作用域中重新定义外层作用域中有的名字。\n\n::: warning如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。:::\n\n## 复合类型\n\n> 定义:复合类型是基于其他类型定义的类型。\n\n### 引用\n\n引用：为对象起另外一个名字。\n\n::: warning引用必须被初始化。引用本身不是对象，所以不能定义引用的引用。引用要和绑定的对象严格匹配。引用类型的初始值，必须是一个对象。:::\n\n### 指针\n\n指针：本身就是一个对象。允许对指针赋值和拷贝。指针无须在定义的时候赋值。\n\n（1）利用指针访问对象\n\n如果指针指向了一个对象，则允许使用解引用符（*）来访问该对象。\n\n（2）void* 指针\n\n### 理解复合类型的声明\n\n（1）指向指针的指针\n\n** 表示指向指针的指针\n\n*** 表示指向指针的指针的指针\n\n（2）指向指针的引用\n\n不能定义指向引用的指针。但指针是对象，所以存在对指针的引用。\n\n## const限定符\n\n定义：const用于定义一个变量，它的值不能被改变。const对象必须初始化。\n\n::: tip\n\n默认状态下，const对象仅在文件内有效。当多个文件出现了同名的const变量时，等同于在不同文件中分别定义了独立的变量。\n\n如果想让const变量在文件间共享，则使用extern修饰。\n\n:::\n\n（1）const的引用\n\n允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式。\n\n一般，引用的类型必须与其所引用对象的类型一致，特殊情况是表达式。\n\n（2）指针和const\n\n弄清楚类型，可以从右边往左边阅读。\n\n（3）顶层const\n\ntop-level const 表示指针本身是个常量\n\nlow-level const表示指针所指的对象是一个常量。\n\n（4）constexpr和常量表达式\n\nC++新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。\n\n## 处理类型\n\n### 类型别名\n\n两种方法用于定义类型别名：\n\n（1）使用关键词typedef\n\n```\ntypedef double wages; //wages是double的同义词\ntypedef wages *p; // p是double*的同义词\n```\n\n（2）别名声明\n\n```\nusing SI = Sales_item;  // SI是Sales_item的同义词\n```\n\nauto类型说明符：让编译器通过初始值来推算变量的类型。\n\ndecltype类型指示符：选择并返回操作符的数据类型。只得到类型，不实际计算表达式的值。\n\n## 自定义数据结构\n\n（1）类\n\n数据结构是把一组相关的数据元素组织起来，然后使用它们的策略和方法。\n\n类一般不定义在函数体内，为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应该与类的名字一样。\n\n头文件通常包含那些被定义一次的实体。\n\n（2）预处理器\n\n```\n#ifndef SALES_DATA_H\n#define SALES_DATA_H\n#endif\n```\n\n一般把预处理变量的名字全部大写。\n\n## 术语\n\n**空指针** ：值为0的指针，空指针合法但是不指向任何对象。nullPtr是表示空指针的字面值常量。\n\n**void\\***：可以指向任意非常量的指针类型，不能执行解引用操作。\n\n# 第三章 字符串、向量和数组\n\nP74-P118\n\nstring表示可变长的字符序列，vector存放的是某种给定类型对象的可变长序列。\n\n## 命名空间的 using 声明\n\n```\nusing namespace:name;\n```\n\n头文件不应包含using声明。\n\n## 标准库类型 string\n\n```\n#include <string>\nusing namespace std;\n```\n\n（1）定义和初始化\n\n```\nstring s1;\nsting s2(s1);\nstring s3(\"value\");\nstring s3 = \"value\";\nstring s4(n, 'c');\n```\n\n（2）string对象的操作\n\n```\ns.empty();      // 判空\ns.size();       // 字符个数\ns[n];           // s中第n个字符的引用\ns1+s2;          // s1和s2连接\n<,<=,>,>=       // 比较\n```\n\n::: warning\n\n标准局允许把字面值和字符串字面值转换成string对象。字面值和string是不同的类型。\n\n:::\n\n(3)处理string对象中的字符\n\n::: tipC++程序的头文件应该使用cname，而不应该使用name.h的形式:::\n\n遍历给定序列中的每个值执行某种操作\n\n```\nfor (declaration : expression)\n    statement\n```\n\n## 标准库类型 vector\n\n标准库vector表示对象的集合，其中所有对象的类型都相同。\n\nvector是一个类模板，而不是类型。\n\n（1）定义和初始化vector对象\n\n```\nvector<T> v1;\nvector<T> v2(v1);\nvector<T> v2 = v1;\nvector<T> v3(n, val);\nvector<T> v4(n);\nvector<T> v5{a,b,c...}\nvecrot<T> v5={a,b,c...}\n```\n\n如果用圆括号，那么提供的值是用来构造vector对象的。\n\n如果用花括号，则是使用列表初始化该vector对象。\n\n（2）向vector对象添加元素\n\n先定义一个空的vector对象，在运行的时候使用push_back向其中添加具体指。\n\n（3）其他vector操作\n\n```\nv.empty();\nv.size();\nv.push_back(t);\nv[n];\n```\n\n::: warning\n\n只能对确认已存在的元素执行下标操作。\n\n:::\n\n## 迭代器介绍\n\n迭代器运算符\n\n```\n*iter            // 解引用，返回引用\niter->mem        // 等价于  (*iter).mem\n++iter\n--iter\niter1 == iter2\niter1 != iter2\niter + n\niter - n\niter += n\niter -= n\niter1 - iter2     // 两个迭代器相减的结果是它们之间的距离\n>, >=, <, <=      // 位置比较\n```\n\n::: warning\n\n凡是使用了迭代器的循环体，都不能向迭代器所属的容器添加元素。\n\n:::\n\n## 数组\n\n（1）数组、指针\n\n使用数组下标的时候，通常将其定义为size_t类型。\n\n::: warning\n\n定义数组必须指定数组的类型，不允许用auto推断。\n\n不存在引用的数组。\n\n如果两个指针分别指向不相关的对象，则不能进行对这2个指针进行比较。\n\n:::\n\n## 多维数组\n\n多维数组实际上是数组的数组。\n\n```\nsize_t cnt = 0;\nfor(auto &row : a)\n\tfor (auto &col : row){\n\t\tcol = cnt;\n\t\t++cnt;\n\t}\nint *ip[4];    // 整型指针的数组\nint (*ip)[4];  // 指向含有4个整数的数组\n```\n\n## 术语\n\n**begin** string和vector的成员，返回指向第一个元素的迭代器。也是一个标准库函数，输入一个数组，返回指向该数组首元素的指针。\n\n**end** string和vector的成员，返回一个尾后迭代器。也是一个标准库函数，输入一个数组，返回指向该数组尾元素的下一个位置的指针。\n\n# 第四章 表达式\n\nP120-P151\n\n## 基础\n\n**重载运算符**：为已经存在的运算符赋予了另外一层含义。\n\n**左值、右值**：\n\n当一个对象用作右值得时候，用的是对象的值（内容）。\n\n当对象被用作左值得时候，用的是对象的身份（在内存中的位置）。\n\n## 算术运算符\n\n**%**：参与取余运算的运算对象必须是整数类型。\n\n## 逻辑和关系运算符\n\n| 运算符 |\n| :----: |\n|   !    |\n|   <    |\n|   <=   |\n|   >    |\n|   >=   |\n|   ==   |\n|   !=   |\n|   &&   |\n|  \\|\\|  |\n\n&& 运算符和 || 运算符都是先求左侧运算对象的值再求右侧运算对象的值。  \n\n::: warning\n\n进行比较运算的时候，除非比较的对象是bool类型，否则不要使用布尔字面值true,false作为运算对象。\n\n:::\n\n## 赋值运算符\n\n赋值运算符满足右结合律。\n\n不要混淆相等运算符和赋值运算符\n\n```\nif (i = j)\n\nif (i == j)\n```\n\n## 递增和递减运算符\n\n递增运算符 ++\n\n递减运算符 --\n\n## 成员访问运算符\n\n点运算符和箭头运算符\n\n```\nn = (*p).size();\nn = p->size();\n```\n\n## 条件运算符\n\n```\ncondition ? expression1 : expression2;\n```\n\n## 位运算符\n\n| 运算符 | 功能   | 用法           | 备注                                         |\n| :----- | ------ | -------------- | :------------------------------------------- |\n| ~      | 位求反 | ~expr          | 1置为0，0置为1                               |\n| <<     | 左移   | expr << expr2  | 在右侧插入值位0的二进制位                    |\n| >>     | 右移   | expr1 >> expr2 |                                              |\n| &      | 位与   | expr1 & expr2  | 对应位置都是1，则结果1，否则为0。            |\n| ^      | 位异或 | expr1 ^ expr2  | 对应位置有且只有1个为1，则结果是1，否则为0。 |\n| \\|     | 位或   | expr1 \\| expr2 | 对应位置至少有1个位1，则结果是1，否则为0。   |\n\n## sizeof运算符\n\nsizeof运算符返回一条表达式或一个类型名字所占的字节数，其所得值是一个size_t类型，是一个常量表达式。\n\n```\nsizeof (type)\nsizeof expr\n```\n\n## 逗号运算符\n\n逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。\n\n## 类型转换\n\n**隐式转换**\n\n**显式转换**\n\n命名的强制类型转换\n\n```\ncast-name<type>(expression)\n\n// cast-name是static_cast,dynamic_cast,const_cast,reinterpret_cast\n```\n\n::: tip\n\n由于强制类型转换干扰了正常的类型检查，因此建议避免强制类型转换。\n\n:::\n\n## 运算符优先级表\n\n# 第五章 语句\n\nP154-P178\n\n## 简单语句\n\n（1）空语句\n\n```\n;    // 空语句\n```\n\n（2）复合语句\n\n复合语句是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作块（block）。\n\n```\n{}\n```\n\n## 语句作用域\n\n定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量就超出其作用范围。\n\n## 条件语句\n\n（1）if 语句\n\n（2）switch 语句\n\ncase关键字和它对应的值一起被称为case标签。\n\ncase标签必须是整形常量表达式。\n\n如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显示的中断了这一过程。\n\ndedault 标签：如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧跟在default标签后面的语句。\n\n## 迭代语句\n\n（1）while 语句\n\n```\nwhile (condition)\n\t\t\tstatement\n```\n\n（2）传统 for 语句\n\n```\nfor (initializar; condition; expression)\n\t\tstatement\n```\n\nfor 语句中定义的对象只在for循环体内可见。\n\n（3）范围 for 语句\n\n```\nfor (declaration : expression)\n\t\tstatement\n```\n\n（4）do while 语句\n\n```\ndo \n\tstatement\nwhile (condition)\n```\n\n## 跳转语句\n\n**break**\n\nbreak只能出现在迭代语句或者switch语句内部。仅限于终止离它最近的语句，然后从这些语句之后的第一条语句开始执行。\n\n**continue**\n\ncontinue语句终止最近的循环中的当前迭代并立即开始下一次迭代。\n\n**goto**\n\ngoto的作用是从goto语句无条件跳转到同一函数内的另一条语句。\n\n容易造成控制流混乱，应禁止使用。\n\n**return**\n\n## try语句块和异常处理\n\nC++中异常处理包括：throw表达式、try语句块。\n\ntry和catch，将一段可能抛出异常的语句序列括在花括号里构成try语句块。catch子句负责处理代码抛出的异常。\n\nthrow表达式语句，终止函数的执行。抛出一个异常，并把控制权转移到能处理该异常的最近的catch字句。\n\n# 第六章 函数\n\nP182-P225\n\n## 函数基础\n\n（1）形参和实参：\n\n实参的类型必须与对应的形参类型匹配。\n\n函数的调用规定实参数量应与形参数量一致。\n\n（2）局部对象\n\n形参和参数体内部定义的变量统称为**局部变量**，它们对函数而言是\"局部\"的，仅在函数的作用域内可见，同时局部变量还会隐藏外层作用域中同名的其他变量。\n\n**自动对象**：只存在于块执行期间的对象。\n\n局部静态对象：在程序的执行路径第一次经过对象定义语句时候进行初始化，并且直到程序终止才会被销毁。\n\n```\nsize_t count_calls()\n{\n\tstatic size_t ctr = 0;\n\treturn ++ctr;\n}\n```\n\n（3）函数声明\n\n函数的三要素：（返回类型、函数名、形参类型）。\n\n函数可被声明多次，但只能被定义一次。\n\n（4）分离式编译\n\n分离式编译允许把程序分割到几个文件中去，每个文件独立编译。\n\n编译->链接\n\n## 参数传递\n\n当形参是引用类型，这时它对应的实参被引用传递或者函数被传引用调用。\n\n当实参被拷贝给形参，这样的实参被值传递或者函数被传值调用。\n\n（1）传值参数\n\n（2）被引用传参\n\n（3）const形参和实参\n\n（4）数组形参\n\n为函数传递一个数组时，实际上传递的是指向数组首元素的指针。\n\n```\nvoid print(const int*);\nvoid pring(const int[]);\nvoid print(const int[10]);\n// 以上三个函数等价\n```\n\n数组引用实参：f(int (&arr)[10])\n\n```\nint *matrix[10];   // 10个指针构成的数组\nint (*matrix)[10]; // 指向含有10个整数的数组的指针\n```\n\n（5）含有可变形参的数组\n\ninitializer_list\n\n```\nfor err_msg(initializer_list<string> li)\n```\n\n## 返回类型和return语句\n\n2种：无返回值函数和右返回值函数。\n\n```\nreturn;\nreturn expression;\n```\n\n函数完成后，它所占用的存储空间也会随着被释放掉。\n\n::: warning\n\n返回局部对象的引用是错误的；返回局部对象的指针也是错误的。\n\n:::\n\n## 函数重载\n\n重载函数：同一作用域内的几个函数名字相同但形参列表不通，我们称之为重载函数。（overloaded）。\n\n不允许2个函数除了返回类型外其他所有的要素都相同。\n\n**重载与作用域**\n\n如果在内存作用域中声明名字，它将隐藏外层作用域中声明的同名实体。\n\n## 特殊用途语言特性\n\n（1）默认实参\n\n函数调用时，实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参。\n\n```\ntypedef string::size_type sz;\nstring screen(sz ht = 24, sz wid = 80, char background = ' ');\n```\n\n::: tip\n\n当设计含有默认实参的函数时，需要合理设置形参的顺序。一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。\n\n:::\n\n（2）内联函数\n\n使用关键词inline来声明内联函数。\n\n内联用于优化规模较小，流程直接，频繁调用的函数。\n\n（3）constexpr函数\n\nconstexpr函数是指能用于常量表达式的函数。\n\n## 函数匹配\n\nStep1:确定候选函数和可选函数。\n\nStep2:寻找最佳匹配。\n\n## 函数指针\n\n函数指针指向的是函数而非对象。\n\n```\nvoid useBigger (const string &s1, const string &s2, bool pf(const string &, const string &));\n等价于\nvoid useBigger (const string &s1, const string &s2, bool (*pf)(const string &, const string &));\n```\n\n# 第七章 类\n\nP228-P273\n\n类的基本思想是数据抽象和封装。\n\n抽象是一种依赖于接口和实现分离的编程技术。\n\n封装实现了类的接口和实现的分离。\n\n## 定义抽象数据类型\n\n（1）this\n\n任何对类成员的直接访问都被看作this的隐式引用。\n\n```\nstd::string isbn() const {return bookNo;}\n```\n\n等价于\n\n```\nstd::string isbn() const {return this->bookNo;}\n```\n\n（2）在类的外部定义成员函数\n\n类外部定义的成员的名字必须包含它所属的类名。\n\n```\ndouble Sales_data::avg_price() const {\n\tif (units_sol)\n\t\treturn revenue/units_sols;\n\telse\n\t\treturn 0;\n}\n```\n\n（3）构造函数\n\n> 定义：类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。\n>\n> 构造函数没有返回类型；\n>\n> 构造函数的名字和类名相同。\n\n类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**。\n\n编译器创建的构造函数被称为**合成的默认构造函数**。\n\n::: tip\n\n只有当类没有声明任何构造函数的时，编译器才会自动的生成默认构造函数。\n\n一旦我们定义了一些其他的构造函数，除非我们再定义一个默认的构造函数，否则类将没有默认构造函数\n\n:::\n\n## 访问控制与封装\n\n（1）访问控制\n\n| 说明符  | 用途                                                         |\n| ------- | ------------------------------------------------------------ |\n| public  | 使用public定义的成员，在整个程序内可被访问，public成员定义类的接口。 |\n| private | 使用private定义的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了类的实现细节。 |\n\n（2）友元\n\n类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的友元。\n\n以friend关键字标识。\n\n友元不是类的成员，不受访问控制级别的约束。\n\n::: tip\n\n友元的声明仅仅制定了访问的权限，而非通常意义的函数声明。必须在友元之外再专门对函数进行一次声明。\n\n:::\n\n```\n// Sales_data.h\n\nclass Sales_data {\nfriend Sales_data add(const Sales_data&, const Sales_data&);\nfriend std::ostream &print(std::ostream&, const Sales_data&);\nfriend std::istream &read(std::istream&, Sales_data&);\n}\n\n// nonmember Sales_data interface functions\nSales_data add(const Sales_data&, const Sales_data&);\nstd::ostream &print(std::ostream&, const Sales_data&);\nstd::istream &read(std::istream&, Sales_data&);\n\n//Sales_data.cpp\n\nSales_data \nadd(const Sales_data &lhs, const Sales_data &rhs)\n{\n\tSales_data sum = lhs;  // copy data members from lhs into sum\n\tsum.combine(rhs);      // add data members from rhs into sum\n\treturn sum;\n}\n\n// transactions contain ISBN, number of copies sold, and sales price\nistream&\nread(istream &is, Sales_data &item)\n{\n\tdouble price = 0;\n\tis >> item.bookNo >> item.units_sold >> price;\n\titem.revenue = price * item.units_sold;\n\treturn is;\n}\n\nostream&\nprint(ostream &os, const Sales_data &item)\n{\n\tos << item.isbn() << \" \" << item.units_sold << \" \" \n\t   << item.revenue << \" \" << item.avg_price();\n\treturn os;\n}\n```\n\n## 类的其他特性\n\n（1）重载成员变量\n\n```\nScreen myScrren;\nchar ch = myScreen.get();\nch = myScreen.get(0,0);\n```\n\n（2）类数据成员的初始化\n\n类内初始值必须使用=或者{}的初始化形式。\n\n```\nclass Window_mgr{\nprivate:\n    std::vector<Screen> screens{Screen(24, 80, ' ')};\n}\n```\n\n（3）基于const的重载\n\n```\nclass Screen {\npublic:\n\t// display overloaded on whether the object is const or not\n    Screen &display(std::ostream &os) \n                  { do_display(os); return *this; }\n    const Screen &display(std::ostream &os) const\n                  { do_display(os); return *this; }\n}\n```\n\n当某个对象调用display的时候，该对象是否是const决定了应该调用display的哪个版本。\n\n（3）类类型\n\n对于一个类来说，在我们创建他的对象之前该类必须被定义过，而不能仅被声明。\n\n（4）友元\n\n*友元类*\n\n如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。\n\n```\nclass Screen {\n\t// Window_mgr的成员可以访问Screen类的私有部分\n\tfriend class Window_mgr;\n}\n```\n\n*令成员函数作为友元*\n\n```\nclass Screen {\n\t// Window_mgr::clear必须在Screen类之前被声明\n\tfriend void Window_mgr::clear(ScreenIndex);\n}\n```\n\n## 类的作用域\n\n一个类就是一个作用域。\n\n## 构造函数再探\n\n（1）构造函数的初始值有时必不可少\n\n::: tip\n\n如果成员是const、引用，或者属于某种未提供默认构造函数的类类型化。我们必须通过构造函数初始值列表为这些成员提供初值。\n\n:::\n\n```\nclass ConstRef{\npublic:\n\tConstRef (int i);\nprivate:\n\tint i;\n\tconst int ci;\n\tint &ri;\n};\n\nConstRef:ConstRef(int ii) : i(ii), ci(ii), ri(i){  }\n```\n\n（2）成员初始化的顺序\n\n成员初始化的顺序与它们在类定义中出现 的顺序一致。P259\n\n（3）委托构造函数\n\n使用它所述类的其他构造函数执行它自己的初始化过程。\n\n（4）如果去抑制构造函数定义的隐式转换？\n\n在类内声明构造函数的时候使用explicit关键字。\n\n## 类的静态成员\n\n（1）声明静态成员\n\n在成员的声明之前加上关键词static。\n\n类的静态成员存在于任何对象之外，对象中不包含任何与静态成员有关的数据。\n\n（2）使用类的静态成员\n\n```\ndouble r;\nr = Account::rate();\n```\n\n## 小结\n\n类有两项基本能力：\n\n一是数据数据抽象，即定义数据成员和函数成员的能力；\n\n二是封装，即保护类的成员不被随意访问的能力。\n\n# 第八章 IO库\n\nP278-P290\n\nC++语言不直接处理输入输出，而是通过一组定义在标准库中的类型来处理IO。\n\n- iostream处理控制台IO\n- fstream处理命名文件IO\n- stringstream完成内存string的IO\n\nifstream和istringstream继承自istream\n\nofstream和ostringstream继承自ostream\n\n## IO类\n\n（1）IO对象无拷贝或复制。\n\n进行IO操作的函数通常以引用方式传递和返回流。\n\n（2）刷新输出缓冲区\n\nflush刷新缓冲区，但不输出任何额外的字符；\n\nends向缓冲区插入一个空字符，然后刷新缓冲区。\n\n## 文件输入输出\n\n| 类       | 作用                   |\n| -------- | ---------------------- |\n| ifstream | 从一个给定文件读取数据 |\n| ofstream | 从一个给定文件写入数据 |\n| fstream  | 读写给定文件           |\n\n## string流\n\n| 类            | 作用                                   |\n| ------------- | -------------------------------------- |\n| istringstream | 从string读取数据                       |\n| ostringstream | 向string写入数据                       |\n| stringstream  | 既可从string读数据也可以向string写数据 |\n\n\n\n```\n\t// will hold a line and word from input, respectively\n\tstring line, word;\n\n\t// will hold all the records from the input\n\tvector<PersonInfo> people;\n\n\t// read the input a line at a time until end-of-file (or other error)\n\twhile (getline(is, line)) {       \n\t\tPersonInfo info;            // object to hold this record's data\n\t    istringstream record(line); // bind record to the line we just read\n\t\trecord >> info.name;        // read the name\n\t    while (record >> word)      // read the phone numbers \n\t\t\tinfo.phones.push_back(word);  // and store them\n\t\tpeople.push_back(info); // append this record to people\n\t}\n```\n\n\n\n```\n\t// for each entry in people\n\tfor (vector<PersonInfo>::const_iterator entry = people.begin();\n\t\t\t\tentry != people.end(); ++entry) {    \n\t\tostringstream formatted, badNums; // objects created on each loop\n\n\t\t// for each number\n\t\tfor (vector<string>::const_iterator nums = entry->phones.begin();\n\t\t\t\tnums != entry->phones.end(); ++nums) {  \n\t\t\tif (!valid(*nums)) {           \n\t\t\t\tbadNums << \" \" << *nums;  // string in badNums\n\t\t\t} else                        \n\t\t\t\t// ``writes'' to formatted's string\n\t\t\t\tformatted << \" \" << format(*nums); \n\t\t}\n\t\tif (badNums.str().empty())      // there were no bad numbers\n\t\t\tos << entry->name << \" \"    // print the name \n\t\t\t   << formatted.str() << endl; // and reformatted numbers \n\t\telse                   // otherwise, print the name and bad numbers\n\t\t\tcerr << \"input error: \" << entry->name \n\t\t\t     << \" invalid number(s) \" << badNums.str() << endl;\n\t}\n```\n\n# 第九章 顺序容器\n\nP292-P332\n\n顺序容器为程序员提供了控制元素存储和访问顺序的能力。\n\n## 顺序容器概述\n\n| 类型         | 作用                                                         |\n| ------------ | ------------------------------------------------------------ |\n| vector       | 可变数组大小。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢。 |\n| deque        | 双端队列。支持快速随机访问。在头尾位置插入/删除速度很快。    |\n| list         | 双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快。 |\n| forward_list | 单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快。 |\n| array        | 固定大小数组。支持快速随机访问。不能添加或删除元素。         |\n| string       | 与vector相似的容器，但专门用于保存字符、随机访问快。在尾部插入/删除速度快。 |\n\n## 容器库概述\n\n一般，每个容器都定义在一个头文件中。\n\n容器均定义为模板类。\n\n| 类型别名        |                                                        |\n| --------------- | ------------------------------------------------------ |\n| iterator        | 此容器类型的迭代器类型                                 |\n| const_iterator  | 可以读取元素，但不能修改元素的迭代器类型               |\n| size_type       | 无符号整数类型，足够保存此种容器类型最大可能容器的大小 |\n| difference_type | 带符号整数类型，足够保存两个迭代器之间的距离           |\n| value_type      | 元素类型                                               |\n| reference       | 元素的左值诶性：与value_type&含义相同                  |\n| const_reference | 元素的const左值类型（即，const value_type&）           |\n\n| 构造函数        |                                                             |\n| --------------- | ----------------------------------------------------------- |\n| C c;            | 默认构造函数，构造空容器                                    |\n| C c1(c2)        | 构造c2的拷贝c1                                              |\n| C c(b, e)       | 构造c，将迭代器b和e指定的范围内的元素拷贝到c（array不支持） |\n| C c{a, b, c...} | 列表初始化c                                                 |\n\n| 赋值与swap        |                                               |\n| ----------------- | --------------------------------------------- |\n| c1=c2             | 将c1中的元素替换为c2中元素                    |\n| c1 = {a, b, c...} | 将c1中的元素替换为列表中元素（不适用于array） |\n| a.swap(b)         | 交换a和b的元素                                |\n| swap(a, b)        | 与a.swap(b)等价                               |\n\n| 大小         |                                         |\n| ------------ | --------------------------------------- |\n| c.size()     | c中元素的数组（不支持forward_list）     |\n| c.max_size() | c中可保存的最大元素数目                 |\n| c.empty()    | 若c中存储了元素，返回false,否则返回true |\n\n| 添加/删除元素（不适用于array） |                             |\n| ------------------------------ | --------------------------- |\n| c.insert(args)                 | 将args中的元素拷贝进c       |\n| c.emplace(inits)               | 使用inits构造c中的一个元素  |\n| c.erase(args)                  | 删除args指定的元素          |\n| c.clear()                      | 删除c中的所有元素，返回void |\n\n| 关系运算符 |                                 |\n| ---------- | ------------------------------- |\n| ==, !=     | 所有容器都支持相等(不等运算符)  |\n| <,<=,>,>=  | 关系运算符(无序关联容器不支持） |\n\n| 获取迭代器           |                                           |\n| -------------------- | ----------------------------------------- |\n| c.begin(), c.end()   | 返回指向c的首元素和尾元素之后位置的迭代器 |\n| c.cbengin(),c.cend() | 返回const_iterator                        |\n\n| 反向容器的额外成员（不支持forward_list） |                                           |\n| ---------------------------------------- | ----------------------------------------- |\n| reverse_iterator                         | 按逆序寻址元素的迭代器                    |\n| const_reverse_iterator                   | 不能修改元素的逆序迭代器                  |\n| c.rbegin(), c.rend()                     | 返回指向c的尾元素和首元素之前位置的迭代器 |\n| c.crbegin(), c.crend()                   | 返回const_reverse_iterator                |\n\n（1）迭代器\n\n标准库的迭代器允许我们访问容器中的元素，所有迭代器都是通过解引用运算符来实现这个操作。\n\n一个迭代器返回由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置。它们标记了容器中元素的一个范围。\n\n左闭合区间：[begin, end)\n\n```\nwhile (begin !=end){\n\t\t*begin = val;\n\t\t++begin;\n}\n```\n\n（2）容器类型成员\n\n见概述\n\n通过别名，可以在不了解容器中元素类型的情况下使用它。\n\n（3）begin和end成员\n\nbegin是容器中第一个元素的迭代器\n\nend是容器尾元素之后位置的迭代器\n\n（4）容器定义和初始化\n\nP290\n\n```\nC c;            // 默认构造函数\nC c1(c2)\nC c1=c2\nC c{a,b,c...}   // 列表初始化\nC c={a,b,c...}\nC c(b,e)        // c初始化为迭代器b和e指定范围中的元素的拷贝\n// 只有顺序容器（不包括array）的构造函数才能接受大小参数\nC seq(n)\nC seq(n,t)\n```\n\n**将一个容器初始化为另一个容器的拷贝**:\n\n当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。\n\n不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型相同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。\n\n**标注库array具有固定大小**:\n\n不能对内置数组类型进行拷贝或对象赋值操作，但array并无此限制。P301\n\n（5）赋值与swap\n\narrray类型不允许用花括号包围的值列表进行赋值。\n\n```\narray<int, 10> a2={0}; //所有元素均为0\ns2={0};  // 错误！\n```\n\nseq.assign(b,e)  // 将seq中的元素替换为迭代器b和e所表示的范围中的元素。迭代器b和e不能指向seq中的元素。\n\nswap用于交换2个相同类型容器的内容。调用swap之后，两个容器中的元素将交换。\n\n（6）容器大小操作\n\nsize 返回容器中元素的数目\n\nempty 当size为0返回布尔值true，否则返回false\n\nmax_size 返回一个大于或等于该类型容器所能容纳的最大元素数的值\n\n（7）关系运算符\n\n关系运算符左右两边的元素符对象必须是相同类型的容器。\n\n::: tip\n\n只有当元素类型也定义了相应的比较运算符，才可以使用关系元素安抚来比较两个容器\n\n:::\n\n## 顺序容器操作\n\n（1）向顺序容器添加元素\n\n表格P305\n\n**使用push_back**:追加到容器尾部\n\n**使用push_front**:插入到容器头部\n\n**在容器中的特定位置添加元素**:使用insert\n\n```\nvector <string> svec;\nsvec.insert(svec.begin(), \"Hello!\");\n```\n\n**插入范围内元素**:使用insert\n\n**使用emplace操作**:\n\nemplace_front、emplace和emplace_back分别对应push_front、insert和push_back。\n\nemplace函数直接在容器中构造函数，不是拷贝。\n\n（2）访问元素\n\nP309\n\n注意end是指向的是容器尾元素之后的元素。\n\n| 在顺序容器中访问元素的操作 |                                                              |\n| -------------------------- | ------------------------------------------------------------ |\n| c.back()                   | 返回c中尾元素的引用。若c为空，函数行为未定义                 |\n| c.front()                  | 返回c中首元素的引用。若c为空，哈数行为未定义                 |\n| c[n]                       | 返回c中下标为n的元素的引用，n是一个无符号整数。若n>=size(),则函数行为未定义 |\n| c.at[n]                    | 返回下标为n的元素的引用。如果下标越界，则抛出out_of_range异常 |\n\n（3）删除元素\n\n| 顺序容器的删除操作 |                                                              |\n| ------------------ | ------------------------------------------------------------ |\n| c.pop_back()       | 删除c中尾元素。若c为空，则函数行为未定义。返回返回void       |\n| c.pop_front()      | 删除c中首元素。若c为空，则函数行为未定义。返回void           |\n| c.erase(p)         | 删除迭代器p所指定的元素，返回一个指向被删除元素之后元素的迭代器，如p指向尾元素，则返回尾后(off-the-end)迭代器。若p是尾后迭代器，则函数行为未定义 |\n| c.erase(b, e)      | 删除迭代器b和e所指定范围内的元素。返回一个指向最后一个被删除元素之后元素的迭代器。若e本身就是尾后迭代器，则函数也返回尾后迭代器 |\n| c.claer()          | 删除c中的所有元素。返回void                                  |\n\n（4）特殊的forwar_list操作\n\nP313\n\nbefor_begin();cbefore_begin();insert_after;emplace_after;erase_after;\n\n（5）改变容器大小\n\nreseize用于扩大或者缩小容器。\n\nresize操作接受一个可选的元素值参数，用来初始化添加到容器内的元素。\n\n如果容器保存的是类类型元素，且resize向容器中添加新元素，则必须提供初始值，或者元素类型必须提供一个默认构造函数。\n\n## vector对象是如何增长的\n\n为了避免影性能，标准库采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，vector和string通常会分配比新的新的空间需求更大的内存空间。容器预留这些空间作为备用，可以用来保存更多的新元素。\n\n**容器管理的成员函数**:\n\n| 容器大小管理擦作  |                                                              |\n| ----------------- | ------------------------------------------------------------ |\n| c.shrink_to_fit() | 请将capacity()减少为与size()相同大小                         |\n| c.capacity()      | 不重新分配内存空间的话,c可以保存多少元素                     |\n| c.reverse()       | 分配至少能容纳n个元素的内存空间。reverse并不改变容器中元素的数量，它仅影响vector预先分配多大的内存空间。调用reverse永远不减少容器占用的内存空间。 |\n\n**capcacity和size**:\n\n区别：\n\n容器的size是指它已经保存的元素的数目；\n\ncapcacity则是在不分配新的内存空间的前提下它最多可以保存多少元素。\n\n注意：只有当迫不得已时才可以分配新的内存空间。\n\n## 额外的string操作\n\n（1）构造string的其他方法\n\n| 构造string的其他方法      |                                            |\n| ------------------------- | ------------------------------------------ |\n| string s(cp, n)           | s是cp指向的数组中前n个字符的拷贝           |\n| string s(s2, pos2)        | s是string s2从下标pos2开始的字符的拷贝。   |\n| string s (s2, pos2, len2) | s是string s2从下标pos2开始len2个字符的拷贝 |\n\n**substr操作**:\n\nsubstr操作返回一个string，它是原始string的一部分或全部的拷贝。\n\ns.substr(pos, n)  返回一个string，包含s中从pos开始的n个字符的拷贝。pos的默认值为0。n的默认值为s.size() - pos， 即拷贝从pos开始的所有字符\n\n（2）改变string的其他方法\n\nassign  替换赋值，总是替换string中的所有内容\n\ninsert  插入\n\nappend 末尾插入，总是将新字符追加到string末尾\n\nreplace 删除再插入\n\n（3）string搜索操作\n\n| string搜索操作            |                                               |\n| ------------------------- | --------------------------------------------- |\n| s.find(args)              | 查找s中args第一次出现的位置                   |\n| s.rfind(args)             | 查找s中args最后一次出现的位置                 |\n| s.find_first_of(args)     | 在s中查找args中任何一个字符第一次出现的位置   |\n| s.find_last_of(args)      | 在s中查找args中任何一个字符最后一次出现的位置 |\n| s.find_first_not_of(args) | 在s中查找第一个不在args中的字符               |\n| s.find_last_not_of(args)  | 在s中查找最后一个不在args中的字符             |\n\n（4）compare函数\n\ncompare有6个版本，P327\n\n（5）数值转换\n\nP328\n\ntostring\n\nstod\n\n## 容器适配器\n\n顺序容器适配器：\n\nstack; queue; priority_queue;\n\n适配器是一种机制，能使某种事物看起来像另外一种事物。\n\n**定义一个适配器**:\n\n适配器有2个构造函数:\n\n> 1、默认构造函数创建一个空对象\n>\n> 2、接受一个容器的构造函数\n\n**栈适配器**:\n\n| 栈的操作        |                                                              |\n| --------------- | ------------------------------------------------------------ |\n| s.pop()         | 删除栈顶元素，但不返回该元素值                               |\n| s.push(item)    | 创建一个新元素压入栈顶，该元素通过拷贝或移动item而来，或者由args构造 |\n| s.emplace(args) | 由arg构造                                                    |\n| s.top()         | 返回栈顶元素，但不将元素弹出栈                               |\n\n**队列适配器**:\n\n| queue和priority_queue操作    |                                                              |\n| ---------------------------- | ------------------------------------------------------------ |\n| q.pop()                      | 返回queue的首元素或priority_queue的最高优先级的元素，但不删除此元素 |\n| q.front()          q.back()  | 返回首元素或尾元素，但不删除此元素。只适用于queue            |\n| q.top()                      | 返回最高优先级元素，但不删除该元素。只适用于priority_queue   |\n| q.push(item) q.empalce(args) | 在queue末尾或priority_queue中恰当的位置创建一个元素，其值为item,或者由args构造 |\n\n## 术语\n\nbegin容器操作：返回一个指向容器首元素的迭代器，如果容器为空，则返回尾后迭代器。是否返回const迭代器依赖于容器的类型。\n\ncbegin容器操作：返回一个指向容器尾元素之后的const_iterator。\n\n# 第十章 泛型算法\n\nP336-P371\n\n标准库并未给每个容器添加大量功能，而是提供了一组算法。这些算法是通用的，可以用于不同类型的容器和不同类型的元素。\n\n## 概述\n\n头文件：algorithm、numeric\n\n算法不依赖于容器，但算法依赖于元素类型的操作。\n\n## 初识泛型算法\n\n（1）只读算法\n\naccumulate  求和\n\nequal 是否相等\n\n（2）写容器元素的算法\n\n算法不检查写操作\n\n拷贝算法：copy\n\n重排容器元素的算法：sort\n\n::: tip\n\n标准库函数对迭代器而不是容器进行操作。因此，算法不能直接添加或删除元素\n\n:::\n\n## 定制操作\n\n标准库允许我们提供自己定义的操作来代替默认运算符。\n\n（1）向算法传递函数\n\n**谓词**:\n\n谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。\n\n> 标准库算法的谓词分为两类：\n>\n> 1、一元谓词：只接受单一参数。\n>\n> 2、二元谓词：接受两个参数。\n\n```\nbool isShorter(const string &s1, const string &s2)\n{\n\t\tretrun s1.size() < s2.size();\n}\n\nsort(words.begin(), words.end(), isShorter);\n```\n\n**排序算法**:\n\nstable_sort算法维持相等元素的原有顺序。\n\n（2）lambda表达式\n\n**lamba**:\n\nlambda表达式表示一个可调用的代码单元。一个lambda具有一个返回类型、一个参数列表和一个函数体。\n\n```\n[capture list](parameter list) -> return type {function body}\n// capture list 捕获列表，lambda所在函数中定义的局部变量\n// 捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字\n// lambda必须使用尾置返回来指定返回类型\n```\n\n（3）lambda捕获和返回\n\n两种：值捕获、引用捕获\n\n::: warnning\n\n当以引用方式捕获一个变量时，必须保证在lambda执行时变量是存在的。\n\n一般的，应该尽量减少捕获的数据量，来避免潜在的问题。\n\n如果可能，避免捕获指针或引用。\n\n:::\n\n**隐式捕获**：\n\n当混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个&或=。显式捕获的变量必须使用与隐式捕获不同的方式。\n\nlambda捕获列表 P352\n\n**可变lambda**:\n\n若希望改变一个被捕获的变量的值，必须在参数列表首加上关键字mutable。\n\n**指定lambda返回类型**:\n\n当需要为lambda定义返回类型时，必须使用尾置返回类型。\n\n（4）参数绑定\n\n**标准库bind函数**:\n\n```\nauto newCallable = bind(callable, arg_list);\n// 调用newCallable时，newCallable会调用callable,并传递给它arg_list中的参数\n```\n\n## 再探迭代器\n\n插入迭代器、流迭代器、反向迭代器、移动迭代器\n\n（1）插入迭代器\n\nback_inserter：创建一个使用push_back的迭代器\n\nfront_inserter：创建一个使用push_front的迭代器\n\ninserter：创建一个使用inserter的迭代器\n\n（2）iostream迭代器\n\nistream_iterator 读取输入流\n\nostream_iterator 向一个输出流写数据\n\n**istream_iterator操作**:\n\n| istream-iterator操作         |                                                              |\n| ---------------------------- | ------------------------------------------------------------ |\n| istream_iterator<T> in(is);  | in从输入流is读取类型为T的值                                  |\n| istream_iterator<T> end;     | 读取类型为T的值得istream_iterator迭代器，表示尾后位置        |\n| in1 == in2        in1 != in2 | in1和in2必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等 |\n| *in                          | 返回从流中读取的值                                           |\n| in->mem                      | 与(*in).mem含义相同                                          |\n| ++in, in++                   | 用>>从输入流读取下一个值                                     |\n\n**ostream_iterator操作**:\n\n| ostream_iterator操作            |                                                              |\n| ------------------------------- | ------------------------------------------------------------ |\n| ostream_iterator<T> out(os);    | out将类型为T的值写到输出流os中                               |\n| ostream_iterator<T> out(os, d); | out将类型为T的值写到输出流os中，每个值后面都输出一个d。d指向一个空字符串结尾的字符数组 |\n| out = val                       | 用<<将val写入到out所绑定的ostream中                          |\n| *out, ++out, out++              |                                                              |\n\n（3）反向迭代器\n\n反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。\n\n## 泛型算法结构\n\n| 迭代器类别     |                                      |\n| -------------- | ------------------------------------ |\n| 输入迭代器     | 只读、不写；单遍扫描，只能递增       |\n| 输出迭代器     | 只写，不读；单遍扫描，只能递增       |\n| 前向迭代器     | 可读写；多遍扫描，只能递增           |\n| 双向迭代器     | 可读写，多遍扫描，可递增递减         |\n| 随机访问迭代器 | 可读写，多遍扫描，支持全部迭代器运算 |\n\n## 特定容器算法\n\n对于list、forward_list，应该优先使用成员函数的算法而不是通用算法。\n\n## 术语\n\ncref标准库函数：返回一个可拷贝的对象，其中保存了一个指向不可拷贝类型的const对象的引用\n\n# 第十一章 关联容器\n\nP374-P397\n\n关联容器支持高效的关键字查找和访问。\n\n| 类型               | 备注                              |\n| ------------------ | --------------------------------- |\n| map                | 关联数组，保存关键字-值对         |\n| set                | 值保存关键字的容器                |\n| multimap           | 关键字可重复出现的map             |\n| multiset           | 关键字可重复出现的set             |\n| unordered_map      | 用哈希函数组织的map               |\n| unordered_set      | 用哈希函数组织的set               |\n| unordered_multimap | 哈希组织的map；关键字可以重复出现 |\n| unordered_multiset | 哈希组织的set；关键字可以重复出现 |\n\n## 使用关联容器\n\nmap是关键词-值对的集合。\n\n为了定义一个map，我们必须指定关键字和值的类型。\n\n```\n// 统计每个单词在输入中出现的次数\nmap<string, size_t> word_count;\nstring word;\nwhile (cin >> word)\n    ++word_count[word];\nfor (const auto &w : word_count)\n  \tcount << w.first << \" cccurs \" < w.second \n  \t\t\t\t<< ((w.second > 1) ? \" times\" : \"time\") << endl;\n```\n\nset是关键字的简单集合。\n\n为了定义一个set，必须指定其元素类型。\n\n```\n// 统计输入中每个单词出现的次数，并忽略常见单词\nmap<string, size_t> word_count;\nset<string> exclude = {\"the\", \"But\"};\nstring word;\nwhile (cin >> word)\n\t\t// 只统计不在exclude中的单词\n\t\tif (exclude.find(word) == exclude.end())\n\t\t\t\t++word_count[word]; //获取并递增word的计数器\n```\n\n## 关联容器概述\n\n（1）定义关联容器\n\n定义map时，必须指明关键字类型又指明值类型；\n\n定义set时，只需指明关键字类型。\n\n（2）pair类型\n\npair标准库类型定义在头文件utility中。\n\n一个pair保存两个数据成员。当创建一个pair时，必须提供两个类型名。\n\n```\npair<string, string> anon; // 保存两个string\npair<string, string> author{\"James\", \"Joyce\"}; // 也可为每个成员提供初始化器\n```\n\npair的数据类型是public的，两个成员分别命名为first和second。\n\npair上的操作，见表，P380\n\n## 关联容器操作\n\n| 关联容器额外的类型别名 |                                                              |\n| ---------------------- | ------------------------------------------------------------ |\n| key_type               | 此容器类型的关键字类型                                       |\n| mapped_type            | 每个关键字关联的类型，只适用于map                            |\n| value_type             | 对于set，与key_type相同；对于map，为pair<const key_type, mapped_type> |\n\n（1）关联容器迭代器\n\nset的迭代器是const的\n\nset和map的关键字都是const的\n\n**遍历关联容器**：\n\nmap和set都支持begin和end操作。使用beigin、end获取迭代器，然后用迭代器来遍历容器。\n\n（2）添加元素\n\n| 关联容器insert操作 |                          |\n| ------------------ | ------------------------ |\n| c.insert(v)        | v是value_type类型的对象; |\n| c.emplace(args)    | args用来构造一个元素     |\n| c.insert(b, e)     |                          |\n| c.insert(il)       |                          |\n| c.insert(p, v)     |                          |\n| c.emplace(p ,args) |                          |\n\n（3）删除元素\n\n| 从关联容器删除元素 |                                                              |\n| ------------------ | ------------------------------------------------------------ |\n| c.erase(k)         | 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除的元素的数量 |\n| c.erase(p)         | 从c中删除迭代器p指定的元素。p必须指向c中一个真实元素，不能等于c.end()。返回一个指向p之后元素的迭代器，若p指向c中的尾元素，则返回.end() |\n| c.erase(b, e)      | 删除迭代器b和e所表示的范围中的元素。返回e                    |\n\n（4）map的下标操作\n\n| map和unorder_map的下标操作 |                                                              |\n| -------------------------- | ------------------------------------------------------------ |\n| c[k]                       | 返回关键字为k的元素；如果k不在c中，添加一个关键字为k的元素，对其进行值初始化 |\n| c.at[k]                    | 访问关键字为k的元素，带参数检查；若k不在c中，抛出一个out_of_range异常 |\n\n::: tip\n\nmap进行下标操作，会获得mapped_type对象；当解引用时，会得到value_type对象。\n\n:::\n\n（5）访问元素\n\n```\nc.find(k)  // 返回一个迭代器，指向第一个关键字k的元素，如k不在容器中，则返回尾后迭代器\nc.count(k)  // 返回关键字等于k的元素的数量。对于不允许重复关键字的容器，返回值永远是0或1\nc.lower_bound(k)  // 返回一个迭代器，指向第一个关键字不小于k的元素;不适用于无序容器\nc.upper_bound(k)  // 返回一个迭代器，指向第一个关键字大于k的元素；不适用于无序容器\nc.equal_bound(k)  // 返回一个迭代器pair，表示关键字等于k的元素的范围。如k不存在，pair的两个成员均等于c.end()\n```\n\n## 无序容器\n\n无序容器使用关键字类型的==运算符和一个hash<key_type>类型的对象来组织元素。\n\n无序容器在存储上组织为一组桶，适用一个哈希函数将元素映射到桶。\n\n无序容器管理操作，表格，P395\n\n还可以自定义自己的hash模板 P396\n\n```\nusing SD_multiset = unordered_multiset<Sales_data, decltype(hasher)*, decltype(eqOp)*>;\nSD_multiset bookStore(42, haser, eqOp);\n```\n\n# 第十二章 动态内存\n\nP400-P436\n\n## 动态指针与智能指针\n\n| 智能指针   | 用途                                                         |\n| ---------- | ------------------------------------------------------------ |\n| shared_ptr | 提供所有权共享的智能指针：对共享对象来说，当最后一个指向它的shared_ptr被销毁时会被释放。 |\n| unique_ptr | 提供独享所有权的智能指针：当unique_ptr被销毁的时，它指向的独享被释放。unique_ptr不能直接拷贝或赋值。 |\n| weak_ptr   | 一种智能指针，指向由shared_ptr管理的对象。在确定是否应释放对象视，shared_ptr并不把weak_ptr统计在内。 |\n\n（1）shared_ptr类\n\n```\nshared_ptr<string> p1;\n```\n\n**make_shared函数**:\n\nmake_shared在动态内存中分配一个对象并初始化它，返回此对象的shared_ptr。\n\n```\nshare_ptr<int> p3 = make_shared<int>(42);\n```\n\n**shared_ptr的拷贝和赋值**:\n\n每个shared_ptr都有一个关联的计数器，称为引用计数。一旦一个shared_ptr的引用计数变为0，就会自动释放自己所管理的对象。\n\n（2）直接管理内存\n\n运算符new分配分配内存，delete释放new分配的内存。\n\n**使用new动态分配和初始化对象**:\n\n```\n// 默认情况下，动态分配的对象是默认初始化的\nint *pi = new int; // pi指向一个动态分配的、未初始化的无名对象\n// 直接初始化方式\nint *pi = new int(1024); // pi指向的对象的值为1024\n// 对动态分配的对象进行值初始化，只需在类型名之后加上一对空括号\nint *pi1 = new int;   // 默认值初始化；*pi1的值未定义\nint *pi2 = new int(); // 值初始化为0；*pi2为0\n```\n\n**动态分配的const对象**:\n\n```\nconst int *pci = new const int(1024);\n```\n\n**释放动态内存**:\n\n```\ndelete p;\n```\n\ndelete表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存。\n\n（3）unique_ptr\n\n某个时刻，只能有一个unique_ptr指向一个给定对象。\n\n当unique_ptr销毁时，它所指向的对象也被销毁。\n\n| unique_ptr操作        |\n| --------------------- |\n| unique_ptr<T> u1      |\n| unique_ptr<T, D> u2   |\n| unique_ptr<T, D> u(d) |\n| u = nullptr           |\n| u.release()           |\n| u.reset()             |\n| u.reset(p)            |\n| u.reset(nullptr)      |\n\n（4）weak_ptr\n\nweak+ptr是一种不受控制所指向对象生存期的智能指针，它指向由一个shared_ptr管理的对象，而且不会改变shared_ptr的引用计数。\n\n| weak_ptr 操作     |                               |\n| ----------------- | ----------------------------- |\n| weak_ptr<T> w     |                               |\n| weak_ptr<T> w(sp) |                               |\n| w = p             |                               |\n| w.reset()         | 将w置空                       |\n| w.use_count()     | 与w共享对象的shared_ptr的数量 |\n| w.expired()       |                               |\n| w.lock()          |                               |\n\n使用weak_ptr之前，需要调用lock，检查weak_ptr指向的对象是否存在。\n\n## 动态数组\n\n（1）new和数组\n\n在类型名之后跟一对方括号，在其中指明要分配的对象的数目。\n\n释放动态数组：\n\n```\ndelete p;      // p必须指向一个动态分配的对象或为空\ndelete [] pa;  // pa必须指向一个动态分配的数组或为空\n```\n\n智能指针和动态数组\n\n```\nunique_ptr<T []> u;\nunique_ptr<T []> u(p);\nu[i];\n```\n\n（2）allocator类\n\n标准库allocator类定义在头文件memory中，帮助将内存和对象构造分离开来。\n\n```\nallocator<string> alloc;\nauto const p = alloc.allocate(n);\n```\n\n| 表达式               | 作用                                                         |\n| -------------------- | ------------------------------------------------------------ |\n| allocator[T] a       | 定义了一个名为a的allocator对象，它可以为类型为T的对象分配内存 |\n| a.allocate(n)        | 分配一段原始的、未构造的内存，保存n个类型为T的对象           |\n| a.construct(p, args) | 为了使用allocate返回的内存，我们必须使用construct构造对象。使用未构造的内存，其行为是未定义的。 |\n| a.destroy(p)         | p为T*类型的指针，此算法对p指向的对象执行析构函数             |\n\n## 术语\n\n*new* : 从自由空间分配内存。new T 分配并构造一个类型为T的指针。如果T是一个数组类型，new 返回一个指向数组首元素的指针。类似的，new  [n]  T 分配 n 个类型为T的对象，并返回指向数组首元素的指针。\n\n*空悬指针*：一个指针，指向曾经保存一个对象但现在已释放的内存。\n\n*智能指针*：标准库类型。负责在恰当的时候释放内存。\n\n# 第十三章 拷贝控制\n\nP440-P486\n\n五种拷贝控制操作：\n\n拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符、析构函数。\n\n拷贝构造函数、移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。\n\n拷贝赋值运算符、移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。\n\n析构函数定义了当此类型对象销毁时做什么。\n\n## 拷贝、赋值与销毁\n\n（1）拷贝构造函数\n\n拷贝构造函数的第一个参数必须是一个引用类型。\n\n```\nclass Foo {\npublic :\n\tFoo(); // 默认构造函数\n\tFoo(const Foo&); // 拷贝构造函数\n}\n```\n\n**合成拷贝构造函数**:\n\n若未定义拷贝构造函数，编译器会定义一个。\n\n**拷贝初始化**:\n\n拷贝初始化，要求编译器将右运算对象拷贝到正在创建的对象中。拷贝初始化通常使用拷贝构造函数来完成。\n\n（2）拷贝赋值运算符\n\n重载赋值运算符：oprator=\n\n合成拷贝赋值运算符：若一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。\n\n（3）析构函数\n\n析构函数：用于释放对象使用的资源，销毁对象的非static数据成员。\n\n```\nclass Foo {\npublic:\n\t~Foo(); // 析构函数，一个类只会有唯一一个析构函数。\n}\n```\n\n在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。销毁类类型的成员需要执行成员自己的析构函数。\n\n**合成析构函数**：当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。\n\n析构函数体本身并不直接销毁成员。\n\n（4）三五法则\n\nP447\n\n需要析构函数的类也需要拷贝和赋值操作\n\n需要拷贝操作的类也需要赋值操作，反之亦然\n\n（5）使用default=\n\n将拷贝控制成员定义为=dafault来显式地要求编译器生活才能合成的版本。\n\n```\nclass Sales_data {\npublic:\n\t\tSales_data(const Sales_data&) = default;\n}\n```\n\n（6）阻止拷贝\n\n在函数参数列表后面加上=delete。\n\n=delete必须出现在函数第一次声明的时候。\n\n析构函数不能是删除的成员\n\n**合成的拷贝控制成员可能是删除的**:\n\n如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。\n\n## 拷贝控制和资源管理\n\n（1）行为像值的类\n\n为了提供类值的行为，对于类管理的对象，每个对象都应该拥有一份自己的拷贝。\n\n**类值拷贝赋值运算符**:通常组合了析构函数和构造函数的操作。\n\n```\nHasPtr& HasPtr::operator=(const HasPtr &rhs)\n{\n\tauto newp = new string(*rhs.ps);\n\tdelete ps;\n\tps = newp;\n\ti = rhs.i;\n\treturn *this;\n}\n```\n\n（2）行为像指针的类\n\n如果需要可直接管理资源，可以使用引用计数。\n\n## 交换操作\n\nswap\n\n## 拷贝控制示例\n\nP460\n\n## 动态内存管理类\n\nP464\n\n## 对象移动\n\n与任何赋值运算符一样，移动赋值运算符必须销毁左侧运算对象的旧状态。\n\n（1）右值引用\n\n可通过move函数开获得绑定到左值上的右值引用。\n\n```\nint && rr3 = std::move(rr1);\n```\n\n（2）移动构造函数和移动赋值运算符\n\n移动构造函数的第一个参数是该类类型的一个右值引用。\n\n**移动赋值运算符**:\n\n```\nStrVec &StrVec::operator=(StrVec &&rhs) noexcept\n{\n\n}\n```\n\n**合成的移动操作**：\n\n若一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。\n\n如果一个类没有移动操作，类会使用对应的拷贝操作来代替移动操作。\n\n**移动迭代器**:\n\n移动迭代器的解引用运算符生成一个右值引用。\n\n（3）右值引用和成员函数\n\n::: tip\n\n区分移动和拷贝的重载函数通常有一个版本接受一个const T&，而另一个版本接受一个T&&。\n\n:::\n\n**右值和左值引用成员函数**:\n\n指出this的左值/右值属性的方式与定义const成员函数相同，在参数列表后放置一个引用限定符。P483\n\n::: tip\n\n如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。P485\n\n:::\n\n## 术语\n\n**引用限定符**：被&限定的函数只能用于坐值；被&&限定的函数只能用于右值。\n\n# 第十四章 重载运算与类型转换\n\nP490-P523\n\n通过运算符重载可重新定义该运算符的含义。\n\n## 基本概念\n\n**定义**：重载运算符是具有特殊名字的函数。名字由operator和符号组成。重载运算符包含返回类型、参数列表和函数体。\n\n::: tip\n\n当一个重载的运算符是成员函数时，this绑定到左侧运算对象。成员运算符函数的显式参数数量比运算对象的数量少一个。\n\n对于一个运算符来说，它或者是类的成员，或者至少含有一个类类型的参数。\n\n我们只能重载已有的运算符。\n\n:::\n\n**直接调用一个重载的运算符函数**\n\n```\ndata1 + data2;\noperator+(data1, data2);\n// 以上2个调用等价\n```\n\n## 输入和输出运算符  \n\n（1）重载输出运算符<<\n\n```\nostream &operator<<(ostream &os, const Sales_data &item)\n{\n\tos << item.isbn() << \" \" << item.unites_sold << \" \" << item.revenue << \" \" << item.avg_price();\n\treturn os;\n}\n```\n\n（2）重载输入运算符>>\n\n```\nistream &operator>>(istream &is, Sales_data &item)\n{\n\tdouble price;\n\tis >> item.bookNo >> item.units_sold >> price;\n\tif (is)\n\t\titem.revenue = items.units_sold * price;\n\telse\n\t\titem = Sales_data();\n\treturn is;\n}\n```\n\n## 算术和关系运算符\n\n（1）相等运算符\n\n```\nbool operator==(const Sales_data &lhs, const Sales_data &rhs)\n{\n\treturn lhs.isbn() == rhs.isbn() &&\n\t\t\tlhs.unites_sold == rhs.units_sold &&\n\t\t\tlhs.revenue == rhs.revenue;\n}\n```\n\n（2）关系运算符\n\noperator<\n\n## 赋值运算符\n\noperator=\n\noperator+=\n\n## 下标运算符\n\noperator[]\n\n下标运算符必须是成员函数。\n\n```\nclass StrVec{\npublic:\n\tstd::string& operator[](std::size_t n){\n\t\treturn elements[n];\n\t}\n\tconst std::string& operator[](std::size_t n) const{\n\t\treturn elements[n];\n\t}\nprivate:\n\tstd::string *elements;\n}\n```\n\n## 递减和递增运算符\n\n递增运算符（++）\n\n递减运算符（--）\n\n**定义前置递增/递减运算符**:\n\n```\nclass StrBlobPtr{\npublic:\n\tStrBlobPtr& operator++();  // 前置运算符\n\tStrBlobPtr& operator--();\n}\n```\n\n**区分前置和后置运算符**:\n\n```\nclass StrBlobPtr{\npublic:\n\tStrBlobPtr operator++(int); // 后置运算符\n\tStrBlobPtr operator--(int);\n}\n```\n\n## 成员访问运算符\n\noperator*\n\noperator->\n\n## 函数调用运算符\n\n如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。\n\n```\nstruct absInt{\n\tint operator()(int val) const {\n\t\treturn val < 0 ? -val : val;\n\t}\n};\n\nabsInt absObj;\nint ui = absObj(i);\n```\n\n如果定义了调用运算符，则该类的对象称为函数对象。\n\n## 重载、类型转换与运算符\n\n（1）类型转换运算符\n\n类型转换运算符是类的一种特殊成员函数，将一个类类型的值转换成其他类型。形式：\n\noperator type() const;\n\n（2）避免有二义性的类型转换\n\n（3）函数匹配与重载运算符\n\n::: warning\n\n如果对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，将会遇到重载运算符与内置运算符的二义性问题。\n\n:::\n\n## 术语\n\n**类类型转换**:由构造函数定义的从其他类型到类类型的转换以及由类型转换运算符定义的从类类型到其他类型的转换。\n\n# 第十五章 面向对象程序设计\n\nP526-P575\n\n## OOP:概述\n\n（1）**面对对象程序设计（object-oriented programming）的核心思想**：\n\n数据抽象、继承和动态绑定。\n\n（2）**继承**：\n\n> 继承是一种类联系在一起的一种层次关系。这种关系中，根部是*基类*，从基类继承而来的类成为*派生类*。\n\n基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。\n\n虚函数：virtual function。基类希望派生类各自定义自身版本的函数。\n\n```\nclass Quote {\npublic:\n\t\tstd::string isbn() const;\n\t\tvirtual double net_price(std::size_t n) const;\n}\n```\n\n（3）**动态绑定**：\n\n::: tip\n\n在C++语言中，当我们使用基类的引用（或者指针）调用一个虚函数时将发生动态绑定（也称*运行时绑定*）。P527\n\n:::\n\n## 定义基类和派生类\n\n（1）定义基类\n\n虚函数：基类希望派生类进行覆盖的函数。\n\n> 基类将该函数定义为虚函数（virtual）。\n\n> 基类通过在其成员函数的声明语句之前加上关键词virtual使得该函数执行动态绑定。\n\n> 关键词virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。\n\n> 如果基类把一个函数声明成虚函数，则该函数在派生类中隐式的也是虚函数。\n\n（2）定义派生类\n\n派生类必须通过派生类列表明确指出它是从哪个基类继承而来的。\n\n```\nclass Bulk_quote : public Quote {\n... // 省略\n}\n```\n\n对于派生类中的虚函数的处理：\n\n若派生类未覆盖基类中的虚函数，则该虚函数的行为类似其他普通成员。\n\nC++允许派生类显式注明覆盖了基类的虚函数，可通过添加override关键字。\n\n**派生类对象**:\n\n一个派生类对象包含多个部分：自己定义的成员的子对象，以及基类的子对象。\n\n**派生到基类的类型转换**：\n\n由于派生类对象中含有与其基类对象的组成部分，因此可以进行隐式的执行派生类到基类的转换。\n\n```\nQuote item;        // 基类\nBulk_quote bulk;   // 派生类\nQuote *p = &item;  // p指向Quote对象\np = &bulk;         // p指向bulk的Quote部分\nQuote &r = bulk;   // r绑定到bulk的Quote部分。\n```\n\n**派生类构造函数**：\n\n每个类控制自己的成员的初始化过程。派生类首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。\n\n**派生类使用基类的成员**：\n\n派生类可以访问基类的公有成员和受保护成员。\n\n::: tip\n\n派生类对象不能直接初始化基类的成员。派生类应该遵循基类的借口，通过调用基类的构造函数来初始化从基类继承来的成员。\n\n:::\n\n**被用作基类的类**:\n\n若使用某个类作为基类，则该类必须已被定义而非仅仅声明。\n\n派生类包含它的直接基类的子对象以及每个间接基类的子对象。\n\n**防止继承发生**:\n\n在类名后面跟着一个关键字final。\n\n```\nclass NoDerived final {};   // NoDerived不能作为基类\n```\n\n（3）类型转换与继承\n\n我们可以将基类的指针或引用绑定到派生类对象上。\n\n**静态类型与动态类型**:\n\n静态类型：在编译时已知，是变量声明时的类型或表达式生成的类型。\n\n动态类型：运行时才可知，是变量或表达式表示的内存中的对象的类型。\n\n如果表达式既不是引用也不是指针，则动态类型与静态类型永远一致。\n\n**不存在基类向派生类隐式类型转换**:\n\n```\nQuote base;\nBulk_quote *bulkP = &base;    // 错误!\nBulk_quote *bulkRef = base;   // 错误!\n```\n\n::: warning\n\n当我么用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分会被忽略掉。\n\n:::\n\n## 虚函数\n\n**C++的多态性**：使用这些类型的多种形式，而无须在意它们的差异。\n\n**派生类中的虚函数**:\n\n一个派生类如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。\n\n**final和override说明符**:\n\n如果用override标记了某个函数，但是该函数并没有覆盖已存在的虚函数，此时编译器将报错。\n\n如果用final标记了某个函数， 则之后任何尝试覆盖该函数的操作都将错误。\n\n**虚函数与默认实参**：\n\n如果虚函数某次被调用使用了默认实参，则该实参值由本次调用的静态类型决定。\n\n## 抽象基类\n\n**纯虚函数**:\n\n书写=0可以将一个虚函数说明为纯虚函数（pure virtual），纯虚函数无须定义。\n\n不能在类的内部为一个=0的函数提供函数体。\n\n```\nclass Disc_quote : public Quote {\npublic:\n\t\tdouble net_price(std::size_t) const = 0;\n}\n```\n\n**抽象基类**：\n\n含有纯虚函数的类是抽象基类。\n\n不能创建抽象基类的对象。\n\n## 访问控制与继承\n\n**受保护的成员**:\n\n派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。P543\n\n**公有、私有和受保护继承**：\n\n派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员无影响；\n\n对基类成员的访问权限只与基类中的访问说明符有关。\n\n派生访问说明符的目的是控制派生类用户对于基类成员的访问权限。\n\n**改变个别成员的可访问性**:\n\n通过在类的内部使用using声明语句，我们可以将该类的直接或间接基类中的任何可访问成员标记出来。\n\n```\nclass Derived : private Base {\npublic:\n\t\tusing Base::size;\n}\n```\n\n::: tip\n\n派生类只能为它可访问的名字提供using声明。\n\n:::\n\n**默认的继承保护级别**:\n\n使用class关键字定义的派生类是私有继承的；\n\n使用struct关键字定义的派生类是共有继承的。\n\n```\nclass Base {};\nstruct D1 : Base {};  // 默认public继承\nclass D2 : Base {};   // 默认private继承\n```\n\n## 继承中的类作用域\n\n**在编译时进行名字查找**:\n\n一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。\n\n**名字冲突与继承**:\n\n派生类的成员将隐藏同名的基类成员。\n\n::: tip\n\n出了覆盖继承而来的虚函数外，派生类最好不雅重用其他定义在基类中的名字。\n\n:::\n\n如果派生类的成员函数与基类的某个成员函数同名，则派生类将在其作用域内隐藏掉该基类成员函数。\n\n::: tip\n\n非虚函数不会发生动态绑定。\n\n:::\n\n## 构造函数与拷贝控制\n\n（1）虚析构函数\n\n在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。\n\n```\nQuote *itemP = new Quote;\ndelete itemP;           // 调用Quote的析构函数\nitemP = new Bulk_quote;\ndelete itemP;           // 调用Bulk_quote的析构函数\n```\n\n虚析构函数会阻止合成移动操作。\n\n（2）合成拷贝控制与继承\n\n基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当确实要执行移动操作的时候就要首先在基类中进行显式定义。P554\n\n（3）派生类的拷贝控制成员\n\n**派生类的拷贝或移动构造函数**:\n\n::: tip\n\n默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式的使用基类的拷贝（或移动）构造函数。\n\n:::\n\n**派生类的赋值运算符**:\n\n派生类的赋值运算符必须显式的为其基类部分赋值。\n\n**派生类的析构函数**:\n\n派生类函数只负责销毁由派生类自己分配的资源。\n\n## 容器与继承\n\n当使用容器存放继承体系中的对象时，必须采用间接存储的方式。因为不允许在容器中保存不同类型的元素。\n\n## 术语\n\n覆盖：override，派生类中定义的虚函数如果与基类中定义的同名虚函数与相同的形参列表，则派生类版本将覆盖基类的版本。\n\n多态：程序能够通引用或指针的动态类型获取类型特定行为的能力。\n\n# 第十六章 模板与泛型编程\n\nP578-P630\n\n（1）控制实例化\n\n当编译器遇到extern模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为extern就表示承诺在程序其他位置有该实例化的一个非extern声明（定义）。对于一个给定的实例化版本，可能有多个extern声明，但必须只有一个定义。\n\n（2）模板是标准库的基础。\n\n生成特定类或者函数的过程称为实例化。\n\n（3）术语\n\n类模板：模板定义，可从它实例化出特定的类。类模板的定义以关键词template开始，后面跟尖括号对<和>，其内为一个用逗号分隔的一个或多个模板参数的列表，随后是类的定义。\n\n函数模板：模板定义，可从它实例化出特定函数。函数模板的定义以关键词template开始，后跟尖括号<和>，其内以一个用逗号分隔的一个或多个模板参数的列表，随后是函数的定义。\n\n","categories":["Cpp 学习"]},{"title":"C++ 20 高级编程","url":"/posts/dc6df7d2.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 第一章 C++和标准库速成\n\n## C++速成\n\n### 小程序\"Hello World\"\n\n主要是接触引入模块的概念，程序如下：\n\n~~~cpp\n// hello.cpp\nimport <iostream>;  // 引入模块，目前的gcc不支持\n// #include <iostream>\n\nint main() {\n    std::cout << \"hello world\" << std::endl;\n\n    return 0;\n}\n~~~\n\n<!-- more -->\n\n但是由于目前的`gcc`不支持引入模块，所以会报错，我们可以尝试一下，输入如下命令：\n\n其中`-fmodules-ts`表示开启模块支持\n\n~~~bash\ng++ hello.cpp -std=c++20 -fmodules-ts\n~~~\n\n但是很遗憾，目前的`gcc`不支持，所以会报错：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231115171602184.png\" alt=\"image-20231115171602184\" style=\"zoom: 67%;\" />\n\n引入模块确实是个不错的选择，后续`C++`可能就会有自己的包管理器了，`C++是世界上最好的语言.py`\n\n这里我们替换为头文件即可\n\n### 关于模块和头文件\n\n在引入模块之前，`C++`对于封装通常是函数的声明放在`.h`文件中，函数的定义(实现)放在`.cpp`文件中，这样进行管理；但是有了模块之后，就不需要进行声明和定义的分离了(但是现在我的编译器不支持我还没办法看到实例...)\n\n关于在`C++`中使用`C`标准库的头文件，注意：\n\n- 不适用`.h`后缀，而改为前缀`c`，例如`< stdio.h >`改为使用`< cstdio >`\n\n  为什么呢？在`C++`中所有的头文件的内容都是放在标准的命名空间`std`当中的，这样做是为了防止用户的命名和系统的命名发生冲突，同时也是对标准库的封装做了隔离和保护，使用`c`开头的头文件，这些内容都是在`std`中的，而`.h`就没有\n\n- `import`引入模块可能并不支持`C`标准的头文件，所以还是先用`#include`吧\n\n### 一些预处理命令\n\n如下，主要就`#include`，`#define`，`#ifdef`，`#ifndef`，`#endif`，`#pragma`这几个\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231115172651618.png\" alt=\"image-20231115172651618\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231115172659405.png\" alt=\"image-20231115172659405\" style=\"zoom:67%;\" />\n\n# 后续\n\nTODO\n\n","categories":["Cpp 学习"]},{"title":"UNIX 环境高级编程","url":"/posts/6fbfe9af.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 第一章 UNIX基础知识\n\n## UNIX体系结构\n\n操作系统是计算机裸机上的第一个软件，他控制计算机硬件资源，提供程序运行环境，通常我们称之为**内核**\n\n以下是UNIX系统的体系结构图：\n\n![image-20230827151538210](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827151538210.png)\n\n<!-- more -->\n\n内核的接口被称为**系统调用**，公共函数库，比如C语言的C runtime library就是依托在操作系统提供的API上的，这导致C语言的标准库能够完美适配各种系统，我们的程序既可以使用公共函数库，也可以使用操作系统的API，也就是系统调用\n\nshell，也就是我们常用的终端，就是一个特殊的程序，它可以在里面调用其他应用程序，也就是启动其他进程\n\n## shell\n\n上面说到，shell终端是一个特殊的程序，的确；用户登录之后，通常先显示一些系统信息，接着用户就可以向shell输入命令了；也就是说，shell是一个命令行解释器，他读取用户的输入，然后就可以执行相关的操作命令；shell的用户输入可以来自用户在终端命令行的输入，也可以来自shell脚本，我们可以把需要执行的shell命令写成一个文件交给shell终端去读取然后执行\n\n例如，这是我的shell终端截图：\n\n![image-20230827153122412](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827153122412.png)\n\n不同的Linux系统一般默认使用不同的shell，但是 POSIX 1003.2 标准对shell进行了标准化\n\n以下是一些UNIX系统中常见的shell：\n\n![image-20230827152956059](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827152956059.png)\n\n## 文件和目录\n\n### 文件系统\n\n我们打开一个shell终端，他的默认路径是 **~** 符号表示的，如图：\n\n![image-20230827153213499](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827153213499.png)\n\n这不是我们的根目录，浏览文件目录之后发现这是我们的 home 目录下的用户目录：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230827153303414.png\" alt=\"image-20230827153303414\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230827153312742.png\" alt=\"image-20230827153312742\" style=\"zoom:67%;\" />\n\n也就是说，我们 ~ 目录对应的实际上是 /home/lzx0626 目录在这里\n\n好，我们现在来看一下根目录，根目录的名称是字符 **/**，我们切换过去：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230827153445254.png\" alt=\"image-20230827153445254\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230827153453150.png\" alt=\"image-20230827153453150\" style=\"zoom:67%;\" />\n\n**目录项的逻辑视图(就是如图)和实际上在硬盘上的存放方式是不同的**，这一点我们后面细谈\n\n### 文件名\n\n**文件名字在命名的时候，斜线 ( / ) 和空字符 ( 注意不是空格 ) 不能出现在文件名当中，斜线用来区分路径，空字符用来终止一个路径名**\n\n**创建新目录的时候会自动创建两个文件名，就是 . 和 .. ，. (点)用来指向当前目录， .. (点点)用来指向上级目录；在最高等级的根目录当中，这两个相同。以下是一个空目录中的例子：**\n\n![image-20230827154133983](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827154133983.png)\n\n### 路径名\n\n路径名分为绝对路径和相对路径，绝对路径以根目录为起始，也就是以 / 斜线开头，因为斜线 / 是根目录的路径，不以斜线 / 开头的就是相对路径，基准路径是当前路径的文件；文件系统根的名字( / )是一个特殊的绝对路径名，它不包含文件名\n\n#### <span id='ls -l'>例子</span>\n\n模拟实现 ls 命令，就是列出目录当中的所有文件名\n\n需要用到 `opendir`()，`readdir`()，`closedir`() 函数，来读取，他们的功能可以类比读取文件的操作，只不过这里是操作目录的路径\n\n~~~cpp\n//打开目录\n#include <dirent.h>\n#include <sys/types.h>\nDIR *opendir(const char *name);\n//参数：\n    //name：需要打开的目录的名称\n//返回值：\n    //DIR * 类型，理解为目录流，对比打开文件返回文件描述符，这个返回的是一个目录流指针\n    //错误 返回nullptr\n\n//读取目录中的数据\n#include <dirent.h>\nstruct dirent *readdir(DIR *dirp);\n//参数：\n    //dirp是通过opendir返回的结果\n//返回值：\n    //struct dirent 代表读取到的文件的信息\n    //读取到了文件末尾或者失败了，返回Null，区别是读到文件末尾不会修改errno，失败会修改\n\t//一次只能读取一个文件的信息，读取一个目录最好循环读取\n\n//关闭目录\n#include <dirent.h>\nint closedir(DIR *dirp);\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <dirent.h>\n\nint main(int argc, char const *argv[]) {\n    if (argc < 2) {\n        printf(\"usage : %s  <pathname>\\n\", argv[0]);\n        return -1;\n    }\n\n    // 打开文件目录\n    const char *pathname = argv[1];\n\n    DIR *_dir = opendir(pathname);\n    if (nullptr == _dir) {\n        perror(\"opendir\");\n        return -1;\n    }\n\n    // 开始循环读取，因为一次只能读一个\n    while (1) {\n        struct dirent *_dirent = readdir(_dir);\n        if (nullptr == _dirent)\n            break;\n\n        cout << _dirent->d_name << '\\t';\n    }\n\n    // 关闭文件目录\n    closedir(_dir);\n\n    cout << endl;\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230827162316877](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827162316877.png)\n\n注意一个有趣的地方，我们程序读取文件信息的顺序排列不是按照字母顺序排列的，但是ls命令一般是按照字母顺序排列的，例如：\n\n![image-20230827162546548](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827162546548.png)\n\n## 输入和输出\n\n### 文件描述符\n\n文件描述符(file descriptor)是一个小的非负整数，内核用以标识一个进程访问的文件；当内核打开或者创建一个文件的时候，都返回文件描述符；在我们相对文件读写的时候都可以使用这个文件描述符\n\n### 标准输入，标准输出和标准错误\n\n**我们一个进程分为用户区和内核区，在内核区中有一张文件描述表，注意是每个进程都具有自己的内核区，进程之间互不干涉，因此我用两个程序打开同一个文件返回的文件描述符没有其他特殊情况应该是同一个值，都应该是3；我们的进程默认 标准输入 STDIN_FILENO 是0；标准输出 STDOUT_FILENO 是1；标准错误 STDERR_FILENO 是2；**这三个文件描述符默认是定向到终端的，我们的shell命令中可以使用 > 可以让他重定向到文件当中，例如如下：\n\n![image-20230827164726247](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827164726247.png)\n\n现在我打开 a.txt：\n\n![image-20230827164746803](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827164746803.png)\n\n### 不带缓冲的`I/O`\n\n取名为不带缓冲的`I/O`，并不是指数据的传递过程当中不存在缓冲区，当然存在缓冲机制，但是这里的不带缓冲特指的是进程不提供缓冲区，也就是在用户区没有缓冲机制，但是内核还是提供缓冲的，因为我们的文件描述符对应的就是读写缓冲区，这个是在内核当中的\n\n**因此不带缓冲的概念要弄明白了：所谓不带缓冲，并不是指内核不提供缓冲，而是只单纯的系统调用，不是函数库的调用。**\n\n系统调用就比如我们Linux下的read()和write()函数，函数库的调用就比如C标准库当中的fread()和fwrite()函数，下面我们具体聊一聊他们的工作机制：\n\n- 系统内核对磁盘的读写都会提供一个块缓冲（在有些地方也被称为内核高速缓存），当用write函数对其写数据时，直接调用系统调用，将数据写入到块缓冲进行排队，当块缓冲达到一定的量时，才会把数据写入磁盘。因此所谓的不带缓冲的`I/O`是指进程不提供缓冲功能（但内核还是提供缓冲的）。每调用一次write或read函数，直接系统调用。\n- 而带缓冲的`I/O`是指进程对输入输出流进行了改进，提供了一个流缓冲，当用fwrite函数网磁盘写数据时，先把数据写入流缓冲区中，当达到一定条件，比如流缓冲区满了，或刷新流缓冲，这时候才会把数据一次送往内核提供的块缓冲，再经块缓冲写入磁盘。（双重缓冲）。因此，带缓冲的`I/O`在往磁盘写入相同的数据量时，会比不带缓冲的`I/O`调用系统调用的次数要少。\n\n比如我们Linux系统提供的API：open，read，write，lseek，close都是不带缓冲的`I/O`，并且对应的都是内核区的文件描述符\n\n#### 例子\n\n我们从标准输入读取数据，然后将其原封不动的输出到屏幕上，这里就使用了 STDIN_FILENO 和 STDOUT_FILENO 的固定文件描述符\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n\nint main() {\n    char buf[MAX_BUFFER_SIZE] = {0};\n\n    while (1) {\n        bzero(buf, sizeof(buf));\n\n        int len = read(STDIN_FILENO, buf, sizeof(buf) - 1);\n        if (-1 == len) {\n            perror(\"read\");\n            return -1;\n        }\n\n        if (0 == len)  // 读取到末尾\n            break;\n\n        write(STDOUT_FILENO, buf, strlen(buf));\n    }\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n标准输入是用回车符 '\\n' 来判断是否结束输入的\n\n![image-20230827182021232](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827182021232.png)\n\n#### 扩展\n\n我们用过这个例子玩一些花活，比如使用shell命令重定向该进程的标准输入和标准输出\n\n例如，我可以将标准输出定向到文件当中，使用命令\n\n~~~bash\n./a.out > 02.txt\n~~~\n\n这个时候该进程的标准输入和标准错误还是定向到终端的，但是标准输出重定向到这个文件中了，如果这个文件不存在，那么会将其创建出来\n\n![image-20230827182352781](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827182352781.png)\n\n我们可以看一下这个文件的内容\n\n![image-20230827182523353](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827182523353.png)\n\n或者，我们可以把标准输入也给重定向一下，刚才标准输出用的是 > ，类比一下标准输入应该用的是 <\n\n~~~bash\n./a.out < 02_src.txt > 02_dest.txt\n~~~\n\n执行结果：\n\n可以看出实现了这个需求\n\n![image-20230827182917510](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827182917510.png)\n\n### 标准`I/O`\n\n标准`I/O`就是指的是在系统提供的API基础上进行封装之后给我们用户使用的函数库，比较典型的就是C语言的c runtime library，里面的很多函数都和Linux下的系统API非常类似，但是他们的参数和返回值有所区别，具体可以查询man文档；例如，Linux下读写操作使用的是read()和write()接口，在C标准库当中对应的是fread()和fwrite()\n\n标准`I/O`和不带缓冲的`I/O`的巨大区别就在于标准`I/O`在用户区提供了供`I/O`操作的缓冲区，而不带缓冲的`I/O`对应系统调用则没有，只有内核区的缓冲；**使用标准`I/O`的函数有一个好处就是我们可以不用考虑如何选取缓冲区的最佳大小，例如我们read()需要给出buf数组的大小，他帮我们做了更多的事情**\n\n典型的标准`I/O`函数就是printf()和scanf()函数，这里我们用getc()和putc()每次读写一个字符的函数举例\n\n#### 例子\n\n我们读键盘的字符然后输出到屏幕上\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    while (1) {\n        int c = getc(stdin);\n        if (EOF == c)  // getc()读取完毕的标志是EOF\n            break;\n        putc(c, stdout);\n    }\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230827184247517](https://cdn.davidingplus.cn/images/2025/01/31/image-20230827184247517.png)\n\n同样，可以用shell命令进行一些重定向的操作，这里就不写了\n\n## 程序和进程\n\n### 程序\n\n程序是在磁盘上某个目录当中的可执行文件；内核调用exec函数族，可以将这个程序读入内存，然后执行程序\n\nexec函数族一般有下面这几个\n\n![image-20230718154816547](https://cdn.davidingplus.cn/images/2025/02/01/image-20230718154816547.png)\n\n### 进程和进程ID\n\n程序是死的，他需要被读进内存才会变成进程，UNIX系统给每个进程都有一个独立的编号，就是进程号，或者叫进程ID，他总是一个非负整数。Linux操作系统的第一个进程是init进程，其他的所有进程都是这个进程创建或者这个进程的子孙进程创建出来的\n\n我们可以用 ps aux 来查看我们操作系统中的进程状态\n\n我们可以看到第一个进程就是 init ，他的进程号是1\n\n![image-20230828105813917](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828105813917.png)\n\n### 进程控制\n\n有三个用于进程控制的主要函数：fork，exec函数族和waitpid\n\n#### 例子\n\n我们从标准输入中读取命令，然后执行这些命令，这些命令都比较简单，我们规定他们不带有执行参数，比如 pwd ; ls 等等，这里我们就可以用到exec函数族\n\n代码中需要注意一点是fgets()读取到的字符串末尾结束符之前有一个 '\\n' 回车符，需要将其删掉才是正确的命令\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <sys/wait.h>\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n\nint main() {\n    char buf[MAX_BUFFER_SIZE] = {0};\n\n    while (1) {\n        // 读取命令(简单的没有参数的)\n        bzero(buf, sizeof(buf));\n        fgets(buf, sizeof(buf) - 1, stdin);\n        // 将buf中的'\\n'字符替换成'\\0'，不然命令会出错\n        buf[strlen(buf) - 1] = 0;\n\n        pid_t pid = fork();\n        if (-1 == pid) {\n            perror(\"fork\");\n            return -1;\n        }\n\n        if (pid > 0) {\n            // 父进程回收子进程，等待执行，回收一次读取下一次命令\n            waitpid(pid, nullptr, 0);\n            printf(\"child process has been recycled, pid :%d\\n\", pid);\n        } else if (0 == pid)\n            // 子进程调用exec函数族执行命令\n            execlp(buf, buf, nullptr);\n    }\n\n    return 0;\n}\n~~~\n\n### 线程和线程ID\n\n通常一个进程只有一个控制线程，但是对于一个复杂问题，如果我们能够用多个线程分别作用于他的不同部分，那么解决起来就容易得多；另外，多线程也可以充分利用多处理器系统的并行能力\n\n一个进程内的所有线程共享同一地址空间，文件描述符以及与进程相关的属性；**最重要的一点就是数据是共享的，但是这就带来了一个问题，如何保证线程在访问共享数据的时候保证线程的数据同步**\n\n线程也用线程ID标识，但是线程ID只在本进程当中起作用，一个线程ID在其他进程当中没有作用\n\n线程也有相关的系统API，这个后面再说\n\n## 出错处理\n\n**当UNIX系统函数出错的时候，通常函数会返回一个负数值，并且会修改错误号 errno 为特定的值**\n\nerrno定义在头文件 <errno.h> 中，当中定义了各种常量，这些常量都以 **E** 开头\n\n在多线程当中，每个线程都有自己的局部 errno ，以避免一个线程干扰了另一个线程\n\n注意，对于errno应该注意两条规则：\n\n- 如果没有出错，errno的值不应该被进程或者线程清除，我们只有在调用系统函数的返回值出错的时候，才会检验 errno 的值\n- 任何函数都不会将errno的值设置为 0 ，并且在头文件中定义的所有错误号宏都不为0\n\n### 两个错误信息打印函数\n\nC语言给出了两个错误信息打印函数，strerror()和perror()\n\n~~~cpp\nchar* strerror(int errnum);\n// 作用：根据我们给出的错误号，将其映射为一个错误消息的字符串并将其返回\n// 参数：错误号\n\nvoid perror(const char* msg);\n// 作用：基于当前我们的errno值，在标准错误的文件描述符上面生成一条错误消息，输出到终端\n// 参数：一个字符串，在输出的时候首先输出 msg 字符串，然后输出一个冒号，后面就是我们的错误信息，最后换行\n~~~\n\n#### 例子\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char* error_msg = strerror(EACCES);  // Permission denied\n    cerr << error_msg << endl;\n\n    errno = ENOENT;  // No such file or directory\n    perror(\"msg\");\n\n    return 0;\n}\n~~~\n\n### 出错恢复\n\n错误一般可以分为致命性和非致命性的，对于致命性的错误，没有办法进行恢复，我们最多能进行的操作就是在屏幕上打印一条出错消息或者将一条出错消息写入日志文件，然后退出程序；对于非致命性的错误，我们可以较为妥善的进行处理，并且大多数的非致命性错误都是暂时的，例如资源短缺，对于资源类的非致命性错误的典型恢复操作是延迟一段时间，然后重试\n\n我们自己在写程序的时候有时候也会遇到非致命错误，这个时候我们可能需要做一些手动的特殊判断处理，这样能够增强我们程序的健壮性\n\n## 用户标识\n\n### 用户ID\n\n用户ID是一个数值，它可以标识不同的用户；用户不能更改用户ID，通常每个用户有一个唯一的用户ID\n\n用户ID为0的用户是根用户或者超级用户；我们称登录名为root的用户为超级用户特权，超级用户对系统有绝对自由的支配权\n\n### 组ID\n\n口令文件登录项中也包括用户的组ID，他也是一个数值；**组用于将若干用户集合到项目或者部门当中去，这种机制允许同组的各个成员之间共享资源，例如文件**，我们可以设置文件的权限让组内的所有成员都能访问该文件，但是组外的成员不能访问\n\n组文件在我们的系统中通常是 /etc/group ，打开之后长这样，下面还有数据，截图截不全，可以看出他把我们的组名映射成了组ID\n\n![image-20230828144329771](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828144329771.png)\n\n我们可以用如下的代码打印我们的用户ID和所在的组ID\n\n~~~cpp\nprintf(\"uid = %d , gid = %d\\n\", getuid(), getgid());\n~~~\n\n在我的Linux上打印出来是1000\n\n![image-20230828144714174](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828144714174.png)\n\n### 附属组ID\n\n除了在口令文件对一个登录名指定一个组ID之外，**大多数UNIX系统还允许一个用户属于另外一些组**\n\n## 信号\n\n信号是用于通知给我们的进程发生了某种情况，举一个例子，例如我们现在执行了除法除以0的操作，系统会给进程发出 SIGEPE (浮点异常)，我们一般有三种方式来处理信号：\n\n- **忽略信号**，我们不推荐使用这种方式，因为忽略系统发送的信号听起来就是个不明智的选择，但是在某些情况下有使用\n\n- **系统按照默认方式处理**，对于除数为0，系统默认的方式是终止该进程\n\n- **提供一个函数，信号发生的时候就调用这个函数，我们称为信号捕捉，这个函数我们可以自己编写，通过这个函数我们就可以知道信号发生的时候我们怎么具体处理**\n\n  我一般用的比较多的是就是 sigaction() 函数\n\n  ~~~cpp\n   \t#include <signal.h>\n  \n      int sigaction(int signum,\n                          const struct sigaction *_Nullable restrict act,\n                          struct sigaction *_Nullable restrict oldact);\n  // 作用：用来检查或者改变信号的处理，信号捕捉\n  // 参数：\n  //     signum：需要捕捉的信号的编号或者宏值\n  //     act：捕捉到信号之后相应的处理动作\n  //     oldact：上一次对信号捕捉的相关的设置，一般不使用，传递nullptr\n  // 返回值：\n  //     成功 0\n  //     失败 -1，设置errno\n  \n      struct sigaction {\n              //函数指针，指向的函数就是信号捕捉到之后的处理函数\n              void     (*sa_handler)(int);\n              //函数指针，一般不使用\n              void     (*sa_sigaction)(int, siginfo_t *, void *);\n              //临时阻塞信号集，在信号捕捉函数执行过程中会临时阻塞某些信号，执行完之后恢复\n              sigset_t   sa_mask;\n              //指定是用第一个回调处理sa_handler还是第二个sa_sigaction，0表示第一个，SA_SIGINFO表示第二个，还有其他的值，但是用的少\n              int        sa_flags;\n              //被废弃掉了，不需要用，传入nullptr\n              void     (*sa_restorer)(void);\n      };\n  ~~~\n\n  **在很多情况下都能产生信号，在终端上可以有两种从键盘录入产生信号的方法，分别称为中断键，通常是 ctrl + C 和退出键，通常是 ctrl + \\，都可以用于结束当前的进程，他们发出的信号分别是 SIGINT 和 SIGQUIT；**\n\n  **我们也可以调用系统提供的 kill() 函数来产生信号，比如我们可以产生9号信号 SIGKILL，就可以无条件终止进程，这个信号不能被阻塞或者捕获；当然我们通过进程向另一个进程发送信号的时候也不是随便发的，也有权限要求，我们必须是这个进程的所有者或者是超级用户权限才行**\n\n### 例子\n\n下面我们用sigaction()函数来捕捉一下SIGINT信号，我从键盘录入字符，然后遇到 ctrl + C 就打印一句话，但是不终止程序\n\n书上用的是signal()函数，但是我觉得用sigaction()更好一些\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <signal.h>\n\n#define MAX_BUFFER_SIZE 1024\n\nvoid my_hander(int signum);\n\nint main() {\n    // 设置一些参数\n    struct sigaction act;\n    act.sa_handler = my_hander;\n    sigemptyset(&act.sa_mask);\n    act.sa_flags = 0;\n\n    sigaction(SIGINT, &act, nullptr);\n\n    char buf[MAX_BUFFER_SIZE] = {0};\n    while (1) {\n        bzero(buf, sizeof(buf));\n        fgets(buf, sizeof(buf) - 1, stdin);\n\n        write(STDOUT_FILENO, buf, strlen(buf));\n    }\n\n    return 0;\n}\n\nvoid my_hander(int signum) {\n    printf(\"signal SIGINT got.\\n\");\n}\n~~~\n\n执行结果：\n\n![image-20230828151530963](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828151530963.png)\n\n## 时间值\n\nUNIX系统使用过两种不同的时间值\n\n### 日历时间\n\n这个时间是自世界协调时 1970年1月1日 00:00:00 到现在所经过的秒数，系统用 time_t 保存这种时间值\n\n### 进程时间\n\n也叫做CPU时间，是用来度量进程使用的中央处理器资源，系统用 clock_t 保存这种时间值\n\n当度量一个进程的执行时间的时候，UNIX提供了三个进程时间值：\n\n- 时钟时间\n- 用户CPU时间\n- 系统CPU时间\n\n关于时间的说明我们后面再谈\n\n## 系统调用和库函数\n\n各种UNIX都提供了定义好的，数量有限，直接进入内核的入口点，这些称作系统调用；系统调用接口在UNIX中是用C语言定义的，但是早期的操作系统那些系统是按照传统方式的用机器的汇编语言定义的\n\n**在Linux当中我们的man文档，第二章记录的是Linux的系统API，第三章记录的是C标准库的一些内容，这就是我们前面提到的系统调用和库函数的区别**；库函数在调用的时候不一定经过了系统调用，但是要实现某些功能，比如打印到屏幕，就会经过系统调用。例如我们的printf()函数，底层调用了write()；但是函数strcpy()和atoi()函数是C标准库的函数，他们并不调用任何内核的系统调用\n\n**我们举一个例子来更进一步，以存储空间的分配函数malloc为例，这是C的库函数；但是在UNIX当中处理存储空间分配的系统调用是 sbrk() ，而我们的malloc()很可能底层调用了sbrk()函数作为支撑，我不知道是不是对的，只是我的猜测，库函数在系统调用的基础上省去了很多面向内核的直接操作，在用户层面更加方便了我们的使用**\n\n我们用一个图来展示系统调用和库函数的关系：\n\n![image-20230828154002555](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828154002555.png)\n\n**另一个区别是：系统调用通常提供一个最小的接口，实现的功能比较简单；而库函数大多数是在系统调用的基础上，可以提供更加复杂的功能供用户使用**\n\n# 第二章 UNIX标准及实现(当小说看)\n\n## UNIX 标准\n\n1. ISO C：\n\n   意图是提供C程序的可移植性，使得它能够适合于大量不同的操作系统。\n\n   - 该标准不仅定义了C程序设计语言的语法和语义，还定义了标准库\n\n2. POSIX(Portable Operating System Interface): \n\n   指的是**可移植操作系统接口**。该标准的目的是提升应用程序在各种UNIX系统环境之间的可移植性。它定义了“符合POSIX”的操作系统必须提供的各种服务。\n\n   - POSIX 包含了 ISO C 标准库函数\n\n3. SUS(Single Unix Specification)：\n\n   是 POSIX 标准的一个超集，他定义了一些附加接口扩展了 POSIX 规范提供的功能。\n\n4. 上述三个标准只是定义了接口的规范，而具体的实现由厂商来完成。目前UNIX主要有以下实现：\n\n   - SVR4(UNIX System V Release 4)\n   - 4.4 BSD(Berkeley Software Distribution)\n   - FreeBSD\n   - Linux\n   - Mac OS X\n   - Solaris\n\n## 限制\n\n1. UNIX 系统实现定义了很多幻数和常量。有两种类型的限制是必须的：\n\n   - 编译时限制，如 `short int` 最大值是多少\n   - 运行时限制，如文件名最长多少个字符\n\n2. 通常编译时限制可以在头文件中定义；运行时限制则要求进程调用一个函数获得限制值。\n\n3. 某些限制在一个给定的 UNIX 实现中可能是固定的（由头文件定义），在另一个 UNIX 实现中可能是动态的（需要由进程调用一个函数获得限制值）。如文件名的最大字符数在不同的操作系统中，是属于动态/静态限制。因此提供了三种限制：\n\n   - 编译时限制（由头文件给定）\n   - 与文件或者目录无关的运行时限制（由 `sysconf`函数给定）\n   - 与文件或者目录相关的运行时限制（由 `pathconf`函数以及`fpathconf`函数给定）\n\n4. ISO C 限制：ISO C 所有编译时限制都在头文件 `<limits.h>` 中,如整型大小。\n\n   - 这些限制常量在一个给定的操作系统中不会改变\n   - 关于浮点数的最大最小值的编译时限制，在`<float.h>`头文件中定义\n   - `<stdio.h>` 头文件还定义了三个编译时限制：\n     - `FOPEN_MAX`：可同时打开的标准`I/O` 流限制的最小数\n     - `TMP_MAX`：由`tmpnam`函数产生的唯一文件名的最大个数\n     - `FILENAME_MAX`：虽然 ISO C 定义了该常量，但是要避免使用。而要用 POSIX 提供的 `NAME_MAX`和 `PATH_MAX` 常量\n\n5. POSIX 限制：POSIX定义了很多涉及操作系统实现限制的常量。这些常量大多数在`<limits.h>`中，也有的按照具体条件定义在其他头文件中\n\n6. 获取运行时限制：\n\n   ```cpp\n   #include<unistd.h>\n   long sysconf(int name); \n   long pathconf(const char*pathname,int name);\n   long fpathconf(int fd,int name); //fd 为文件描述符\n   ```\n\n   - 参数：\n     - `name`：指定的限制值。`name`参数是系统定义的常量\n       - 以 `_SC_`开头的常量用于 `sysconf`函数\n       - 以 `-PC_`开头的常量用于`pathconf`和`fpathconf`函数\n     - `pathname`：文件名\n     - `fd`：打开文件的文件描述符\n   - 返回值：\n     - 成功：返回对应的限制值\n     - 失败： 返回 -1\n\n   这三个函数失败的情况：\n\n   - 若`name`参数并不是一个合适的常量，则这三个函数返回-1，并将 `errno`设置为 `EINVAL`\n   - 有些`name`会返回一个不确定的值，这通过返回 -1 来体现，同时不改变`errno`\t\n\n# 第三章 文件`I/O`\n\n大多数文件`I/O`只需要用到5个函数，`open`,`read`,`write`,`lseek`和`close`，这五个函数都是不带缓冲的`I/O`，这个前面进行过了说明，\n\n补充一点，不带缓冲也可以说是调用内核当中的一个系统调用，因为在用户层没有缓冲区，但是在内核区存在缓冲机制\n\n## 文件描述符\n\n对于内核而言，打开的文件用文件描述符来进行标识；文件描述符是一个非负整数，当打开一个文件或者创建一个文件的时候，系统向进程返回文件描述符，我们的`read`和`write`函数是以文件描述符作为文件的依据的\n\n按照惯例，UNIX系统一般把0 1 2 当作标准输入，标准输出和标准错误的文件描述符，他们默认是定向到终端的；他们当然也存在自己的宏，分别是`STDIN_FILENO`，`STDOUT_FILENO`，`STDERR_FILENO`\n\n文件描述符的变化范围是：0 ~ `OPEN_MAX` -1，任何一个运行中的程序能够同时打开的文件数是有限制的，这个限制通常是由<`limits.h`>头文件中的常量`OPEN_MAX`定义的，它的值随系统的不同而不同，但POSIX要求它至少为**16**！\n\n## 函数open和openat\n\n~~~cpp\n#include <fcntl.h>\n\nint open(const char *pathname, int flags, mode_t mode);\n\nint openat(int dirfd, const char *pathname, int flags, mode_t mode);\n~~~\n\n我们先看`flags`参数，分为必须有的和可选的：\n\n必须有的\n\n我们一般用的多的就是前三个，只读，只写和读写\n\n![image-20230828191437922](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828191437922.png)\n\n可选的\n\n可选的里面用的比较多的就是 O_APPEND，O_CREAT，一个表示进行追加，另一个表示创建文件，值得一提的是，创建文件的时候第三个参数 mode，需要给出指定的权限，比如0664(八进制数)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230828192132187.png\" alt=\"image-20230828192132187\" style=\"zoom:80%;\" />\n\n![image-20230828192152274](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828192152274.png)\n\n由open和openat函数返回的文件描述符一定是最小的未用描述符数值，也就是说一般来说是按照顺序来的，但是如果前面的文件描述符被关闭之后，新用的文件描述符应该优先考虑最小的文件描述符值\n\n下面我们来看一下`open`和`openat`的区别：\n\n- `path`参数如果指定的是绝对路径名，在这种情况下，`fd`参数被忽略，`openat`函数相当于`open`函数\n- `path`参数如果指定的是相对路径名，`fd`参数指出了相对路径名在文件系统中的开始地址，但是为什么是`fd`文件描述符呢？因为这个开始地址是我们通过打开相对路径名所在的目录获取的，需要用到`O_DIRECTORY`参数\n- path参数指定了相对路径名，fd参数具有特殊值`AF_FDCWD`，在这种情况下，路径名从当前工作目录中获取，这一点和open函数的性能比较类似\n\n### 例子\n\n下面我们举个例子来看看`openat`函数的使用，`open`函数我用了很多次了，这里就不演示了\n\n两个例子都是用了相对路径，第一个是使用我们指定的相对路径作为起始地址打开文件，第二个是使用当前工作目录作为起始地址\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\n#define MAX_BUF1FER_SIZE 1024\n\nint main() {\n    // 通过open函数打开项目中的01目录\n    int dir_fd = open(\"./01\", O_DIRECTORY);\n    if (-1 == dir_fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 通过openat函数使用相对路径打开其他目录(01)的文件\n    int fd1 = openat(dir_fd, \"01.txt\", O_RDONLY);\n    if (-1 == fd1) {\n        perror(\"openat\");\n        return -1;\n    }\n\n    char buf1[MAX_BUF1FER_SIZE] = {0};\n    int len = read(fd1, buf1, sizeof(buf1) - 1);\n    if (-1 == len) {\n        perror(\"read\");\n        return -1;\n    }\n    printf(\"fd1 read : %s\", buf1);\n\n    // 通过openat函数使用相对路径打开当前目录的文件\n    int fd2 = openat(AT_FDCWD, \"01.txt\", O_RDONLY);\n    if (-1 == fd1) {\n        perror(\"openat\");\n        return -1;\n    }\n\n    char buf2[MAX_BUF1FER_SIZE] = {0};\n    len = read(fd2, buf2, sizeof(buf2) - 1);\n    if (-1 == len) {\n        perror(\"read\");\n        return -1;\n    }\n    printf(\"fd2 read : %s\", buf2);\n\n    close(dir_fd);\n    close(fd1);\n    close(fd2);\n\n    return 0;\n}\n~~~\n\n其中`read`函数的返回值相关的讨论，我们后面再聊\n\n使用`openat`函数可以看出，我们可以使用相对路径名打开目录中的文件，特别是其他目录中的，或者说我们可以把寻找文件的起始目录给改变，这一点是非常不错的，可以在多线程中使用相对路径名打开目录中的文件，同一进程中的所有线程共享相同的工作目录，但是很难让同一进程的不同线程在同一时间内工作在不同的目录当中；\n\n第二就是可以避免`TOCTTOU`错误，以下是解释，了解即可：\n\n![image-20230828200348003](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828200348003.png)\n\n## 函数creat\n\n用来创建一个文件\n\n~~~cpp\n#include <fcntl.h>\n\nint creat(const char *pathname, mode_t mode);\n\n// 这个函数等效于\nopen(path, O_RDONLY | O_CREAT, mode);\n~~~\n\n**对于这个函数我们要注意一点，这个函数只能是以只读的方式创建文件的**，因此我们如果要写文件的话，还需要先将这个文件描述符关闭，然后再重新以读写的方式打开该文件才行，所以就有点麻烦\n\n## 函数close\n\n用来关闭一个文件描述符\n\n~~~cpp\n#include <unistd.h>\n\nint close(int fd);\n~~~\n\n**关闭文件的同时还会释放该进程在该文件上的所有记录锁**，这个我们后面讨论\n\n**当一个进程终止的时候，内核会自动关闭它所有打开的文件；很多程序都自动调用了这个功能而不显示调用`close`关闭文件，这是内核对我们的负责，但是我们在写代码的时候要注意代码的健壮性，有打开就有关闭**\n\n但是内核的的确确帮我们做了很多事情，比如我们在利用标准输入输出`STDIN_FILENO`和`STDOUT_FILENO`的时候，这也是文件描述符，只不过是内核帮我们打开的，但是我们最后没有关闭它，而是在进程结束的时候内核关闭了\n\n## 函数lseek\n\n每个打开的文件描述符，都有一个与其相关联的当前文件偏移量，用来标识我们操作文件的时候从哪里开始，大小就是从文件开始处到此处的字节数；我们的读写操作都是从文件偏移量开始的，当到文件末尾之后函数就会返回，下一次就会重置\n\n按照系统默认的情况，当打开一个文件的时候，除非是使用`O_APPEND`选项，否则偏移量都应该被设置为0\n\n**`lseek`函数仅将当前的文件偏移量记录在内核当中，并不引起任何`I/O`操作，然后，该偏移量就用于下一个读或者写的操作**\n\n~~~cpp\n//标准C库的函数\n#include <stdio.h>\n\nint fseek(FILE *stream, long offset, int whence);\n\n//Linux系统函数\n#include <sys/types.h>\n#include <unistd.h>\n\noff_t lseek(int fd, off_t offset, int whence);\n~~~\n\n标准库的`fseek`和`Linux`下面的系统调用`lseek`很类似，我们这里就说`lseek`\n\n第一个参数是文件描述符，第二个参数是我们给的偏移量，这个偏移量可正可负，也就是说，我们的指针可以往前移\n\n第三个参数`whence`：\n\n- `SEEK_SET` 设置偏移量，从头开始\n- `SEEK_CUR` 设置偏移量：当前位置 + 第二参数`offset`的值\n- `SEEK_END` 设置偏移量：文件大小 + 第二参数`offset`的值\n\n返回值是文件指针的新位置，失败返回-1并且修改`errno`\n\n### 作用\n\n那么这个函数就有很多作用了\n\n- 移动文件指针到头部\n  ~~~cpp\n  lseek(fd, 0, SEEK_SET);\n  ~~~\n\n- 获取当前文件指针的位置\n  ~~~cpp\n  lseek(fd, 0, SEEK_CUR);\n  ~~~\n\n- 获取文件的长度\n  ~~~cpp\n  lseek(fd, 0, SEEK_END);\n  ~~~\n\n- 扩展文件的长度\n\n  **为什么能扩展呢？我们想一下第三个参数我传入`SEEK_CUR`，然后这不是已经到文件末尾了吗？然后我第二个自己给的偏移量我给正数，按理来说不就超出文件边界了吗？但是内核帮我们把文件进行了扩展**\n\n  ~~~cpp\n  #include <iostream>\n  using namespace std;\n  #include <fcntl.h>\n  #include <unistd.h>\n  \n  int main() {\n      int fd = open(\"02.txt\", O_RDWR);\n      if (-1 == fd) {\n          perror(\"open\");\n          return -1;\n      }\n  \n      // 将文件扩展\n      off_t offset = lseek(fd, 100, SEEK_END);\n      if (-1 == offset) {\n          perror(\"lseek\");\n          return -1;\n      }\n  \n      // 需要立即进行一次写的操作，否则修改不会成功\n      write(fd, \" \", 1);\n  \n      close(fd);\n  \n      return 0;\n  }\n  ~~~\n\n  我们发现在扩展了之后需要**立即**进行一次写的操作，否则修改就会失败，请注意我用的立即这个词语，这可能是因为如果没有立即进行写，内核会认为我们这样扩张文件是没有意义的，所以就会把扩展的行为给撤回，因此就会失败；\n\n  **扩展之后的文件我们一般称作具有空洞的文件，因为我们加长了文件但是没有往其中写入任何内容**\n\n  执行结果：\n\n  其中包含了我们扩张的100字节和一次写的1个字节\n\n  ![image-20230828203838354](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828203838354.png)\n\n当然并不是所有的文件描述符都可以被我们设置偏移量，比如匿名管道`PIPE`，有名管道`FIFO`，网络套接字等等都不能被设置，这时候`lseek`函数会返回-1，并且`errno`会被设置为``ESPIPE`\n\n我们可以用一个程序来看下我们能否修改标准输入的偏移量\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    // 我们看能否修改标准输入的偏移量\n    off_t offset = lseek(STDIN_FILENO, 100, SEEK_CUR);\n    if (-1 == offset)\n        perror(\"lseek\");\n    else\n        printf(\"lseek ok.\\n\");\n\n    return 0;\n}\n~~~\n\n显而易见是不可以的的，执行结果：\n\n![image-20230828204419474](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828204419474.png)\n\n### 补充(od命令)\n\n我们可以用`od`命令去观察文件的实际内容，命令行中可以加上`-c`表示以字符方式打印文件内容，这个应该用的比较常见\n\n命令如下：\n\n~~~bash\nod -c <filename>\n~~~\n\n例如，我用它来观察一个文本文件：\n\n![image-20230828204950430](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828204950430.png)\n\n我也用它来观察可执行的二进制文件`a.out`\n\n内容太多了包含不下\n\n![image-20230828205027807](https://cdn.davidingplus.cn/images/2025/01/31/image-20230828205027807.png)\n\n## 函数read\n\n~~~cpp\n#include <unistd.h>\n\nssize_t read(int fd, void *buf, size_t count);\n// 参数：\n\t// fd：文件描述符，通过open得到的，通过文件描述符操作某个文件\n\t// buf：缓冲区，需要读取数据存放的地方，数组的地方(传出参数)\n\t// count：指定的数组的大小\n\n// 返回值：\n\t// 成功 >0 返回实际读取到的字节数\n\t// ==0 文件已经读取完了(注意是在调用read函数之前文件指针就在末尾了才会返回0，一次性从头读完是会返回读取的字节数的)\n\t// 失败 -1 并且修改errno\n~~~\n\n当然在某些情况下实际读取到的字节数可能会小于我们要求读的字节数，这里我截图如下：\n\n![image-20230829150051220](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829150051220.png)\n\n第三个参数的类型是`size_t`，当然我们也有类似的`ssize_t`，他们的原型如下：\n\n~~~cpp\ntypedef unsigned long size_t; // 无符号整型\ntypedef long ssize_t; // 有符号整型\n~~~\n\n当然看到`long`，他和`int`类型还是有区别的，列图如下：\n\n在我的电脑上`long`占据8个字节，`int`类型占据4个字节；当然还有`short`，占据2个字节\n\n![image-20230829150521471](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829150521471.png)\n\n## 函数write\n\n~~~cpp\n#include <unistd.h>\n\nssize_t write(int fd, const void *buf, size_t count);\n// 参数：\n    // fd：文件描述符，通过open得到，通过文件描述符操作某个文件\n    // buf：要往磁盘写入的数据\n    // count：要写入的实际的大小\n\n// 返回值：\n    // 成功 >0 返回实际写入的字节数\n    // ==0 文件已经写入完了\n    // 失败 -1 并且修改errno\n~~~\n\n`write`函数出错的一个常见原因就是磁盘已写满了，或者超过了一个给定进程的最大文件长度限制\n\n### 例子\n\n下面我们举一些例子，来看看`write`函数的写入到底是从哪里开始的\n\n现在我准备一个文件`03.txt`，里面写入内容：\n\n![image-20230829153031374](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829153031374.png)\n\n然后我们编写程序如下：\n\n我们不用 `O_APPEND`，打开文件写一次，看发生什么现象\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    // 打开一个已经存在的文件，不带 O_APPEND，然后看是从哪里开始写的\n    int fd = open(\"03.txt\", O_RDWR);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 开始写入\n    const char* buf = \"my name is your father.\\n\";\n    write(fd, buf, strlen(buf));\n    \n    close(fd);\n\n    return 0;\n}\n~~~\n\n结果：\n\n可见是从头开始写的\n\n![image-20230829152129366](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829152129366.png)\n\n现在我尝试在一个程序当中多次调用write函数，但是我还是不加O_APPEND标志，我看后面的write会不会接着上一次的写入呢？\n\n修改程序如下：\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    // 打开一个已经存在的文件，不带 O_APPEND，然后看是从哪里开始写的\n    int fd = open(\"03.txt\", O_RDWR);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 开始写入\n    const char* buf = \"my name is your father.\\n\";\n    // 在一个程序中连续不断的写入\n    write(fd, buf, 5);\n    write(fd, buf, 5);\n    \n    close(fd);\n\n    return 0;\n}\n~~~\n\n结果：\n\n可见第二次的写入是跟着当前的文件偏移量走的\n\n![image-20230829152416691](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829152416691.png)\n\n**因此，对于一般的文件，不加入`O_APPEND`，文件偏移量是从文件开头开始的，在一个程序中多次调用`write`函数，注意要操作的是一个文件描述符，关闭了再打开会被重置，又从头开始了，多次调用`write`函数的时候文件偏移量第一次从头开始，后面就是按照正常的偏移走，该怎么样就怎么样**\n\n现在我们恢复文件中的内容，加上`O_APPEND`来看看会怎么样：\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    // 打开一个已经存在的文件，带或者不带O_APPEND，然后看是从哪里开始写的\n    // int fd = open(\"03.txt\", O_RDWR);\n    int fd = open(\"03.txt\", O_RDWR | O_APPEND);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 开始写入\n    const char* buf = \"my name is your father.\\n\";\n    write(fd, buf, strlen(buf));\n    close(fd);\n\n    return 0;\n}\n~~~\n\n结果：\n\n可见是追加上去的\n\n![image-20230829153056681](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829153056681.png)\n\n多次调用也是追加效果，我就不演示了\n\n**总结以下，不管是带不带`O_APPEND`，就一个区别，就是写入文件的起始文件偏移量的位置，不带就是从头开始，带的话就是在文件末尾开始追加，在关闭文件描述符之前后续的操作就是正常的该怎么样就怎么样**\n\n### 补充\n\n我们根据这个例子来看看`strlen`和`sizeof`的区别：\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    const char* str = \"helloworld\\n\";\n    cout << strlen(str) << endl\n         << sizeof(str) << endl;\n\n    cout << endl;\n\n    char buf[1023] = {0};\n    cout << strlen(buf) << endl\n         << sizeof(buf) << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n![image-20230829154907298](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829154907298.png)\n\n我们先看第一个`str`字符串，`strlen()`是获取他的长度，我们也可以实现这个函数，判断`'\\0'`即可；`sizeof()`在这里放入`str`，`str`是一个指针，类型是`char*`，64位操作系统上指针是8个字节，所以返回8\n\n第二个是开的`char`数组，大小预设为1023，`strlen()`仍然是获取长度，为0；`sizeof()`这时候就指的是数组的整体大小了，所以返回1023\n\n## 文件共享\n\nUNIX系统支持在不同进程间共享打开文件；我们了解一下内核用于打开文件的数据结构是什么\n\n先画一张图：\n\n![image-20230829160203372](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829160203372.png)\n\n**进程表，也称进程控制块（`PCB`），是由操作系统维护的，每个进程占用其中一个表项。该表项包含了操作系统对进程进行描述和控制的全部信息，从而保证该进程换出后再次启动时，就像从未中断过一样。**\n\n**每个进程在进程表当中都有自己的一个记录项，在文件方面记录项会维护一张文件描述符表，里面的索引就是文件描述符的`int`值，每项存储的包括文件描述符标志（目前只定义了一个标志`FD_CLOEXEC`）和指向一个文件表的指针**\n\n**文件表还没有到存放文件实际数据的地方，它是由内核维护的，里面记录的内容包括文件状态标志，就是读，写，读写这些；还有就是当前的文件偏移量；最后是指向一个v结点的指针**\n\n我们来看看v结点是指什么？我截了书上的原图：\n\n**v结点和i结点的信息是打开文件的时候就从磁盘读入到内存里了，是属于用户区的；前面的文件描述符表和文件表项是属于内核区**\n\n![image-20230829161117279](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829161117279.png)\n\n如果有两个独立进程各自打开了磁盘上的同一个文件，那么他们的图是这样的：\n\n**由于只有一份文件，因此v结点的信息只有一份，两个进程中的文件表项的v结点指针指向的是同一处位置**\n\n**由于我们每个进程都可以获得自己对这份文件的文件偏移量，因此我们每个进程针对这份同个文件都可以获得自己的文件项**\n\n![image-20230829161314772](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829161314772.png)\n\n**当然很可能有多个文件描述符指向同一个文件表项**，这个我们后面再说\n\n## 原子操作\n\n### 例子\n\n**顾名思义，原子操作就是不能被分割的操作，否则就会出现问题；书上的定义是原子操作是由多步组成的一个操作，说的没错，他们分开执行的话有时容易出问题**；我们举一个例子来说明：\n\n独立的进程A和B对同一文件进行追加操作，进程都打开了文件，但是没使用`O_APPEND`标志，那么怎么办呢？\n\n那肯定是先移动文件偏移量到末尾，然后开始写文件\n\n~~~cpp\nlseek(fd, SEEK_END, 0);\nwrite(fd, buf, strlen(buf));\n~~~\n\n对单个程序而言，这个似乎没有什么问题，但是多个进程可能会出问题\n\n**我们设想A先执行，设置到末尾，然后这个时候内核切换到进程B，B也设置到末尾，然后开始写，假设B写了100个字节；然后切换，A开始写，没有人通知A进程B已经修改了文件，那么A就在刚才的基础上进行修改，B的内容就会被覆盖，这就是问题**\n\n问题就是先定位到末端在写入数据，这是两个分开的系统调用，解决问题的办法是把这两个操作合在一起成为一个原子操作，要么执行就两步一起执行完，要么就不执行，因此内核在打开文件的时候提供了`O_APPEND`标志，合理的解决了这个可能出现的问题(可能实际情况基本不会发生，但是还是有这种可能性)\n\n### 函数pread和pwrite\n\n这两个函数可以指定从某个偏移量位置开始读或者写\n\n~~~cpp\n#include <unistd.h>\n\nssize_t pread(int fd, void buf[.count], size_t count, off_t offset);\n\nssize_t pwrite(int fd, const void buf[.count], size_t count, off_t offset);\n~~~\n\n参数中的`offset`就是我们可以指定的偏移位置\n\n**`pread`相当于先调用`lseek`再调用read，但是区别是`pread`调用的时候无法被中断操作，也就是是一个原子操作，这就可以用来解决前面的问题；`pwrite`同理类似**\n\n**并且这两个函数执行完毕之后，调用之前的文件偏移量不会被修改**，我们相当于进行了一次不影响大局的额外操作\n\n### 另一个例子\n\n书上有另一个例子，是关于`O_CREAT`标志的，这里就不赘述了\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230829164021537.png\" alt=\"image-20230829164021537\" style=\"zoom:80%;\" />\n\n## 函数dup和dup2\n\n### dup\n\n~~~cpp\n#include <unistd.h>\nint dup(int oldfd);\n// 作用：复制一个新的文件描述符，他们是指向同一个文件的，只是用了两个文件描述符\n// 新的文件描述符会使用空闲的文件描述符表中最小的那个!!!\n~~~\n\n看到这个函数的作用就知道上面说可能有多个文件描述符指向同一个文件表项的意思了，这里就体现出来了\n\n### dup2\n\n~~~cpp\n#include <unistd.h>\n\nint dup2(int fd1, int fd2);\n// 作用：重定向文件描述符\n    // fd1指向a.txt，fd2指向b.txt\n    // 调用函数成功后，fd2和b.txt的连接做close(fd1仍指向a.txt)，fd2指向a.txt\n    // fd1必须是一个有效的文件描述符\n    // 如果相同则相当于什么都没做\n// 返回值：\n    // fd2，他们都指向的是fd1之前指向的文件\n~~~\n\n总结`dup2`的作用就是：**关闭`fd2`指向指向的文件的连接，然后用当前的文件描述符索引，指向`fd1`指向的文件**；如果fd1和fd2相等，那么就啥也没干；这个函数可以使用`fd2`参数之前使用的文件描述符索引值而不是文件描述符中最小的那个\n\n这两个函数执行过后，文件描述符和文件表项大致长这个样子：\n\n可以看出有多个文件描述符指向了同一块文件表\n\n![image-20230829165153954](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829165153954.png)\n\n### 关于fcntl\n\n另一个复制文件描述符的方法是调用`fcntl`函数，这个后面具体说明\n\n对于`dup`函数，这样是等效的：\n\n~~~cpp\ndup(fd);\n\nfcntl(fd, F_DUPFD, 0);\n~~~\n\n对于`dup2`函数，这样是等效的：\n\n~~~cpp\ndup2(fd1,fd2);\n\nclose(fd2);\nfcntl(fd1, F_DUPFD, fd2);\n~~~\n\n其实这两个并不完全等效，`dup2`是个原子操作，下面的两句话是分开的；另外一个就是`dup2`和`fcntl`的错误号`errno`有一些区别\n\n## 函数sync，fsync和fdatasync(了解)\n\n这部分内容了解即可，我就截图了\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230829170048031.png\" alt=\"image-20230829170048031\" style=\"zoom:80%;\" />\n\n## 函数fcntl\n\n`fcntl`函数可以改变已经打开的文件的属性；**这个函数可以用来复制文件描述符或者设置/获取文件的状态标志**\n\n~~~cpp\n#include <fcntl.h>\n#include <unistd.h>\n\nint fcntl(int fd, int cmd, ...); ...当中是可变参数\n// 参数：\n//     fd：需要操作的文件描述符\n//     cmd：表示对文件描述符进行如何操作\n//         F_DUPFD 复制文件描述符，复制的是第一个参数，得到一个新的文件描述符(返回值)\n//             int ret = fcntl(fd,F_DUPFD);\n//         F_GETFL 获取指定文件描述符的文件状态flag\n//             获取的flag和我们通过open函数传递的flag是一个东西\n//         F_SETFL 设置文件描述符的文件状态flag\n//             必选项：O_RDONLY O_WRONLY O_RDWR 不可以被修改\n//             可选项：O_APPEND O_NONBLOCK\n//                 O_APPEND 表示追加数据\n//                 O_NONBLOCK 设置成非阻塞\n//                     阻塞和非阻塞：描述的是函数调用的行为\n~~~\n\n除了我们平时用的很多的这两个作用，书上总结了以下五个作用，有重复：\n\n![image-20230829195127023](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829195127023.png)\n\n**注意第二条和第三条的区别，一个是文件描述符的标志，目前只定义了一个文件描述符标志`FD_CLOEXEC`，这个是干嘛的我现在不知道；另一个是文件状态的标志，这就是我们`open`函数的第二个参数`flags`，比如`O_RDONLY`，`O_WRONLY`，`O_RDWR`；注意这两个的区别**\n\n我们看一下一些可能用到的cmd的用法：\n\n复制文件描述符的操作前面有提到过，用的比较多的就是复制，重定向用的比较少，因为需要经过两步操作，我们最好用dup2的原子操作\n\n文件描述符复制可以这么写，这种情况下函数返回新的文件描述符标志`newfd`\n\n~~~cpp\ndup(fd);\n// 等效于\nfcntl(fd, F_DUPFD, 0);\n~~~\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230829200156270.png\" alt=\"image-20230829200156270\" style=\"zoom:80%;\" />\n\n这个`F_GETFL`用的比较多，作用是用来获取文件状态标志，这些标志是用二进制存储的，表现出来就是一个数字，如果我们想要叠加状态标志的话就用按位或 `|` ，以下列出了文件状态的很多标志，这个在前面`open`函数的时候也提到过\n\n![image-20230829200209943](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829200209943.png)\n\n`F_SETFL`是用来设置文件状态标志，我们要对已有的文件描述符进行操作的话，一般需要先获取现在的文件状态标志，然后再进行按位或叠加 `|` ，然后再设置进去\n\n例如，这里我们将`read`函数要读的文件设置为非阻塞读取\n\n~~~cpp\nint flag = fcntl(fd, F_GETFL);\nflag |= O_NONBLOCK;\nfcntl(fd, F_SETFL, flag);\n~~~\n\n![image-20230829201513184](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829201513184.png)\n\n![image-20230829201520327](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829201520327.png)\n\n`fcntl`函数的返回复制和修改文件状态标志用的比较多，这个用的时候自己就明白了；所有情况下错误返回-1，并且修改`errno`\n\n### 例子\n\n我们写一个程序来观察以下文件状态标志\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\nvoid set_flag(const int& fd, const int& add_flag) {\n    int flag = fcntl(fd, F_GETFL);\n    flag |= add_flag;\n    fcntl(fd, F_SETFL, flag);\n}\n\nint main() {\n    // 如果不存在则创建\n    if (0 != access(\"04.txt\", F_OK)) {\n        int fd1 = open(\"04.txt\", O_RDWR | O_CREAT, 0664);\n        if (-1 == fd1) {\n            perror(\"open\");\n            return -1;\n        }\n\n        close(fd1);\n    }\n\n    // 打开文件\n    int fd = open(\"04.txt\", O_RDWR);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 查看文件状态标志\n    int flag = fcntl(fd, F_GETFL);\n    // 先看必有的三个状态，只读，只写，读写\n    if (flag & O_RDONLY)\n        cout << \"read only\" << endl;\n    else if (flag & O_WRONLY)\n        cout << \"write only\" << endl;\n    else if (flag & O_RDWR)\n        cout << \"read write\" << endl;\n    else\n        cout << \"unknown access mode\" << endl;\n\n    // 可以选择再看一些其他的状态标志，这里我就看O_NONBLOCK\n    if (flag & O_NONBLOCK)\n        cout << \"nonblock\" << endl;\n    else\n        cout << \"not nonblock\" << endl;\n\n    // 设置fd为非阻塞状态标志\n    set_flag(fd, O_NONBLOCK);\n\n    // 然后我再看一次\n    flag = fcntl(fd, F_GETFL);\n    if (flag & O_NONBLOCK)\n        cout << \"nonblock\" << endl;\n    else\n        cout << \"not nonblock\" << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n可见我们的设置是成功的\n\n![image-20230829203611074](https://cdn.davidingplus.cn/images/2025/01/31/image-20230829203611074.png)\n\n我们在设置文件状态标志`flag`的时候，我自己写了一个函数\n\n这很好理解，我先获取，然后修改，最后设置进去\n\n~~~cpp\nvoid set_flag(const int& fd, const int& add_flag) {\n    int flag = fcntl(fd, F_GETFL);\n    flag |= add_flag;\n    fcntl(fd, F_SETFL, flag);\n}\n~~~\n\n当然，如果我们把第二行修改为：\n\n这就是把这个标志从当中删除，原理就是这一位为0，其他为1，然后和标志相与，就可以只把这一位设置为0\n\n~~~cpp\nvoid del_flag(const int& fd, const int& add_flag) {\n    int flag = fcntl(fd, F_GETFL);\n    flag &= ~add_flag;\n    fcntl(fd, F_SETFL, flag);\n}\n~~~\n\n### 补充(了解)\n\n~~~cpp\nvoid set_flag(const int& fd, const int& add_flag) {\n    int flag = fcntl(fd, F_GETFL);\n    flag |= add_flag;\n    fcntl(fd, F_SETFL, flag);\n}\n\n// 我们调用这行代码\nset_flag(fd, O_SYNC);\n~~~\n\n我们看`O_SYNC`状态标志：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230829204551172.png\" alt=\"image-20230829204551172\" style=\"zoom:150%;\" />\n\n**其实在UNIX系统中，通常write只是将数据排入队列，而实际写的操作可能在之后的某个时刻完成，这个就叫延迟写；但是在这段时间内write函数已经返回并且程序继续执行了**\n\n**这样的话有可能会造成数据丢失，因为我们没有办法知道数据是否写入，只有当我们打开文件的时候才能检查。所以这里我们加入`O_SYNC`状态标志，这个标志要求每次`write`都要等待数据写到磁盘之上然后再返回，这个就叫同步写；数据库系统一般需要使用`O_SYNC`，这样我们能知道确实数据写到了磁盘上**\n\n## 函数ioctl(了解)\n\n`itocl`函数是`I/O`操作的杂物箱；不能用其他函数表示的`I/O`操作通常都用`ioctl`表示；终端`I/O`是`ioctl`用的最多的地方\n\n~~~cpp\n#include <sys/ioctl.h>\n\nint ioctl(int fd, unsigned long request, ...);\n~~~\n\n这个函数看不懂书上讲的什么，我把图贴上来：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230829205620460.png\" alt=\"image-20230829205620460\" style=\"zoom:80%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230829205626464.png\" alt=\"image-20230829205626464\" style=\"zoom:80%;\" />\n\n## /dev/fd\n\n我的系统上提供了`/dev/fd`目录，我们打开它看一下有什么内容：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230829210020506.png\" alt=\"image-20230829210020506\" style=\"zoom: 80%;\" />\n\n可以看出，目录项名为0，1，2的文件在里面，我猜测他们对应标准输入，标准输出和标准错误，打开`/dev/fd/n`等效于复制文件描述符n(我们假设文件描述符n是打开的)\n\n我们用程序来说明：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n\nint main() {\n    int fd = open(\"/dev/fd/0\", O_RDONLY);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    cout << fd << endl;  // 3 说明是复制了这个文件描述符，他们两个指向同一个文件表项\n\n    return 0;\n}\n~~~\n\n**我们在`open`函数的第二个参数传入了我们打开文件的文件状态标志，但是对于`/dev/fd/n`来说，系统基本上是忽略这个标志的，因为我们打开的是系统文件，对应的是系统的文件描述符，不能这么随意就让状态标志让我们给改了**\n\n**所以，如果我们执行下面的代码，如果文件描述符0之前就被标记为只读，即使我们这行代码执行成功，我们依然没有办法对`fd`进行写操作**\n\n~~~cpp\nint fd = open(\"/dev/fd/0\", O_RDWR);\n~~~\n\n**在Linux上面这么做要非常小心，因为Linux上在打开这些文件的时候实际上是把文件描述符映射成为了指向底层物理文件的符号链接(软链接)，比如上面就是`/dev/pts/4`，意识是比如我们打开0，我们在操作和标准输入相关的系统文件了，如果操作不得当很可能出现问题，所以我们要格外注意**\n\n# 第四章 文件和目录\n\n## 函数stat，fstat，fstatat和lstat\n\n~~~cpp\n#include <sys/stat.h>\n\nint stat(const char *restrict pathname, struct stat *restrict statbuf);\n\nint fstat(int fd, struct stat *statbuf);\n\nint lstat(const char *restrict pathname, struct stat *restrict statbuf);\n\n#include <fcntl.h>           /* Definition of AT_* constants */\n#include <sys/stat.h>\n\nint fstatat(int dirfd, const char *restrict pathname, struct stat *restrict statbuf, int flags);\n~~~\n\n这里里面用的最多的就是`stat`函数，它可以用来得到与文件相关的信息，并且存储在传出参数`statbuf`当中，我们先谈谈`stat`函数\n\n### 函数stat\n\n~~~cpp\nint stat(const char *pathname, struct stat *statbuf);\n//作用：获取一个文件的相关的信息\n//参数：\n    //pathname：操作的文件路径\n    //statbuf：结构体变量，传出参数，用于保存获取到的文件信息\n//返回值：\n    //成功 0\n    //失败 -1，并且修改errno\n~~~\n\n里面又有一个参数结构体叫`stat`结构体，与函数同名，但是这里是一个结构体，我们看看这个结构体里面存放的是什么东西\n\n![image-20230714152755154](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714152755154.png)\n\n**里面用的比较多的是类型是`mode_t`的`st_mode`变量，这个变量用来记录文件的类型和存取的权限，`mode_t`实际上是`typedef unsigned int mode_t`，因此又是用每一位来表示有无的例子，合起来就是一个数字，加入记得用按位或`|`**\n\n**下面的这些数字全部都是八进制数字，前四位表示的是文件类型，紧接着三位表示特殊权限位，然后后面的每三位分别表示用户，组和其他的对该文件的权限，可读r，可写w，可执行x**\n\n**前四位里面存在一个掩码，我们要判断文件类型的时候就用值和掩码想与然后判断是哪一个类型就好了；后面权限的判断也同理**\n\n![image-20230714153204023](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714153204023.png)\n\n当然`shell`终端也可以使用`stat`命令，例如：\n\n![image-20230830150500142](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830150500142.png)\n\n### 其他函数\n\n1. `fstat`函数\n\n   **`fstat`函数用来获得已经打开的文件的相关信息，它的参数需要的是一个已经打开的文件描述符**\n\n   **它和`stat`函数对比的话，`stat`就相当于是先打开这个文件获取文件描述符然后获取这个文件的信息结构，是一个原子操作**\n\n   ~~~cpp\n   int fstat(int fd, struct stat *statbuf);\n   //作用：获取一个已经打开的文件描述符相关的信息\n   //参数：\n       //fd：文件描述符\n       //statbuf：结构体变量，传出参数，用于保存获取到的文件信息\n   //返回值：\n       //成功 0\n       //失败 -1，并且修改errno\n   ~~~\n\n2. `lstat`函数\n\n   **`lstat`函数基本功能和stat函数没有区别，但是遇到我们要获取的文件是一个符号链接(软链接)的时候就有区别了，下面是一个例子**\n\n   **`2.txt`文件指向`1.txt`，这是一个链接文件，并且是软链接；这时候我们通过`lstat`函数获取`2.txt`就是获取`2.txt`这个链接文件本身的信息，如果我们用`stat`函数获取的就是`1.txt`的信息，这就是区别**\n\n   ![image-20230714154550861](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714154550861.png)\n\n3. `fstatat`函数\n\n   这个函数提供了更多的功能，但是一般我们都可以用前面的函数来代替，所以这里我就简单写一下就好，用的时候来查询就好了\n\n   ~~~cpp\n   int fstatat(int dirfd, const char *restrict pathname, struct stat *restrict statbuf, int flags);\n   // 参数：\n   \t// dirfd：文件目录的文件描述符，注意打开的是文件目录，为什么我们后面看\n   \t// pathname：\n   \t\t// 如果是绝对路径，那么dirfd参数会被忽略\n   \t\t// 如果是相对路径，并且dirfd参数是AT_FDCWD(和openat有点类似)，那么在dirfd的目录基础上进行定位\n   \t// statbuf：传出参数，存储文件的信息的数据结构\n   \t// flags：当设置为AT_SYMLINK_NOFOLLOW的时候，对于软链接文件，不会继续定位他指向的文件，会记录这个文件本身的信息\n   \t//        默认情况下返回这个符号链接(软链接)实际指向的文件信息\n   ~~~\n\n以上这四个函数**成功都返回0，失败都返回-1并且设置错误号**\n\n### 例子\n\n下面我们写一个程序来模拟实现 `ls -l` 命令，命令行参数传入文件名\n\n给一个`ls -l` 的例子：\n\n![image-20230830150739907](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830150739907.png)\n\n我们就试着实现这个程序\n\n~~~cpp\n#include <ctime>\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n\n#define MAX_FILEINFO_SIZE 1024\n\nint main(int argc, char const* argv[]) {\n    if (argc < 2) {\n        printf(\"usage: %s  <filename>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* filename = argv[1];\n\n    struct stat stat_buf;\n\n    int ret = stat(filename, &stat_buf);\n    if (-1 == ret) {\n        perror(\"stat\");\n        return -1;\n    }\n\n    // 开始解读stat_buf数组的文件信息内容\n    string file_info;\n\n    // 获取文件类型\n    switch (stat_buf.st_mode & S_IFMT) {\n    case S_IFSOCK:\n        file_info.append(\"s\");\n        break;\n    case S_IFLNK:\n        file_info.append(\"1\");\n        break;\n    case S_IFREG:\n        file_info.append(\"-\");\n        break;\n    case S_IFBLK:\n        file_info.append(\"b\");\n        break;\n    case S_IFDIR:\n        file_info.append(\"d\");\n        break;\n    case S_IFCHR:\n        file_info.append(\"c\");\n        break;\n    case S_IFIFO:\n        file_info.append(\"p\");\n        break;\n    default:\n        file_info.append(\"?\");\n        break;\n    }\n\n    // 获取三个权限\n    file_info.append(stat_buf.st_mode & S_IRUSR ? \"r\" : \"-\");\n    file_info.append(stat_buf.st_mode & S_IWUSR ? \"w\" : \"-\");\n    file_info.append(stat_buf.st_mode & S_IXUSR ? \"x\" : \"-\");\n\n    file_info.append(stat_buf.st_mode & S_IRGRP ? \"r\" : \"-\");\n    file_info.append(stat_buf.st_mode & S_IWGRP ? \"w\" : \"-\");\n    file_info.append(stat_buf.st_mode & S_IXGRP ? \"x\" : \"-\");\n\n    file_info.append(stat_buf.st_mode & S_IROTH ? \"r\" : \"-\");\n    file_info.append(stat_buf.st_mode & S_IWOTH ? \"w\" : \"-\");\n    file_info.append(stat_buf.st_mode & S_IXOTH ? \"x\" : \"-\");\n\n    // 获取文件硬连接数\n    nlink_t nlink_num = stat_buf.st_nlink;\n\n    // 获取文件所有者\n    // getpwuid()通过用户ID反向获得用户名称\n    // 引头文件 <grp.h>\n    string User = getpwuid(stat_buf.st_uid)->pw_name;\n\n    // 获取文件所在组\n    // getgrgid()通过用户组ID反向获得组名称\n    // 引头文件 <pwd.h>\n    string Group = getgrgid(stat_buf.st_gid)->gr_name;\n\n    // 获得文件的大小\n    off_t file_size = stat_buf.st_size;\n\n    // 获取修改时间\n    // ctime()函数可以将时间差值转化为本地时间\n    string mtime = string(ctime(&stat_buf.st_mtime));\n    // 这个时间格式化之后回车换行了，将其去掉\n    mtime.pop_back();\n\n    // 格式化信息\n    char buf[MAX_FILEINFO_SIZE] = {0};\n    sprintf(buf, \" %ld %s %s %ld %s %s\", nlink_num, User.c_str(), Group.c_str(), file_size, mtime.c_str(), filename);\n\n    file_info += buf;\n\n    // 输出信息\n    cout << file_info << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n可见实现的还不错，注意代码中怎么通过用户ID和组ID反向获得用户名和组名，以及对时间的格式化\n\n![image-20230830153051111](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830153051111.png)\n\n## 文件类型\n\n**我们一般用的比较多的两个文件类型就是普通文件和目录**，当然还有一些其他的类型\n\n截图如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230830154128435.png\" alt=\"image-20230830154128435\" style=\"zoom:80%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230830154139467.png\" alt=\"image-20230830154139467\" style=\"zoom:80%;\" />\n\n**从第一条我们知道，普通文件里面存放的是什么数据，比如是文本还是二进制数据，对内核而言无所紧要；但是内核想要执行二进制文件，那肯定需要对二进制文件的格式要进行规范标准化，这样才能确定程序文本和数据的加载位置**\n\n**目录文件，里面包含了目录当中文件的名字和指向这些文件信息的指针；对一个目录文件具有读权限的进程能够读目录下的任意文件的内容，但是只有内核能直接对目录文件进行写操作，进程要写需要调用系统API通过内核操作才能进行修改**\n\n其他的文件看图即可\n\n关于查看文件的类型，书上给出了一个例子，这个例子已经在我们模拟`ls -l`命令的时候已经做过了，见前面\n\n## 设置用户ID和组ID\n\n与进程相关的ID有6个之多，截书上的图说明如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230830171807717.png\" alt=\"image-20230830171807717\" style=\"zoom:80%;\" />\n\n通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID\n\n每一个文件都有一个所有者和一个组所有者，所有者由结构体`stat`中的变量`st_uid`指定，组所有者由变量`st_gid`指定\n\n## 文件访问权限\n\n`st_mode`里面也包含了对文件的访问权限；**值得注意的是，这里的文件不仅仅是指普通文件，其他的任何类型，包括目录，字符特别文件等等，都具有访问权限**\n\n文件访问权限有9位，每三位分别代表用户，组，其他的读，写，可执行权限，具体如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230830184628138.png\" alt=\"image-20230830184628138\" style=\"zoom:80%;\" />\n\n### 目录的可读和可执行权限\n\n我们要说明一下一个目录的可读和可执行权限\n\n例如，我们要打开文件`/usr/include/stdio.h`，我们需要依次访问目录 `/`(根目录)，`/usr`和`/usr/include`这三个目录；对于`stdio.h`文件的访问权限我们不做讨论；\n\n**对于目录而言，可读的权限代表这我们可以读这个目录，获得这个目录下的所有文件列表；可执行权限代表我们可以搜索这个目录，找到我们需要找到的指定的文件或者目录**，这两个不要弄混了\n\n### 文件的访问权限和open函数中的文件状态标志之间的关系\n\n提到这里我们不得不提一下文件自身的访问权限和我们`open`函数打开文件指定的文件状态标志的关系了\n\n比如我们`open`函数用读写的方式打开一个文件，按照常理来说是没问题的，但是如果这个文件是只读的，也就是不允许我们写；那么这个时候就会有所不同，我们用读写的方式打开文件就会报错，见下面程序：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n\nint main() {\n    int fd = open(\"02.txt\", O_RDWR);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n可见并不是我们指定怎么访问就怎么访问，还得看文件本身的访问权限\n\n![image-20230830190310031](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830190310031.png)\n\n### 关于进程打开文件\n\n当一个进程需要打开，创建或者删除一个文件的时候，内核就对文件进行访问权限的设置，具体测试如下(了解)：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230830190756047.png\" alt=\"image-20230830190756047\" style=\"zoom:80%;\" />\n\n我们只需要知道的就是，**如果想要正确的访问文件，这个文件就应该提供相应的权限给我，否则即使我要求用这种方式访问也是不行的**\n\n## 新文件和目录的所有权\n\n新文件的用户ID设置为进程的有效用户ID\n\n组ID选择下面二者其一：\n\n- 可以是进程组的有效组ID\n- 可以是所在目录的组ID\n\n## 函数access和faccessat\n\n~~~cpp\n#include <unistd.h>\nint access(const char *pathname, int mode);\n// 作用：用来判断某个文件是否有某个权限，或者判断文件是否存在\n// 参数：\n// pathname：文件路径\n// mode：\n    // R_OK 是否有读权限\n    // W_OK 是否有写权限\n    // X_OK 是否有执行权限\n    // F_OK 文件是否存在\n// 返回值：\n// 成功 返回0\n// 失败(没有这个权限) 返回-1，并且修改errno\n~~~\n\n`faccessat`函数和`access`函数类似，但是有一些区别：\n\n~~~cpp\nint faccessat(int dirfd, const char *pathname, int mode, int flags);\n// dirfd，看这个形式，就是知道我们需要传入的是一个目录的文件描述符，所以open函数记得加上O_DIRECTORY\n// pathname：\n\t// 绝对路径，那么这个时候dirfd被忽略，就找指定绝对路径的文件，来看他的权限\n\t// 相对路径，如果dirfd传入AF_FDCWD，那么相对路径从本程序的工作目录开始计算；不是就从dirfd打开的目录开始计算\n// mode：需要检测的一些权限，同上面\n// flags：\n\t// 这个参数一般我们用不上，默认给0就行了\n\t// 但是我们传入AT_EACCESS，访问检查用的是调用进程的有效用户ID和组ID，而不是实际用户ID和组ID(我目前不知道作用)\n~~~\n\n### 例子\n\n我们写一个程序来看一下该怎么使用\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\nint main(int argc, char* const argv[]) {\n    if (argc < 2) {\n        printf(\"usage: %s  <filename>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* filename = argv[1];\n\n    // 检测这个文件是否具有读权限\n    if (0 == faccessat(AT_FDCWD, filename, R_OK, 0))\n        cout << \"read access ok\" << endl;\n    else\n        perror(\"read access error\");\n\n    // 看打开这个文件会不会被拒绝\n    if (-1 != open(filename, O_RDONLY))\n        cout << \"open for reading ok\" << endl;\n    else\n        perror(\"open for reading error\");\n\n    return 0;\n}\n~~~\n\n结果：\n\n![image-20230830195427643](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830195427643.png)\n\n## 函数umask\n\n这个函数用来**设置进程在创建文件时候的访问权限屏蔽字**，什么意思呢？\n\n我们先来看看open函数创建文件时候的情况\n\n~~~cpp\nint fd = open(\"test.txt\", O_RDWR, 0664);\n~~~\n\n第三个参数，这里我给的是八进制数0664，664每位数字分别代表3位，就是用户，组和其他的可读，可写和可执行权限\n\n### 进制数表示\n\n说到这里我就必须提一下C语言对二进制，八进制和十六进制数的表示方法：\n\n- **二进制由 0 和 1 两个数字组成，使用时必须以`0b`或`0B`（不区分大小写）开头，例如：0b101**\n- **八进制由 0~7 八个数字组成，使用时必须以`0`开头（注意是数字 0，不是字母 o），例如：0664**\n- **十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，使用时必须以`0x`或`0X`（不区分大小写）开头，例如：0x2A**\n\n所以这里的0664显然是一个八进制数\n\n### 实际的文件访问权限\n\n我们给他一个八进制数，那么内核是不是就把我们的这个数应用到文件的访问权限上了呢？\n\n其实不是，在我们终端的进程打开的时候系统会初始化一个变量叫`umask`，我的电脑上是0022，这也是一个八进制数：\n\n![image-20230830200859566](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830200859566.png)\n\n它有什么用呢？\n\n我们先看书上的定义，`umask`函数是设置进程在创建文件时候的访问权限屏蔽字，请注意这里的**屏蔽**二字，**实际上我们设置的权限要和系统的`umask`进行一下运算，得到的`mode`才是真正的访问权限**\n\n~~~cpp\nmode & = ~umask;\n~~~\n\n**我们想一下，取反就是把`umask`想要屏蔽的位置为0，不屏蔽的位置为1；然后与我们设置的想与，实际上就是想把它想屏蔽的权限设置位0，也就是我们想设置这个权限，但是他不给我们，我们设置了也没用**\n\n**因此`umask`函数的实际作用其实就相当于在进程中修改`umask`，也就是他说的创建访问权限屏蔽字，这样屏蔽的权限我们没办法设置出来**\n\n### 例子\n\n我们先不设置`umask`，然后设置一定的屏蔽字，看看执行结果：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n// 定义一个权限宏\n#define RWRWRW (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH)\n\nint main() {\n    // 先将umask置为0\n    umask(0);\n\n    // 先正常创建一个文件，这里我用creat函数\n    if (0 != access(\"foo.txt\", F_OK))\n        remove(\"foo.txt\");\n\n    int fd1 = creat(\"foo.txt\", RWRWRW);\n    if (-1 == fd1) {\n        perror(\"creat\");\n        return -1;\n    }\n\n    // 然后调用umask创建屏蔽字\n    umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\n    if (0 != access(\"bar.txt\", F_OK))\n        remove(\"bar.txt\");\n\n    int fd2 = creat(\"bar.txt\", RWRWRW);\n    if (-1 == fd2) {\n        perror(\"creat\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n我的电脑自己的用户是超级用户，给了满权限，所以这里用书上的结果：\n\n![image-20230830202932811](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830202932811.png)\n\n但是无关紧要，我们知道`umask`函数和`umask`屏蔽字在文件创建的时候的作用就好\n\n### shell命令\n\n我们可以用`shell`命令来查看系统给我们创建的`umask`屏蔽字并且进行修改，\n\n我们可以用`-S`参数来直观的查看屏蔽了哪些，具体如下：\n\n![image-20230830204021285](https://cdn.davidingplus.cn/images/2025/01/31/image-20230830204021285.png)\n\n## 函数chmod，fchmod和fchmodat\n\n又是一组类似的函数，显然`chomd`函数是基础，后面的两个都是在这个基础上进行改造\n\n通过这三个函数，我们可以**更改当前文件的访问权限**\n\n~~~cpp\n#include <sys/stat.h>\nint chmod(const char *pathname, mode_t mode);\n// 作用：修改文件权限\n// 参数：\n//     pathname：文件路径\n//     mode：需要修改的权限值，八进制的数\n// 返回值：\n//     成功返回0\n//     失败返回-1\n~~~\n\n另外两个函数也整理如下：\n\n~~~cpp\n#include <sys/stat.h>\n\nint fchmod(int fd, mode_t mode);\n// 是对一个已经打开的文件进行操作，所以传入的是文件描述符fd；\n// chmod是open和fchmod合并起来的原子操作\n\nint fchmodat(int dirfd, const char *pathname, mode_t mode, int flags);\n// 看到这个函数和前面at后缀结尾的函数族非常类似，他们的模式是一样的，我直接复制笔记\n// dirfd，看这个形式，就是知道我们需要传入的是一个目录的文件描述符，所以open函数记得加上O_DIRECTORY\n// pathname：\n\t// 绝对路径，那么这个时候dirfd被忽略，就找指定绝对路径的文件，来看他的权限\n\t// 相对路径，如果dirfd传入AF_FDCWD，那么相对路径从本程序的工作目录开始计算；不是就从dirfd打开的目录开始计算\n// mode：需要检测的一些权限，同上面\n// flags：这里按照具体的功能有区别\n\t// 这个参数一般我们用不上，默认给0就行了\n\t// 但是我们传入AT_SYMLINK_NOFOLLOW(参考lstat)，遇到符号链接(软链接)不会继续追踪，而是就处理这个符号链接文件\n~~~\n\n**为了改变一个文件的访问权限，进程的有效用户ID必须等于文件的所有者ID，或者该进程是超级用户权限**，我的就是\n\n以下是可能设置的一些权限宏：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230830205536347.png\" alt=\"image-20230830205536347\" style=\"zoom:80%;\" />\n\n### S_ISUID和S_ISGID\n\n可以参考博客：[https://blog.csdn.net/u011580175/article/details/107749465](https://blog.csdn.net/u011580175/article/details/107749465)，这里我结合他的笔记和书上的例子进行总结\n\n- 对于文件\n\n  对于文件的`S_ISUID`，我们举个例子：\n\n  **`passwd`，原理是通过修改`/etc/shadow`文件从而实现用户账号密码的修改。而`shadow`文件只有`root`用户可以修改的。那普通用户为什么可以通过`passwd`修改字节的账号密码呢。**\n\n  **其原理其实就是，`passwd`程序`st_mode`被设置了，`S_ISUID`。此时，因为`passwd`文件的所有者是`root`用户，由于设置了`S_ISUID`，在程序运行时，程序的有效用户`ID`会被设置为`root`。所以，程序拥有`root`用户的权限，可以修改`shadow`文件。**\n\n  **如果没有设置`S_ISUID`，则`passwd`被A用户运行时，有效用户`ID`会被设置为A的``uid。则只会有A用户的权限。**\n\n- 对于文件夹\n\n  **对于文件夹的`S_ISGID`，如果文件夹A设置了`S_ISGID`，如果在A文件夹内创建B文件夹，则B文件夹的组`ID`默认为A文件夹的组`ID`。如果，没设置，则为创建文件夹的进程的有效组`ID`。**这里和书上讲的一致\n\n## 黏着位(了解)\n\n黏着位叫`S_ISVTX`；如果黏着位被设置了，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或者重命名该目录下的文件：\n\n- 拥有此文件\n- 拥有此目录\n- 是超级用户\n\n## 函数chown，fchown，fchownat和lchown\n\n又是一组类似的函数，毫无疑问我们先研究函数`chown`，**它可以用来修改文件的用户ID和组ID**\n\n~~~cpp\n#include <unistd.h>\n\nint chown(const char *pathname, uid_t owner, gid_t group);\n// 作用：可以用来修改文件的用户ID和组ID\n// 参数：(从左到右)文件路径，绝对路径或者相对路径；用户ID；组ID\n\t // 如果参数用户ID owner和组ID group被设置为-1，则对应的ID不做修改\n~~~\n\n其他三个函数和前面的族如出一辙，我就简单写了：\n\n~~~cpp\n#include <unistd.h>\n\nint fchown(int fd, uid_t owner, gid_t group);\n// 用来修改一个已经打开的文件的用户ID和组ID，所以传入的参数是文件描述符fd\n\nint lchown(const char *pathname, uid_t owner, gid_t group);\n// 和chown功能基本相同\n// 区别就在于链接文件，lchown函数会作用于该链接文件本身而不是他指向的文件\n\nint fchownat(int dirfd, const char *pathname, uid_t owner, gid_t group, int flags);\n// 首先dirfd，我们需要的是一个已经打开的文件目录，所以open函数记得加上参数O_DIRECTORY\n// pathname：\n\t// 绝对路径，这个时候dirfd参数会被忽略\n\t// 相对路径：dirfd如果设置为AF_FDCWD，则从当前工作目录开始找；否则就是我们自己打开的目录开始找\n// flags：\n\t// 如果设置了AT_SYMLINK_NOFOLLOW标志，则会作用于链接文件本身而不是指向的文件\n\t// 如果没设置，例如0，那么就是一般的行为\n~~~\n\n## 文件长度\n\n**`stat`的结构成员`st_size`表示以字节为单位的文件的长度。此字段只对普通文件，目录文件和符号链接(软链接)有意义!**\n\n例如：\n\n在这个文件夹当中，目录文件 `./` 和 `../` 的大小是有意义的；普通文件`text.txt`和链接文件`test2.txt`的大小是有意义的；但是我创建了一个有名管道`FIFO`，从结果中可以看出大小是0，代表着这个参数对他没有意义\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230831133347919.png\" alt=\"image-20230831133347919\" style=\"zoom:80%;\" />\n\n**对于普通文件，其文件长度与里面存放的数据的大小相关，是以字节数为单位；对于链接文件，文件长度是指向的文件名的实际字节数**，比如上面的`test2.txt`是链接文件，他指向文件`test.txt`，他的文件名长度是8个字节，所以`test2.txt`的文件长度是8个字节；**对于目录，文件长度通常是16或者512的整数倍**，这里是4096，符合要求\n\n### 文件中的空洞\n\n我们前面也提到过，用`lseek`函数可以修改文件的偏移量，当修改的偏移量超过文件本身的大小的时候，内核就会有帮我们扩充文件大小的想法，当我们写入一个字符的时候就会真正扩充这个文件的大小\n\n**但是相应的，扩充的这段空间里面啥也没有，当我们调用`read`函数读取的时候读到的数据(字节为单位)是0，我们形象的称他们为空洞**\n\n以下是一个例子：\n\n**图中文件的长度是`8483248B`，换算过来差不多`8.09MB`，但是`du`命令看到文件占据磁盘总量是`272`个`512`字节数，也就是`136KB`，这是实际有数据的部分，可以文件当中存在多么多么大的空洞**\n\n![image-20230831200037933](https://cdn.davidingplus.cn/images/2025/01/31/image-20230831200037933.png)\n\n如果我们不用`ls`命令，我们用`wc`命令，也可以读出文件的实际大小：\n\n![image-20230831201205022](https://cdn.davidingplus.cn/images/2025/01/31/image-20230831201205022.png)\n\n现在我们调用`cat`命令将带有空洞的`core`文件拷贝一份，我们来看看结果：\n\n![image-20230831201245761](https://cdn.davidingplus.cn/images/2025/01/31/image-20230831201245761.png)\n\n**我们发现拷贝出来的`core.copy`实际占据磁盘的大小似乎变大了，这是因为在拷贝的时候所有文件中的空洞都会被填满，其中的空洞的数据字节全部都填充为0，所以占据磁盘的大小变大了**\n\n## 函数truncate和ftruncate(文件截断)\n\n基础的函数是`truncate`，我们来看看他的性质：\n\n~~~cpp\n#include <sys/types.h>\n#include <unistd.h>\n\nint truncate(const char *path, off_t length);\n// 作用：缩减或者扩展文件尺寸到达指定的大小\n// 参数:\n    // path：文件路径\n    // length：需要最终文件变成的大小\n// 返回值：\n    // 成功 0\n    // 失败 -1\n\nint ftruncate(int fd, off_t length);\n// 参数：fd，已经打开的文件描述符，可见是我们已经打开的文件，其他没什么\n~~~\n\n我们有的时候需要在文件末尾截取一些数据来缩短文件的长度，**比如我们可以把文件长度缩减为0，这是一个比较特别的情况，我们在打开文件的时候使用状态标志`O_TRUNC`也可以做到这一点**\n\n![image-20230901092349390](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901092349390.png)\n\n**我们设置的偏移量`length`如果小于文件本身的长度，那么文件新的长度设置为`length`，超过`length`的部分就没有办法访问；**\n\n**如果设置的`length`大于文件本身的长度，文件长度就将增加，就和`lseek`函数扩充文件是一个道理，`truncate`函数帮我们进行了一步写的操作，这是个原子操作，所以新多出来的空间都将读作0，也就是形成了一个空洞**\n\n## 文件系统(重要，理解!)\n\n**我们可以把磁盘进行分区，每个分区里面就可以说是一个独立的文件系统，我们通过前面知道`i`结点可以存储文件的相关信息**\n\n### 硬链接和软链接\n\n我们来看一下什么是硬链接和软链接(符号链接)\n\n硬链接：\n\n- **一个文件有多个名字时，名字之间互为硬链接，他们的数据对应磁盘当中的同一块数据块。**\n\n- **当删除有硬链接的文件时，只要没有删除掉最后一个，文件仍然存在并能打开。只是我们通过哪个文件名打开不同而已，对应的文件数据块是相同的**\n\n- 文件详细信息中第二列的数值：**源文件+硬链接的和（`N-1`=硬链接数）**\n\n  **每个`i`结点中都有一个链接计数，其值是指向这个`i`结点的目录项数，只有当链接计数减少为0的时候，才可以删除这个文件**\n\n  **这也是为什么删除一个目录项的函数被称为`unlink`，`unlink`函数的作用就是让链接计数减1，当减为0的时候就将其删除；在`stat`结构中，链接计数包含在`st_nlink`成员中，类型是`nlink_t`，这种链接就叫硬链接；**\n\n  **链接计数==硬链接数+1**\n\n- 拥有硬链接的文件，在修改了内容之后，`Inode`号不变。有多处位置保存了文件指向位置。\n\n- **不能对目录创建硬链接(对，就是不可以，书上说超级用户可以，但是我的电脑底层文件系统不支持)，并且不能跨区创建。因不同分区有各自的`Inode`号，跨区可能冲突。**\n\n软连接(符号链接)：\n\n- **创建软链接时一定要使用绝对路径，否则创建出来的软链接文件是失效文件。**\n- 软链接文件不存储具体数据，**只存储原文件的绝对路径**。（**大小是指向的文件的文件名的大小，一旦创建大小不变**）\n- **当软链接对应的原文件被删除时，软连接仍然存在，但失效了。**\n- **源文件和软链接各自拥有不同的`Inode`号和`Block`块数。**\n- **两个文件不管修改哪一个均可同步**\n- 软链接文件权限为rwxrwxrwx,但最终生效权限以源文件为准。\n- **软链接既可以链接文件，也可以链接目录，并可以跨区创建。**\n\n#### 创建方式\n\n软链接\n\n我们可以对不存在的文件创建软链接，**但是是失效的**\n\n~~~bash\n 格式：ln -s 源文件（绝对路径） 目标位置（目标位置/新名字）\n$ ln -s /root/1.txt /tmp\n~~~\n\n硬链接\n\n~~~bash\n ln 源文件 目标位置（目标位置/新名字）\n$ ln /root/1.txt /tmp\n~~~\n\n#### 例子\n\n我们来创建一下硬链接和软链接\n\n从图中可以看出，`test.txt`是源文件，`test_hard.txt`是我们创建出来的硬链接文件，他和源文件互为硬链接，然后他们的内容是相同的；对应的都是磁盘中的同一块空间，所以我随意修改哪一个文件这两个文件的内容都会同步\n\n`test_soft.txt`则是创建源文件创建出来的软链接文件，他指向了文件`test.txt`，并且软链接文件的存储内容就是指向文件的文件名，大小也就是指向文件的文件名的大小\n\n![image-20230901101558329](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901101558329.png)\n\n现在我用`stat`命令看一下：\n\n硬链接文件之间所用的`Inode`号是相同的，他们都指向了同一个文件，并且他们的`Links`都是2，所以硬链接数也就是`2-1==1`，就是`test_hard.txt`文件\n\n软链接文件和源文件的`Inode`号不同，但是他存储了源文件的文件名和路径信息，可以很方便的找到源文件的位置，所以可以跨区建立\n\n![image-20230901102054279](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901102054279.png)\n\n### i 结点\n\n`i`结点包含了文件有关的所有信息，`stat`中的大部分信息都是来自`i`结点：**文件类型，文件访问权限位，文件长度和指向文件数据块的指针**等等，下面是一个图表示了磁盘中的存储结构：\n\n![image-20230901103020737](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901103020737.png)\n\n**目录项(放在磁盘中，和前面的文件共享的地方记得区分)中存放了两个重要的内容，就是文件名和i结点编号，因为目录项中的`i`节点编号指向同一文件系统中的相应`i`节点，而在其他文件系统当中，`i`结点的编号就不统一了，因此这也就是硬链接文件不能跨区建立的原因**\n\n**如果我们想对文件进行移动或者重命名，我们只需要把旧的文件目录项删除然后建立一个新的目录项指向对应的`i`结点就行了，磁盘中数据块的位置根本不用动，并且链接计数不会变；例如：我们把文件`/usr/lib/foo`重命名为`/usr/foo`，在我们的眼里就是移动了位置，如果`/usr/lib`和`/usr`在一个文件系统中，当然一般都是，foo的内容，也就是数据块位置不用移动，修改目录块的内容即可，就按照我前面所说的，就给了我们以为文件位置移动的假象**\n\n## 函数link，linkat，unlink，unlinkat和remove\n\n### link系列\n\n`link`系列函数可以用来给指定的文件项创建硬链接文件：\n\n**要注意一点，创建硬链接文件必须在同一个磁盘分区，也就是同一个文件系统中创建，否则i结点编号不统一就出问题了**\n\n**还有就是创建了硬链接文件之后，链接计数也需要加1，在`link`函数当中这是原子操作**\n\n~~~cpp\n#include <unistd.h>\n\nint link(const char *oldpath, const char *newpath);\n// oldpath：旧的目录项或者目录，newpath当然就是新的\n// 只有root用户才能对目录创建硬链接，当然不建议，因为有可能形成文件循环，所以我们一般不对目录创建硬链接\n// 创建硬链接必须在同一个磁盘分区\n\nint linkat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath, int flags);\n// 这个就是对已经打开的文件目录的基础上进行硬链接的创建\n// path如果是绝对路径，那么dirfd参数会被忽略\n// path如果是相对路径：dirfd指定为AF_FDCWD，那么对应的path就从当前工作目录的基础开始找；否则就从指定的目录开始找\n// flags：如果设置了AF_SYMLINK_NOFOLLOW，针对软连接文件创建硬链接，那么就是作用于该软链接文件本身，否则就是指向目标\n~~~\n\n#### 例子\n\n我们对目录中的文件分别用两个函数创建两个硬链接文件来熟悉用法\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    // link函数\n    int ret = link(\"07.txt\", \"07_1.txt\");\n    if (-1 == ret) {\n        perror(\"link\");\n        return -1;\n    }\n\n    // linkat函数\n    int dir_fd = open(\"./\", O_DIRECTORY);\n    if (-1 == dir_fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    ret = linkat(dir_fd, \"07.txt\", AT_FDCWD, \"07_2.txt\", 0);\n    if (-1 == ret) {\n        perror(\"linkat\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n可见成功了，这三个文件互为硬链接文件并且链接计数为3，用的是用一个`Inode`\n\n![image-20230901111815358](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901111815358.png)\n\n### unlink系列\n\n`remove`的功能和`unlink`相同，区别是`remove`是C标准的函数，`unlink`是系统调用\n\n**`unlink`相反就可以解除硬链接，他的机制是把链接计数减1，只有当减到0的时候才会删除该文件，删除文件指的是把文件的信息从磁盘中删除，在删除的过程可能我把文件最开始命名的文件删除了，这是正常的，因为其他硬链接的文件也指向同一块文件块，就相当于是变了个名字，这一点要理解，不存在源文件地位高一点什么的，都是平等的，只是名字不同**\n\n~~~cpp\n#include <unistd.h>\n\nint unlink(const char *pathname);\n// 删除一个现有的文件项，对应磁盘中i结点信息修改，链接计数-1，当链接计数减到0的时候，会把磁盘中关于该文件的数据块和其他信息删除\n\nint unlinkat(int dirfd, const char *pathname, int flags);\n// dirfd：打开的文件目录\n// pathname：分绝对路径和相对路径，dirfd的取值注意被忽略，还是打开的目录或者AF_FDCWD\n// flags：注意不会删除软链接指向的文件，而是删除软链接的文件本身！！！这一点和前面不同\n\t\t// 另外，如果设置了AF_REMOVEDIR，那么这个函数可以删除目录\n~~~\n\n我再强调一下，对于多个文件项，他们有不同的名字，但是他们对应的是同一个文件块，他们的数据部分是共享的，修改也是同步的\n\n**现在我用`unlink`函数把一个其中一个文件项删除，这个硬链接的文件项就被删除了，文件块对应的链接计数会减1，只有当所有的文件项都被删除了，也就是链接计数减到0，真实的文件块内容会被删除**\n\n**注意文件项和真实的文件块的区别，文件项就是我们看到的文件结构，但是这个真正存储的结构是不一致的，文件块就是磁盘当中保存这个文件的信息**\n\n#### 例子\n\n我们针对上面的例子继续编写代码\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    int ret = unlink(\"07.txt\");\n    if (-1 == ret) {\n        perror(\"unlink\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n当我执行`unlink`代码之后，`07.txt`文件项被删除了，同时文件块的链接计数变为了2，意思是我们仍然可以通过剩下的这两个文件项访问文件块的内容\n\n![image-20230901113952445](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901113952445.png)\n\n**另外，还有一个条件可以阻止程序删除文件块，就是进程打开了这个文件，其内容就不能删除；所以内核先检查有无进程打开这个文件，当打开的个数变成0，也就是没有进程打开的时候，再去检查文件的链接计数，为0则将其文件块的内容删除**\n\n## 函数rename和renameat\n\n这两个函数可以对文件或者目录进行重命名\n\n~~~cpp\n#include <stdio.h>\n\nint rename(const char *oldpath, const char *newpath);\n// 传入旧的文件名将其修改为新的\n\nint renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath);\n// dirfd：绝对路径的时候被忽略；相对路径根据是否AF_FDCWD判断是从工作目录开始还是从指定的目录开始\n~~~\n\n关于`rename`有几点需要注意：\n\n- **如果`oldpath`是一个文件而不是目录，那么就对该文件本身进行重命名，对于符号链接也是如此，对符号链接本身进行命名**\n\n  **在这种情况下，`newpath`肯定最好是一个目录里不存在的文件名，如果已存在，`newpath`肯定不能为一个目录，假如我们想要命名的`newpath`已经存在，就是重名，那么内核会将`newpath`的目录项删除并且将`oldpath`的文件重命名为`newpath`，这意味着原来叫`newpath`的文件会被删除，然后被替代**\n\n  当然我们要对两个文件项进行修改操作，肯定需要具有读写权限\n\n  我们通过代码来看：\n\n  ~~~cpp\n  #include <iostream>\n  using namespace std;\n  \n  int main() {\n      int ret = rename(\"08_1.txt\", \"08.txt\");\n      if (-1 == ret) {\n          perror(\"rename\");\n          return -1;\n      }\n  \n      return 0;\n  }\n  ~~~\n\n  在执行之前这是我的两个文件内容：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230901132559546.png\" alt=\"image-20230901132559546\" style=\"zoom:80%;\" />\n\n  执行过后，结果：\n\n  原`08.txt`已经被删掉，然后`08_1.txt`重命名为了`08.txt`\n\n  ![image-20230901132633366](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901132633366.png)\n\n  ![image-20230901132653264](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901132653264.png)\n\n- **如果`oldpath`是一个目录，`newpath`肯定最好也是一个名字不重复的新目录名字；如果重名了，那么这个目录需要是一个空目录才行，这时就会先把空目录删除然后将`oldpath`重命名，对于有内容的目录是不行的**\n\n  例如：`newpath`不能包含`oldpath`的路径前缀，比如把`/usr/foo`重命名为`/usr/foo/test`，因为会把`foo`目录删除然后再创建新目录，这显然是不对的\n\n  **不能对`./`目录和`../`目录重命名**，比如我不能打开一个目录，然后使用`./`给这个目录重命名，不可以的\n\n  我们同样写一个程序来看一下\n\n  此时我的目录中只有文件夹`test`，并且里面是空的\n\n  ~~~cpp\n  #include <iostream>\n  using namespace std;\n  #include <fcntl.h>\n  #include <unistd.h>\n  \n  int main() {\n      int dir_fd = open(\"../08/\", O_DIRECTORY);\n      if (-1 == dir_fd) {\n          perror(\"open\");\n          return -1;\n      }\n  \n      int ret = renameat(dir_fd, \"./test\", AT_FDCWD, \"./test2/\");\n      // int ret = renameat(dir_fd, \"./test\", AT_FDCWD, \"./test/test2/\");\n      if (-1 == ret) {\n          perror(\"rename\");\n          return -1;\n      }\n  \n      close(dir_fd);\n  \n      return 0;\n  }\n  ~~~\n\n  结果修改成功了，但是如果我尝试让`newpath`包含`oldpath`路径，就是注释的那段代码，就会报错：\n\n  ![image-20230901144324802](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901144324802.png)\n\n  当然我们也要试一下重命名成为一个有文件的目录，这里我创建一个目录`test2`，`test`目录里存放了一些文件\n\n  这是原来的目录tree：\n\n  ![image-20230901144650852](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901144650852.png)\n\n  代码：\n\n  ~~~cpp\n  #include <iostream>\n  using namespace std;\n  \n  int main() {\n      int ret = rename(\"test\", \"test2\");\n      if (-1 == ret) {\n          perror(\"rename\");\n          return -1;\n      }\n  \n      return 0;\n  }\n  ~~~\n\n  在空目录`test2`下，执行结果：\n\n  可见`test2`被删除，`test2`目录重命名并且文件也在，**当然文件块的位置和`i`结点没变，只是文件目录的命名变了**\n\n  ![image-20230901144731958](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901144731958.png)\n\n  现在我让`test2`加上数据，再来尝试：\n\n  ![image-20230901144925401](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901144925401.png)\n\n  执行结果：\n\n  函数返回了-1，错误信息说目录不为空，可见结果在预期内\n\n  ![image-20230901144951938](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901144951938.png)\n\n## 符号链接(软链接)\n\n符号链接是对一个文件的间接指针，它与硬链接有所不同，硬链接是一个文件块有多个文件项指向它，他们有着不同的命名，但是`Inode`是相同的，里面就存在这链接计数；而软链接就是指向一个文件或者目录的一个间接指针，主要是为了避开硬链接的一些限制：\n\n- **硬链接要求创建的硬链接文件在同一文件系统内，因为不在同一文件系统和分区，Inode不通用**\n\n- **在底层文件系统支持的前提下，只有超级用户能够创建指向目录的硬链接，其他的是不允许的，我的系统就不行**\n\n  我们为什么不推荐创建指向目录的硬链接或者软连接呢？\n\n  因为有可能发生循环，我们举个例子：\n\n  在我的09目录中存在空目录`test`，现在我在test目录中创建一个指向09目录的软连接文件\n\n  ![image-20230901151254437](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901151254437.png)\n\n  如下：\n\n  可见`foo`文件指向了外层目录09，这不就是一个循环吗？实际操作的过程中很可能就出现问题了\n\n  所以不少系统不允许用户创建指向目录的硬链接，即使是超级用户也不可以\n\n  ![image-20230901151357940](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901151357940.png)\n\n**对于符号链接，倒是并未有这些限制，任何用户都可以创建指向文件或者目录的软链接，只是我们要注意不要操作失误导致文件循环；但是也不是没有办法，我们可以用`unlink`函数消除，因为他是不跟随符号链接的，就可以删除链接文件本身；但是对于硬链接文件就不好办了，因为想要将其彻底删除得让链接计数为0，而且还是在卡入循环的情况下，这就更加复杂了，总之就是最好不要建对目录建立硬链接**\n\n### 跟随，不跟随软链接？\n\n以下是书上的图，它记录了大部分函数对软链接的处理：\n\n前面基本都提到过了\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230901151720798.png\" alt=\"image-20230901151720798\" style=\"zoom:80%;\" />\n\n## 创建和读取符号链接\n\n### symlink系列\n\n前面的`link`系列函数是用来创建硬链接，这里的`symlink`系列函数是用来创建软链接\n\n**值得注意的是，`target`路径可以不存在，这时仍然可以创建出来软链接，只是这个软链接文件失效**\n\n~~~cpp\n#include <unistd.h>\n\nint symlink(const char *target, const char *linkpath);\n// target路径想要被指向的路径，可以不存在；两个路径不需要在同一个文件系统中\n\nint symlinkat(const char *target, int newdirfd, const char *linkpath);\n// newdirfd：允许我们操作一个已经打开的想存放软链接文件的目录，AF_FDCWD表示从当前工作目录找起；如果是绝对路径将被忽略\n~~~\n\n#### 例子\n\n我们分别创建一个有效的和一个失效的软链接\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"./\", O_DIRECTORY);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 创建一个指向文件存在的\n    int ret = symlinkat(\"10.txt\", fd, \"10_1.txt\");\n    if (-1 == ret) {\n        perror(\"symlink\");\n        return -1;\n    }\n\n    // 创建一个指向文件不存在的\n    ret = symlink(\"11.txt\", \"10_1.txt\");\n    if (-1 == ret) {\n        perror(\"symlink\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n`10_1.txt`正常指向`10.txt`，但是`10_2.txt`指向了一个不存在的`11.txt`，虽然创建链接成功了，但是他是失效的\n\n![image-20230901153517526](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901153517526.png)\n\n当我们尝试通过软链接文件去查看指向文件的内容的时候，就会凸显出差异：\n\n失效的软链接文件`10_2.txt`指向了一个不存在的文件，读取不出来\n\n![image-20230901153642964](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901153642964.png)\n\n### readlink系列\n\n**当然上面的情况我们用`open`函数打开软链接文件也会出现类似的结果，失效的软链接文件没有办法打开，因为`open`函数是跟随符号链接的**\n\n**因此我们需要有一种方法来打开软链接文件本身，软链接文件里面就存储者指向文件的路径，我们就像把这个东西读取出来**，因此就有了`readlink`系列函数\n\n~~~cpp\n#include <unistd.h>\n\nssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);\n// 用buf接受读取到的数据，bufsize是buf的大小\n// 成功返回读取到的字节数，失败返回-1并且设置错误号errno\n\nssize_t readlinkat(int dirfd, const char *restrict pathname, char *restrict buf, size_t bufsize);\n// 经典dirfd，绝对路径忽略；相对路径AF_FDCWD从当前工作目录找起，否则从指定目录找起\n~~~\n\n#### 例子(续上)\n\n我们跟着上面的例子继续走，这时候我想要读取软链接文件`10_1.txt`存储的内容\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n\nint main() {\n    char buf[MAX_BUFFER_SIZE] = {0};\n\n    int len = readlink(\"10_1.txt\", buf, sizeof(buf) - 1);\n    if (-1 == len) {\n        perror(\"readlink\");\n        return -1;\n    }\n    printf(\"%s\\n\", buf);\n\n    return 0;\n}\n~~~\n\n结果：\n\n**里面就存储的是指向文件的路径，我们给的是相对路径，是因为链接文件和指向文件在同一目录下，下面会细讲**\n\n![image-20230901154605717](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901154605717.png)\n\n#### 软链接文件存储的内容(重要)\n\n从上面的例子我们看到，软链接文件存储的内容似乎是指向文件的名字，但是不是的，**软链接文件存储的其实是指向文件的路径**，记住，一定是路径，为什么？因为我要通过存储的内容其访问指向的文件，仅仅有个文件名字怎么可能呢？，下面我们来举例子说明：\n\n我在目录下面建立一个`a.txt`，和一个建立软链接文件的目录，这样我就把软链接文件和目标文件分开了：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230901155847954.png\" alt=\"image-20230901155847954\" style=\"zoom:80%;\" />\n\n现在我分别在soft目录中用三种方式创建软链接文件，名字，绝对路径和相对路径：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230901160019983.png\" alt=\"image-20230901160019983\" style=\"zoom:80%;\" />\n\n我们现在分别打开这三个文件来看下能否读出对应内容呢？\n\n2和3成功了，1失败了，这已经够明显了，**存储的是路径，访问他们的时候就是通过读取他们存储的路径内容去查找的，绝对路径从根目录开始找，相对路径就从该文件的目录开始找**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230901160110538.png\" alt=\"image-20230901160110538\" style=\"zoom:80%;\" />\n\n我们同样可以查看文件存储的大小来看一下他们是否存储的是路径，我就不写程序去readlink了\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230901160316403.png\" alt=\"image-20230901160316403\" style=\"zoom:80%;\" />\n\n**所以软链接文件存储的内容是指向的路径，这个路径在软链接文件和指向文件在同一目录的时候，命名就是相对路径，但是一旦分开，我建议用绝对路径，因为这样不管链接文件到哪里去，只要指向文件位置不变，就能找到**\n\n## 文件的时间\n\n对于每个文件维护了三个时间字段，在stat结构中可以获得：\n\n![image-20230901161513319](https://cdn.davidingplus.cn/images/2025/01/31/image-20230901161513319.png)\n\n我们要注意这分为两类时间，**一类是文件内容或者文件数据的时间，一类是`Inode`的时间；时间又可以分为两类，最后一次的访问时间和最后一次的修改时间，图中并没有维护`Inode`的最后访问时间，所以在`stat`和`access`获取文件属性和权限的时候并不会对`Inode`不会进行修改操作，不会更新`st_ctim`的值**\n\n然后我们要注意一下文件数据最后修改时间`st_mtim`和`Inode`最后更改时间`st_ctim`：\n\n**修改时间是文件内容最后一次被修改的时间，`Inode`最后修改时间也叫状态更改时间，因为`Inode`里面存储了文件的各种属性，stat函数获取stat结构体的数据大部分是来自于`Inode`的，有很多操作都能影响`Inode`，例如：更改文件的访问权限，更改用户ID，更改链接数等等，但是这些操作并没有修改文件数据块的内容；这也是因为`Inode`中的所有信息和文件的实际内容在磁盘中是分开存储的，这两者都有可能被修改，所以需要维护各自的最后修改时间**\n\n**我们一般称这三个时间(图中顺序)为：文件的访问，修改和状态更改时间**，因为用户一般不知道`Inode`，我们就称文件的状态更改时间\n\n下面是一个书上的一个表用来记录不同系统调用对这三个时间的是否修改：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230904105617965.png\" alt=\"image-20230904105617965\" style=\"zoom:80%;\" />\n\n## 函数futimens，utimesat和utimes\n\n一个文件的访问和修改时间(不是上面的第三个状态更改时间)可以由下面的系统调用修改\n\n~~~cpp\n#include <fcntl.h>\n#include <sys/stat.h>\n\nint futimens(int fd, const struct timespec times[_Nullable 2]);\n// fd：通过打开指定文件的文件描述符来进行修改\n// times：数组，类型是stat结构体中timespec结构体类型，第一个元素表示访问时间，第二个元素表示修改时间\n\t// 这两个时间是日历时间，也就是从1970年1月1日00:00:00到现在经过的秒数\n\nint utimensat(int dirfd, const char *pathname, const struct timespec times[_Nullable 2], int flags);\n// dirfd：老规矩，需要我们打开一个目录，open函数记得加上O_DIRCTORY\n// pathname：如果是绝对路径，dirfd参数被忽略；相对路径如果传入AF_FDCWD则从当前工作目录找起，否则从指定目录\n// times：同上\n// flags：设置AT_SYMLINK_NOFOLLOW，针对符号链接则作用于符号链接本身而不是指向文件\n~~~\n\n关于时间戳的设置值，给出书上的图进行理解：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230904111133258.png\" alt=\"image-20230904111133258\" style=\"zoom:80%;\" />\n\n同时，执行这些函数所要求的权限取决于`times`参数的值：\n\n我们都修改文件`stat`的内容了，那肯定我们进程肯定需要相应的权限才行啊，不然怎么保证安全\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230904111206863.png\" alt=\"image-20230904111206863\" style=\"zoom:80%;\" />\n\n我们来看另一个函数`utimes`\n\n~~~cpp\n#include <sys/time.h>\n\nint utimes(const char *filename, const struct timeval times[_Nullable 2]);\n// filename：就是指定的文件\n// times：数组，第一个参数是文件访问时间，第二个是文件修改时间\n\t// 它的类型和前面的不同，是timeval结构体\n\n// timeval结构体\nstruct timeval {\n\tlong tv_sec;        /* seconds */\n\tlong tv_usec;       /* microseconds */\n};\n~~~\n\n**注意，我们不能对文件的状态更改时间(`Inode`的最后修改时间)进行指定，因为我们在调用这些函数的时候，肯定修改了`Inode`的值，所以这个字段会自动更新**\n\n### 例子\n\n我们创建一个文件，然后过一段时间打开它，我们尝试修改他的访问时间和修改时间，具体如下：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n\nint main() {\n    // 11.txt文件是之前创建出来的，我们先获取它的信息，然后修改这个文件，然后再修改文件访问和修改时间看是否成功\n    struct stat stat_buf;\n\n    int ret = stat(\"11.txt\", &stat_buf);\n    if (-1 == ret) {\n        perror(\"stat\");\n        return -1;\n    }\n\n    // 获得两个修改时间\n    struct timespec last_visited = stat_buf.st_atim;\n    struct timespec last_modified = stat_buf.st_mtim;\n    struct timespec times[2] = {last_visited, last_modified};\n\n    // 修改文件，将其截断为0\n    int fd = open(\"11.txt\", O_RDWR | O_TRUNC);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 修改文件的访问时间和修改时间\n    ret = futimens(fd, times);\n    if (-1 == ret) {\n        perror(\"futimens\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n文件长度被截断为0，如果我们不修改，那么时间会被自动更新，但是我们修改了，成功：\n\n![image-20230904133117860](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904133117860.png)\n\n## 函数mkdir，mkdirat和rmdir\n\n### mkdir系列\n\n`mkdir`系列函数创建一个新的空目录，这个空目录里面会自动加入 `./` 和 `../` 目录项(很合理)\n\n~~~cpp\n#include <sys/stat.h>\n\nint mkdir(const char *pathname, mode_t mode);\n// pathname：需要创建的目录路径，相对路径或者绝对路径\n// mode：权限，八进制数；目录获得的实际权限要和umask屏蔽字想与\n// 返回值：成功0；失败-1并且修改errno\n\nint mkdirat(int dirfd, const char *pathname, mode_t mode);\n// dirfd：目录的文件描述符，open函数记得加上O_DIRECTORY\n// pathname：绝对路径的话dirfd将被忽略；相对路径的话dirfd若AF_FDCWD则从当前工作目录找起，不是则从指定的目录找起\n~~~\n\n### 目录的读和执行权限(复习)\n\n我们来复习一下目录的这两个权限，写权限不说了，就是用户可以向目录当中创建文件或者子目录\n\n**目录的读权限是指能够知道这个目录当中的所有文件名，我知道有哪些；**\n\n**目录的执行权限是指能够访问这个目录中的文件名，通过这个文件名找到对应的`Inode`，然后有机会访问文件，注意访问文件就和目录的权限没关系了**\n\n总结：\n\n- **目录读权限：表示用户可以用`ls`命令将目录下的具体子目录和文件罗列出来。**\n- **目录写权限：表示用户可以在该目录下可创建子目录或者文件。**\n- **目录执行权限：表示可以用`cd`进入该目录，知道里面有哪些文件**\n\n这两点需要格外注意\n\n### rmdir\n\n函数`rmdir`可以删除一个空目录，空目录就是目录项只有 `./` 和 `../` 的目录\n\n~~~cpp\n   #include <unistd.h>\n\n   int rmdir(const char *pathname);\n~~~\n\n#### 例子\n\n值得注意的是，只有目录为空才会删除，我们可以写一个程序来验证\n\n我们先用一个程序创建一个目录，然后创建一个文件；另一个进程就尝试删除这个目录\n\n~~~cpp\n// mkdir.cpp\n#include <iostream>\nusing namespace std;\n#include <sys/stat.h>\n#include <unistd.h>\n\nint main() {\n    // 创建一个新目录，这次我用绝对路径\n    int ret = mkdirat(-1, \"/mnt/d/Code/Cpp/为了工作/Linux/UNIX 环境高级编程/第4章-文件和目录/12/test\", 0664);\n    if (-1 == ret) {\n        perror(\"mkdirat\");\n        return -1;\n    }\n\n    // 调用exec函数族在目录里面创建一个文件\n    execlp(\"touch\", \"touch\", \"./test/12.txt\", nullptr);\n\n    return 0;\n}\n~~~\n\n执行过后目录项是这样：\n\n![image-20230904155757324](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904155757324.png)\n\n~~~cpp\n// rmdir.cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    // 尝试删除test文件夹\n    int ret = rmdir(\"test/\");\n    if (-1 == ret) {\n        perror(\"rmdir\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n可以看出没办法删除非空目录\n\n![image-20230904155841171](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904155841171.png)\n\n#### 补充\n\n**和文件一样，目录也存在链接(硬链接)，但是我们一般不建议这么做，只有部分操作系统并且是超级用户允许这么做，因为可能会发生文件循环；但是删除的机制是一样的，和文件类似，存在一个链接计数，删除目录是将链接计数减一并且将这一个名字的目录删除，我们以后没办法通过这个目录访问，但是我们可以用过其他名字的目录访问目录中的文件，只有当目录为空并且链接计数为0的时候才会真正释放这个目录块在磁盘上的空间；**\n\n**当然，如果遇到了删除的时候某些进程正在使用这个目录，那么并不立刻释放这个目录，这些进程仍然可以看到这些目录，但是没办法对这个目录进行后续操作了，当所有进程结束的时候就会释放掉这个目录块的内容**\n\n## 读目录\n\n**写目录就是对目录本身进行操作，和目录的写权限(可以创建子目录或者文件)不同，并且只有内核才能写目录，是为了防止文件系统紊乱**\n\n读目录和读文件类似，但是有区别，我们前面模拟实现过`ls -l`的命令，这里复习一遍里面的系统调用：\n\n### opendir\n\n如你所见，`Unix`提供给我们访问目录的`API`是`DIR`结构\n\n~~~cpp\n#include <sys/types.h>\n#include <dirent.h>\n\nDIR *opendir(const char *name);\n// 打开一个目录，返回一个可以操作目录的指针 DIR*\n\nDIR *fdopendir(int fd);\n// 类似，只不过是传入一个打开的目录的文件描述符\n~~~\n\n### readdir\n\n~~~cpp\n#include <dirent.h>\n\nstruct dirent *readdir(DIR *dirp);\n// 接受opendir返回的DIR流结构体指针，然后开始读取目录中的文件项\n// 这个函数一次只能读取目录中一个文件的dirent结构体，并且有偏移指针记录，读到末尾或者出错会返回nullptr\n\n// dirent结构体\nstruct dirent {\n   ino_t          d_ino;       /* Inode number */\n   off_t          d_off;       /* Not an offset; see below */\n   unsigned short d_reclen;    /* Length of this record */\n   unsigned char  d_type;      /* Type of file; not supported\n                                  by all filesystem types */\n   char           d_name[256]; /* Null-terminated filename */\n};\n// 这个结构体需要注意两个值，一个是类型是ino_t的d_ino，表示的是i结点的编号；另一个是d_name[]，就是文件名字\n// 我们是通过dirent结构体里面的Inode去寻找对应的文件块访问的\n\nint closedir(DIR *dirp);\n// 关闭打开的文件目录\n~~~\n\n### 其他函数\n\n~~~cpp\n#include <sys/types.h>\n#include <dirent.h>\n\nvoid rewinddir(DIR *dirp);\n// 设置目录流dirp目前的读取位置为目录流的起始位置\n\nlong telldir(DIR* dirp);\n// 获取目录流当前的读取当前位置(偏移量)，错误返回-1\n\nvoid seekdir(DIR *dirp, long loc);\n// 设置目录流的偏移量，下一次readdir将会从新位置开始读取\n~~~\n\n我本来准备写例子的，但是前面写过了模拟实现`ls -l`命令，这里就不写了，[点这里跳转过去](#ls -l)\n\n## 函数chdir，fchdir和getcwd\n\n### chdir系列\n\n我们一个进程执行的时候默认的工作目录就是进程可执行文件的存放目录，但是有时候我们想要更改目录怎么办呢？\n\n~~~cpp\n#include <unistd.h>\n\nint chdir(const char *path);\n// 更改当前的工作目录为path指向的路径\n\nint fchdir(int fd);\n// 给的参数是打开目录的文件描述符，记得open函数加上O_DIRECTORY\n~~~\n\n#### 例子\n\n我们通过终端启动一个程序，然后更改进程的工作目录干一些事情\n\n我的目录情况：\n\n![image-20230904170648902](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904170648902.png)\n\n代码：\n\n我想通过`chdir.cpp`程序去向`12.txt`中写入一些数据，当然我是通过修改工作目录来的，从`open`函数用的修改之后的相对路径就可以看出来\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n\nint main() {\n    chdir(\"./test\");\n\n    char buf[MAX_BUFFER_SIZE] = {0};\n\n    int fd = open(\"12.txt\", O_RDWR | O_TRUNC);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    while (1) {\n        static int count = 0;\n\n        bzero(buf, sizeof(buf));\n        sprintf(buf, \"hello, count: %d\\n\", count++);\n\n        write(fd, buf, strlen(buf));\n        sleep(1);\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n写入成功，没有问题\n\n![image-20230904170803393](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904170803393.png)\n\n#### 思考\n\n在这里我们通过`shell`终端启动了一个进程来修改工作目录，注意修改的工作目录只是这个进程的，我们终端的工作目录并没有修改哦，这一点从终端提示符或者`pwd`命令都可以看出来：\n\n![image-20230904170951129](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904170951129.png)\n\n并且，我最开始向通过向标准输出重定向，就是这样：\n\n~~~bash\n./chdir > 12.txt\n~~~\n\n**但是这样不行，就是因为我修改的是通过shell终端启动的进程的工作目录，不是shell终端本身，所以会失败；他会在我当前目录新建一个12.txt的文件来写入**\n\n所以我们可以怎么修改终端的工作目录呢？\n\n##### cd命令\n\n所以`cd`命令就自然而然被定义出来了，`cd`命令也就内建在`shell`中了，并且我们还无时不刻不在使用\n\n### getcwd\n\n我们上面通过pwd命令获得了工作目录的绝对路径，我们也可以通过系统调用来实现\n\n~~~cpp\n#include <unistd.h>\n\nchar *getcwd(char *buf, size_t size);\n// 获得当前的工作目录\n~~~\n\n他的实现思路如图：\n\n我来解释一下为什么要匹配`Inode`编号：\n\n**对于当前的目录，我们目录项中记录的是`./`，而不是目录名字，当前目录的名字是由上一级目录中保存的，但是二者的`Inode`是相同的(但是二者不是链接关系，是同一个，链接数也是1，`./`目录比较特殊)，这样查询就能找到当即目录的名字，循环反复遇到根就找到了**\n\n![image-20230904171646868](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904171646868.png)\n\n我后续一定要自己实现一下`getcwd`这个函数\n\n### 补充\n\n**`chdir`函数是要跟随符号链接的，因为我们可以很方便的通过符号链接找到另一个工作目录然后修改；**\n\n**`getcwd`函数不会跟随符号链接，他就返回当前目录的绝对路径**\n\n## 设备特殊文件(了解)\n\n这个不是很重要，我也没看懂，截图吧\n\n![image-20230904172357819](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904172357819.png)\n\n![image-20230904172404121](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904172404121.png)\n\n![image-20230904172411254](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904172411254.png)\n\n## 文件访问权限位小结\n\n如下：\n\n![image-20230904172514551](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904172514551.png)\n\n![image-20230904172520134](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904172520134.png)\n\n# 第五章 标准`I/O`\n\n这一章涉及到C标准库当中的内容，是在`Linux`操作系统之上进行的封装扩充，牛客`Linux`的课程没有涉及到，所以认真学\n\n不仅是UNIX，很多其他操作系统都实现了标准`I/O`库，这个库由`ISO C`标准进行说明\n\n**标准库的`I/O`处理了很多细节，比如缓冲区分配，以优化的块长度执行`I/O`等等，在系统调用的基础上使得用户的调用更加的方便和严谨安全；这些处理使得用户不用担心如何正确选择正确的块长度；但是我们也要深入了解以下标准`I/O`库函数的操作，以及是如何与系统调用联系起来的，否则出了问题不知道怎么办**\n\n## 流和FILE对象\n\n前面提到的`I/O`都是围绕文件描述符的，我们打开一个文件返回给我们一个文件描述符，然后我们通过对文件描述符对文件进行后续的操作；\n\n**但是对于标准`I/O`，所有的操作都是围绕流(`stream`)展开的，我们打开一个文件，标准`I/O`返回我们一个流用于进行和文件的关联**\n\n下面我们看一下单字节流和多字节流：\n\n- **对于ASCII字符集，一个字符用一个字节表示。对于国际字符集，一个字符可以用多个字节表示。标准`I/O`文件流可用于单字节或多(宽)字节字符集。流的定向决定了所读、写的字符是单字节还是多字节。**\n- **当一个流最初被创建时，它并没有定向。如若在未定向的流上使用一个多字节`I/O`函数，则将该流的定向设置为宽定向的。若在未定向的流上使用一个单字节`I/O`函数，则将该流的定向设置为字节定向的。**\n- **只有两个函数可以改变流的定向。`freopen`函数清除一个流的定向；`fwide`函数设置流的定向。**\n\n~~~cpp\n#include <wchar.h>\n\nint fwide(FILE *stream, int mode);\n// stream：打开文件返回的流对象\n// mode：不同的值有不同的作用\n\t// 0，则表示不试图设置流的走向，返回现在流走向的值\n\t// 正数，则表示试图设置流的走向为宽(多字节)走向\n\t// 负数，则表示试图设置流的走向为单字节走向\n// 返回值：返回设置之后的字节流走向(传入正数或者负数) 或者 现在流走向的值(传入0)\n~~~\n\n我们写一个程序来加深一下印象：\n\n代码中`fopen`是标准`I/O`库提供的打开文件的函数，其中第二个参数表示只读，对应`open`函数的`O_RDONLY`，这个后面再说\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <wchar.h>\n\nint main() {\n    FILE* file = fopen(\"01.txt\", \"r\");\n    if (nullptr == file) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    int ret = fwide(file, 100);\n    cout << ret << endl;\n\n    // 现在我在已经设置宽定向的基础上再设置一次\n    ret = fwide(file, -100);\n    cout << ret << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n返回1，文件刚打开的时候是未定向的流，标志值是0，然后我进行设置之后就返回宽定向的标志值，正数，这里返回了1；\n\n但是第二次我设置未单字节流，为什么还是返回1呢？**这表示我们尝试设置不成功，但是程序没有异常终止**，这就是这个函数的特性了\n\n![image-20230905200000664](https://cdn.davidingplus.cn/images/2025/01/31/image-20230905200000664.png)\n\n从上面我们可以看出，**`fwide`函数没有办法改变已定向流的定向，并且没有出错返回；**\n\n如果流无效的时候，我们该怎么办呢？我们可以在调用`fwide`之前，清除`errno`，然后执行函数之后检查`errno`的值，这个倒不算重要\n\n**另外，当我们用`fopen`打开一个文件时，返回给我们一个操作文件的流，这个流包含了`I/O`管理这个文件的所有信息，包括内核实际上使用的文件描述符，指向该流使用缓冲区(这个缓冲区是用户区的那个)的指针，缓冲区的长度，当前缓冲区的字符数以及出错的标志等等**\n\n### 单字节和多字节\n\n所以说了这么多，我们还是要区分一下单字节和多字节：\n\n- **单字节就是用一个字节就可以表示出所有的字符，也就是8位，也就是可以表示最多256个字符，这一点在英语当中是没有问题的，这也是ASCII字符集使用的字节表示方式**\n- **但是单字节没有办法统一表示国际上的所有字符，比如不同国家就有自己的字符，汉字也有自己的字符，所以这个时候单字节就显得少了，所以引入了多字节，多字节中又可以分为统一有多少个字节表示的标准和可以由一个或者多个字符表示的标准，但是这不是我们了解的重点；**\n- **重点是不同的标准下就对文件有了不同的编码，如果我们不使用统一的编码，文件中就很可能会出现乱码，现在普遍使用的编码方式就是`utf`-8，就是对应8位，单字节，对应的就是`ASCII`编码集；像`GB2312`这些就是多字节编码，我们后面都不考虑，只考虑单字节**\n\n## 标准输入，标准输出和标准错误(流)\n\n与文件描述符的0 1 2类似的，**内核对进程预定义了三个流，`stdin`，`stdout`和`stderr`**，这三个流就对应了系统调用中的文件描述符`STDIN_FILENO`，`STDOUT_FILENO`和`STDERR_FILENO`\n\n## 缓冲\n\n**标准`I/O`库提供缓冲的目的就是尽可能少的调用`write`和`read`函数，也是对每个`I/O`流自动进行缓冲管理，而不需要应用程序考虑这一点，可能带来麻烦。**\n\n### 缓冲区的目的（重要）\n\n当我们向文件中写入数据时，这是一个 I/O 的过程。I/O 的次数越多，那么时间浪费越多，效率越低。如果使用一个东西预先存储这些数据，先不将这些数据写入文件，而是当到达一定规模时统一写入文件，那么 I/O 的次数就会减少，进而效率提升。\n\n因此，**缓冲区存在的意义就是通过减少 I/O 次数达到效率上的提升**。\n\n更多细节请参考博客：[https://blog.csdn.net/weixin_61857742/article/details/127424052](https://blog.csdn.net/weixin_61857742/article/details/127424052)\n\n读了这篇文章以后，再来考虑一下读取数据的过程。和写入类似，为了减少 I/O 请求，读取的时候可能会一次性读取一大块数据到 I/O 缓冲区中。当用户请求读取的时候，优先查询缓冲区，如果有就可以有效的减少 I/O 操作了，而不用每次读取都从文件中读取。由于 I/O 缓冲区的数据和用户的存储结构都是在内存中，因此 fread() 执行以后，用户的存储结构的数据更新是实时的，而非 fwrite() 函数先写到 I/O 缓冲区中，需要 fflush() 才刷新。这和 fread() 首先就需要从文件中读取数据有关，也和 fread() 和 fwrite() 的语义不同有关。\n\n因此，理解到这里，应该知道，用户程序中的接收数组，例如 char[] 字符串最好不要叫做 buff 了，免得与 I/O 缓冲区相混淆。\n\n### 三种类型的缓冲\n\n标准`I/O`库提供了三种不同的缓冲：\n\n- 全缓冲\n\n  在这种情况下，**当缓冲区被填满之后才会进行相应的`I/O`操作**，比如读需要等缓冲区被写满了再去读，写需要等缓冲区被读完了再去写；**对于磁盘上的文件通常是由标准`I/O`库实现全缓冲的；对于一个流，第一次执行`I/O`操作的时候，通过`malloc`函数去获得其需要使用的缓冲区**\n\n  **当然我们可以手动的冲洗缓冲，冲洗(`flush`)这个术语用来说明标准`I/O`的写操作；缓冲区可以由标准`I/O`自动冲洗，比如缓冲区被填满的时候；我们也可以手动调用`fflush`函数冲洗一个流**\n\n  在UNIX中，冲洗有两种意思：**在标准`I/O`方面，表示将缓冲区的数据写到磁盘中(缓冲区可能是部分填满的)，在终端驱动程序方面，`flush`意味着丢弃存储在缓冲区的数据**，这个我们后面再说\n\n- 行缓冲\n\n  在这种情况下，**在输入和输出遇到换行符的时候**，标准库`I/O`自动执行相应的`I/O`操作；\n\n  **当流涉及一个终端的时候，就是标准输入和标准输出，通常对应的就是行缓冲**\n\n  我们写一个程序来验证：\n\n  ~~~cpp\n  #include <iostream>\n  using namespace std;\n  \n  int main() {\n      // cout << \"hello\";\n      printf(\"hello\");\n  \n      while (1)\n          ;\n  \n      cout << endl;\n  \n      return 0;\n  }\n  ~~~\n\n  结果：\n\n  可见标准输出对应的是行缓冲，当我把字符串和换行符分开，就没办法及时输出了，遇到换行符就会立即刷新缓冲区\n\n  ![image-20230906145510209](https://cdn.davidingplus.cn/images/2025/01/31/image-20230906145510209.png)\n  \n  注意：\n  \n  - **标准库`I/O`提供的行缓冲区大小是有限的，所以如果填满了缓冲区，即使没有换行符，也会进行`I/O`操作**(这里有点像上面的行缓冲)\n  - **任何时候通过标准`I/O`库从一个不带缓冲的流，或者一个行缓冲的流中得到输入数据，那么系统会冲洗缓冲区输出流进行输出**；对于第二个行缓冲，它可能需要从内核中读取数据，也可能不需要，因为数据可能在缓冲区中，但是对于不带缓冲的流肯定需要从内核的缓冲中获得数据\n  \n- 不带缓冲\n\n  **标准`I/O`库不对字符进行缓冲存储(内核中还有缓冲)，意思是我们希望数据尽快的输入或者输出**；例如我们调用`fputs`函数输出一些字符到不带缓冲的流当中，我们就期望这些数据能够尽快输出，这时候在底层很可能就调用了系统API的write进行后续操作\n\n  **标准错误stderr通常是不带缓冲的，因为错误信息应该尽可能快的显示出来，而不需要管他们有没有换行符**\n\nISO C标准要求缓冲有下列特征：\n\n- **标准输入和标准输入通常是行缓冲的，当且仅当他们不指向交互式设备(例如，键盘，鼠标，显示器等等)，才是全缓冲**\n- **标准错误绝不可能是全缓冲的**\n\n但是上面的说法并没有告诉我们，当标准输入和输出指向交互式设备的时候是行缓冲还是不带缓冲；标准错误是行缓冲还是不带缓冲，所以一般来说系统默认使用如下的缓冲：\n\n- **标准输入和标准输出，指向交互式设备的时候是行缓冲(例如在终端屏幕上输出信息)，否则就是全缓冲**\n- **标准错误是不带缓冲的**\n\n关于标准`I/O`缓冲后续会说的更具体\n\n### 函数setbuf和setvbuf\n\n对于一个流，系统一般会默认给流缓冲的方式，比如标准输入输出使用行缓冲默认定向到终端，如果我们想要修改可以通过如下的函数进行修改\n\n这两个函数的第一个参数都要求传入要给已经打开的流\n\n~~~cpp\n#include <stdio.h>\n\nvoid setbuf(FILE *restrict stream, char *restrict buf);\n// stream：想要修改的流\n// buf：我们用户手动指定的用户缓冲区，系统在输入输出的时候数据都是先到这里\n// 这个函数设置之后默认该流就是全缓冲的(一般是)，想要设置行缓冲或者不带缓冲需要用下面的函数\n// 当然如果buf传递的是nullptr，那么这个流会被设置未不带缓冲\n\nint setvbuf(FILE *restrict stream, char *restrict buf, int mode, size_t size);\n// 作用和上面的函数类似，但是有一些其他的功能\n// mode：使用这个函数，我们可以具体的设置缓冲类型，具体如下:\n\t// _IOFBF 全缓冲\n\t// _IOLBF 行缓冲\n\t// _IONBF 不带缓冲\n// 如果我们指定为全缓冲或者行缓冲，则buf和size我们可以指定选择一个缓冲区和大小\n// 系统给我们提供了一个默认的缓冲区大小的宏 BUFSIZ ，指是8192个字节\n// 当然我们指定这个流是带缓冲的，但是我们给的buf是nullptr，那么标准`I/O`会自动分配给该流适当长度的缓冲区，比如可以是BUFSIZ\n~~~\n\n我们可以用下面这个图进行更详细的总结他们的运作：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230907145440431.png\" alt=\"image-20230907145440431\" style=\"zoom:80%;\" />\n\n我们要知道，虽然我们指定了缓冲区的大小，但是缓冲区中还可能存放着他自己的管理操作信息，所以可以存放在当中的实际字节数要小于缓冲区的大小，这个并不是很重要，因为缓冲区的大小一般都是往上开够用了\n\n**一般而言，我们可以让系统自己选择缓冲区的长度，然后自动分配缓冲区，这样关闭流的时候，标准`I/O`库会自动释放缓冲区**\n\n### 函数fflush\n\n任何时候，我们都可以强制冲洗一个流\n\n**这个函数会让所有未写的数据都被送至内核当汇总(内核中也有缓冲区，然后就可以进行后续的操作)**\n\n**如果传递的是`nullptr`，那么所有输出流都会被冲洗**\n\n~~~cpp\n#include <stdio.h>\n\nint fflush(FILE *stream);\n~~~\n\n### 例子\n\n#### 全缓冲\n\n我们写一个例子来实际操作一下\n\n在这个程序当中，我将标准输出的缓冲区定向为我设置的`outbuf`数组，然后分两次`puts`一些内容；然后刷新，然后再写\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nchar outbuf[BUFSIZ];  // BUFSIZ是指默认给的缓冲区大小，是8192个字节\n\nint main() {\n    setbuf(stdout, outbuf);  // 把缓冲区与流相连\n\n    puts(\"This is a test of buffered output.\");  // puts最后会自带一个换行符\n    puts(outbuf);                                // 这里我除了写入自定义字符串，我把outbuf的内容也写一遍，所以会有两个换行符\n\n    sleep(3);\n\n    fflush(stdout);  // 刷新\n\n    puts(\"This is a test of buffered output.\");\n\n    sleep(3);\n\n    return 0;\n}\n\n~~~\n\n结果：\n\n前面三行(包括第三行的空行)经过3秒输出，最后一行又经过3行输出，符合我们的预期\n\n我们可以看出这里的`setbuf`给我们的是全缓冲\n\n![image-20230907150903812](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907150903812.png)\n\n#### 不带缓冲\n\n下面我给一个不带缓冲的例子\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    setvbuf(stdout, nullptr, _IONBF, 0);\n\n    puts(\"This is a test of buffered output.\");  // puts最后会自带一个换行符\n\n    sleep(3);\n\n    fflush(stdout);  // 刷新\n\n    puts(\"This is a test of buffered output.\");\n\n    sleep(3);\n\n    return 0;\n}\n~~~\n\n结果：\n\n这两行都是执行`puts`函数之后立即输出的，可以看出不带缓冲\n\n![image-20230907151214997](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907151214997.png)\n\n#### 行缓冲\n\n那怎么能少了行缓冲呢？还是全缓冲的例子，我这次设置为行缓冲\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nchar buf[BUFSIZ] = {0};\n\nint main() {\n    setvbuf(stdout, buf, _IOLBF, sizeof(buf));\n\n    puts(\"This is a test of buffered output.\");  // puts最后会自带一个换行符\n\n    sleep(3);\n\n    fflush(stdout);  // 刷新\n\n    puts(\"This is a test of buffered output.\");\n\n    sleep(3);\n\n    return 0;\n}\n~~~\n\n结果：\n\n由于`puts`会自带一个换行符，所以也是立即输出的\n\n![image-20230907151444480](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907151444480.png)\n\n## 打开流\n\n我们可以用以下的函数来打开一个标准`I/O`流\n\n~~~cpp\n#include <stdio.h>\n\nFILE *fopen(const char *restrict pathname, const char *restrict mode);\n// 打开指定路径的文件，返回用于操作的标准I/O流，可以是绝对或者相对路径\n\nFILE *fdopen(int fd, const char *mode);\n// 通过一个已有的文件描述符，并用一个标准的I/O流和该文件描述符进行结合，让我们可以通过流的方式操作文件描述符\n// 但是为什么我们不直接打开文件呢？因为这个函数主要是用于一些特殊的文件描述符的，比如创建管道和创建socket套接字获得的文件描述符，这些文件描述符没有路径，所以我们可以通过fdopen来与之结合\n\nFILE *freopen(const char *restrict pathname, const char *restrict mode, FILE *restrict stream);\n// 一般用来重定向标准输入，标准输出和标准错误(重要！)\n// 意思是我们可以把输出到终端的数据输出到文件中；把从终端中输入变为从文件中输入读取\n// pathname：我们指定的文件，可以替代标准输出的位置和标准输入的来源\n~~~\n\n上面的`mode`参数是一个字符串类型，用于指定标准`I/O`流的读写方式，具体如下图，他们和**文件状态标志**对应：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230907152718910.png\" alt=\"image-20230907152718910\" style=\"zoom:80%;\" />\n\n书上还给出了一些注意事项，如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230907153412560.png\" alt=\"image-20230907153412560\" style=\"zoom:80%;\" />\n\n### 例子\n\n打开文件返回标准`I/O`流的例子就不写了，这里写一个重定向标准输入和标准输出的例子\n\n这里我从文件中读取数据并经过简单计算然后写入另一个文件\n\n**注意打开之后需要关闭，这里就是关闭标准输入和输出，注意最好是在程序末尾，不然关闭了之后就没办法正常输入输出了**，下面也给出了具体说明\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // 重定向stdin和stdout\n    freopen(\"03_src.txt\", \"r\", stdin);\n    freopen(\"03_dest.txt\", \"w\", stdout);\n\n    int a, b;\n    cin >> a >> b;\n\n    cout << a + b << endl;\n\n    // 关闭重定向的标准输入输出流，注意放在末尾，不然关了之后标准输入输出用不了\n    fclose(stdout);\n    fclose(stdin);\n\n    cout << \"hello\" << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n确实关闭了之后`hello`没有打印出来\n\n![image-20230907153827144](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907153827144.png)\n\n### 其他注意事项(了解)\n\n我就放书上的图了\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230907154448173.png\" alt=\"image-20230907154448173\" style=\"zoom:80%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230907154453879.png\" alt=\"image-20230907154453879\" style=\"zoom:80%;\" />\n\n### 函数fclose\n\n我们可以用`flose`函数来关闭一个打开的流，这也是为什么前面关闭之后就没办法打印到终端了\n\n~~~cpp\n#include <stdio.h>\n\nint fclose(FILE *stream);\n~~~\n\n注意：\n\n- **在文件关闭之前，系统会自动冲洗输出缓冲中的所有数据，然后进行输出；输入缓冲区中的所有数据将被丢弃**\n- **如果标准I/O库已经为该流自动分配了一个缓冲区，那么系统会自动释放该缓冲区**\n- **同样当一个进程终止或者结束的时候，也会自动冲洗输出缓冲中的所有数据，输入缓冲区的数据会被丢弃；所有打开的标准I/O流都会被关闭**\n\n## 读和写流\n\n一旦打开了流，我们有三种不同的方式的非格式化`I/O`进行选择，然后进行读写操作：\n\n- **每次一个字符的`I/O`，意思是一次读写一个字符；如果流是带缓冲的，那么标准`I/O`会处理缓冲**\n- **每次一行的`I/O`，我们可以借助标准`I/O`函数`fgets`和`fputs`来实现，每行都以一个换行符终止**\n- **直接`I/O`，每次`I/O`操作的时候读或者写指定的对象，这个对象具有一定的长度；比如`fread`函数和`fwrite`函数，他们可以让底层的`read`和`write`函数调用次数更少，因此执行效率更高**\n\n### 输入函数\n\n#### getc系列\n\n以下的函数可以用于一次读一个字符\n\n~~~cpp\n#include <stdio.h>\n\n// getc和fgetc都可以用于从一个流当中读取一个字符\n// 区别是：getc可以被实现为宏，fgetc不可以\nint getc(FILE *stream);\n// 返回值：由于我们使用的编码是utf-8，所以是单字节定向，对应的是ASCII码集，返回的值是int类型，也就是字符的ASCII码值\n// 当读取到文件末尾或者发生错误的时候，返回EOF，EOF是标准I/O定义的一个宏，值为-1\n\nint fgetc(FILE *stream);\n// 除了上面的一个区别其他相同\n\nint getchar(void);\n// 等效于getc(stdin); 就不赘述了\n~~~\n\n所以和`read`函数类似的，我们要检验读取到文件末尾，**但是这里不同的是当读取到文件末尾或者发生错误的时候这三个函数都返回相同的值，都是`EOF`**，所以我们要想办法区分\n\n#### 函数ferror和feof\n\n这两个函数就是用来检测到底是发生错误还是读取到末尾了；\n\n**标准`I/O`为每个`FILE`对象维护了两个标志，也就是出错标志和文件末尾标志，他们就可以分别被下面的`ferror`和`feof`来获得**，这样我们就可以判断到底是什么状况\n\n~~~cpp\n#include <stdio.h>\n\n// 获得文件的出错标志 1真 0假\nint ferror(FILE *stream);\n\n// 获得文件末尾标志 1真 0假\nint feof(FILE *stream);\n\n// 可以清除这两个标志\nvoid clearerr(FILE *stream);\n~~~\n\n#### 例子\n\n我们写一个程序来实操一下\n\n我们做两次测试，一次正常读完，一次读取出错，如下所示：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // 复习一下，将标准输入重定向\n    freopen(\"04.txt\", \"r\", stdin);\n    // freopen(\"05.txt\", \"r\", stdin);\n\n    int ret;\n    while (EOF != (ret = getc(stdin)))\n        cout << (unsigned char)ret;\n\n    // 我们来看一下EOF对应的是哪个状态\n    if (ferror(stdin))\n        cout << \"ferror: read error\" << endl;\n    if (feof(stdin))\n        cout << \"feof: end of file\" << endl;\n\n    // 关闭\n    fclose(stdin);\n\n    return 0;\n}\n~~~\n\n结果：\n\n正常读完\n\n![image-20230907170621432](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907170621432.png)\n\n读取错误\n\n![image-20230907170649491](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907170649491.png)\n\n#### 函数ungetc\n\n**当从流当中读取数据之后，我们可以调用`ungetc`把字符压回流当中**\n\n这里我准备从一个文件当中读取数据，然后读取之前我压入了一些字符到流中\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // 打开一个文件\n    FILE* file_stream = fopen(\"04.txt\", \"r\");\n\n    // 先压入几个字符\n    for (int i = 0; i < 10; ++i)\n        ungetc((int)'a' + i, file_stream);\n\n    int ret = EOF;\n    while (EOF != (ret = getc(file_stream)))\n        cout << (unsigned char)ret;\n\n    return 0;\n}\n~~~\n\n结果：\n\n**我压入的顺序是`a`到`j`，但是输出的顺序是`j`到`a`，可以压入和输出的关系是一个栈的关系，这一点注意一下**\n\n![image-20230907171454664](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907171454664.png)\n\n注意：\n\n- **我们不能回送`EOF`，因为下一次就读到他表示错误或者文件结束，但是其实并没有，就会出问题**\n- **当读取到文件末尾的时候，我们可以回送一个字符，这样下次就会读取这个字符，再次读就会返回`EOF`，之所以能这样做是一次成功的`ungetc`会调用`clearerr`函数清除两个标志，因为压入之后这两个标志应该会不存在**\n\n### 输出函数\n\n对应上面的输入函数，也有一个输出函数，就是一次输出一个字符到输出缓冲区\n\n~~~cpp\n#include <stdio.h>\n\n// 完全和上面的对应，这里就不写了\nint fputc(int c, FILE *stream);\nint putc(int c, FILE *stream);\nint putchar(int c);\n~~~\n\n**`putc`函数和`ungetc`函数都可以向流中写数据，`putc`一次写一个字符到输出流缓冲区中，`ungetc`和他的区别大了，他是往读取缓冲区写，这样读的时候就会先读取我写的数据，注意如果不加设置为不带缓冲他们会先写到缓冲区当中**\n\n#### 例子\n\n我们用一个程序深刻理解上面的意思\n\n这里我打开一个文件用读和追加的方式打开，然后向文件中写数据，我人为指定为全缓冲，由系统给我分配，然后写完我休眠几秒，然后再读取，我们看一下程序的结果\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    // 打开一个文件\n    FILE* file_stream = fopen(\"04.txt\", \"a+\");\n\n    setvbuf(file_stream, nullptr, _IOFBF, 0);\n\n    // 先写入几个字符\n    for (int i = 0; i < 10; ++i)\n        putc((int)'a' + i, file_stream);\n\n    // 最后写一个换行符\n    putc((int)'\\n', file_stream);\n\n    sleep(5);\n\n    // 重置文件偏移量指针\n    fseek(file_stream, 0, SEEK_SET);\n\n    int ret = EOF;\n    while (EOF != (ret = getc(file_stream)))\n        cout << (unsigned char)ret;\n\n    return 0;\n}\n~~~\n\n结果：\n\n**程序睡了5秒之后才输出，这也证明了是数据是先到缓冲区当中了，然后后面调用了`fseek`或者`getc`函数刷新了缓冲区，因此就能正常读到数据，注意这里`putc`和`getc`使用的都是系统给我分配的全缓冲，我们在两次操作之间缓冲区被冲洗了；最后输出到终端上用的标准输出的行缓冲，这个与上面无关**\n\n![image-20230907173421891](https://cdn.davidingplus.cn/images/2025/01/31/image-20230907173421891.png)\n\n## 每行一行I/O\n\n### 每次输入一行(fgets系列)\n\n下面的函数提供了每次输入一行的功能\n\n~~~cpp\n#include <stdio.h>\n\n// 这两个函数都制定了缓冲区的地址，然后将读到的行送到buf中\n// fgets函数可以指定从指定的流读取\nchar* fgets(char* restrict buf, int n, FILE* restrict fp);\n\n// gets从标准输入读\nchar* gets(char* buf);\n~~~\n\n注意：\n\n- **注意这里`buf`是我们存储数据的地方，不是缓冲区，就像`read`函数需要`buf`来存放数据一样，缓冲区需要我们指定大小，就是`n`，如果我们没用`setvbuf`设置缓冲区的属性，那么默认就由系统给我们分配，然后程序结束系统给我们回收(这里要理解好)**\n- **对于`fgets`，我们必须指定缓冲区的长度，这个函数直到读到下一个换行符为止，由于字符串的末尾有一个`'\\0'`符号，所以我们实际上只能读取到`n-1`个字符，这也是标准`I/O`为我们提供的保护；但是如果该行包括最后一个换行符超出了`n-1`个字符，则`fgets`只返回一个不正常的行，但是缓冲区只以`null`字节结尾，下一次的调用会从这里继续**\n\n- **我们不推荐使用`gets`函数，因为他没有手动指定缓冲区的大小，这就可能造成缓冲区溢出，然后导致内存泄漏，这一点的危害是致命的，所以我们不推荐，而且它也很局限，只能从标准输入中读取**\n\n#### 例子\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    FILE* file_stream = fopen(\"05.txt\", \"r\");\n    if (!file_stream) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    char buf[1024] = {0};\n\n    fgets(buf, 5, file_stream);  // 如果读的数据超过缓冲区大小，那么最后一个字符会留为'\\0'，然后冲洗缓冲区到buf当中\n\n    cout << buf;\n\n    sleep(5);\n\n    return 0;\n}\n~~~\n\n结果：\n\n程序睡了五秒之后然后输出，为什么只有4个字符？**因为缓冲区满了，但是他会留出末尾一个'\\0'符号，然后送到存储位置`buf`中**，然后由于标准输出是行缓冲，没有换行符，所以就睡了五秒再输出\n\n![image-20230909093226773](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909093226773.png)\n\n### 每次输出一行(fputs系列)\n\n~~~cpp\n#include <stdio.h>\n\nint fputs(const char *restrict s, FILE *restrict stream);\n// 将一个以null字节结尾的字符串写入到指定的流，尾部的null('\\0')不写出\n// 注意，这个函数的判断是以null字节，他不会在末尾给你补上换行符'\\n'\n// 还有，是把这个字符串写到目标流的缓冲区中，那什么时候写入就需要看流是什么缓冲了\n// 通常我们都喜欢在null字节前，放一个回车换行符'\\n'\n\nint puts(const char *s);\n// 写到标准输出，并且在后面自带一个换行符，可能是写到标准输出默认写道终端，换行更美观\n// 我们尽量避免使用puts函数，虽然他并不像gets可能让缓冲区爆掉，因为这样我们就可以不用关心是否需要手动写一个换行符\n// 但是有时候我们打印一行数据用puts还是挺香的\n~~~\n\n#### 例子\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    const char* str = \"helloworld\";\n\n    fputs(str, stdout);  // 不带换行符\n\n    sleep(3);\n\n    puts(str);  // 自带换行符\n\n    return 0;\n}\n~~~\n\n结果：\n\n程序睡了3秒输出，因为标准输出是行缓冲，`fputs`函数输出的字符串不带回车符，`puts`带有\n\n![image-20230909095214017](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909095214017.png)\n\n## 二进制I/O\n\n上面的函数以一次一个字符或者一次一行进行操作，如果我们进行二进制I/O操作，那么我们更愿意一次读写一个完整的结构\n\n- **如果使用`getc`和`putc`函数，那么我们一次只能读或者写一个字符，必须通过循环进行整个结构的读写；**\n- **如果使用`fputs`和`fgets`函数，`fgets`函数遇到换行符'\\n'或者缓冲区满或者遇到`null`字节会停止，`fputs`函数遇到null字节就会停止，这样想要读完也要循环，也是相对比较麻烦的**\n\n因此类似于系统调用的`read`和`write`函数，我们这里有两个二进制`I/O`操作可以读取一个完整的结构\n\n~~~cpp\n#include <stdio.h>\n\nsize_t fread(void *restrict ptr, size_t size, size_t count, FILE *restrict stream);\n\nsize_t fwrite(const void *restrict ptr, size_t size, size_t count, FILE *restrict stream);\n// 参数：\n\t// ptr：要存放读取数据的存储区或者写出数据的数据来源区\n\t// size：读取或者写入的数据单元的大小，我们一般读文件都是读字符串，然后就给char的大小1就好\n\t// count：需要读或者写的大小，读的话我们不知道stream的数据有多大，可以给存储区ptr的大小，这也说明了返回值小于count不一定是错误，也有可能是文件读到末尾了，因为我们事先不知道stream的数据有多大；写的话就给ptr数组数据的个数就好了，如果不相等就是错误\n\t// stream：标准I/O文件流\n~~~\n\n这两个函数的作用在下面给出：\n\n- 有两种常见的用法：\n\n  - **读或者写一个二进制数组**\n\n    ![image-20230909103740225](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909103740225.png)\n\n  - **读或者写一个结构**\n\n    ![image-20230909103759521](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909103759521.png)\n\n  **这两种用法其实有相同的地方，第一个参数传入的是想要读或者写入的结构单位，第二个参数传入的是这个单位的大小，第三个参数传入的是想要读或者写的个数，第四个参数给定的是指定的流，当然首先是读入或者写入缓冲区，后面根据情况判断什么时候才会到达目标位置**\n\n- 这两个函数**返回读或者写的对象个数**\n\n  - **对于读，如果出错或者到达文件末尾，返回的值不为`count`，这个时候可以用`ferror`或者`feof`来判断是哪一种情况**\n  - **对于写，如果返回的值不为`count`，那么就是出错了**\n\n### 例子\n\n第一个例子，我们把一些二进制数据和结构进行标准输出\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <string>\n\nstruct Person {\n    string name;\n    string sex;\n    double height;\n    double weight;\n};\n\nint main() {\n    // 将二进制数组的一些元素写到标准输出\n    char data[10] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'};\n\n    fwrite(&data[2], sizeof(char), 3, stdout);\n\n    puts(\"\");  // 输出一个空行\n\n    // 写一个结构到标准输出\n    Person p{\"Paul\", \"boy\", 190, 88.5};\n\n    fwrite(&p, sizeof(p), 1, stdout);\n\n    puts(\"\");  // 输出一个空行\n\n    return 0;\n}\n~~~\n\n结果：\n\n**字符串是可以正常输出的**，其他类型的数据可能因为编码或者类型问题会出现乱码，但是我们一般都是处理字符串，所以问题不大\n\n![image-20230909105848043](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909105848043.png)\n\n第二个例子，我们从文件当中读取数据，然后输出，注意体会第二个参数`size`和第三个参数`count`的含义\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n\n#define MAX_BUFFER_SIZE 1024\n\nint main() {\n    // 从06.txt中读取数据，然后输出到屏幕上\n    FILE* file_stream = fopen(\"06.txt\", \"r\");\n    if (!file_stream) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    char buf[MAX_BUFFER_SIZE] = {0};\n    // 读到buf中\n    fread(buf, 1, sizeof(buf), file_stream);\n\n    // 标准输出\n    int ret = fwrite(buf, 1, strlen(buf), stdout);\n    if (ret != strlen(buf)) {\n        perror(\"fwrite\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n结果：\n\n**我们读取和写出的单位都是字符，所以`size`给的是1，读取的时候不知道`stream`数据到底有多少，所以我们给大一点，可以给`buf`数据区的大小，所以返回值不为count有可能是读到末尾或者失败；写的时候就给`buf`的实际长度。**\n\n**注意，`buf`可不是`file_stream`的读写缓冲区，`buf`是我们指定的存储数据的地方，从写之后`strlen(buf)`不为0这一点也可以看出来**\n\n![image-20230909110026630](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909110026630.png)\n\n注意`fread`，`fwrite`函数和`read`，`write`函数的联系和区别，他们的使用方式还是有区别的\n\n## 定位流\n\n有三种方法定位I/O流，如下图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230909110812555.png\" alt=\"image-20230909110812555\"  />\n\n我们了解下面的函数即可：\n\n~~~cpp\n#include <stdio.h>\n\nlong ftell(FILE *stream);\n// 返回当前文件位置的偏移量，错误则返回long(-1)，并且修改错误号\n\nint fseek(FILE *stream, long offset, int whence);\n// 和lseek函数一样，可以设置文件偏移量指针\n// 第一个参数是文件流指针，第二个参数是我们给的偏移量，这个偏移量可正可负，也就是说，我们的指针可以往前移\n\n// 第三个参数`whence`：\n\t// - `SEEK_SET` 设置偏移量，从头开始\n\t// - `SEEK_CUR` 设置偏移量：当前位置 + 第二参数`offset`的值\n\t// - `SEEK_END` 设置偏移量：文件大小 + 第二参数`offset`的值\n\n// 返回值是文件指针的新位置，失败返回-1并且修改`errno`\n\nvoid rewind(FILE *stream);\n// 移动文件指针到开头\n~~~\n\n还有两个函数，他们除了类型和前面的函数不一样之外，是off_t，其他相同，但是我们还是倾向于用上面的函数：\n\n~~~cpp\n#include <stdio.h>\n\ntypedef long off_t\n\n// 这里的类型是off_t，前面是long\noff_t ftello(FILE *stream);\n\nint fseeko(FILE *stream, off_t offset, int whence);\n~~~\n\n### 例子\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\n#define MAX_BUFFER_SIZE 1024\n\nint main() {\n    FILE* file_stream = fopen(\"07.txt\", \"r\");\n    if (!file_stream) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    long pos = ftell(file_stream);\n    cout << pos << endl;\n\n    // 现在我读取一个字符\n    char buf[MAX_BUFFER_SIZE] = {0};\n    fread(buf, 1, 1, file_stream);\n\n    cout << buf << endl;\n    pos = ftell(file_stream);\n    cout << pos << endl;\n\n    // 设置文件偏移指针到开头\n    // rewind(file_stream);\n    fseek(file_stream, 0, SEEK_SET);\n\n    fread(buf, 1, 2, file_stream);  // 这里第二次读从buf的地址位置开始写入，所以之前的数据会被覆盖\n\n    cout << buf << endl;\n    pos = ftell(file_stream);\n    cout << pos << endl;\n\n    return 0;\n}\n~~~\n\n注意里面第二次fread的注释，为什么会被覆盖\n\n结果：\n\n显然在我们的预期内\n\n![image-20230909113626829](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909113626829.png)\n\n## 格式化I/O\n\n### 格式化输出\n\n#### printf系列\n\n格式化`I/O`是通过`printf`系列函数来处理的\n\n~~~cpp\n#include <stdio.h>\n\n// 将格式化数据写到标准输出\nint printf(const char *restrict format, ...);\n\n// 将格式化数据写到指定的流\nint fprintf(FILE *restrict stream, const char *restrict format, ...);\n\n// 将格式化数据写到指定的文件描述符\nint dprintf(int fd, const char *restrict format, ...);\n\n// 前三个函数成功返回输出字符数，如果输出错误，返回负值\n\n// 将格式化数据写到我们指定的buf存储区\nint sprintf(char *restrict buf, const char *restrict format, ...);\n// 成功返回输入的字符数，如果编码错误，返回负值\n\n// 为了避免sprintf函数可能造成的buf装满而爆掉，引入了snprintf函数，需要给出指定的长度\nint snprintf(char *restrict buf, size_t size, const char *restrict format, ...);\n// 如果给定的size足够大，返回将要存入数组的字符数，如果编码错误，返回负值\n~~~\n\n#### 格式化标准\n\n这显然就涉及到格式化的标准了，当然这里需要我们自己进行对数据进行合适的格式化处理\n\n这些标志其中括号里面是可选的，`convtype`是不可选的，如下图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230909142120139.png\" alt=\"image-20230909142120139\" style=\"zoom:80%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230909142131548.png\" alt=\"image-20230909142131548\" style=\"zoom:80%;\" />\n\n![image-20230909142140609](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909142140609.png)\n\n#### vprintf函数(了解)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230909144901212.png\" alt=\"image-20230909144901212\" style=\"zoom: 80%;\" />\n\n### 格式化输入\n\n#### scanf系列\n\n以下几个函数用作格式化输入\n\n~~~cpp\n#include <stdio.h>\n\n// 从标准输入中读取\nint scanf(const char *restrict format, ...);\n\n// 从标准输入中读取写入流中(是先写入流缓冲区中)\nint fscanf(FILE *restrict stream, const char *restrict format, ...);\n\n// 从标准输入中读取写入字符串str中\nint sscanf(const char *restrict str, const char *restrict format, ...);\n~~~\n\n这几个函数返回值我们可以不用判断，判断了也没有什么作用，所以只提一嘴：返回赋值的输入项数，若输入出错或者在任一转换之前已经到达文件末端，则返回EOF\n\n#### 格式化标准\n\n同前面，截图：\n\n![image-20230909145428023](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909145428023.png)\n\n![image-20230909145440049](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909145440049.png)\n\n#### vscanf系列(了解)\n\n![image-20230909145502533](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909145502533.png)\n\n![image-20230909145508121](https://cdn.davidingplus.cn/images/2025/01/31/image-20230909145508121.png)\n\n## 实现细节\n\n在标准I/O中，每一个标准I/O流都对应着一个与其相关联的文件描述符，我们可以调用以下函数来进行获得\n\n~~~cpp\n#include <stdio.h>\n\nint fileno(FILE *stream);\n~~~\n\n### 例子\n\n我们写个程序简单看一下\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    FILE* file_stream = fopen(\"07.txt\", \"r\");\n    if (!file_stream) {\n        perror(\"fopen\");\n        return -1;\n    }\n\n    int fd = fileno(file_stream);\n    if (-1 == fd) {\n        perror(\"fileno\");\n        return -1;\n    }\n\n    printf(\"file descriptor: %d\\n\", fd);\n\n    return 0;\n}\n~~~\n\n结果：\n\n应该返回文件描述符的值是3，结果是，符合预期\n\n![image-20230911103808954](https://cdn.davidingplus.cn/images/2025/01/31/image-20230911103808954.png)\n\n我们这里再复习一下，标准错误默认是不带缓冲的，因为我们想要错误信息尽快显示到屏幕上，而不是关心是否具有换行符；标准输入和输出在连接到终端的时候默认是行缓冲的，如果定向到文件就是全缓冲\n\n## 临时文件(了解)\n\n### tmpnam系列\n\n有两个库函数可以用来帮助创建临时文件\n\n~~~cpp\n#include <stdio.h>\n\nchar *tmpnam(char *s);\n// tmpnam函数产生一个与现有文件名不同的一个有效路径名字符串，给的是路径名字\n// 每次调用的时候都产生一个不同的路径名，最多的次数是TMP_MAX(238328)\n// 现在tmpnam函数已经被弃用了，所以在使用的时候会报警告，但是能用，不推荐使用\n// 在文件关闭或者程序结束的时候就自动删除这个临时文件\n\nFILE *tmpfile(void);\n// 用来创建一个二进制临时文件，同样在文件关闭或者程序结束的时候就自动删除这个临时文件\n// UNIX对二进制文件不做区分\n~~~\n\n#### 例子\n\n我们先写一个关于tmpnam的例子\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char name[1024] = {0};\n\n    // c++使用这个函数会被警告说不安全，tmpnam函数返回一个临时文件的路径名，这个路径名中对应的文件名和本文件不相同\n    const char* tmp_path = tmpnam(name);\n    if (!tmp_path) {\n        perror(\"tmpnam\");\n        return -1;\n    }\n\n    cout << TMP_MAX << endl;\n\n    cout << tmp_path << endl;\n    cout << name << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n- 在编译的时候，说这个函数不推荐，很危险\n- 输出结果可以看出`TMP_MAX`的值是238328，产生的有效路径字符串路径是`/tmp/file6PoHsM`，我们可以推测`/tmp`路径就是产生临时文件路径的，并且我传进去的`name`字符串数组也被赋值为了路径名，返回值也是这个，双重保险\n\n![image-20230915150756157](https://cdn.davidingplus.cn/images/2025/01/31/image-20230915150756157.png)\n\n我们来看下`/tmp`路径：\n\n文件在程序结束之后就是释放掉了，确实是临时文件，做得很好\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230915150920192.png\" alt=\"image-20230915150920192\" style=\"zoom:80%;\" />\n\n### mkdtemp系列\n\n刚才使用`tmpnam`的时候编译器就提醒我们`tmpnam`函数不安全，建议使用`mkdtemp`函数\n\n~~~cpp\n#include <stdlib.h>\n\nchar *mkdtemp(char *template);\n// 这个函数可以用来创建一个目录，这个目录有一个唯一的名字\n// 这个名字是根据我传入的template路径指定的，我的template可以是一个绝对路径也可以是一个相对路径\n// 但是为了保证名字唯一，必须要在这个字符串后面加上XXXXXX(6个)的路径名，系统会替换这六个字符让目录名字唯一\n\nint mkstemp(char* template);\n// 以唯一的名字创建一个普通文件并且打开文件，返回的值是文件描述符\n// 成功，返回文件描述符；失败，返回-1\n\n// 这两个函数创建的目录和文件都不会自动删除，如果想要删除我们必须要手动删除才可以！\n~~~\n\n#### 例子\n\n我们先试一下`mkdtemp`函数\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    char name[1024] = {\"./mydirXXXXXX\"};\n\n    char *file_path = mkdtemp(name);\n    if (!file_path) {\n        perror(\"mkdtemp\");\n        return -1;\n    }\n\n    cout << name << endl;\n    cout << file_path << endl;\n\n    return 0;\n}\n\n~~~\n\n结果：\n\n创建了一个目录，并且`name`字符串和函数的返回值都是这个路径，并且路径的位置也是正确的，当然我要选择绝对路径或者相对路径都是可以的\n\n![image-20230915161012243](https://cdn.davidingplus.cn/images/2025/01/31/image-20230915161012243.png)\n\n当然`mkdtemp`函数还有其他的作用：\n\n![image-20230915161221228](https://cdn.davidingplus.cn/images/2025/01/31/image-20230915161221228.png)\n\n## 内存流(了解)\n\n这部分看不懂思密达。。。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230915163646515.png\" alt=\"image-20230915163646515\" style=\"zoom:80%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230915163654809.png\" alt=\"image-20230915163654809\" style=\"zoom:80%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230915163712024.png\" alt=\"image-20230915163712024\" style=\"zoom:80%;\" />\n\n# 后续\n\nTODO\n\n","categories":["Linux 学习","用户层"]},{"title":"TCP IP 网络编程","url":"/posts/c5690fb7.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 前言\n\n里面需要很多计算机网络的知识，我也懒得写了，在计算机网络复习当中有写到，这是文章的链接：[计算机网络期末复习](https://blog.davidingplus.cn/posts/b9598422.html)\n\n# 第一章 理解网络编程和套接字\n\n## 理解网络编程和套接字\n\n网络编程的目的就是使两台联网的计算机相互交换数据。首先需要物理连接，这一点已经达到了，基本上所有的电脑都是连通庞大的互联网的，所以这一点不需要担心；在此基础上我们只需要考虑如何使用程序来将两个主机建立连接即可，操作系统会给我们提供名为套接字(`socket`)的部件。\n\n<!-- more -->\n\n### TCP套接字\n\n我们先考虑比较重要的TCP套接字，他是建立连接的，可靠的运输层协议\n\n这是TCP协议的通信过程，我们来看一下其中哪些地方比较重要：\n\n![image-20230818143501064](https://cdn.davidingplus.cn/images/2025/02/01/image-20230818143501064.png)\n\n我们将通信过程总结如下：\n\n~~~cpp\n// TCP 通信的流程\n// 服务器端 （被动接受连接的角色）\n    1. 创建一个用于监听的套接字\n        - 监听：监听有客户端的连接\n        - 套接字：这个套接字其实就是一个文件描述符\n    2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）\n    \t- 客户端连接服务器的时候使用的就是这个IP和端口\n    3. 设置监听，监听的fd开始工作\n    4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字(fd)\n    5. 通信\n        - 接收数据\n        - 发送数据\n    6. 通信结束，断开连接\n~~~\n\n~~~cpp\n// 客户端\n    1. 创建一个用于通信的套接字（fd）\n    2. 连接服务器，需要指定连接的服务器的 IP 和 端口\n    3. 连接成功了，客户端可以直接和服务器通信\n        - 接收数据\n        - 发送数据\n    4. 通信结束，断开连接\n~~~\n\n**客户端有两个套接字比较重要，一个是用于监听服务端的套接字`listen_fd`，这个套接字用于时刻监听客户端是否连接；另一个是和客户端进行通信的套接字`connect_fd`，这个套接字就是用来进行通信的。套接字就是伪文件描述符，使用方法和文件描述符一样**\n\n### <span id='example'>例子</span>\n\n我们写一个程序来进行TCP本地双方的简单通信：\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n#define MAX_IPV4_STRING_SIZE 16\n\nint main(int argc, char* const argv[]) {\n    // 判断命令行参数\n    if (argc < 3) {\n        printf(\"usage: %s  <ip>  <port>.\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const unsigned short server_port = atoi(argv[2]);\n\n    // 1.创建socket套接字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.由于客户端需要主动连接，服务端需要绑定一个固定端口\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // ip\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n    // 端口\n    server_addr.sin_port = htons(server_port);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    printf(\"server has initalized.\\n\");\n\n    // 3.开始监听\n    ret = listen(listen_fd, 8);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    // 4.接受客户端连接\n    // 我们就简单的让客户端发送数据，服务端不断接受，并且是p2p\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n\n    int connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n    if (-1 == connect_fd) {\n        perror(\"accept\");\n        return -1;\n    }\n\n    // 获取客户端信息\n    in_port_t client_port = ntohs(client_addr.sin_port);\n    char client_ip[MAX_IPV4_STRING_SIZE] = {0};\n    inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip, sizeof(client_ip));\n\n    char buf[MAX_BUFFER_SIZE] = {0};\n    // 5.开始通信\n    while (1) {\n        bzero(buf, sizeof(buf));\n\n        int len = recv(connect_fd, buf, sizeof(buf) - 1, 0);\n        if (-1 == len) {\n            perror(\"recv\");\n            return -1;\n        }\n\n        if (len > 0)\n            printf(\"recv client(ip: %s,port:%d) message: %s\", client_ip, client_port, buf);\n        else {  // 写端关闭\n            printf(\"client(ip: %s,port:%d) has closed...\\n\", client_ip, client_port);\n            break;\n        }\n    }\n\n    // 6.关闭socket\n    close(connect_fd);\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUFFER_SIZE 1024\n\nint main(int argc, char* const argv[]) {\n    // 判断命令行参数\n    if (argc < 3) {\n        printf(\"usage: %s  <ip>  <port>.\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const unsigned short server_port = atoi(argv[2]);\n\n    // 1.创建socket套接字\n    int connect_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == connect_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.开始连接\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // ip\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n    // port\n    server_addr.sin_port = htons(server_port);\n\n    int ret = connect(connect_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"connect\");\n        return -1;\n    }\n\n    // 3.开始通信\n    char buf[MAX_BUFFER_SIZE] = {0};\n    // 每隔一秒向服务端发送一次数据\n    while (1) {\n        static int count = 0;\n        bzero(buf, sizeof(buf));\n        sprintf(buf, \"hello,this is client, count:%d\\n\", count++);\n        printf(\"send: %s\", buf);\n\n        send(connect_fd, buf, strlen(buf), 0);\n        sleep(1);\n    }\n\n    // 4.关闭连接\n    close(connect_fd);\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n客户端每隔一秒发送一次，服务端正确接收并且打印了出来\n\n服务端\n\n![image-20230903173752565](https://cdn.davidingplus.cn/images/2025/02/01/image-20230903173752565.png)\n\n客户端\n\n![image-20230903173820969](https://cdn.davidingplus.cn/images/2025/02/01/image-20230903173820969.png)\n\n## 基于Linux的文件操作\n\n对Linux而言，socket套接字和文件操作没有区别，或者说socket套接字是一个伪文件，我们完全可以用操作文件的方式去操作它\n\n但是在windows当中，是要区分socket和套接字文件的，在windows当中需要调用特殊的数据传输的相关函数\n\n### 文件描述符(文件句柄)\n\n#### open函数\n\n两种形式\n\n```c++\n// 打开一个已经存在的文件\nint open(const char *pathname, int flags);\n\n// 创建一个新的文件\nint open(const char *pathname, int flags, mode_t mode);\n```\n\n##### open函数打开文件\n\n```c++\nint open(const char* pathname, int flags);\n```\n\n参数解释\n\n- pathname：文件路径\n- flags：对文件的操作权限设置，还有其他的设置，例如：O_RDONLY，O_WRONLY，O_RDWR 这三个设置是互斥的\n- 返回值：返回一个新的文件描述符(int类型，类似于编号)，如果失败，返回-1\n\n##### open函数创建新文件\n\n```c++\nint open(const char *pathname, int flags, mode_t mode);\n```\n\n参数解释：\n\n- pathname：创建的文件路径\n\n- flags：对文件的操作权限和其他的设置 \n  **必选项：O_RDONLY, O_WRONLY, or O_RDWR 这三个之间是互斥的**\n  **可选项：O_CREAT 文件不存在创建新文件；O_APPEND 可以进行文件的追加**\n  **flags参数是一个int类型的数据，占4个字节，32位，每一位就是一个标志位，1表示有，0表示没有，所以用按位或**\n\n- mode：八进制的数，表示用户对创建出的新的文件的操作权限，比如：0777\n  **3个7分别表示对不同的用户(所有者，组成员，其他用户的权限)的权限，每一个都是3位 ，第一位表示读R，第二位表示写W，第三位 表示可执行X，7对应就是111全有!!!**\n\n  **最终的权限是：mode & ~umask**\n  umask可以通过shell命令 umask 查看\n  umask的作用是为了抹去某些权限，让我们创建的权限更加合理一些\n  例子：0777 & ~0022\n\n关闭函数\n\n~~~cpp\nint close(int fd);//  fd：文件描述符 fd\n~~~\n\n#### read,write函数\n\n头文件：\n\n```c++\n#include <unistd.h>\n```\n\n两个函数：\n\n```c++\nssize_t read(int fd, void *buf, size_t count);\n```\n\n- 参数：\n\n  - fd：文件描述符，通过open得到的，通过文件描述符操作某个文件\n  - buf：缓冲区，需要读取数据存放的地方，数组的地方(传出参数)\n  - count：指定的数组的大小\n\n- 返回值：\n\n  - 成功 >0 返回实际读取到的字节数\n\n    ​\t\t**==0 文件已经读取完了(注意是在调用read函数之前文件指针就在末尾了才会返回0，一次性从头读完是会返回读取的字节数的)**\n\n  - 失败 -1 并且修改errno\n\n```c++\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n- 参数：\n  - fd：文件描述符，通过open得到，通过文件描述符操作某个文件\n  - buf：要往磁盘写入的数据\n  - count：要写入的实际的大小\n\n- 返回值：\n  - 成功 >0 返回实际写入的字节数\n     ==0 文件已经写入完了\n  - 失败 -1 并且修改errno\n\n程序我就不写了，之前学牛客 Linux的时候写了无数遍了，需要自查\n\n# 第二章 套接字类型与协议设置\n\n## 套接字协议以及数据传输特性\n\n### 关于协议\n\n两个人需要进行远距离通话，必须要先决定通话方式，如果一方使用电话，那么另一方也必须只能使用电话，否则就无法进行正常的通信。对于他们而言，电话就是两个人通话的协议。\n\n**而对于`socket`而言，协议就是计算机之前对话需要具备的通信规则，它由语法，语义，同步三个要素组成；简单理解，协议就是为了完成数据交换而定好的约定**\n\n### 创建套接字socket\n\n`Linux`给我们提供了系统调用`socket`函数来是我们可以创建套接字\n\n~~~cpp\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <arpa/inet.h> // 包含了这个头文件，上面两个就可以省略\n\nint socket(int domain, int type, int protocol);\n    - 功能：创建一个套接字\n    - 参数：\n    - domain: 协议族\n        AF_INET : ipv4\n        AF_INET6 : ipv6\n        AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）\n\t// 第二个参数type和第三个参数protocol一个是协议类型，一个是具体的某个协议，划分的还比较细和周到\n    - type: 通信过程中使用的协议类型\n        SOCK_STREAM : 流式协议(例如：字节流的TCP，当然不一定只有这一种，可以被第三个参数具体指定)\n        SOCK_DGRAM : 报式协议(例如：用户数据报的UDP，当然不一定只有这一种，可以被第三个参数具体指定)\n    - protocol : 具体的一个协议。一般写0，可以表示默认的或者当协议类型中只有一个具体类型的时候就是用这个具体的类型\n        - SOCK_STREAM : 流式协议默认使用 TCP\n        - SOCK_DGRAM : 报式协议默认使用 UDP\n    - 返回值：\n        - 成功：返回文件描述符，操作的区域是内核缓冲区。\n        - 失败：-1，并且设置errno\n~~~\n\n### 协议族\n\n`socket`函数的协议族可分为如下几类：\n\n我们用的最多的就是`PF_INET`和`PF_LOCAL`，也就是网络上通过`IPV4`，本地通过本地套接字，当然本地也可以用`IPV4`\n\n![image-20230904193622248](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904193622248.png)\n\n### 套接字类型(重要)\n\n套接字类型就是表示套接字的数据传输方式，比如是类似于`TCP`的建立连接可靠的面向字节流的，还是类似`UDP`针对于用户数据报的无连接不可靠的，通过socket函数的第二个参数进行传输，下面我们将针对这两种进行阐述：\n\n#### 面向连接的套接字(SOCK_STREAM)：TCP\n\n面向连接，顾名思义，就是在进行正式数据传输之前需要建立连接，可以理解为在双方之间建立了一条逻辑通道，这种方式书上给出了一个类比的例子，同时图中也给出了他的特点：\n\n![image-20230904194133084](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904194133084.png)\n\n在运输层当中这就对应者TCP协议，TCP协议是面向字节流的建立连接的可靠的传输服务，下面是一些理解：\n\n- **收发双方之间存在缓冲，虽然`write`和`read`函数是不带缓冲的`I/O`函数，但是内核会提供缓冲区，带不带缓冲是针对在用户区有没有缓冲而言的。这个缓冲简而言之就是字节数组，套接字传输的数据并没有直接给到对方，而是在对方的内核的读缓冲区等待读取**\n- **关于不存在数据边界的理解：就是我每次传输的数据不一定就是一个完整的数据，可能我指定的写端的缓冲区比较小，我一次写的数据很少，但是我读端一次可以读取很多，写端写了三次，但是读端一次就读完了；这是合理的，读端也能够把数据正确接受，并不会因为数据被分开传输收到就会怎么样，因此我们称为不存在数据边界**\n- **数据不会丢失和按序传输数据：`TCP`套接字有累计确认`ACK`的机制，如果我前面的数据没有收到，那么到了一定时间会让发送方进行重传，然后进行累计确认，这就是协议内部具体的实现了，我们目前不需要过于了解，只需知道TCP可靠的机制保证了按序到达即可**\n\n#### 面向消息的套接字(SOCK_DGREAM)：UDP\n\n面向消息，顾名思义，就是强调传输的速度，强调消息传输的及时性，在运输层中对应UDP协议；TCP的传输虽然稳定，但是由于需要建立连接，还有其他的乱七八糟的，效率自然就没有UCP好，虽然面向消息的传输是无连接的面向数据报的不可靠的服务，但是在针对实时性的问题上我们还是选择这个会好一点，比如游戏和视频会议的通信；TCP就可以用在文件的传输上\n\n书上给出了类比图和特点：\n\n![image-20230904195220706](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904195220706.png)\n\n理解：\n\n- **由于没有建立连接，所以发送方发给谁，其实是不知道的，接收方通过套接字收取数据，可能这个时候发送方已经发送了部分数据，接收方就丢失了一部分数据；另外，由于没有连接保证，传输的顺序也是没有保证的，有可能按序到达，也有可能不按序到达，我们本地测试的时候看不出来，但是一旦网络拓扑复杂起来就会出问题了因为数据并不一定是沿一条路径走的；**\n- **其次，由于没有连接保证，发送方可不会管接收方接受多少数据，或者是否接收到，发送方就自己发，一旦数据大了，接收方没办法及时接受完全，这部分数据就丢了，这就是坏处，虽然效率提高了，因此需要限制每次传输的数据大小；**\n- **关于`UDP`的缓冲区，`UDP`只有一个接收缓冲区，是没有发送缓冲区的，就是说发送方有数据就发出去，不会说接收方缓冲区满了怎么样，因此我们使用UDP通信的时候都不用`read`/`write`函数，都用另一组系统调用`recvfrom`和`sendto`；所以UDP的发送方分批发送的数据，接收方没有办法缓存起来一起接受，因为我们不知道发送方什么时候会继续发送数据，`TCP`如果满了就会等待读完在发送，这也得益于`TCP`的写缓冲区，因此`UDP`具有传输的数据边界**\n\n### 协议的最终选择\n\n第三个参数使用来决定最终使用什么协议，因为确认了协议族和套接字类型之后，仍有可能存在多个数据传输方式相同的协议，但是TCP和UDP这里是唯一的，他们表示如下：\n\n~~~cpp\n// TCP\nsocket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  // 第三个参数也可以传入0，表示默认用这个\n\n// UDP\nsocket(AF_INET, SOCK_DGREAM, IPPROTO_UDP);  // 也可以传0\n~~~\n\n### 例子\n\n为了证明TCP的套接字是没有数据边界的，我们可以修改上面程序的缓冲区大小，让recv函数和send函数调用次数不同，我们再来看读取结果，[程序点击这里](#example)，下面只写改动的地方：\n\n~~~cpp\n// server.cpp\nint len = recv(connect_fd, buf, 5, 0);\nif (-1 == len) {\n    perror(\"recv\");\n    return -1;\n}\n\nif (len > 0)\n    // printf(\"recv client(ip: %s,port:%d) message: %s\", client_ip, client_port, buf);\n    printf(\"%s\", buf);\n// 这里我让每次读取的最大的长度为5个字节，显然一次没办法接受完数据\n// 然后为了避免每次接受数据都有前缀打印，会有干扰，我把前缀删了\n~~~\n\n结果：\n\n服务端接收到的数据仍然没有任何问题，说明TCP的数据传输是没有边界的\n\n![image-20230904203131451](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904203131451.png)\n\n# 第三章 地址族与数据序列\n\n## 分配给套接字的IP地址与端口号\n\n**`IP`是`Internet Protocol`(网络协议)的简写，是为了收发网络数据而分配给计算机的值，可以用于唯一标识一台在互联网中的计算机；**\n\n**端口并非赋予计算机的值，而是为了区分不同主机之间的进程，这个和进程号有区别，端口号是为了让不同主机的进程都知道，这样才能正确的进行通信**\n\n### 网络地址\n\n`IP`地址分为`IPv4`和`IPv6`地址，分别由4个字节和16个字节组成，一个字节8个`bit`，所以`IPv4`有32位，`IPv6`有128位；\n\n`IPv6`是为了应对`IPv4`地址耗尽的问题提出的标准，但是目前尚未得到普及\n\n网络地址是为了区分不同网络而设置的`IP`地址，是把`IP`地址的子网号部分设置为0得到的`IP`地址，全部设置为1就是广播地址，这些东西在计网已经学过了，详情请参考计网复习资料的部分\n\n### 网络地址分类与主机地址边界\n\n书上写的很清楚，这里截图：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230905105657336.png\" alt=\"image-20230905105657336\" style=\"zoom:80%;\" />\n\n当然更详细的分类如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230624203408369.png\" alt=\"image-20230624203408369\" style=\"zoom: 50%;\" />\n\n当然还有一些特殊的IP使用：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230624211609006.png\" alt=\"image-20230624211609006\" style=\"zoom: 80%;\" />\n\n### 用于区分套接字的端口号\n\n我们已经有了IP用来区分不同的主机，这样可以使我们的数据从一个主机通过庞大的互联网找到另一个主机，但是虽然数据到了主机，但是仅凭这些没有办法传输给应用程序。\n\n**这个时候我们就需要区分套接字的端口号了，端口号就是为了区分同一操作系统内不同套接字而设置的，所以没有办法将一个端口号分配给不同的套接字；**\n\n**同时也是为了区分不同主机之间的应用进程，端口号在设置的时候是双方都知道的，因此可以定位到某一个用于通信的进程；**\n\n**值得注意的是，虽然端口号不能重复，但是`TCP`和`UDP`的套接字不会公用端口号，所以允许重复**\n\n用一个图可以如下形象的表示：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230905112425335.png\" alt=\"image-20230905112425335\" style=\"zoom:80%;\" />\n\n## 地址信息的表示\n\n### 表示IPv4的结构体\n\n`Unix`对网络编程接口的`socket`地址提供了通用`socket`地址和专用`socket`地址\n\n`socket` 网络编程接口中表示 `socket` 地址的是结构体 `sockaddr`，这个在一般是通用的，其定义如下：\n\n~~~cpp\n#include <bits/socket.h>\nstruct sockaddr {\n    sa_family_t sa_family;\n    char sa_data[14]; //存储数据，包括IP和端口号的信息\n};\ntypedef unsigned short int sa_family_t;\n~~~\n\n我们向内核提供的是这个通用的`socket`地址，但是`socket`地址实际上根据不同的用途可以分为很多种，比如`IPv4`，`IPv6`还有本地套接字，他们都有适用于自己的专用`socket`地址，下图就非常清晰的列出来了，我们在这里主要研究`IPv4`的`socket`地址\n\n![image-20230905154922422](https://cdn.davidingplus.cn/images/2025/02/01/image-20230905154922422.png)\n\n#### sockaddr_in结构体\n\n~~~cpp\n#include <netinet/in.h>\nstruct sockaddr_in {\n    sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) */ // 地址族\n    in_port_t sin_port; /* Port number. */ // 16位端口号\n    struct in_addr sin_addr; /* Internet address. */ // 存储IPv4地址，是一个结构体，定义在下面\n    /* Pad to size of `struct sockaddr'. */\n    unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -\n    sizeof (in_port_t) - sizeof (struct in_addr)];\n};\n\nstruct in_addr {\n\tin_addr_t s_addr; // 32位IPv4地址\n};\n~~~\n\n我们来逐个分析一下这个结构体的成员：\n\n- `sin_family`：**每种协议族对应了一个地址族，其实在实现的时候协议族和地址族宏对应的值是相同的**，所以用哪个都无所谓，以下是对应的协议族和地址族：\n\n![image-20230904193622248](https://cdn.davidingplus.cn/images/2025/02/01/image-20230904193622248.png)\n\n![image-20230905155342817](https://cdn.davidingplus.cn/images/2025/02/01/image-20230905155342817.png)\n\n- `sin_port`：**保存16位端口号，注意传入的时候记得转化为大端网络字节序**\n- `sin_addr`：**是一个结构体，保存32位IPv4地址信息，也是按照大端网络字节序保存的**，但是我们不用自己动手，有系统调用(`inet_pton`)帮我们做了\n- sin_zero：**没有特殊含义，因为系统接受的是通用的`sockaddr`结构体，我们的`sockaddr_in`结构体的成员大小不一定匹配，需要有一定的额外大小来让两个结构体的大小一致而适配，没有特殊含义**\n\n#### 思考\n\n既然`sockaddr_in`是专门给`IPv4`使用的结构体，那么为什么里面还要有`sin_family`的地址族成员呢？\n\n**这个问题非常好，我们前面说到，需要做到专用`socket`地址和通用`socket`地址的匹配，我通过指针强制类型转换的时候不会发生错误，而通过`socket`地址里面有地址族的成员，因为他不是为某一个协议而服务的，所以为了和它保持一致，专用`socket`地址这里也需要一个地址族成员**\n\n## 网络字节序与地址变换\n\n对于单个字节的数据，在计算机中的保存倒无所谓，计算机是以字节存储数据的；但是如果是多个字节，比如双字节，就分为高字节和低字节，高字节就是高位嘛；那么我们的高字节是存储在内存地址的高处还是低处呢？这就是一个问题了，因此字节序分为了大端和小端字节序\n\n我先给出定义：**小端字节序是低位字节存储在内存的低地址处，高位字节存储在内存的高地址处；大端字节序则相反!!!**\n\n### 例子\n\n我们可以写一个程序来看自己的电脑是大端还是小端字节序\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // 给一个双字节的数据\n    short num = 0x1223;\n\n    char* ch = (char*)&num;\n\n    cout << ((*ch == 0x23) ? \"小端字节序\" : \"大端字节序\") << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n在我的电脑上是以小端字节序存储的，也就是高位存在高地址的地方\n\n![image-20230905162539547](https://cdn.davidingplus.cn/images/2025/02/01/image-20230905162539547.png)\n\n### 思考\n\n所以问题来了，不同的电脑存储的方式不同，难以得到统一，如果我们不加规范，那么在网络传输信息当中就很容易出现数据错误的问题，这将是致命的；\n\n因此，**在网络中，我们规定都用大端字节序传递数据，称为网络字节序**\n\n### 字节序转换\n\n**`Linux`系统给我们提供了系统`API`可以把主机字节序转化为网络字节序，可以转化`short`类型和`long`类型的值，也就是2个字节和8个字节的转化，为什么没有4个字节的`int`呢？因为2个字节对应16位的端口号，这是因为最初的时候`long`是4个字节，可以用来进行32位的转化，但是不同的系统的long不同，现在的long在大多数的机器上都是8个字节了，但是我们一般用不到，因为转化`IPv4`有其他的接口**\n\n以下是转化字节序的`API`：\n\n~~~cpp\nh - host 主机，主机字节序\nto - 转换成什么\nn - network 网络字节序\ns - short unsigned short\nl - long unsigned int\n~~~\n\n~~~cpp\n#include <arpa/inet.h>\n// 转换端口 端口号 0-65535，就是16位，因此是 uint16_t\nuint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序\nuint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序\n// 转IP IP地址，IPV4是32位，因此是uint32_t\nuint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序\nuint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序\n~~~\n\n所以以后在给`sockaddr_in`结构体初始化的时候，传入的端口号和`IPv4`地址记得转换字节序\n\n#### 例子\n\n我们写一个转化网络字节序的例子\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n\nint main() {\n    unsigned short host_port = 0x1234;\n    unsigned long host_addr = 0x12345678;\n\n    unsigned short net_port = htons(host_port);\n    unsigned long net_addr = htonl(host_addr);\n\n    // hex流可以让一个数以十六进制输出!!!\n    cout << \"Host ordered port: 0x\" << hex << host_port << endl;\n    cout << \"Network ordered port: 0x\" << hex << net_port << endl;\n    cout << \"Host ordered address: 0x\" << hex << host_addr << endl;\n    cout << \"Network ordered address: 0x\" << hex << net_addr << endl;\n\n    return 0;\n}\n~~~\n\n结果：\n\n我们看到了主机字节序和网络字节序的区别\n\n![image-20230905164245873](https://cdn.davidingplus.cn/images/2025/02/01/image-20230905164245873.png)\n\n#### 补充\n\n让数据以二进制，八进制，十六进制输出(`c++`)\n\n- **二进制：借助`bitset`库**\n- **八进制：借助`oct`流**\n- **十六进制：借助`hex`流**\n\n用法如下：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <bitset>\n\nint main() {\n    int num = 100;\n\n    cout << bitset<10>(num) << endl; // 0001100100，模板参数10是输出多少位\n    cout << oct << num << endl; // 144，oct流\n    cout << hex << num << endl; // 64，hex流\n\n    return 0;\n}\n~~~\n\n## 网络地址的初始化与分配\n\n通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用 十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录 日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字 符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：\n\n**这个是旧的函数，只能适用于IPv4地址，可以使用但是不建议**\n\n~~~cpp\n#include <arpa/inet.h>\n// 这个数字转化过来之后是网络字节序，就是大端\nin_addr_t inet_addr(const char *cp); \n// 第二个参数是传出参数，保存转换后的结果，返回值 1 成功，0 失败，字符串非法，不设置错误号\nint inet_aton(const char *cp, struct in_addr *inp); \nchar *inet_ntoa(struct in_addr in);\n~~~\n\n**下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：(推荐使用这里的新的api)**\n\n我一般写代码只用新的API，就是p开头的\n\n~~~cpp\n#include <arpa/inet.h>\n// p:点分十进制的IP字符串，n:表示network，网络字节序的整数\nint inet_pton(int af, const char *src, void *dst);\n    // af:地址族： AF_INET AF_INET6\n    // src:需要转换的点分十进制的IP字符串\n    // dst:转换后的结果保存在这个里面，是一个传出参数\n    // 将网络字节序的整数，转换成点分十进制的IP地址字符串\n    // 返回值：1 成功 ；失败 0 或者 -1，0表示传入的点分制字符串不合理invalid，不设置errno；-1表示错误(比如地址族内容不合理)，并且设置errno\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n    // af:地址族： AF_INET AF_INET6\n    // src: 要转换的ip的整数的地址\n    // dst: 转换成IP地址字符串保存的地方\n    // size：第三个参数的大小（数组的大小）\n    // 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的\n~~~\n\n### INADDR_ANY\n\n**我们在创建服务端的时候可能有多个IP都可以分配给服务端，但是我们不知道用哪一个，这个时候我们可以传入`INADDR_ANY`参数，表示地址只要是我有的都能接受，可以省去一些麻烦**\n\n以下是书上的例子：\n\n![image-20230905165356272](https://cdn.davidingplus.cn/images/2025/02/01/image-20230905165356272.png)\n\n# 第四章 基于TCP的服务端/客户端(1)\n\n## 深入理解TCP，UDP\n\n基于网络协议的套接字可以分为`TCP`套接字和`UDP`套接字，`TCP`是面向连接的，又称为基于字节流的套接字\n\n### TCP/IP协议栈\n\n如图所示，我们的数据收发过程实际上经过了这四个层次的过程：\n\n我们的计算机网络问题并不是仅凭软件就能够解决的，编写软件之前需要构建硬件系统，在此基础上通过软件实现各种算法；因此我们是把一个大问题划分为若干个小问题再逐个击破，这样可以大幅度的提高效率\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230909150644608.png\" alt=\"image-20230909150644608\" style=\"zoom:80%;\" />\n\n###  链路层\n\n链路层是将`IP`数据报封装成为帧并且传输的过程，又叫数据链路层(实际的`bit`传输在物理层)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230909151100190.png\" alt=\"image-20230909151100190\" style=\"zoom:80%;\" />\n\n### IP层(网络层)\n\n`IP`层(网络层)帮我们解决了在巨大的互联网当中我们怎么如何选择路径还有如何进行传递\n\n`IP`本身是面向消息的，不可靠的协议，但是我们的传输层可以通过`TCP`协议来帮我们实现可靠数据的传输\n\n### TCP/UDP层(运输层)\n\nTCP/UDP是在网络层之上的运输层，TCP协议是面向字节流的可靠的传输服务，它可以帮助不可靠的IP协议变得可靠，他有一系列机制帮助实现他的面向连接和可靠性；UDP协议是面向数据报的不可靠的协议\n\nTCP具体来说是这么为IP的不可靠服务提供可靠性的：\n\n![image-20230909151937552](https://cdn.davidingplus.cn/images/2025/02/01/image-20230909151937552.png)\n\n### 应用层\n\n上面的功能都是不会暴露给用户的，因此我们用户在使用的过程中根本看不见下层的操作；我们需要做的就是使用下层封装出来给我们的`API`，在网络中就是`socket`套接字，我们根据规定的规则编写程序就可以进行通信，这就是一个简单的例子\n\n## 实现基于TCP的服务端/客户端\n\n### 服务端的操作顺序\n\n如下图：\n\n具体的操作在我的另一门课牛客`Linux`当中已经讲的很清楚了，这里给出对应文章的地址：\n\n[第四章：TCP套接字通信（这一篇就够了！）](https://blog.csdn.net/m0_61588837/article/details/132432615)\n\n![image-20230909152233914](https://cdn.davidingplus.cn/images/2025/02/01/image-20230909152233914.png)\n\n我们注意一点的`listen`函数，注意他的第二个参数`backlog`\n\n~~~cpp\nint listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn\n    - 功能：监听这个socket上的连接\n    - 参数：\n        - sockfd : 通过socket()函数得到的文件描述符\n        - backlog : 连接请求等待队列的长度，表示最多有多少个连接请求排队，并不是服务端最多可以连接通信的个数，因为出队列之后就可以进行通信，这个时候请求队列减一恢复了\n~~~\n\n代码我就不放了，第一章写得非常清楚，[点击这里跳转过去](#example)\n\n### 客户端的操作顺序\n\n客户端一般不需要绑定`bind`，因为服务端绑定是因为客户端需要`IP`和端口号来进行请求连接，所以需要绑定而不是让系统自动给我分配，我们也可以看到在没有绑定的客户端的IP和端口都是系统分配的\n\n![image-20230909153956078](https://cdn.davidingplus.cn/images/2025/02/01/image-20230909153956078.png)\n\n### TCP服务端和客户端的关系\n\n总体流程如下：\n\n![image-20230909154125497](https://cdn.davidingplus.cn/images/2025/02/01/image-20230909154125497.png)\n\n## 实现迭代服务端和客户端\n\nTODO\n\n","categories":["Linux 学习","用户层"]},{"title":"使用 git","url":"/posts/13ca1b18.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n本文是一个使用 git 的简要总结。\n\n- 准备工作，git 配置 ssh：[https://blog.csdn.net/lqlqlq007/article/details/78983879](https://blog.csdn.net/lqlqlq007/article/details/78983879)\n- 第一次拉取，以 github 服务器为例，其他服务器将 github.com 替换成为对应的 IP 或者域名：git clone git@github.com:xxx/xxx.git 前面写用户名，后面写仓库名称；拉取之后会把 github 上的目录拉取到本地，在目录当中会有一个 .git/ 隐藏文件夹，不要动它，这是自动生成的配置\n\n<!-- more -->\n\n- 后续的拉取：\n\n  - git pull\n- 后续提交按照顺序：\n  - git add . \n  - 将所有的文件放到暂存区，这个时候可以用 git status 查看文件状态，已经放到暂存区\n- git commit -m \"xxx\"\n\n  - 使用 git commit 提交文件，此时提交的修改仍然存储在本地，并没有上传到远程服务器。-m 后为此次提交的说明，解释做了哪些修改，方便他人理解\n- git push -u origin master（可以加 -u 也可以不加）\n  - origin 表示是远程仓库，master 是我们操作的分支，我一般就用 master\n  - 我们可以用 git remote -v 查看地址\n- git 切换分支\n  - git branch -a 查看远端仓库的所有分支\n  - git branch 查看现在项目处于哪个分支\n  - git checkout master 切换到指定的分支，我这里指定的是 master\n- git 新建分支\n  - git checkout -b <branch>：保留当前分支的 commit 历史，开一个新分支，这时候 merge 原分支是最新的\n  - git checkout --orphan <branch>：开一个没有 commit 历史的独立分支，这两个分支是独立的\n  - 在实际工作中，用第一个保留历史的最好，因为独立分支的话，后续应用主分支的修改还要 merge，就会把该分支第一次的 commit 全 merge 过来，效果和第一个一样，但是更费力，不推荐，除非是功能不相干的分支，使用第二个比较好\n  - 最终 push 到远端的时候需要显式指定分支，这里最好加上都 -u 参数\n- 恢复修改 M 和删除 D 的文件：git chekcout .\n- 删除未追踪 U 的文件：git clean -fd\n  - 参考链接：[https://blog.csdn.net/zhu_superman/article/details/136326154](https://blog.csdn.net/zhu_superman/article/details/136326154)\n- 关于 git 的大小写敏感问题\n  - 在 Windows 上默认是不敏感的，在 Linux 和 Mac 上是敏感的\n  - 也就是说在 Windows 下，修改一个文件或者目录的字符大小写，不会被检测到，这就可能出现很大的问题了。\n  - 解决办法：git config core.ignorecase false，将忽略大小写设置为 false，这样就能正确识别了，当然也可以使用参数 --global 设置全局\n  - 但是有个问题：设置了全局以后，每次克隆一个仓库，默认会添加这一条 core.ignorecase，并且为 true，没办法，手动改一下吧，至少解决主要问题了。\n- git 版本回退的步骤：[https://blog.csdn.net/qing040513/article/details/109150075](https://blog.csdn.net/qing040513/article/details/109150075)\n\n  - 使用 git log 命令或 code 的 git graph 插件查看需要恢复的 commit 的 ID\n  - git reset --hard <commit>，回退到某次的 commit 版本\n    - 注意：--hard 的参数的有无是很重要的，有 --hard 参数，回退以后本地当前的修改全部清空，没有才会保留\n    - 因此，引申出撤销已经 commit 但未 push 的提交：git reset origin/<branch>，记得不要加上 --hard\n  - git commit --allow-empty，当然可以在此版本上修改之后在提交，但这里为了简便，就空提交了\n  - git push -f -u origin <branch>，-f 参数表示强制推送，这样会覆盖回退的版本到最新版本之间的所有 commit，直接到达最新提交的 commit；所以 -f 参数还是慎用，否则把别人的工作干掉了得不偿失，尽量还是拉取合并解决冲突吧\n- git 在合并的时候全部采用某一端的文件：[https://blog.csdn.net/chaiyu2002/article/details/83791671](https://blog.csdn.net/chaiyu2002/article/details/83791671)\n\n  - merge 的时候加上采用传入端或者本端\n    - 采用传入修改：git merge <branch> --strategy-option theirs\n\n    - 采用本地修改：git merge <branch> --strategy-option ours\n\n  - 如果显示 unrelated histories，在后面加上 --allow-unrelated-histories\n\n  - 同理 git pull 在冲突需要合并的时候也可以采取这样的方法\n- git 同步远程已删除的分支和删除本地多余的分支：[https://www.cnblogs.com/saysmy/p/9166331.html](https://www.cnblogs.com/saysmy/p/9166331.html)\n  - 查看本地分支和追踪情况：git remote show origin\n  - 同步远程已删除的分支：git remote prune origin\n  - 删除本地分支：git branch -D <branch>\n- git 删除远程分支：git push origin --delete <branch>\n- git 重命名分支\n\n  - 重命名本地分支：git branch -m <newName>\n  - 如何重命名远程分支？\n    - 首先将本地对应的分支（一般都是与远程分支相同，如果不同请跳过这一步）重命名为想要的名字\n    - 然后将原远程分支删除\n    - 最后重新将本地重命名的分支推送上去即可：git push -u origin <newBranch>\n- git 将 vim 设置为默认编辑器（Linux 下默认的是 nano，用着不太习惯）：git config --global core.editor vim\n- git 指定合并某次的 commit（相当于可以跳过 git tree 中间的一些 commit）：git cherry-pick命令\n  - [https://geek-docs.com/git/git-questions/1103_git_git_skipping_specific_commits_when_merging.html](https://geek-docs.com/git/git-questions/1103_git_git_skipping_specific_commits_when_merging.html)\n  - [https://geek-docs.com/git/git-questions/71_git_git_cherry_picking_with_ourstheirs_strategy.html](https://geek-docs.com/git/git-questions/71_git_git_cherry_picking_with_ourstheirs_strategy.html)\n  - [https://zhuanlan.zhihu.com/p/355413226](https://zhuanlan.zhihu.com/p/355413226)\n- git 报错 fatal: bad object refs/remotes/origin/xxx 的解决方法：[https://www.cnblogs.com/along007/p/17335825.html](https://www.cnblogs.com/along007/p/17335825.html)\n- git 拉取子模块中的所有内容：[https://blog.csdn.net/toopoo/article/details/104225592](https://blog.csdn.net/toopoo/article/details/104225592)\n  - 使用子模块的仓库的例子，boost：[https://github.com/boostorg/boost](https://github.com/boostorg/boost)\n- git 报错对象文件为空（object-file-is-empty）的解决方法：[https://blog.csdn.net/syx_1990/article/details/117237631](https://blog.csdn.net/syx_1990/article/details/117237631)\n- git 仓库的默认分支修改以后，最好同步将 origin/HEAD 同步修改，和 git 仓库的默认分支保持一致，否则在 fetch 和 pull 的时候可能会出现奇奇怪怪的问题：git remote set-head origin <branch>\n- git 中 tag 的使用：[https://blog.csdn.net/qq_39505245/article/details/124705850](https://blog.csdn.net/qq_39505245/article/details/124705850)\n- git status 不能显示中文：[https://blog.csdn.net/u012145252/article/details/81775362](https://blog.csdn.net/u012145252/article/details/81775362)\n- git lfs 的使用: [https://zhuanlan.zhihu.com/p/106295945](https://zhuanlan.zhihu.com/p/106295945)\n- git 项目文件大小优化（去除大文件）：[https://www.cnblogs.com/fuhua/p/15527023.html](https://www.cnblogs.com/fuhua/p/15527023.html)\n  - 注意 git rev-list 和 git filter-branch 命令是可以指定分支的。默认是全部分支，也就是 --all。如果需要指定分支将 --all 替换为对应分支即可，例如 master。这样可以过滤非必要分支，例如 gh-pages。\n  - 移除某个目录下所有文件的引用，命令 `git filter-branch --force --prune-empty --index-filter 'git rm -rf --cached --ignore-unmatch report/app/public/pdf/*.*' --tag-name-filter cat -- --all` 中 `*.*` 建议替换为 `*` 防止无法匹配无后缀的文件，例如 Makefile。另外例如想要匹配任何目录下名为 images 的目录可使用 `*/images/*`。\n- git 遇到类似 error: cannot lock ref 'refs/remotes/origin/master': unable to resolve reference 'refs/remotes/origin/master' 的问题：[https://blog.csdn.net/a54674/article/details/102302288](https://blog.csdn.net/a54674/article/details/102302288)\n\n","categories":["一些技巧"]},{"title":"LDir 和 LFileInfo 的语义和设计","url":"/posts/fceabd3a.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n`LarkSDK`中`FileSystem`中关于`LDir和LFileInfo的语义和设计`的总结。\n\n# 语义明确\n\n​\t`QDir`和`QFileInfo`的语义一直以来都比较令人费解。我们知道文件和目录的关系是：目录是一种特殊的文件。按照`QDir`和`QFileInfo`的命名来讲，应该是`QDir`管理目录，`QFileInfo`管理文件，但是实际上这两个类的功能是非常混乱的，`QDir`可以操作文件，`QFileInfo`也可以操作目录。而初版的`LDir`和`LFileInfo`也是完全按照QT的思维走的，因此导致该部分的语义非常混乱，让我们和用户感到非常费解。\n\n<!-- more -->\n\n​\t注意，该任务不包括`LFile`的部分，只关心`LDir`和`LFileInfo`的语义和设计问题。`LFile`是一类，需要通过`IO`进行文件操作，类似于`IODevice`。而`LDir`和`LFileInfo`是一类。\n\n​\t现在的设计方式是直接存储一个`LString`类型的路径，但是这样对于`windows`平台非常不友好。`QT`也是这样做的，不过可能是因为历史原因，未能按照更好的方式修改。但是QT的功能经过庞大的迭代是很稳定的，但是这部分初版的功能一言难尽。\n\n​\t同时，目前`LDir`和`LFileInfo`的语义非常不明确。为了避免混淆，将二者重新命名为`LFileSystemPath`和`LFileSystemEntry`，后续`LDir`作为`LFileSystemPath`的别名，`LFileInfo`作为`LFileSystemEntry`的别名。经过我的思考和组内集体的讨论，有了如下的设计。\n\n1. `LFileSystemPath`：存储规范化后的路径的结构。\n\n   `LFileSystemPath`讨论以后的设计是能够将用户传入的路径进行合理并且严格的规范化，本类只负责这个功能。至于该路径指向的具体是文件还是目录，该路径指向的文件或目录是否存在，有什么权限，本类不关心。按照此语义，本类应当不会涉及与平台相关的具体接口。\n\n2. `LFileSystemEntry`：内部存储一个路径结构`LFileSystemPath`，真正与系统`API`打交道的类。\n\n   `LFileSystemPath`对路径做了严格规定，因此在`LFileSystemEntry`中会存储这个结构用于处理系统中的路径。在本类当中就会提供平台相关的借口了，比如创建目录`mkdir`，进入目录`cd`，文件权限`permission`等等操作，当然，这些操作都离不开路径结构`LFileSystemPath`。\n\n   与`Qt`不同的是，`LFileSystemEntry`中存储的路径指向的文件或目录都必须是在系统中实际存在的，不允许存储不存在的路径，因为这样没有意义。如果非要存储，请使用单纯的路径结构`LFileSystemPath`。\n\n3. 二者的命名规定。\n\n   对于大多数用户而言，可能并不知道目录是一种特殊的文件（目录和文件都具有`rwx`权限，只是表现方式不同），因此本类的名称有待商榷，目前的商讨结果是将`LDir`作为另一个类（例如`LFileSystemPath`这种）的别名，类似`LVector`和`LPaddedVector`的关系。保留`LDir`是考虑了`Qt`的缘故。`LFileSystemEntry`与`LFileInfo`的关系同理。\n\n# 更多细节\n\n1. `LFileSystemPath`如何存储路径。\n\n   经过对比`Qt`和与钟老师讨论，决定使用`StringList`存储各级目录名和文件名的方式。\n\n   `windows`和`linux`文件系统最大的区别就在于`windows`使用反斜杠`\\`，`linux`使用正斜杠`/`，但是这些在存储的时候根本没有必要存储，因此直接使用`StringList`存储文件名即可。下面会涉及到更多的细节。\n\n   第一，如何判断绝对路径还是相对路径。\n\n   在`Linux`下，绝对路径以`/`开始。在`windows`下同理，绝对路径是盘符加上`\\`，例如`c:\\`，用户传递进来的路径经过我们内部的`split`处理存入到一个一个的`StringList`元素中，很容易联想到，在开头作标识即可。如果是绝对路径，那么`StringList`开头会留出一个空元素，相对路径则不会。\n\n   例如，对路径`/path/to/../to/local`，就是这样的结构：\n\n   <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240411163331656.png\" alt=\"image-20240411163331656\" style=\"zoom: 80%;\" />\n\n   第二，如何判断末尾是文件还是目录。\n\n   文件和目录很有可能出现同名的情况，这是必须要考虑的事情。（这和文件是否具有后缀没有关系，目录也可以写成带后缀的形式）我们需要想办法在`LFileSystemPath`的结构里面表现出来。结合上面的例子，如果我的路径是`/path/to/../to/local/`的话，就一定代表`local/`是一个目录了，具体在系统中到底存不存在本类不关心，可以效仿刚才的做法，在末尾加上一个空元素，即可区分。\n\n   对于文件还是目录，在本类中做了严格的规定，`local`是文件，`local/`是目录。之所以要这样做，请看下面`LFileSystemEntry`提出的联想问题。\n\n   对于路径`/path/to/../to/local/`，就是这样的结构：\n\n   <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240411164213369.png\" alt=\"image-20240411164213369\" style=\"zoom:80%;\" />\n\n   至此，我们就在`LFileSystemPath`的层面对绝对路径和相对路径，文件和目录进行了严格的规定。\n\n2. `LFileSystemEntry`构造时关于文件和目录的修正。\n\n   在构造的时候会涉及到一个问题，对于`LFileSystemPath`而言，我们硬性对目录和文件做了规定，目录结尾必须有`/`，文件没有。但是对用户而言，可能并不知道，因此用户可能想要目录，也可能写入`/path/to/../to/local`，如果系统中这个`local`的确是一个目录，并且没有要给同名的`local`文件存在，这是没有毛病的。这个问题需要进行处理。\n\n   比较合理的解决方式是，首先由于无论是在`linux`还是在`windows`下，文件和目录不能同名，也就是不能同时出现`test`和`test/`。对于`LFileSystemEntry`而言，对于文件类型的路径，既能匹配到文件也能匹配到目录，因此如果匹配成功，需要做二次匹配，匹配对应的目录，如果匹配失败，代表是一个文件路径；如果匹配成功，需要对此时的`LFileSystemPath`存储的内容做了修正，变成了`/path/to/../to/local/`。当然用户如果传入`/path/to/../to/local/`，那一定匹配的是目录，这一点毋庸置疑。\n\n3. 考虑盘符。\n\n   `windows`下存在盘符，例如路径`d:\\a\\b\\c`，其中`d:`就代表盘符，`\\a\\b\\c`就是从`d:`盘符下的根目录开始的依次的`a`，`b`目录和`c`文件，那么对应到`linux`下面呢？例如`d:/a/b/c`，这就是一个正确的相对路径了，分别对应`d:`，`a`，`b`目录和`c`文件，可见如何处理盘符是一个非常重要的问题。\n\n   其次，考虑了盘符以后，我们需要考虑`LFileSystemPath`和`LFileSystemEntry`的对接问题。例如我给出路径`d:a\\b\\c`，对应盘符`d:`和相对路径`a\\b\\c`。我们上面专门谈到过`LFileSystemPath`不关心这个路径是否合法，指向的东西是否存在，只是做一个规范化的存储的数据结构。因此在这里而言，理论上来讲，这个路径下的盘符是没有意义的，因为给出的是一个相对路径，而`LFileSystemPath`的结构为`LFileSystemEntry`服务的时候，真正的工作路径的盘符与用户给出的盘符可能并没有联系，因此经过讨论，这里的盘符会被忽略掉。也就是说如果调用`path()`方法导出路径，会得到`a\\b\\c`，盘符就没有了，这也是比较符合逻辑的。\n\n   当然。上面只是考虑了一种情况，实际的情况可能是有无盘符和绝对相对路径的综合情况，故作下图进行总结：\n\n   <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/综合总结.png\" alt=\"综合总结\" style=\"zoom:80%;\" />\n\n   因此，经过如上考虑，最新的算法流程是一个`path`进来以后，先考虑盘符，如果是`windows`尝试提取盘符，如果是`linux`不管；后面再进行反斜杠`\\`转化为正斜杠`/`，然后`split`，再存储的过程，当然其中会有更多需要注意的小细节。\n\n4. 经过讨论，原`LDir`中处理目录的相关接口和`LFileInfo`处理文件的相关接口移动到新`LFileInfoEntry`中，现将所有接口归纳在这里。\n\n   - 路径返回接口\n\n     - `drive()`：返回盘符，效果等同于`LFileSystemPath`的`drive()`\n     - `path()`：返回路径，效果等同于`LFileSystemPath`的`path()`\n\n     - `canonicalPath()`：返回规范化路径，效果等同于`LFileSystemPath`的`canonicalPath()`\n\n     - `absolutePath()`：返回绝对路径，如果是绝对路径，计算规范化以后的绝对路径；如果是相对路径，以当前可执行文件的工作目录为基准路径，进行拼接，计算最后规范化以后的绝对路径\n     - `relativePath(const LString& path)`：计算给定`path`相对于本类中文件或目录的相对路径（这个算法待写）\n     - 关于`path()`，`canonicalPath()`和`absolutePath()`接口三者的区别，通过一个示例就知道了（假设是`linux`，`windows`同理），设当前可执行文件的目录是：`/a/b/c/d/e/`\n       - 构造原串：`../..///./..`\n       - `path()`：`../.././../`\n       - `canonicalPath()`：`../../../`\n       - `absolutePath()`：`/a/b/`\n\n   - 判断接口\n\n     - `isValid()`：判断路径是否合法，在构造函数的时候会验证路径是否合法（遵循上面的规则），并且`LFileSystemEntry`规定路径指向的文件或目录必须存在，不存在则警告，并且清空数据。后续的其他函数首要逻辑就是判断是否合法\n     - `isAbsolute()`：判断是否为绝对路径\n     - `makeAbsolute()`：将当前类存储的路径转化为绝对路径\n     - `isRelative()`：判断是否为相对路径\n     - `isDir()`：判断是否为目录\n     - `isFile()`：判断是否为文件\n     - `isRoot()`：判断是否为根目录\n     - `isHidden()`：判断是否为隐藏文件或目录\n     - `isReadable()`：判断目录或文件是否具有可读权限\n     - `isWritable()`：判断目录或文件是否具有可写权限\n     - `isExecutable()`：判断目录或文件是否具有可执行权限\n\n   - 名字返回接口\n\n     - `basename()`：返回当前目录或文件的名称。遵循`linux`系统下`basename`命令的规则，经验证，返回完整名字，注意目录需要去掉末尾的斜杠\n     - `name()`：`basename()`的别名\n     - `singleSuffix()`：获取当前文件的后缀，找到最后一个`.`以后的部分\n     - `suffix()`：`singleSuffix()`的别名\n     - `completeSuffix()`：获取当前文件的后缀，找到第一个`.`以后的部分\n\n   - 目录相关接口\n\n     - `cd(const LString& path)`：根据传入的路径进入指定的目录。如果是绝对路径，按照新绝对路径；如果是相对路径，以本类中存储的目录路径会基准进行拼接，得到最终的绝对路径\n     - `cdUp()`：进入父级目录，效果等同于`cd(LString(\"..\"))`\n     - `mkdir(const LString& path)`：根据传入的路径创建新的目录。规则同`cd()`\n     - `rmdir(const LString& path)`：根据传入的路径删除指定的目录。规则同`cd()`\n     - `entryCount()`：统计当前目录中的目录和文件的总数\n     - `count()`：`entryCount()`的别名\n     - `entryList()`：获取当前目录中的目录和文件的列表\n\n   - 其他接口（由于调用了其他的类，目前直接放的旧版内容）\n     - `rename(const LString& path)`：将当前目录或文件重命名为`path`指向的目录或文件\n     - `birthTime()`：返回当前文件或目录的创建日期\n     - `lastModified()`：返回当前文件或目录的最后一次修改日期\n     - `lastRead()`：返回当前文件或目录的最后一次读取日期\n     - `owner()`：返回当前文件或目录的所有者\n     - `setPermission(LPermission permisson)`：设置当前文件或目录的权限\n     - `permission()`：返回当前文件或目录的权限\n\n5. 后续维护任务归纳。\n\n   - 查看其他接口旧版的代码内容，优化修改或者重写\n   - `cd()`接口考虑返回自身引用而不是`bool`值，满足链式调用需求\n   - `isReadable()`、`isWritable()`、`isExecutable()`、`entryCount()`、`entryList()`目前使用旧版代码内容，同第一点\n   - `relativeFilePath()`和`rename()`逻辑待补\n   - `windows`下的`Lark::executableDirPath()`目前采用手动截取的方式，后续看有没有办法改为系统接口\n\n","categories":["实习","合迅科技","课题研究"]},{"title":"标准库 string 的 sso 优化对 LVector 插入影响的探究","url":"/posts/6cd9fef5.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n钟老师让自己的做的一个课题研究，主题是`标准库string的sso优化对LVector插入的影响`。\n\n# 问题背景\n\n`LVector`在插入`std::string`的时候遇到了问题，钟老师研究了一段时间，我接着他的成果继续探讨，将学到的内容总结在这里。\n\n# std::string的优化\n\n标准库的`std::string`其实是做了优化的，不同的编译器实现的细节可能不同，但是基本的大思路框架都是一样的。\n\n注：以下都是理论上的思路分析，具体的底层代码请自行查阅资料。\n\n<!-- more -->\n\n## 基本内存模型\n\n我们熟知的`std::string`的内存模型大致是这样的\n\n- 栈区当中存放容量`capacity`，大小`size`和一根指向堆区数据区域的指针，三个分别占据`8`字节，总共`24`字节\n- 堆区当中`data`是实际存放数据的地方，通过分配器分配出来的（默认使用`std::allocator`，实际就是`new`出来的），`std::string`中的`c_str()`方法获取的就是堆区这个数据区首地址\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240228155812377.png\" alt=\"image-20240228155812377\" style=\"zoom:80%;\" />\n\n## COW优化（现在不用）\n\n`COW`，即为`Copy-On-Write`，写时拷贝。\n\n提到这里，我首先想到了`Linux`当中父子进程的\"**读时共享，写时拷贝**\"，父子进程在读的时候共享用户区的数据，例如先`open()`一个文件，在`fork()`，父子进程的文件描述符是同一个，具体可以表现为父进程读`2`个字节，对于子进程的文件偏移指针也向后偏移`2`个字节；这就是因为用户区的文件描述符表是读时共享的；当需要修改用户区的数据，比如一个变量，就会做拷贝操作了，这点毋庸置疑，这也是优化性能的一种策略。\n\n参上，`std::string`的`COW`优化也是一个道理，具体如下图\n\n- 在读取的时候共享`data`数据内存区域，当需要修改（写）的时候，`str2`就做自己的拷贝\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240228161141491.png\" alt=\"image-20240228161141491\" style=\"zoom:75%;\" />\n\n### 存在的问题\n\n看到上面，可能会想，`COW`这么好，为啥标题还是现在一般不用呢？\n\n之所以不用，是因为这种机制在**多线程**当中可能会出现不可预期的乱七八糟的问题，具体自行查阅资料，这里不作阐述。\n\n## SSO优化\n\n所以就有了`SSO`优化，即`Small String Optimization`，翻译过来就是**短字符串优化**。\n\n那么为什么需要短字符串优化呢？看基本的内存模型\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240228161643461.png\" alt=\"image-20240228161643461\" style=\"zoom: 80%;\" />\n\n想象一下，如果我的字符串比较短，举个例子，小到`8`个字节就能存下，那么是不是就不用存一个指针了，直接在栈区存储即可，还不用去堆区开辟空间，还不用考虑堆区内存释放的问题，岂不美哉？\n\n我们再考虑一下，`8`个字节的`capacity`和`8`个字节的`size`最大能表示多少的数？`2^63 - 1`，这也太大了吧，完全没必要，因此`capacity`和`size`也可以做进一步优化，注意不同编译器的实现不同，但是思路都是这样，能砍的就砍。当然不管如何，里面存放的`pointer`是不会变的，因为`std::string`中还有`c_str()`接口，不能让功能变了。大概的优化模型如下，可以看到数据在栈区，这个时候指针指向自身内部的`data`，合理，非常合理。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240228163129862.png\" alt=\"image-20240228163129862\" style=\"zoom:75%;\" />\n\n当字符串的长度变长，达到长字符串的标准（不同编译器的规定不一样），就会恢复一般的内存模型\n\n关于`SSO`优化的下的字符串的拷贝，由于内存模型中仍然存在指针，显然是一个深拷贝，可以写一个程序测试一下，顺便看一下`std::string`的`SSO`优化的表现\n\n~~~cpp\n#include <iostream>\n#include <string>\n\nint main()\n{\n    std::string a{\"one\"};\n    auto b = a;\n\n    std::string c{\"twooooooooooooooooooooooooooooooooooooooooooooo\"};\n\n    printf(\"a address: %p, c_str address: %p\\n\", &a, a.c_str());\n    printf(\"b address: %p, c_str address: %p\\n\", &b, b.c_str());\n    printf(\"c address: %p, c_str address: %p\\n\", &c, c.c_str());\n\n    return 0;\n}\n~~~\n\n执行结果，可以发现完美验证了我们的分析\n\n- `a`到`b`经过了一次深拷贝，他们两个的数据区地址不同\n- `a、b`的本类地址和数据区地址非常相近，而`c`离的很远\n\n![image-20240228163645469](https://cdn.davidingplus.cn/images/2025/02/01/image-20240228163645469.png)\n\n当然`SSO`优化也存在一定问题，这就不是这个课题的重点了，请自行查阅资料。\n\n# 在LVector中插入std::string\n\n## 问题背景\n\n测试`LVector`的时候，发现`prepend std::string`的时候程序崩溃，返回的值也不符合预期\n\n![image-20240228164611062](https://cdn.davidingplus.cn/images/2025/02/01/image-20240228164611062.png)\n\n## 具体分析\n\n我们先不管这个`LVector`是如何实现的，我们知道`prepend`函数，肯定是调用`insert`方法，所以去查`insert`函数，以下只给出关键代码，其余都是针对代码的显而易见的分析（代码不是我写的，是钟老师写的，我只是阅读）\n\n真正做插入的函数叫`insertMultiple()`，里面有一些算法，不用管他，我们考虑`insert`函数的逻辑，在目标处进行插入，然后需要把其他的数据前移或者后移，也就是说，需要做内存的移动或者拷贝，问题就处在这里，也就是代码中的`moveMemory()`中\n\n~~~cpp\ntemplate <typename T>\ninline void LPaddedVector<T>::moveMemory(T *pTargetAddress, T *pSourceAddress, std::size_t count)\n{\n    std::memmove(pTargetAddress, pSourceAddress, count * sizeof(T));\n}\n~~~\n\n可以发现，`moveMemory`是直接调用的`std::memmove`，直接把原内存给移动过去了，乍一看好像没什么毛病，搬运就搬运呗，但是注意，使用了`std::memmove`，对象仅仅是换了一个位置，里面的数据什么都没变，现在把这个同`std::string`的`SSO`优化结合起来\n\n- 从左边移动到右边，`capacity`、`size`、`data`都没有问题，关键在于这个指针，前面说过，里面的数据仅仅是换了一个位置，那指针指向的还是原先的地址啊，而原先的地址现在如何？不知道，可能被覆盖，可能被释放了，因此就会出现上面的问题\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240228165833325.png\" alt=\"image-20240228165833325\" style=\"zoom: 67%;\" />\n\n## 问题解决\n\n分析了问题的来源，那解决问题就好办了，比如可以为`std::string`做特化，让他在这里使用拷贝的策略，这样能解决问题\n\n- 注意：这里的拷贝和前面移动导致的类似浅拷贝不一样，这里的拷贝是通过分配器构造，实际上调用的是`std::string`的拷贝构造函数，不管`std::string`是哪种优化方式，深拷贝他是必然做的，也就是说那根`pointer`就指向的是自身的`data`而不是之前的了，这样就是对的\n\n~~~cpp\ntemplate <>\ninline void LPaddedVector<std::string>::copyConstruct(std::string *pTargetAddress, const std::string &itemToCopy)\n{\n    sm_allocator.construct(pTargetAddress, itemToCopy.data(), itemToCopy.size());\n}\n\ntemplate <>\ninline void LPaddedVector<std::string>::moveMemory(std::string *pTargetAddress, std::string *pSourceAddress, std::size_t count)\n{\n    if (pTargetAddress < pSourceAddress)\n    {\n        for (int i = 0; i < count; i++)\n        {\n            sm_allocator.construct(pTargetAddress + i, pSourceAddress[i].data(), pSourceAddress[i].size());\n            sm_allocator.destroy(pSourceAddress + i);\n        }\n    }\n    else if (pTargetAddress > pSourceAddress)\n    {\n        for (int i = count - 1; i >= 0; i--)\n        {\n            sm_allocator.construct(pTargetAddress + i, pSourceAddress[i].data(), pSourceAddress[i].size());\n            sm_allocator.destroy(pSourceAddress + i);\n        }\n    }\n}\n~~~\n\n## 继续思考\n\n那么问题来了，如果有一个自定义类型，里面含有`std::string`，那又该怎么办呢？\n\n例如下面的测试\n\n~~~cpp\nstruct DataT\n{\n    int x;\n    std::string desc;\n};\n~~~\n\n![image-20240228170626962](https://cdn.davidingplus.cn/images/2025/02/01/image-20240228170626962.png)\n\n我第一反应想到的就是能不能用`c++`通过某种手段判断一个类当中是否含有指定类型例如`std::string`的成员变量，但由于水平不够，或者因为本来就不太好使，这条路走不通\n\n所以就只能从刚才提到的`moveMemory()`入手了，既然直接移动不好，那我干脆改成拷贝不行吗？当然不好，白白多了很多次拷贝，这是不可接受的，那有没有办法将二者结合起来呢？你别说，还真有。\n\n参考了`Qt`的部分实现，`Qt`中封装了一个叫`QTypeInfoQuery`的类，里面有一个变量`isRelocatable`，这个东西可以用来判断类能否**平凡可复制**，顾名思义，像`std::string`显然不能平凡可复制，因为`SSO`的优化，平凡复制的话指针指向的地方是原来的，显然不行，说白了就是类似浅拷贝，因此这里做了判断，如果不行就拷贝，可以就移动\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/8a91e41e1e61a64d333c6494ae960975.png\" alt=\"8a91e41e1e61a64d333c6494ae960975\" style=\"zoom:75%;\" />\n\n关于`std::string`堆内存那个模型，是满足平凡可复制条件的，画个图如下理解\n\n- `std::memmove`不会触发类的析构函数，因此堆内存还在，不会被释放，因此就做到了完美迁移，同时避免了不必要的栈内存和堆内存的拷贝，提升了效率\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240228171845622.png\" alt=\"image-20240228171845622\" style=\"zoom:70%;\" />\n\n在查看了`QTypeInfoQuery`的`isRelocatable`的来源之后，我发现调用的是标准库的一个`type_traits`，叫`is_trivially_copyable`，可以判断是否可以平凡可复制，平凡可复制的含义见上\n\n这里写了一个程序测试\n\n~~~cpp\n#include <iostream>\n#include <type_traits>\n\nstruct DataT1\n{\n    int x;\n    std::string str;\n};\n\nstruct DataT2\n{\n    int x;\n    DataT1 t;\n};\n\nstruct DataT3\n{\n    int a;\n    int b;\n    int c;\n    int d;\n    int e;\n    int f;\n    int g;\n};\n\nclass DataT4\n{\n\npublic:\n    DataT4() { p = new int(0); }\n\n    ~DataT4()\n    {\n        if (p)\n        {\n            delete p;\n            p = nullptr;\n        }\n    }\n\n    int *p = nullptr;\n};\n\nint main()\n{\n    std::cout << std::is_trivially_copyable<DataT1>::value << '\\n';\n    std::cout << std::is_trivially_copyable<DataT2>::value << '\\n';\n    std::cout << std::is_trivially_copyable<DataT3>::value << '\\n';\n    std::cout << std::is_trivially_copyable<DataT4>::value << '\\n';\n\n    return 0;\n}\n~~~\n\n执行结果\n\n- 前两个类由于具有`std::string`（第二个类套娃，也算），返回`0`，不可平凡可复制\n- 第三个类，全是一些`int`，显然可以\n- 第四个类，堆内存，这个设计和一般的`std::string`是一样的，返回的是`0`\n\n![image-20240228172702844](https://cdn.davidingplus.cn/images/2025/02/01/image-20240228172702844.png)\n\n好，现在问题来了，我们刚才说借助`type_traits`来进行判断，好决定是通过移动还是通过拷贝，代码甚至我都写好了\n\n~~~cpp\ntemplate <typename T>\ninline void LPaddedVector<T>::moveMemory(T *pTargetAddress, T *pSourceAddress, std::size_t count)\n{\n    if (std::is_trivially_copyable<T>::value)\n    {\n        // 如果是平凡可复制类型，可以直接使用 std::memmove\n        std::memmove(pTargetAddress, pSourceAddress, count * sizeof(T));\n    }\n    else\n    {\n        // 如果不是，逐个元素的拷贝\n        // 注意源地址和目标地址的位置不同，拷贝的顺序也不同\n        if (pTargetAddress < pSourceAddress)\n        {\n            for (int i = 0; i < count; ++i)\n            {\n                sm_allocator.construct(pTargetAddress + i, *(pSourceAddress + i));\n                sm_allocator.destroy(pSourceAddress + i);\n            }\n        }\n        else if (pTargetAddress > pSourceAddress)\n        {\n            for (int i = count - 1; i >= 0; --i)\n            {\n                sm_allocator.construct(pTargetAddress + i, *(pSourceAddress + i));\n                sm_allocator.destroy(pSourceAddress + i);\n            }\n        }\n    }\n}\n~~~\n\n我们还是考虑刚才的堆内存模型，经过判断之后是走拷贝这一条路，但是没必要啊，`std::memmove`不会激活对象的析构函数，我把所有数据移动到另一个地方，这个指针还是指向堆区的这一块内存，也就是说，实际上这个内存模型是平凡可复制的，这也是钟老师最初的想法（我研究了这么久才到大佬的初步想法，`e`了），这一点优化，就导致了最开始的问题，但是我们必须要有这种思维。\n\n那么就没有解决方案了吗？\n\n其实是有的，可以在这个判断之前再加上一层判断，例如某个类就是这种堆内存模型，经过分析他其实是可以平凡可复制的，那么我通过某种手段，例如宏，在那个类当中提供一种注册的方式，我保证这个类的行为是平凡可复制的，执行到这里之后先执行这个判断，如果`ok`，那直接走移动的道路，目前这样来看比较合理。这也是钟老师目前总结之后的研发需求。\n\n","categories":["实习","合迅科技","课题研究"]},{"title":"合迅科技 实习工作记录","url":"/posts/c14bed45.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n我在合迅科技的实习工作记录。\n\n# 1.15 - 1.26\n\n## 迭代任务\n\n1. 走查代码`LStack,LQueue,LByteArray`\n\n## 代码走查问题\n\n### LStack,LQueue\n\n二者是一样的设计，一样的问题，这里就统一写了\n\n- 处理结果：刘治学已重构修改\n\n1. 关于使用公有继承的问题\n\n   - 代码中直接使用公有继承的方式，并且使用了目前不完善的`LList`。\n   - 建议改为`LVector`作为底层容器。\n\n<!-- more -->\n\n   ~~~cpp\n   template<class T>\n   class LStack : public LList<T>\n   {\n       ...\n   }\n   ~~~\n\n   - 关于使用继承还是复合的问题：经过讨论，决定保留`public`继承的方式，不做覆盖，因为`Qt`也是这么做的，对于是隐藏父类不需要的功能还是保留，为了减少工作量，选择了保留，这个哲学问题留后续商榷\n\n### LByteArray\n\n- 处理结果：钟老师已重构修改\n\n1. 内存设计极其不合理\n\n   - 未作合理的内存管理，未对内存的开销和释放做合理的设计，目前是有多少开多少，导致较大的性能消耗，`insert`函数就是个典型的例子；字节数组与普通的动态数组区别在于可以接受三种不同的字符串处理方式，经过编码和解码的转换之后，以字节为单位，本质上就是一个动态`char *`，为了合理的管理内存，建议使用钟老师的 `LVector<char>`进行改造，钟老师的里面使用分配器`allocator`作了合理的内存管理\n   - 一个`insert`的不合理设计例子\n\n   ~~~cpp\n   LByteArray& LByteArray::insert(const char* str, int len, int pos)\n   {\n      \t...\n           \n       // 更新size的信息，开辟新内存\n       m_size = m_size + len;\n       unsigned char* lc = new unsigned char[m_size + 1];\n       // 将插入点以前的内容复制到新内存中\n       memcpy(lc, m_pByte, (pos) * sizeof(unsigned char));\n       // 复制要插入的内容到新内存中\n       for (int i = pos, j = 0; i < (pos + len); i++, j++)\n       {\n           unsigned char tempByte = 0;\n           tempByte = (unsigned char)*(str + j);\n           *(lc + i) = tempByte;\n       }\n       // 将插入点以后的内容复制到新内存中\n       memcpy(lc + pos + len, m_pByte + pos, (m_size - pos - len) * sizeof(unsigned char));\n       // 将字节数组存放的数据指向新内存\n       delete[] m_pByte;\n       m_pByte = lc;\n       return *this;\n   }\n   ~~~\n\n# 1.29 - 2.8\n\n## 迭代任务\n\n- 重构代码`LStack`，`LQueue`\n- 走查代码`LObject`，`LApplication`，`LSignal`\n\n## 任务1\n\n- 经过和钟老师商量，决定保留`public`继承的方式，不做覆盖，因为`Qt`也是这么做的，对于是隐藏父类不需要的功能还是保留，为了减少工作量，选择了保留，这个哲学问题留后续商榷\n- 目前已经完成初步重构，已经转测\n\n## 任务2\n\n### LObject\n\n- 这个类是所有类的基类，提供了`3种`非常重要的功能：对象树机制、动态属性功能、信号槽机制\n\n#### 对象树机制\n\n##### 学习的点\n\n- 对象树机制\n\n  - 我们在构造对象的时候，为了方便内存的管理和释放，将所有的对象之间建立关系，每个对象都有父对象和子对象（当然最终的父对象没有），比如`LButton`显然就是`LWindow`的子对象，如此以以来就形成了一颗多叉树\n\n\n  - 用一张图理解\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240130141713776.png\" alt=\"image-20240130141713776\" style=\"zoom:75%;\" />\n\n\n  - 优点：能够做到很好的内存释放，我们确定的父对象，当父对象释放的时候，子对象也必须跟着释放，例如`LWindow`没了，那`LButton`肯定也没了，对象树的功能就是父对象在释放的时候，会首先和他的父对象断开联系，然后释放以自己为根的这颗多叉树，从最下面的子对象开始依次向上释放，最终释放自身，有点`Java`的`gc`的感觉，如果不做处理的话，尤其是在堆上开辟的空间管理将会非常混乱；同时个人认为在`GUI`编程中用的非常频繁\n\n\n  - 在对象树当中，所有的对象为什么都必须处于同一个线程？\n\n    - 可能是跨线程的构造和释放不好管理吧（我也不是很清楚）\t\n\n  - 翻帖子的时候看到一个有意思的程序（重复析构）\n\n    ~~~cpp\n    // main.cpp\n    int main()\n    {\n        // 用户编码行为不规范\n        QPushButton quit(\"Quit\");\n        QWidget window;\n     \n        quit.setParent(&window);\n    }\n    ~~~\n\n\n- 判断对象是否是`new`出来的\n\n  - 重载`new`运算符，对类重载`new`运算符，在外部调用`new`的时候会优先考虑重载的版本\n  - 在这里重载之后，将类内部的数据全部填充为`'L'`\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240130163612435.png\" alt=\"image-20240130163612435\" style=\"zoom:75%;\" />\n\n  - 我们预留了一块内存判断区域，这时候`new`的实际操作顺序是，先调用我们的重载版本的`new`，然后强转为本类指针被接受，然后调用构造函数，因此在构造的时候其他数据段会进行初始化，而内存判断区不会，问题解决\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240130164008701.png\" alt=\"image-20240130164008701\" style=\"zoom:70%;\" />\n\n- `RTTI`机制\n\n  \n  - **由于`C++`是静态类型语言，有关类的信息只在编译期被使用，编译后就不再保留，因此程序运行时无法获取类的信息。这时就需要使用「运行期类型信息」，即`RTTI（Run-Time Type Information）`，运行时类型识别**\n  \n  - `RTTI`主要是在用在多态里面，程序能使用基类的指针来识别实际使用的派生类类型，这个步骤**在编译阶段是无法确定的**\n  \n  - `typeid`\n  \n  \n    - 对于非多态类型，没有虚函数表和虚函数指针的类型对象，`typeid`可以在编译期即完成计算，也就不存在`RTTI`机制，`dynamic_cast`更是没有必要，使用`static_cast`即可满足需求\n    - 对于多态类型，在编译器无法确定基类指针真正指向的类型，其对象的`typeinfo`信息存储在该类的虚函数表中。在运行时刻，根据指针的实际指向，获取其`typeinfo()`信息，从而进行相关操作\n    - 通过`dynamic_cast`进行的安全动态转换，会对应修改虚表中的相关信息，其中就包括`typeinfo`的信息\n  \n  - `dynamic_cast`：将基类指针安全的转化为派生类指针\n  \n  \n    - 从派生类指针转向基类指针，向上转换，是一个静态转换，并不是动态转换，因为子类一定包含基类\n    - 向下转换，编译器则需要沿着继承链寻找派生类是否匹配，查询`typeinfo`中的信息，匹配则转换，不匹配则按照失败处理\n  \n      - 这样会导致一个问题，如果继承链很庞大，效率就会低下，同时其中可能很多信息是没有用的，也消耗更多的空间成本\n  \n\n    ~~~cpp\n    // dynamic_cast\n    Animal* dog = new Dog;\n    \n    // 检查dog的类型\n    // 如果能安全转换返回转换后的指针，不则返回空指针或者抛出异常\n    Dog* res = dynamic_cast<Dog*>(dog);  // success\n    if (res)\n        std::cout << \"Dog success.\\n\";\n    \n    Cat* res2 = dynamic_cast<Cat*>(dog);  // fail\n    if (res2)\n        std::cout << \"Cat success.\\n\";\n    ~~~\n  \n  - `typeinfo`类：`typeinfo`类将构造函数，拷贝构造，移动构造等全部都删除了，因此不能实例化，其中含有方法`name()`，`==`，`!=`，使用`typeinfo`的唯一方式是通过关键字`typeid`\n  \n    ~~~cpp\n    int a = 1;\n    \n    // 不同的编译器输出的结果不同，Ubuntu下这里返回的是 i\n    std::cout << typeid(a).name() << '\\n';\n    \n    // 但是尽管编译器的实现存在差异，typeid是可以进行==号和!=号的比较的\n    std::cout << (typeid(a) == typeid(int)) << '\\n';     // true\n    std::cout << (typeid(a) == typeid(double)) << '\\n';  // false\n    \n    // typeid作用于自定义类\n    // 可以看出是有一定规律的，可以在构造函数的时候做一定解析存入类中\n    std::cout << typeid(Animal).name() << '\\n';  // 6Animal\n    std::cout << typeid(Dog*).name() << '\\n';    // P3Dog\n    std::cout << typeid(Cat**).name() << '\\n';   // PP3Cat\n    ~~~\n  \n\n##### 代码走查的问题\n\n- `Release`函数当中是释放子对象的过程感觉有点问题\n\n  - 子对象可能也有自己的子对象列表，所以应该按照递归的方式去调用，当本对象没有子对象才做真正的释放，这样感觉合理一些\n  - `2.21`更新：我看错了，它`delete`的是`pChild`，这样下去就是递归调用，这一条没有问题\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240204111431725.png\" alt=\"image-20240204111431725\" style=\"zoom:75%;\" />\n\n- 用`LList`替代`std::list`\n\n  - `LList`目前并未走查，也并未针对可能存在的问题修改或重构，代码健壮程度不如`LVector`，但是选用`LVector`的话由于二者接口名称的不同，可能需要改动的工作量较大\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240130145951498.png\" alt=\"image-20240130145951498\" style=\"zoom:80%;\" />\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240130150016313.png\" alt=\"image-20240130150016313\" style=\"zoom:80%;\" />\n\n- `RTTI`机制\n\n  - 我能想到的就是`typeinfo().name()`，它的返回值是有一定规律的，当然我们这里是用作自定义类类名的存储，做一个算法解析，然后在构造函数的时候调用即可\n\n  - 具体见上面\"学习的点\"\n  \n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240130165250475.png\" alt=\"image-20240130165250475\" style=\"zoom:77%;\" />\n\n#### 动态属性功能\n\n- 首先看`Qt`的属性机制，给我总的看法：我觉得很震惊，甚至感觉有点脱裤子放屁\n\n- 属性声明依托于`Q_PROPERTY`宏\n\n  - 最核心的功能：为类内的成员属性很方便的设置一个`getter`和`setter`方法，当然还有一些其他的附加方法\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240130152909683.png\" alt=\"image-20240130152909683\" style=\"zoom:78%;\" />\n\n  - 我自己用`Qt`写了一个`demo`做演示\n\n- 动态属性和静态属性\n\n  - 除了类当中原本就存在的属性，在程序运行的时候还可以运行时插入新的属性，这就是动态属性和静态属性的区别\n\n- 与我们的进行对比\n\n  - 个人认为`Qt`这么做的最大目的就是将属性的`getter`和`setter`方法做接口的统一，也就是使用`property`和`setProperty`，`Qt`用了这个宏的方法实现了基础功能和更加复杂的多样化功能\n  - 但对于我们目前而言，我觉得能够做到`getter`和`setter`就可以了，我们使用了`LVector<PropertyStruct*>`来存储构成存储动态属性的数组\n\n#### 信号槽机制\n\n- 关于信号槽机制原理见`LSignal`中\n\n- 存储连接到本对象某个槽函数的所有信号列表\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240201142729430.png\" alt=\"image-20240201142729430\" style=\"zoom:65%;\" />\n\n- 事件处理接口`event()`，可以处理定时器事件和信号槽事件，我关心信号槽事件，涉及到类`LSignalEvent`，见下面\n\n### LApplication\n\n#### 学习的点\n\n- 单例模式\n  - 不管有多少个`Window`，只能有一个`Application`实例，这个实例在一个进程中有且只能只有一个\n  \n  - 简单的单例程序\n  \n    ~~~cpp\n    // singleton.h\n    #ifndef _SIGLETON_H_\n    #define _SIGLETON_H_\n    \n    #include <iostream>\n    \n    class Singleton {\n    public:\n        static Singleton* getInstance();\n    \n        void print();\n    \n    protected:\n        Singleton() = default;\n        virtual ~Singleton() = default;\n    \n        Singleton(const Singleton&) = delete;\n        Singleton& operator=(const Singleton&) = delete;\n    \n        Singleton(Singleton&&) = delete;\n        Singleton& operator=(Singleton&&) = delete;\n    \n    private:\n        static Singleton* m_instance;\n    };\n    \n    #endif\n    ~~~\n  \n    ~~~cpp\n    // singleton.cpp\n    #include \"singleton.h\"\n    \n    Singleton* Singleton::m_instance = nullptr;\n    \n    Singleton* Singleton::getInstance() {\n        if (nullptr == m_instance)\n            m_instance = new Singleton();\n        return m_instance;\n    }\n    \n    void Singleton::print() {\n        std::cout << \"address: \" << m_instance << '\\n';\n    }\n    ~~~\n\n- 单例与多态结合\n\n  - 在构造`Application`的时候，构造单例平台相关接口，平台接口返回平台相关的一些信息，也是单例\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240131143154853.png\" alt=\"image-20240131143154853\" style=\"zoom:75%;\" />\n\n  - `LPlatformInterface`派生出`LLinuxInterface`和`LWin32Interface`，并且`LPlatformInterface`是一个抽象类，它内部的平台相关功能在派生类覆写，通用功能自己写了，并且它也是一个单例模式，因此派生类也是单例\n\n  - 抽象类无法实例化，但是我们构造`Application`的时候已经实例化出平台相关的派生类单例对象了；这时候多态就派上用场了，由于单例指针的唯一性，我们通过基类方法获得的指针，进而调用的方法就是平台相关的派生类方法，这就是多态\n\n  - 简单的多态程序\n\n    ~~~cpp\n    #include <iostream>\n    using namespace std;\n    \n    class Animal {\n    public:\n        virtual void speak() = 0;\n    };\n    \n    class Dog : public Animal {\n    public:\n        void speak() { cout << \"Dog speak.\" << endl; }\n    };\n    \n    class Cat : public Animal {\n    public:\n        void speak() { cout << \"Cat speak.\" << endl; }\n    };\n    \n    int main() {\n        Animal *dog = new Dog();\n        dog->speak();\n    \n        Animal *cat = new Cat();\n        cat->speak();\n    \n        return 0;\n    }\n    ~~~\n\n- 事件机制（简单理解）\n\n  - 我们的程序是通过事件循环进行轮询，不断检查是否有新的事件发生；发生之后，添加到一个事件队列中，事件循环再依次处理\n  - 每个线程都有自己的事件循环，`Application`是我们的主程序框架，在这就是主线程和主事件循环，主事件循环主要处理与用户界面相关的事件，当然还有所有事件的管理和分发；其他工作线程处理各自的任务，这样可以极大的提高效率\n  - 但是事件机制（`event`）在我们的代码里面如何应用，目前我看不懂。。。\n    - 跟海洋哥交流之后，说事件机制修改过几版，所以应该没有大问题，因此我只需要知道大致运作过程就好了\n  - 当然主程序框架为主事件循环提供了几个接口，例如`exec()`（其中主事件循环），`quit()`（退出事件循环）等\n\n#### 代码走查的问题\n\n- `LApplication`和`lplatforminterface`的移动构造和移动赋值函数的参数应该不需要带上`const`\n\n  - 右值引用代表进来的是一个将亡对象，一般写移动的内部实现是将二者的数据区`swap`，这样原来的数据区就会被自动回收，这样可以减少拷贝的次数，所以应该没有`const`\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240131142031853.png\" alt=\"image-20240131142031853\" style=\"zoom:71%;\" />\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240131141725174.png\" alt=\"image-20240131141725174\" style=\"zoom:70%;\" />\n\n- 代码中的`TODO`\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240131144606076.png\" alt=\"image-20240131144606076\" style=\"zoom:75%;\" />\n\n### LSignal\n\n#### 学习的点\n\n- 信号槽机制\n\n  - 信号槽机制的作用是当将某个信号函数和某个响应的槽函数绑定在一起的时候，当我的信号被触发的时候，就会自动触发对应的槽函数进行响应，比如点击`button`，触发的信号是`clicked`，可以关闭整个窗口，这里的槽函数就是`close()`\n\n- `LSignal`类\n\n  - 信号类，这个类用作信号槽的管理，里面有方法`connect`，`emit`，`disconnect`等\n\n  - `connect`函数\n\n    - 做了两个重载，为了区分类对象的成员函数和普通函数（比如`lambda`）\n\n      - 目前的实现无法处理带捕获的`lambda`，个人阅读`LSignalEvent`的代码之后，觉得`std::function`可能可以解决问题，由于槽函数的返回值是`void`，因此在初始化的时候使用`std::function<void()>`作为回调函数，然后绑定的时候赋值即可，这样带捕获的和不带捕获的就能统一，至于捕获的变量如何处理是用户的事情了\n\n      - 测试样例在`./snippet/SignalEmitTest`中\n    \n      - 但是具体如何使用`std::function`替代函数指针并且做好类成员变量和普通函数（支持`lambda`）的分别处理，需要一起讨论做进一步的设计\n    \n    - 测试程序\n    \n      ~~~cpp\n      // ./snippet/SignalEmitTest/main.cpp\n      #include <iostream>\n      \n      #include \"lobject.h\"\n      #include \"lsignal.h\"\n      \n      class Test : public LObject {\n      public:\n          Test() = default;\n          ~Test() = default;\n      \n          void run(int num) { std::cout << \"class function: \" << num << '\\n'; }\n      };\n      \n      void test1();\n      \n      int main() {\n          test1();\n      \n          return 0;\n      }\n      \n      void test1() {\n          LSignal<int> s;\n      \n          // 为该信号绑定槽函数\n          // 类成员对象函数\n          Test t;\n          s.connect(&t, &Test::run);\n      \n          // 普通函数\n          s.connect([](int num) {\n              std::cout << \"lambda: \" << num << '\\n';\n          });\n      \n          s.emit(1);  // 触发信号\n      }\n      ~~~\n    \n    - `connect`函数的作用是把槽函数加入到自身的槽函数列表中\n    \n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240201110235491.png\" alt=\"image-20240201110235491\" style=\"zoom:75%;\" />\n    \n    - `emit`函数的作用是发送信号，然后通过事件系统进行槽函数的调度\n    - `disconnect`函数就很简单了，就是删除对应的槽函数\n\n- `LSignalConnection`\n\n  - 真正做工作的信号连接类，是将信号发出，调度槽函数执行\n  - 为了区分类的成员函数和普通函数，做了一个简单的多态\n    - `LSignalConnection` `->` `LSignalConnectionToMethod`（类的成员函数） 和 `LSignalConnectionToFunction`（普通函数）\n    - 对于两种情况各自分别处理\n\n#### 代码走查的问题\n\n- 关于`LSignalBase`类\n\n  - 之前的想法\n    - 注释中写到：基类从实际的信号类中剥离泛型特性，方便使用统一的基类指针来实现信号列表的记录\n    - 但是实际上整个代码里面只有一个`LSignal`继承它，并且覆写了一些方法\n    - 在`LSignal`中存储`LSignalConnection`指针来维护槽函数相关的信息，槽函数分为成员函数和普通函数，二者的使用具有一定的区别，因此在`LSignalConnection`这里用到了多态，才是使用基类指针管理派生类\n    - 个人认为`LSignalBase`的存在有一些多余，当然目前能用\n\n  - `2.20`更新\n    - 注意不是`LSignal`，是`LSignal<... Args>`。`LSignal<... Args>`不是【一个】类，是【一系列】类。剥离泛型特性的含义就是可以用统一的`LSignalBase`指针处理任意`LSignal<... Args>`的实例类。任一`LSignal<... Args>`的实例，都以`LSignalBase`作为基类\n    - 而之所以我之前会疑惑在`base`类中没有`connect`方法，就是因为`connect`方法需要接受`... Args`参数，是模板类的成员函数，所以才需要`base`指针统一管理，这又是多态\n\n- 阅读到`LSignalEvent`的代码时候，没有对类的成员函数做相应处理（参见`LSignalConnection`），导致写`demo`时加上注释这一段编译不通过，测试程序在`./snippet/SignalEmitTest`，具体对比`LSignal`对两种类型的槽函数的不同处理\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240201142537356.png\" alt=\"image-20240201142537356\" style=\"zoom:75%;\" />\n\n  - `2.20`更新\n\n    - 是我自己的原因，参数的放置有问题，第一个参数是成员函数指针，第二个参数是类对象指针，后面才是相应的参数\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240220112728945.png\" alt=\"image-20240220112728945\" style=\"zoom:80%;\" />\n\n    - 这是因为`LSignalEvent`里面使用了`std::function`，`std::function`很方便的能够把类的成员函数，普通函数，带捕获和不带捕获的`lambda`统一起来，但是需要注意使用的参数规范\n\n    - 但是关于上面提到的问题，个人的看法是，第二个重载感觉有点抽象，第一个重载可以处理普通函数，带捕获和不带捕获的`lambda`；第二个这个参数形式，一开始确实没办法让我想到可以适用于类的成员函数，因为没有给定第二个参数，相当于第二个类指针的参数隐藏在了`rest...`中，这里建议做一些修改\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240220112939023.png\" alt=\"image-20240220112939023\" style=\"zoom:75%;\" />\n\n    - 参照了这里的思路之后，关于`LSignal`无法处理带捕获的`lambda`，个人认为就可以使用`std::function`替代原本的函数指针了\n\n\n## 会后总结\n\n### LStack，LQueue\n\n1. 自己修改后仍存在一系列代码规范问题，已按要求做相关修改\n\n### LObject\n\n1. `PropertyStruct`结构体中的`name`和`value`建议用`pair`做相关替代\n2. `MetadataStruct`结构体中存储的内容，考虑在后续引入`RTTI`之后，可以直接放在`Object`类中做成员而不用封装一层结构体\n3. 代码中使用`std::list`的部分，后续建议替换为`LVector`，问题在于接口名称统一以及工作量大小\n4. 代码中使用`std::set`的部分，后续建议替换为`LSet`\n5. `RTTI`机制，考虑是否引入？如何引入？\n\n### LApplication\n\n1. 代码中移动构造函数的右值引用不能带上`const`（已处理）\n2. 代码中使用`std::string`的部分，功能完善之后改为`LString`\n\n### LSignal\n\n1. 代码中使用`std::list`的部分，同`LObject`\n2. 现在的信号槽机制无法处理带捕获的`lambda`，个人研究后建议可以使用`std::function`对函数指针做统一的管理，具体用法见`snippet/StdFunctionDemo`，尚需做后续研究（新功能，不影响原先的版本）\n3. `LSignalEvent`中构造函数的第二个重载设计很不合适，已提相关`bug`\n\n# 2.19 - 3.1\n\n## 迭代任务\n\n1. 走查线程与同步相关内容，包括线程管理、线程数据、互斥锁、读写锁\n\n## 学习的点\n\n### 线程管理\n\n#### lthreadinterface\n\n`lthreadinterface`又是一个提供平台接口的单例加多态的例子，这个单例涉及到多线程，需要说明一下\n\n1. 单例在多线程中的表现\n   - 单例，单例，顾名思义，意思是在整个程序当中内存中只允许出现一份，保存在静态存储区的，所有的线程共享这一份单例指针\n2. 类当中的接口都是需要不同线程返回不同的值\n   - 思考到这里，我就在想既然不同线程的结果需要不一样，那么单例设计是否正确呢？\n   - 在这里的线程设计是`ok`的，因为`currentThreadId()`，`sleepForMicroseconds()`，`createThread()`这些接口，底层调用的方法都是线程相关的系统调用，这些方法在不同线程当中返回的值自然是不一样的，而我用统一的单例指针做了管理，这就是这个设计模式的整体思路，经过测试程序验证也是`ok`的，因此没毛病\n\n#### lposixthreadinterface\n\n1. 多线程私有数据`TSD（Thread Specific Data）`\n\n   - 在多线程当中，所有线程共享程序段中的变量，例如一个全局变量，所有线程都可以使用，因此会出现线程同步的相关问题，也就有互斥锁、读写锁、条件变量、信号量等手段；但是现在我们需要一些数据，线程可以单独进行使用，其他线程无法访问，需要引入**线程存储**\n   - `pthread_key_t`，对应一个`key`的变量，这个键在每个线程中可以映射到各自线程的数据区，可以存储对应的值，因此`key`是共享的，起着索引的作用（理解这一点，后续理解销毁就轻松了），但是在各自线程中存储的数据是不一样的，这就是实现的大致思路，这也是线程存储的意义\n   - `pthread_key_delete`，关于这个东西的销毁机制需要说明一下\n     - 查阅资料之后得知，所有的线程都可以通过共享的`key`得到线程私有的`value`，当线程内部调用`pthread_key_delete`之后，当前线程`key`与`value`的连接断开，不能再通过`key`获取到原先的`value`，但是注意，原先的数据还在内存中，现在本线程再通过`pthread_getspecific`获取`value`得到的是空或者是系统设置的默认值，反正得不到之前的数据\n     - 那么之前的数据如何清理呢？这就需要`pthread_create`的第二个参数了，第二个参数传入一个函数指针，用于对`value`的清理；当`key`被`delete`之后，系统会在线程结束的时候自动调用清理函数释放相关资源\n     - 注意，第二个参数的类型是`void*`，和线程的普遍设计一样，都给定`void*`，然后自己进行特定类型指针的转化即可\n     - 值得提到的是，一定需要手动调用`pthread_key_delete`对存储键进行销毁，否则可能无法正确激活系统对清理函数的调用，因为系统可能认为存储键还绑定着，这样就可能导致内存泄漏\n   - 关于如何使用见`./snippet/PthreadKeyTest`\n\n2. `pthread_once`：在多线程中让某些操作**只执行一次**\n\n   ~~~cpp\n   int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；\n   \n   // 功能：本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。\n   ~~~\n\n   - 多线程中，尽管`pthread_once`会出现在多个线程中，但是能保证`init_routine`的函数只执行一次，`once_control`作执行一次的标志作用，并且`Linux`要求`once_control`的初始值必须为`PTHREAD_ONCE_INIT`，否则函数行为不正常\n\n3. 有以上二者就能够理解代码中获取线程数据的设计了，代码中注释理解\n\n   - `reinterpret_cast`：`reinterpret_cast`用于进行各种不同类型的指针之间、不同类型的引用之间以及指针和能容纳指针的整数类型之间的转换。转换时，执行的是逐个`bit`复制的操作。这种转换提供了很强的灵活性，但转换的安全性只能由程序员的细心来保证了。例如，程序员执意要把一个`int*`指针、函数指针或其他类型的指针转换成`string*`类型的指针也是可以的，至于以后用转换后的指针调用`string`类的成员函数引发错误，程序员也只能自行承担查找错误的烦琐工作\n\n   ~~~cpp\n   pthread_once_t LPosixThreadInterface::sm_onceFlag = PTHREAD_ONCE_INIT;\n   \n   // 函数用作获取线程存储数据的指针\n   LThreadData *LPosixThreadInterface::currentThreadData()\n   {\n       // 用pthread_once保证，initThreadLocalStorage只执行一次\n       // initThreadLocalStorage函数用作初始化pthread_key_t，也就是存储键，可以让key共享，但是不同线程各自存储各自的数据\n       pthread_once(&sm_onceFlag, LPosixThreadInterface::initThreadLocalStorage);\n       // pthread_getspecific()，获取key对应的数据，这里就是线程数据；这样我的线程数据被更改之后就能通过这个接口通过key进行访问获得\n       LThreadData *pThreadData = reinterpret_cast<LThreadData *>(pthread_getspecific(sm_tlsKeyThreadData));\n       // 有则获得，无则创建返回\n       if (!pThreadData)\n       {\n           pThreadData = new LThreadData();\n           int res = pthread_setspecific(sm_tlsKeyThreadData, pThreadData);\n           if (res != 0)\n           {\n               throw LException(\"无法在线程本地存储中设置线程数据。\");\n           }\n       }\n       return pThreadData;\n   }\n   ~~~\n\n#### lwin32threadinterface\n\n设计同`unix`平台一样，只是平台接口不同，具体可查看文档，我不是搞`windows`的，所以这里不写了\n\n#### lthread\n\n1. 关于`threadRoutine()`函数的设计\n\n   - `threadRoutine()`是干嘛的？是目标线程的入口函数，用户使用`LThread`类的时候，不能直接使用该类，因为本类中真正用户做的`run()`是纯虚函数，所以需要派生覆写。但是`LThread`类作为线程管理类，在执行线程任务的时候除了跑用户的函数，肯定需要做一些类似系统记录的东西，比如做一些赋值，发一些信号等等，因此`threadRoutine()`才是真正传递给`pthread_create()`的函数，并且由于需要作为`pthread_create()`的参数，需要是静态的，执行函数需要的参数通过后面的`void*`参数传入\n\n   - 我们现在看一下`threadRoutine()`的具体实现\n\n     - 在代码中，有且仅有`start()`中用到了`threadRoutine`，并且将`this`指针作为参数传入，至于为什么前面已经提到\n     - 具体的解读在代码注释中，这个设计真的很精妙\n\n     ~~~cpp\n     void LThread::start()\n     {\n         if (isStarted())\n         {\n             std::cerr << \"线程已启动，无法再次启动。\" << std::endl;\n             return;\n         }\n     \n         // 将threadRoutine函数作为子线程真正执行的函数，this指针作为参数传入\n         m_threadId = LPlatformThreadInterface::instance()->createThread(LThread::threadRoutine, this);\n     }\n     \n     // 注意，执行到这里的时候函数体内部已经是子线程中了\n     void *LThread::threadRoutine(void *pParam)\n     {\n         // 这里的pParam就是主线程中的this指针，子线程需要用到主线程中本类的相关内容，因此需要传入\n         if (!pParam)\n         {\n             throw LException(\"线程入口函数未能获取正确的参数。\");\n         }\n         LThread *pThread = reinterpret_cast<LThread *>(pParam);\n     \n         // 创建线程数据\n         LThreadData *pThreadData = LThread::currentThreadData();// 子线程的pThreadData\n         pThread->m_pTargetThreadData = pThreadData;// 通过this指针，更新主线程的类的成员\n         pThreadData->m_pThread = pThread; // 通过this指针，更新子线程的pThreadData的属性\n     \n         // 下面的操作都需要主线程的this指针才能办到，也是执行子线程必不可少的管理步骤\n         \n         // 发送线程起始信号\n         pThread->startSignal.emit();\n     \n         // 调用线程任务函数\n         // 这里才是真正执行用户代码的地方\n         pThread->run(); \n     \n         // 清理\n         // pThread->cleanup();\n     \n         // 发送线程结束信号\n         pThread->finishSignal.emit();\n         pThread->m_threadId = 0;\n     \n         // 目前暂不处理线程返回\n         return nullptr;\n     }\n     ~~~\n\n### 互斥锁\n\n#### lmutex\n\n1. 为了做到平台适配，定义了统一基类`LPlatformMutexContext`指针，针对不同平台派生，使用多态进行处理，在后续的`lock()，trylock()，unlock()`中就很方便的使用`LPlatformMutexContext`的接口即可\n\n   - 在`LMutex`构造函数中，使用`#ifdef、#elif、#else、#endif`宏初始化指针\n\n   ~~~cpp\n   LMutex::LMutex()\n   {\n   #ifdef __unix__\n       m_pMutexContext = new LPosixMutexContext();\n   \n   #elif _WIN32\n       m_pMutexContext = new LWin32MutexContext();\n   \n   #else\n       throw LException(\"无法创建互斥锁上下文：无法检测当前操作系统平台。\");\n   #endif\n   }\n   ~~~\n\n#### lmutexcontext\n\n1. 是一个抽象基类，延申出`unix`和`win32`的各自派生，在类当中的函数都是纯虚函数，等待子类的覆写，由于无法实例化，因此需要在上层在做一层包装，也就是在`lmutex`中使用该类指针进行多态的管理，做到了平台无关\n\n#### lposixmutexcontext\n\n1. 关于互斥锁属性中的普通锁和检错锁\n\n   - 互斥锁属性通过`pthread_mutex_init()`进行设置，第一个参数是互斥锁指针，第二个参数是属性指针\n\n   - 普通锁属性：`PTHREAD_MUTEX_TIMED_NP`，默认值，线程加锁之后，实际上在锁这里形成了等待队列\n\n   - 检错锁属性：`PTHREAD_MUTEX_ERRORCHECK_NP`，和普通锁的区别是检测到自身重复加锁之后不会阻塞，而是返回`EDEADLK（35）`，这样可以一定程度上作加锁的安全检测\n\n#### lwin32mutexcontext\n\n`win`平台下的互斥锁，官方文档：[Synchapi.h 标头 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/api/synchapi/)\n\n1. 代码中使用`CRITICAL_SECTION`关键节对象代表互斥锁，值得注意的是`win`平台自身也具有互斥锁，二者的区别在于关键节对象只能单个进程的线程使用，不支持跨进程共享\n2. 一些接口\n   - `InitializeCriticalSection`、`DeleteCriticalSection`、`EnterCriticalSection`、`TryEnterCriticalSection`、`LeaveCriticalSection`，`CriticalSection`意为临界区，分别对应初始化、销毁、加锁、尝试加锁、解锁，其中只有尝试解锁`trylock()`有返回值，其他的函数均没有返回值，均由操作系统自行处理，所以没有做错误和异常处理\n\n### 读写锁\n\n#### lreadwritelock、lreadwritelockcontext\n\n整体设计和互斥锁一样，这里不再赘述\n\n#### lposixreadwritelockcontext\n\n1. 锁的静态初始化和动态初始化（以读写锁为例）\n\n   - 静态初始化\n\n   ~~~cpp\n   pthread_rwlock_t m_rwlock = PTHREAD_RWLOCK_INITIALIZER;\n   ~~~\n\n   - 动态初始化\n\n   ~~~cpp\n   pthread_rwlock_t m_rwlock;\n   pthread_rwlock_init(&m_rwlock, nullptr);\n   ~~~\n\n   二者的区别：\n\n   - 静态初始化在编译期就初始化完毕；动态初始化在运行期\n   - 静态初始化不能设置锁的相关属性，只能使用默认的；动态初始化可以\n   - 静态初始化的锁存储在静态存储区；动态初始化在堆区\n   - 静态初始化使用完毕之后不需要手动`destroy`；动态初始化需要\n\n2. 读写锁的特别之处\n\n   - 为什么有读写锁？为了增加效率，不同线程可以通过读锁同时读取，共享数据，但是不能修改；需要修改的时候使用排他的写锁，写锁的表现行为和互斥锁是差不多的\n   - 在系统提供的`API`中，加锁有加读锁和加写锁两个，但是解锁只有一个，为什么？\n     - 同一个线程不可能在持有读锁的同时，再去持有写锁，否则会导致死锁，程序阻塞，具体见`./snippet/RwlockTest`\n     - 当然先加排他的写锁，再加共享的读锁是`ok`的，因为排他写锁首先能写，那必然读就隐含在里面了；只是不能持有共享读锁的情况下再加排他写锁\n     - 读写锁明确了读锁就只能读，不能写，如果每次读了就需要写，那还不如使用互斥锁\n     - 因此只有一个解锁接口`unlock()`\n\n#### lwin32readwritelockcontext\n\n1. 代码中使用`SRWLock`代表读写锁\n2. 一些接口\n   - `InitializeSRWLock`、`AcquireSRWLockShared`、`TryAcquireSRWLockShared`、`AcquireSRWLockExclusive`、`TryAcquireSRWLockExclusive`、`ReleaseSRWLockShared`、`ReleaseSRWLockExclusive`，其中只有`trylock()`有返回值，其他函数均没有返回值，不用做异常处理\n3. `win32`下面，释放读写锁是分开的，没有统一的释放接口，只有各自释放的接口，共享读锁`ReleaseSRWLockShared`和排他写锁`ReleaseSRWLockExclusive`\n4. 与互斥锁的临界区作对比\n   - 临界区中销毁临界区`DeleteCriticalSection`，解锁`LeaveCriticalSection`，这两个是区分开的，对应`unix`下面的`pthread_mutex_destroy`和`pthread_mutex_unlock`\n   - 但是读写锁没有销毁函数，销毁操作通过读写锁的释放实现，即`ReleaseSRWLockShared`和`ReleaseSRWLockExclusive`\n\n## 代码走查问题\n\n### 线程管理\n\n#### lthreadinterface\n\n1. `currentThreadId()`接口注释没有`@return`\n\n   ~~~cpp\n   /**\n    * @brief 获取当前线程的线程 ID。\n    * @details 在不同的平台下获取的 ID 数据类型：\n    * - Unix (POSIX) 平台: pthread_t 类型\n    * - Windows 平台：DWORD 类型，即 unsigned long\n    */\n   virtual unsigned long currentThreadId() = 0;\n   ~~~\n   \n1. 禁用了拷贝构造和赋值函数，按理同样应该禁用移动构造和赋值函数\n\n   - 当然在本类中这是单例将构造函数私有，这倒无所谓，但是其他类也有类似的问题，因此还是罗列出来\n\n   ~~~cpp\n   /**\n    * @brief 禁止进行拷贝构造。\n    */\n   LPlatformThreadInterface(const LPlatformThreadInterface &) = delete;\n   \n   /**\n    * @brief 禁止进行赋值构造。\n    */\n   LPlatformThreadInterface &operator=(const LPlatformThreadInterface &) = delete;\n   ~~~\n\n#### lposixthreadinterface\n\n1. 类最前面没有`doxygen`注释\n\n   ~~~cpp\n   #include \"lthreadinterface.h\"\n   \n   #include <pthread.h>\n   \n   \n   class LPosixThreadInterface : public LPlatformThreadInterface\n   {\n   \n   public:\n       \n       ...\n   \n   }\n   ~~~\n\n2. `currentThreadData()`中初始化线程键相关的东西，应放在构造函数中\n\n   ~~~cpp\n   LThreadData *LPosixThreadInterface::currentThreadData()\n   {\n       pthread_once(&sm_onceFlag, LPosixThreadInterface::initThreadLocalStorage);\n       \n       ...\n   }\n   ~~~\n\n   - 这里会引申出另一个问题，就是`key`的释放问题，代码中并没有给出`pthread_key_delete`，也没有在`pthread_create`的时候给出清理函数（第二个参数），这样可能会导致线程退出的时候线程数据没办法得到正确释放，从而导致内存泄漏\n   - 在析构函数中对键进行销毁，调用`pthread_key_delete`\n   - 给出`pthread_create`的第二个参数，是一个函数指针，可以在代码里面设置一个静态的`clean`函数，在实现里面直接`delete`即可，会调用`LThreadData`的析构函数，这个就不用担心了\n\n3. 关于代码里面的所有线程`ID`类型，建议替换为系统给出的线程`ID`类型`pthread_t`\n\n   - `2.26`更新\n     - 为了保持平台无关适配，由于`win`平台不是`pthread_t`，而是`DWORD`，因此需要做一个统一，因此用`unsigned long`，这条没问题\n     - 同理，`unix`下睡眠的`useconds_t`，本质是`unsigned int`，但是为了作适配，由于`win`平台是`unsigned long`，因此统一用`unsigned long`\n\n   ~~~cpp\n   /**\n    * @brief 获取当前线程的线程 ID。\n    */\n   unsigned long currentThreadId() override;\n   ~~~\n\n4. `currentThreadId()`接口注释没有`@return`，同上\n\n5. `createThread()`接口注释没有`@param pParam`\n\n   ~~~cpp\n   /**\n    * @brief 创建并执行线程。若创建成功，返回新线程 ID。\n    * @param fpStarter 入口函数指针\n    * @return 新线程 ID。若失败则返回 0。\n    */\n   unsigned long createThread(void *(*fpStarter)(void *), void *pParam) override;\n   ~~~\n\n6. `joinThread()`有两行代码可以写为一行\n\n   ~~~cpp\n   void LPosixThreadInterface::joinThread(unsigned long threadId)\n   {\n       pthread_t tid = (pthread_t)threadId;\n       int res = pthread_join(tid, nullptr);  // 暂不处理返回值\n   \t\n       ...\n   };\n   ~~~\n\n#### lwin32threadinterface\n\n1. 类最前面没有`doxygen`注释，同`lposixthreadinterface`\n\n2. `currentThreadId()`接口注释没有`@return`，同`lposixthreadinterface`\n\n3. `createThread()`接口注释没有`@param pParam`，同`lposixthreadinterface`\n\n4. 构造函数中的进程只执行一次的设计同`unix`下的`pthread_once()`是相同的功能，但是二者放的位置不同，两种位置均有说法，但是为了保持代码风格统一，可以考虑做一下统一\n\n   ~~~cpp\n   LWin32ThreadInterface::LWin32ThreadInterface()\n   {\n       InitOnceExecuteOnce(&sm_onceFlag, initThreadLocalStorage, nullptr, nullptr);\n   }\n   \n   LThreadData *LWin32ThreadInterface::currentThreadData()\n   {\n       LThreadData *pThreadData = reinterpret_cast<LThreadData *>(TlsGetValue(sm_tlsKeyThreadData));\n       DWORD lastError = GetLastError();\n   \n       if (!pThreadData && lastError == ERROR_SUCCESS)\n       {\n           // 如果线程本地存储的值为 nullptr，则创建新的 LThreadData 对象\n           pThreadData = new LThreadData();\n           if (!TlsSetValue(sm_tlsKeyThreadData, pThreadData))\n           {\n               // 设置线程本地存储的值失败\n               lastError = GetLastError();\n               delete pThreadData;\n               pThreadData = nullptr;\n   \n               throw LException(\"无法在线程本地存储中设置线程数据。\");\n           }\n       }\n   \n       return pThreadData;\n   }\n   ~~~\n\n5. 代码中关于创建线程执行回调函数的设计，很抽象\n\n   - 第一，创建一个`LPair`对象干什么，还是`new`出来的，还把函数指针包进去了\n   - 第二，`threadEntry`里面把函数指针和参数拿出来，然后手动执行，这一步没有必要\n\n   ~~~cpp\n   unsigned long LWin32ThreadInterface::createThread(void *(*fpStarter)(void *), void *pParam)\n   {\n       unsigned long threadId = 0;\n   \n       // 创建LPair对象，用于封装函数指针和参数\n       auto pParams = new LPair<void *(*)(void *), void *>(fpStarter, pParam);\n       \n       // 创建并执行线程\n       HANDLE hThread = CreateThread(nullptr, 0, threadEntry, pParams, 0, &threadId);\n   \n       ...\n   }\n   \n   ...\n       \n   DWORD WINAPI LWin32ThreadInterface::threadEntry(LPVOID pParameter) \n   {\n       auto pParams = static_cast<LPair<void *(*)(void *), void *>*>(pParameter);\n       void *(*fpStarter)(void *) = pParams->key();\n       void *pParam = pParams->value();\n       fpStarter(pParam);\n       delete pParams;\n       return 0;\n   }\n   ~~~\n\n#### lthread\n\n1. 同样应禁用移动构造和赋值函数，同`lthreadinterface`\n\n2. 目前注释了三个接口，`terminate()，setThreadFunction()，cleanup()`，是否考虑后续引入\n\n3. `terminate()`接口未写`@return`注释\n\n   ~~~cpp\n   // /**\n   //  * @brief 尝试强行终止目标线程。\n   //  */\n   // bool terminate();\n   ~~~\n\n4. `threadRoutine()`接口未写`@return`注释\n\n   ~~~cpp\n   /**\n    * @brief 目标线程的入口函数。\n    * @details 遵循各平台下线程入口函数的约定，形参和返回值都为 void * 类型。\n    * 通过入口函数形参传入 \\a this 指针，再在此入口函数中通过 this 指针来执行信号发送等操作。\n    * @param pParam 入口函数形参\n    * @note 注意该函数应执行于目标线程上。\n    */\n   static void* threadRoutine(void *pParam);\n   ~~~\n\n5. `LThread`的构造函数可以内联\n\n   ```cpp\n   // lthread.cpp\n   LThread::LThread() : LObject()\n   {\n   }\n   ```\n\n\n### 线程数据\n\n#### lthreaddata\n\n1. 同样应禁用移动构造和赋值函数，同`lthreadinterface`\n\n2. 文件中做了`LDummyMainThread`的声明，但是本类中，甚至所有其它类中没有地方用到它\n\n   ~~~cpp\n   ...\n   class LDummyMainThread;\n   ...\n       \n   class LThreadData\n   {\n   \n       friend class LThread;\n       friend class LDummyMainThread;\n       \n       ...\n   }\n   ~~~\n\n### 互斥锁\n\n#### lmutex\n\n1. 析构函数注释少写了句号（`。`）\n\n   ~~~cpp\n   /**\n    * @brief 析构函数\n    */\n   ~LMutex();\n   ~~~\n\n2. `lock()`接口注释不应该有`@return`\n\n   ~~~cpp\n   /**\n    * @brief 进行加锁操作，使当前线程占有该锁。若另一线程已持有此锁，将阻塞当前线程。\n    * @return 是否成功加锁\n    */\n   void lock();\n   ~~~\n\n3. 拷贝赋值函数少写了`const`，同时在代码里面未禁用移动构造和赋值，针对互斥锁当前的情况，应当禁用移动构造和赋值函数\n\n   ~~~cpp\n   /**\n    * @brief 禁止拷贝构造。\n    */\n   LMutex(const LMutex &) = delete;\n   \n   /**\n    * @brief 禁止赋值构造。\n    */\n   LMutex &operator=(LMutex &) = delete;\n   ~~~\n\n\n#### lmutexcontext\n\n1. `<pthread.h>`头文件的引入，有点多余\n\n   ~~~cpp\n   #ifdef __unix__\n       #include <pthread.h>\n   #endif\n   ~~~\n\n1. 析构函数注释问题，同`lmutex`\n\n#### lposixmutexcontext\n\n1. `class`前面的注释内容`@class`有误，是`LPosixMutexContext`\n\n   ~~~cpp\n   /**\n    * @class LMutex\n    * @brief POSIX 平台互斥锁上下文。\n    */\n   class LPosixMutexContext : public LPlatformMutexContext\n   {\n       ...\n   }\n   ~~~\n\n2. 析构函数注释问题，同`lmutex`\n\n3. 析构函数和`trylock()`部分错误处理使用了`std::cerr`\n\n   - `trylock()`这里可以理解，因为是试探能否加锁成功，不成功返回`false`，通过标准错误输出信息也可以\n   - 另外，`std::cerr`对应的标准错流是无缓冲的，没必要使用`std::endl`再冲洗一次缓冲区，输出`'\\n'`即可\n   - 析构函数这里失败的话，建议使用异常处理\n\n   ~~~cpp\n   LPosixMutexContext::~LPosixMutexContext()\n   {\n       int res = pthread_mutex_destroy(&m_mutex);\n       if (res != 0)\n       {\n           // Handle error properly\n           std::cout << \"pthread_mutex_destroy() gave error code: \" << res << std::endl;\n       }\n   }\n   \n   bool LPosixMutexContext::tryLock()\n   {\n   \t...\n           \n       else if (res == EBUSY)\n       {\n           std::cerr << \"LMutex::tryLock(): Target mutex is busy.\" << std::endl;\n           return false;\n       }\n   \n       ...\n   }\n   ~~~\n\n4. 在锁的构造函数当中，使用检错锁，但是在`lock()`当中未作重复加锁的针对性判断，具体见`./snippet/MutexLockTest`\n\n   ~~~cpp\n   void LPosixMutexContext::lock()\n   {\n       int res = pthread_mutex_lock(&m_mutex);\n       if (res != 0)\n       {\n           throw LException(LString(\"互斥锁加锁失败，错误代码：\").append(LString(res)));\n       }\n   }\n   ~~~\n\n   - `trylock()`的判断并无问题，经过验证普通锁和检错锁在`trylock()`下加锁失败返回的都是`EBUSY（16）`\n\n#### lwin32mutexcontext\n\n1. 析构函数注释问题，同`lmutex`\n2. `std::cerr`问题，同`lposixmutexcontext`\n\n### 读写锁\n\n#### lreadwritelock\n\n1. 拷贝赋值函数问题，同`lmutex`\n\n#### lreadwritelockcontext\n\n1. `<pthread.h>`头文件的引入，同上\n\n#### lposixreadwritelockcontext\n\n1. 构造函数使用了静态初始化，经研究动态和静态的区别之后认为使用动态初始化可能好一点\n\n   ~~~cpp\n   LPosixReadWriteLockContext::LPosixReadWriteLockContext()\n   {\n       m_rwlock = PTHREAD_RWLOCK_INITIALIZER;\n   }\n   ~~~\n\n   - 静态初始化出来的锁不需要手动释放了，在析构函数中调用了`destroy`，可能会出现不可预测的运行时问题\n   - 互斥锁那边使用的是动态初始化，当然是因为需要设置检错锁必须这么做，但是个人认为为了保持代码风格的统一，建议使用动态初始化\n\n2. `std::cerr`问题，同`lposixmutexcontext`\n\n#### lwin32readwritelockcontext\n\n1. `std::cerr`问题，同`lposixmutexcontext`\n\n2. 代码风格统一问题，`trylock()`的判断，逻辑都是一样的，大致结构也应该一样\n\n   ~~~cpp\n   //互斥锁\n   bool LWin32MutexContext::tryLock()\n   {\n       // 尝试加锁操作\n       if (TryEnterCriticalSection(&m_mutex) != 0) //这里有 !=0\n       {\n           return true;\n       }\n       else\n       {\n           std::cerr << \"无法获取互斥锁。\" << std::endl;\n           return false;\n       }\n   }\n   \n   //读写锁\n   bool LWin32ReadWriteLockContext::tryLockRead()\n   {\n       if (TryAcquireSRWLockShared(&m_rwlock)) //这里没有\n       {\n           return true;\n       }\n       else\n       {\n           std::cerr << \"LWin32ReadWriteLockContext::tryLockRead(): Failed to acquire read lock.\" << std::endl;\n           return false;\n       }\n   }\n   \n   bool LWin32ReadWriteLockContext::tryLockWrite()\n   {\n       if (TryAcquireSRWLockExclusive(&m_rwlock)) //这里没有\n       {\n           return true;\n       }\n       else\n       {\n           std::cerr << \"LWin32ReadWriteLockContext::tryLockWrite(): Failed to acquire write lock.\" << std::endl;\n           return false;\n       }\n   }\n   ~~~\n\n3. `unlock()`接口，个人认为应当实现\n\n   - 在`win`平台下，尝试释放一个为获取的读锁或者写锁，由于函数没有返回值，无法像`unix`一样根据结果进行判断，但是`win`平台调用内部做了相关处理，不用我们操心，在这里对应的结果就是函数执行会被忽略\n   - 因此，这里分别执行释放读锁和写锁就行\n\n   ~~~cpp\n   void LWin32ReadWriteLockContext::unlock()\n   {\n       throw LException(\"Win32 unlock() 未实现，请使用 unlockRead() 或 unlockWrite() 。\");\n   }\n   ~~~\n\n# 3.4 - 3.15\n\n## 迭代任务\n\n1. 走查画笔`LPen`，画刷`LBrush`、`LLinearGradient`，菜单`LMenu`、`LMenuItem`部分代码\n\n## 学习的点\n\n### 画笔\n\n#### LPen\n\n我以为这个类是拿来做画笔的相关绘制的，但其实设计并非我想的这样。这个类`LPen`只是一个数据存储类，保存了画笔需要的一些信息，例如画笔宽度、画笔连接样式、画笔颜色等，真正管理绘画的类是绘画引擎类，对于`LPen`是`LDrawEngine`以及其下面的工具类，这些类里面保存了`LPen`对象，并且针对不同的绘画做了不同的处理，包括下面的画刷`LBrush`也是一样的道理\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240306104337531.png\" alt=\"image-20240306104337531\" style=\"zoom:85%;\" />\n\n### 画刷\n\n#### LBrush\n\n也是一个数据存储类，具体思路见`LPen`，不再赘述\n\n#### LLinearGradient\n\n1. 大致设计思路：\n\n   - 这个类与`LBrush`类一起使用，以指定线形渐变笔刷，在类当中存储了渐变点起始坐标、结束坐标和标识的渐变点数组\n\n     ```cpp\n     /**\n      * @brief 标识渐变起点坐标。\n     */\n     LPoint m_start;\n     \n     /**\n      * @brief 标识渐变终点坐标。\n     */                   \n     LPoint m_finalStop;\n     \n     /**\n     * @brief 标识渐变点数组，包含渐变比例参数和颜色,渐变比例参数范围为[0,1]。\n     */   \n     LVector<LPair<double, LColor>> m_stops;\n     ```\n\n     - 第一个参数是渐变比例参数，范围是`0~1`，如何理解？\n     - 首先理解如何渐变，从起始点开始到结束点，连起来是一条线段，我们的`LBrush`是沿着这条线段进行颜色渐变，垂直线段的颜色是一样的；\n     - 这个比例参数就是在线段上的比例对应位置想要设置的颜色，比如设置一个这个参数之后，左右的线段的渐变就被分为了两个区域，例如从黑到白变成黑到红到白，这两种的视觉效果是不一样的\n\n   - 更多接口的作用见上面，基本每个接口都或多或少存在问题，就写在上面了\n\n   - 可以通过一个测试程序看看效果\n\n     ```cpp\n     #include <iostream>\n     \n     #include \"llineargradient.h\"\n     #include \"lpair.h\"\n     #include \"lvector.h\"\n     #include \"ldrawwindow.h\"\n     #include \"ldrawcontext.h\"\n     #include \"lwindowapplication.h\"\n     \n     int main(int argc, const char *argv[])\n     {\n         LWindowApplication app;\n         LDrawWindow dw;\n         LDrawContext *dc = dw.drawContext();\n     \n         LLinearGradient line(LPoint(100, 0), LPoint(300, 0)); // 渐变从(100,0)到(300,0)\n         dc->setBrushGradient(line);\n         dc->drawRect(LRect(0, 0, 400, 400));// 画一个矩形\n     \n         dw.show();\n         app.exec();\n     }\n     ```\n\n     执行下来大概就是这个结果\n\n     <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240307145534071.png\" alt=\"image-20240307145534071\" style=\"zoom:67%;\" />\n\n### 菜单\n\n#### LMenu\n\n1. 整体设计\n\n   - 菜单的设计牵扯到窗体系统中的一大堆，这部分不归我走查，我也没有这么多精力走查，所以里面还是有一些一知半解的地方\n\n   - `LMenu`的菜单的含义为**弹出式菜单**，本质上是一个弹出式窗口，内部存在可点击的菜单项，还能添加分割线对菜单进行分组\n\n   - 内部的成员变量\n\n     - 四个静态变量，默认菜单项宽度和高度、默认分割线区域高度很容易理解；默认（竖直方向）内边距是指菜单项与边框之间的距离，下面画出一个图就理解了（当然阅读了`repaint()`接口之后，这里其实不只是竖直方向，四边都留了间距）\n     - 菜单项中存放了菜单项需要的一些属性，其中分割线是菜单项的一个派生类，绘图引擎会根据这个做不同的绘制\n     - `m_pointingItemIndex`是一个索引，用来表示当前鼠标指向的是哪一个菜单项，这个东西是通过当前鼠标的坐标与`m_itemPos`数组结合确定的，这个数组存储了所有菜单项的底端`y`坐标，找到范围即可明确\n     - 当然还存储了一个字体类型，可以设置菜单项中的字体样式\n\n     ~~~cpp\n     class LMenu\n     {\n         ...\n         \n     private:\n     /**\n          * @brief 默认菜单项高度。\n          */\n         static const int DefaultItemHeight;\n     \n         /**\n          * @brief 默认分隔线区域高度。\n          */\n         static const int DefaultSeparatorHeight;\n     \n         /**\n          * @brief 默认菜单宽度。\n          */\n         static const int DefaultWidth;\n     \n         /**\n          * @brief 默认（竖直方向）内边距。\n          */\n         static const int DefaultPadding;\n     \n         /**\n          * @brief 菜单项容器。\n          */\n         LVector<LMenuItem *> m_items;\n     \n         /**\n          * @brief 记录各菜单项的竖直方向底端位置，用于判定当前鼠标指向的菜单项索引。\n         */\n         LVector<int> m_itemPos;\n         \n         /**\n          * @brief 鼠标当前指向的项索引。负数表示没有指向任何项。\n          * @todo 目前由鼠标悬停代表指向。后续可考虑键盘上下方向键选择指向。\n          */\n         int m_pointingItemIndex = 0;\n     \n         /**\n          * @brief 字体。\n          */\n         LFont m_font;\n     };\n     ~~~\n\n2. `repaint()`接口\n\n   - 基类预留的可以覆写的接口，当我的`Menu`调用`show()`函数的时候，就会进行重绘，绘出最终的结果，当然其中的逻辑需要派生类自己实现\n\n   ```cpp\n   void LMenu::repaint()\n   {\n       // 绘制背景\n       if (m_pDrawContext) \n       {\n           m_pDrawContext->clearFill(LColor(0xfafafa));\n   \n           // 绘制菜单项和分隔线\n           int y = LMenu::DefaultPadding;\n           for (int i = 0; i < m_items.count(); i++)\n           {\n               LMenuItem *pItem = m_items[i];\n               // LMenuItemSeparator 是 LMenuItem 的一个派生类，这里通过 dynamic_cast 进行运行时类型转换，来判断是基类还是派生类，来实行不同的绘制逻辑\n               LMenuItemSeparator *pSeparator = dynamic_cast<LMenuItemSeparator *>(pItem);\n               if (pSeparator)\n               {\n                   m_pDrawContext->setPenColor(LColor(0xdedede));\n                   int separatorPosY = y + LMenu::DefaultSeparatorHeight / 2;\n                   m_pDrawContext->drawLine(\n                       0,\n                       separatorPosY,\n                       LMenu::DefaultWidth,\n                       separatorPosY\n                   );\n                   y += LMenu::DefaultSeparatorHeight;\n               }\n               else\n               {\n                   if (i == m_pointingItemIndex)\n                   {\n                       m_pDrawContext->setBrushColor(LColor(0xe6e6e6));\n                       m_pDrawContext->fillRect(0, y, LMenu::DefaultWidth, LMenu::DefaultItemHeight);\n                   }\n                   m_pDrawContext->setPenColor(LColor(0x3c3c3c));\n                   m_pDrawContext->drawText(\n                       LRect(LMenu::DefaultPadding, y, LMenu::DefaultWidth - LMenu::DefaultPadding * 2, LMenu::DefaultItemHeight),\n                       pItem->text(),\n                       m_font,\n                       Lark::AlignLeft | Lark::AlignVCenter\n                   );\n                   y += LMenu::DefaultItemHeight;\n               }\n           }\n           m_pDrawContext->flush();\n       }\n   }\n   ```\n\n   - 阅读了这个逻辑之后，我将整个绘图的范围画了一个图更清晰的展现，结合上面的代码就更容易理解了\n\n   <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240312143539023.png\" alt=\"image-20240312143539023\" style=\"zoom:67%;\" />\n\n3. 事件处理机制\n\n   - 基类提供了几个处理事件的接口，包括窗口的，鼠标的，在派生类中进行重写已适应自身的功能\n\n   - `handleShowEvent()`\n\n     - 处理窗体`show()`之后触发的事件的逻辑\n\n     ```cpp\n     void LMenu::handleShowEvent(LShowEvent *e)\n     {\n         // 当菜单`show()`的时候触发，尝试获取鼠标独占，为当前窗口服务\n         grabMouse();\n     }\n     ```\n\n   - `handleMouseReleaseEvent()`\n\n     - 处理鼠标释放触发的事件的逻辑\n     - 这里获取的`x()`和`y()`是鼠标相对本窗体的坐标，而不是全局坐标，全局坐标另有接口`globalX()`和`globalY()`\n\n     ```cpp\n     void LMenu::handleMouseReleaseEvent(LMouseEvent *e)\n     {\n         int x = e->x();\n         int y = e->y();\n         // 判断当前的鼠标位于哪个菜单项上，当我鼠标释放的时候，就是按下之后释放的那个释放，就会做如下的逻辑处理，分割线不管，菜单项则关闭窗体并发出信号，表示点击了某个菜单项，可以针对性的进行处理\n         // 这个函数要结合按下的那个事件一起看才能理解全部的过程，因为有两种极端情况，在里面按下，在外面释放；在外面按下，在里面释放，这两种情况的行为要符合感官认知才行\n         if (m_pointingItemIndex >= 0)\n         {\n             LMenuItem *pItem = m_items[m_pointingItemIndex];\n             if (dynamic_cast<LMenuItemSeparator *>(pItem))\n             {\n                 return;\n             }\n     \n             close();\n             pItem->clickSignal.emit(pItem->text());\n         }\n     }\n     ```\n\n   - `handleMousePressEvent()`\n\n     - 处理鼠标按下触发的事件的逻辑\n     - 结合按下和释放的逻辑，那两种特殊情况\n       - 在里面按下，在外面释放，菜单不会关闭，这很正常\n       - 在外面按下，在里面释放；加入我现在已经有一个打开的菜单，当我立即在外面按下的时候，菜单就关闭了，根本不会有机会在里面释放，这也是符合正常逻辑的\n\n     ```cpp\n     void LMenu::handleMousePressEvent(LMouseEvent *e)\n     {\n         int x = e->x();\n         int y = e->y();\n         // 如果在窗体外按下，则立即关闭窗体\n         if (x < 0 || x >= width() || y < 0 || y >= height())\n         {\n             releaseMouse();\n             close();\n         }\n     }\n     ```\n\n   - `handleMouseMoveEvent()`\n\n     - 处理鼠标移动触发的事件的逻辑\n     - 上面其实一直存留着一个疑惑，就是鼠标按下的时候`m_pointingItemIndex`是如何做到实时更新的，答案就在这里，实时监测鼠标的移动，然后进行修改\n\n     ~~~cpp\n     void LMenu::handleMouseMoveEvent(LMouseEvent *e)\n     {\n         int x = e->x();\n         int y = e->y();\n         // 在外面即 -1\n         if (x < 0 || x >= width() || y < LMenu::DefaultPadding || y >= height() - LMenu::DefaultPadding)\n         {\n             m_pointingItemIndex = -1;\n             repaint();\n     \n             return;\n         }\n     \n         // TODO: 可考虑使用二分查找法压榨效率\n         // 在里面即计算得出下标\n         int i = 0;\n         while (i < m_itemPos.count() && y >= m_itemPos[i])\n         {\n             i++;\n         }\n     \n         if (m_pointingItemIndex != i)\n         {\n             m_pointingItemIndex = i;\n             repaint();\n         }\n         \n         // //鼠标进入菜单范围释放独占,独占时会自动触发一次进入事件，释放会自动触发移出，所以用移动事件处理\n         // LPoint pt(x, y);\n         // LRect bounds(0, 0, width(), height());\n         // if(bounds.contains(pt) && isGrabMouseFlagRaised())\n         // {\n         //     // 释放独占会调用离开事件，给指定的释放独占添加标记防止再次独占\n         //     m_isMoveRelease = true;\n         //     releaseMouse();\n         // }\n     }\n     ~~~\n\n   - `handleMouseLeaveEvent()`\n\n     - 目前实现注释掉了，我看不懂注释之前的逻辑\n\n#### LMenuItem\n\n这个东西就很简单了，就是一个菜单项，存储了一个菜单项的文本内容，一个信号，信号传递的参数是文本内容，可以被用户处理，这部分很简单，就简单略过了。\n\n#### LMenuItemSeparator\n\n`LMenuItem`的派生类，代表是一个分割线，具体如何区分在上面`repaint()`中具体阐述过了，不再赘述。\n\n## 代码走查问题\n\n### 画笔\n\n#### LPen\n\n1. `JointType`线段交点样式，目前是只有一种方式，后续还有更多方式引入吗？\n\n   - 如果有引入，那么构造函数对应也需要进行改造，构造函数见第`2`点\n\n   ~~~cpp\n   /**\n    * @enum JointType\n    * @brief 线段交点样式定义，表示线段相交时，不同的连接方式。\n    */\n   enum JointType\n   {\n       FlatJoint = 0       ///< 直接连接，没有拐点修饰\n   };\n   ~~~\n\n2. 构造函数注释少写`@param color`\n\n   - `m_width`不能直接赋值，因为有可能小于 `1`，需要调用`setColor()`\n\n   ```cpp\n   /**\n    * @brief 构造函数，设置画笔宽度。\n    * @param width 画笔宽度\n    */\n   explicit LPen(int width = 1, const LColor &color = LColor()) : m_width(width), m_color(color) {}\n   ```\n\n3. 拷贝构造函数、`width()`接口的`@brief`没有句号\n\n   ```cpp\n   /**\n   * @brief 拷贝构造函数\n   * @param other 待拷贝对象\n   */\n   LPen(const LPen &other) : m_width(other.width()), m_jointType(other.jointType()), m_color(other.color()) {}\n   \n   ...\n   \n   /**\n   * @brief 返回画笔宽度\n   * @return 画笔宽度\n   */\n   int width() const { return m_width; }\n   ```\n\n4. `setColor()`接口参数传常量引用更好一点\n\n   ```cpp\n   /**\n    * @brief 设置画笔颜色。\n    * @param color 画笔颜色\n    */\n   void setColor(LColor color) { m_color = color; }\n   ```\n\n5. `m_width`注释错误\n\n   ~~~cpp\n   /**\n    * @brief 画笔连接样式。\n    */\n   int m_width = 0;\n   ~~~\n\n### 画刷\n\n#### LBrush\n\n1. 拷贝构造函数可以内联\n\n   ```cpp\n   LBrush::LBrush(const LBrush &other) :\n       m_brushType(other.type()),\n       m_color(other.color())\n   {\n       m_pGradient = new LLinearGradient(*(other.gradient()));\n   }\n   ```\n\n2. `setBrushType`的`@param`的单词与参数不对应\n\n   ```cpp\n   /**\n    * @brief 设置笔刷样式。\n    * @param brushTypes 笔刷样式\n    */\n   void setBrushType(BrushType brushType);\n   ```\n\n3. `setGradient`的`@param`与参数不对应\n\n   - 单词不对应，描述也不对应\n\n   ```cpp\n   /**\n    * @brief 设置渐变色属性。\n    * @param pGradient 渐变色类指针\n    */\n   void setGradient(const LLinearGradient &gradient);\n   ```\n\n4. 代码中`LLinearGradient`结构存放的是指针，内存放在堆区，个人认为完全没有必要\n\n   - `LLinearGradient`的成员变量如下，存这些东西哪里需要放在堆区？\n   - 这里更改之后，源文件中关于指针`new`和`delete`的东西都需要进行修改\n\n   ~~~cpp\n   class LLinearGradient\n   {\n   \t...\n           \n   private:\n       \n       ...\n           \n   \t/**\n        * @brief 标识渐变起点坐标。\n       */\n       LPoint m_start;   \n       /**\n        * @brief 标识渐变终点坐标。\n       */                   \n       LPoint m_finalStop;\n       /**\n        * @brief 标识渐变铺展效果，默认为PadMode。\n       */                   \n       GradientMode m_mode = PadMode;\n       /**\n        * @brief 标识渐变点数组，包含渐变比例参数和颜色,渐变比例参数范围为[0,1]。\n       */   \n       LVector<LPair<double, LColor>> m_stops;\n   };\n   ~~~\n\n   - 同时构造函数的逻辑也需要进行修正\n     - `BrushType`根据不同的类型用到不同的成员变量，`NoBrush`啥都用不到，`SolidBrush`用到`m_color`，`LinearGradientBrush`用到`m_pGradient`\n     - 现在的构造函数逻辑有一些紊乱，用户没办法在构造函数中直接给出线性渐变相关的参数，这是不合适的，我认为修改的版本应给出三个，一个是默认的构造函数，对应`NoBrush`；第二个是针对`LColor`的构造函数，对应`SolidBrush`；第三个是针对`LLinearGradient`的构造函数，对应`LinearGradientBrush`\n\n   ```cpp\n   // 原有的\n   \n   // .h\n   /**\n    * @brief 构造函数。\n    * @param color 笔刷颜色\n    * @param brushType 笔刷样式\n    */\n   explicit LBrush(const LColor &color = LColor(), BrushType brushType = LBrush::SolidBrush) : m_brushType(brushType), m_color(color) {}\n   \n   // .cpp\n   LBrush::LBrush(const LBrush &other) :\n       m_brushType(other.type()),\n       m_color(other.color())\n   {\n       LLinearGradient *pGradient = other.gradient();\n       if (pGradient)\n       {\n           m_pGradient = new LLinearGradient(*pGradient);\n       }\n   }\n   ```\n\n5. `setBrushType()`接口逻辑混乱，设计不合理\n\n   - 这个接口设置的初衷就是用户可以调用设置`brushType`，但是第一行判断如果是渐变，则无法设置，这就很扯淡了\n\n   ```cpp\n   void LBrush::setBrushType(BrushType brushType)\n   {\n       if (brushType == LBrush::LinearGradientBrush)\n       {\n           throw LException(\"无法通过setBrushType设置渐变色，请使用setGradient\"); \n       }\n       m_brushType = brushType;\n       if (m_pGradient)\n       {\n           delete m_pGradient;\n           m_pGradient = nullptr;\n       }\n   }\n   ```\n\n   - 按理来说，`brushType`是能用户任意设置的，需要做判断的是不同`brushType`的各自接口，比如`setColor()`，`setGradient()`，`color()`，`gradient()`\n\n   ```cpp\n   // .h\n   /**\n   * @brief 返回笔刷颜色.\n   * @return 笔刷颜色\n   */\n   LColor color() const { return m_color; }\n   \n   /**\n   * @brief 获得该笔刷的渐变色属性。\n   * @return 渐变色属性\n   */\n   LLinearGradient* gradient() const { return m_pGradient; }\n   \n   \n   /**\n   * @brief 设置笔刷颜色。\n   * @param color 笔刷颜色\n   */\n   void setColor(LColor color) { this->m_color = color; }\n   \n   // .cpp\n   void LBrush::setGradient(const LLinearGradient &gradient)\n   {\n       m_brushType = LBrush::LinearGradientBrush;\n       if (m_pGradient)\n       {\n           delete m_pGradient;\n       }\n       m_pGradient = new LLinearGradient(gradient);\n   }\n   ```\n\n#### LLinearGradient\n\n1. 头文件`<cmath>`的引入错误\n\n   ```cpp\n   #include \"lpoint.h\"\n   #include \"lcolor.h\"\n   #include \"lvector.h\"\n   #include \"lpair.h\"\n   #include \"cmath\"\n   ```\n\n2. `enum`的格式不正确，少了`@enum`，`{`应该提行\n\n   ```cpp\n   /**\n    * @brief 铺展效果枚举。\n   */\n   enum GradientMode {\n       PadMode,             ///<默认铺展效果，没有被渐变覆盖的区域填充单一的起始颜色或终止颜色\n       RepeatMode           ///<渐变在起点与终点的渐变区域外重复\n   };\n   ```\n\n3. 代码中有很多应该有空行，但没有空行的格式问题\n\n   ```cpp\n   #include \"lpoint.h\"\n   #include \"lcolor.h\"\n   #include \"lvector.h\"\n   #include \"lpair.h\"\n   #include \"cmath\"\n   /**\n    * @class LLinearGradient\n    * @brief 渐变色填充类,与LBrush结合使用，以指定线形渐变笔刷。\n    * @details 默认初始起点颜色为黑色，终点颜色为白色。\n    */\n   class LLinearGradient\n   {\n   \n   public:\n       /**\n        * @brief 铺展效果枚举。\n       */\n       enum GradientMode {\n           PadMode,             ///<默认铺展效果，没有被渐变覆盖的区域填充单一的起始颜色或终止颜色\n           RepeatMode           ///<渐变在起点与终点的渐变区域外重复\n       };\n       /**\n        * @brief 默认构造函数。\n        */\n       LLinearGradient();\n   \n       ...\n       \n       /**\n        * @brief 标识渐变起点坐标。\n       */\n       LPoint m_start;   \n       /**\n        * @brief 标识渐变终点坐标。\n       */                   \n       LPoint m_finalStop;\n       /**\n        * @brief 标识渐变铺展效果，默认为PadMode。\n       */                   \n       GradientMode m_mode = PadMode;\n       /**\n        * @brief 标识渐变点数组，包含渐变比例参数和颜色,渐变比例参数范围为[0,1]。\n       */   \n       LVector<LPair<double, LColor>> m_stops;\n   };\n   ```\n\n4. 代码中有很多内联函数，格式不正确\n\n   ```cpp\n   /**\n    * @brief 设置渐变起点位置。\n    * @param start 渐变起点坐标\n    */\n   void setStart(const LPoint &start)\n   {\n       m_start = start;\n   }\n   \n   ...\n   \n   /**\n    * @brief 设置渐变终点位置。\n    * @param finalStop 渐变终点坐标\n    */\n   void setFinalStop(const LPoint &finalStop)\n   {\n       m_finalStop = finalStop;\n   }\n   \n   ...\n   \n   /**\n    * @brief 设置铺展效果。\n    * @param mode 铺展效果\n   */\n   void setMode(GradientMode mode)\n   {\n       m_mode = mode;\n   }\n   \n   ...\n   \n   /**\n    * @brief 获取渐变起点。\n    */\n   LPoint start() const\n   {\n       return LPoint(m_start);\n   }\n   \n   /**\n    * @brief 获取渐变终点。\n    */\n   LPoint finalStop() const\n   {\n       return LPoint(m_finalStop);\n   }\n   \n   /**\n    * @brief 获取铺展效果。\n   */\n   GradientMode mode() const \n   { \n       return m_mode; \n   }\n   \n   /**\n    * @brief 获取渐变颜色数组。\n   */\n   LVector<LPair<double, LColor>> stops() const \n   { \n       return m_stops; \n   }\n   ```\n\n5. 头文件中很多函数不能内联\n\n   ```cpp\n   /**\n    * @brief 设置渐变起点位置。\n    * @param x 渐变起点横坐标\n    * @param y 渐变起点纵坐标\n    */\n   void setStart(int x, int y)\n   {\n       m_start.setX(x);\n       m_start.setY(y);\n   }\n   \n   ...\n       \n   /**\n    * @brief 设置渐变终点位置。\n    * @param x 渐变终点横坐标\n    * @param y 渐变终点纵坐标\n    */\n   void setFinalStop(int x, int y)\n   {\n       m_finalStop.setX(x);\n       m_finalStop.setY(y);\n   }\n   \n   ...\n   \n   /**\n    * @brief 设置渐变颜色数组。\n    * @param stops 渐变颜色数组\n   */\n   void setStops(const LVector<LPair<double, LColor>> &stops)\n   {\n       m_stops = stops;\n       if (m_stops.first().key() != 0)\n       {\n           m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));\n       }\n       if (m_stops.last().key() != 1)\n       {\n           m_stops.append(LPair<double, LColor>(1, LColor(255,255,255)));\n       }\n   }\n   ```\n\n6. 源文件中有的函数可以内联\n\n   ```cpp\n   LLinearGradient::LLinearGradient(int x1, int y1, int x2, int y2)\n       : LLinearGradient(LPoint(x1, y1), LPoint(x2, y2))\n   {\n   }\n   \n   LLinearGradient::~LLinearGradient()\n   {\n   }\n   ```\n\n7. 代码中很多`LVector`的插入可以调用`prepend()`或者`append()`\n\n   ```cpp\n   // .h\n   void setStops(const LVector<LPair<double, LColor>> &stops)\n   {\n       m_stops = stops;\n       if (m_stops.first().key() != 0)\n       {\n           m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));\n       }\n       if (m_stops.last().key() != 1)\n       {\n           m_stops.append(LPair<double, LColor>(1, LColor(255,255,255)));\n       }\n   }\n   \n   ...\n   \n   // .cpp\n   LLinearGradient::LLinearGradient()\n   {\n   \t...\n       \n       m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));\n       m_stops.insert(1, LPair<double, LColor>(1, LColor(255,255,255)));\n   }\n   \n   LLinearGradient::LLinearGradient(const LPoint &start, const LPoint &finalStop)\n   {\n   \t...\n       \n       m_stops.insert(0, LPair<double, LColor>(0, LColor(0,0,0)));\n       m_stops.insert(1, LPair<double, LColor>(1, LColor(255,255,255)));\n   }\n   ```\n\n8. `setColor()`接口代码冗杂，这下面的部分一行就能搞定\n\n   - 接口作用：根据输入的渐变比例`pos`值插入到数组中；我们需要保证标识渐变点数组是按照渐变比例`pos`递增的，因此可以采用二分的思路，这里查询的是不小于`pos`的第一个元素下标\n   - 上面的二分思路，另一处代码中也用到了，查询的位置相同，可以封装出来进行复用\n   - 注释的`{`也有问题\n\n   ```cpp\n   void LLinearGradient::setColor(double pos, const LColor &color) {\n   \t... \n           \n       // 如果已经存在对应的pos值，则覆盖颜色值\n       if (index < m_stops.size() && m_stops[index].key() == pos)\n       {\n           m_stops[index].value() = color;\n       }\n       else\n       {\n           m_stops.insert(index, LPair<double, LColor>(pos, color));\n       }\n   }\n   ```\n\n9. `getColor()`接口，分了三种情况，经过数学推导，一个公式就能搞定\n\n   - 推导过程\n\n     <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/96267918b6de05e058c90fee24804e4.jpg\" alt=\"96267918b6de05e058c90fee24804e4\" style=\"zoom:30%;\" />\n\n   - 接口作用：根据输入点的坐标得出该点的颜色，本函数只负责将坐标转化为渐变比例`pos`（原始值），`pos`的处理和计算颜色的具体逻辑交给`getColorByPadMode()`和`getColorByRepeatMode()`\n\n   - 计算出`pos`之后，分铺展情况调用不同接口一行也能搞定\n\n   ```cpp\n   LColor LLinearGradient::getColor(const LPoint &point) const\n   {\n       if (m_stops.size() < 2)\n       {\n           throw LException(\"尚未完整初始化颜色：至少提供两种颜色\");\n       }\n       // 垂直渐变\n       if (m_start.x() == m_finalStop.x() && m_start.y() != m_finalStop.y())\n       {\n           // 竖向渐变\n           double pos = (point.y() - m_start.y()) / static_cast<double>(m_finalStop.y() - m_start.y());\n           if (m_mode == PadMode)  // PadMode铺展\n           {\n               return getColorByPadMode(pos);\n           }\n           else  // RepeatMode铺展\n           {\n               return getColorByRepeatMode(pos);\n           }\n       }\n       if (m_start.y() == m_finalStop.y() && m_start.x() != m_finalStop.x())\n       {\n           // 横向渐变\n           double pos = (point.x() - m_start.x()) / static_cast<double>(m_finalStop.x() - m_start.x());\n           if (m_mode == PadMode)  // PadMode铺展\n           {\n               return getColorByPadMode(pos);\n           }\n           else  // RepeatMode铺展\n           {   \n               return getColorByRepeatMode(pos);\n           }\n       }\n       // 非垂直渐变\n       // c为起点与终点之间的距离\n       double c = sqrt(std::pow((m_start.x() - m_finalStop.x()),2) + std::pow((m_start.y() - m_finalStop.y()),2));\n       // 通过坐标旋转将非垂直渐变转变为垂直渐变\n       double revolve_x = ((point.x() - m_start.x()) * (m_finalStop.x() - m_start.x()) / c) - \n                          ((point.y() - m_start.y()) * (-(m_finalStop.y() - m_start.y())) / c);\n       double pos = revolve_x / c;\n       if (m_mode == PadMode)  // PadMode铺展\n       {\n           return getColorByPadMode(pos);\n       }\n       else  // RepeatMode铺展\n       {\n           return getColorByRepeatMode(pos);\n       }\n   }\n   ```\n\n10. `getColorByT()`接口代码冗杂，同上\n\n       - 接口作用：这个函数才是根据真正输入的渐变比例`pos`值，找到其在升序数组中的位置，有人为设置则直接返回；没有则根据左右计算，具体逻辑在`computeColorByT()`\n\n    ```cpp\n    LColor LLinearGradient::getColorByT(double t) const\n    {\n        ...\n        \n        // 如果渐变比例t刚好在m_stops中有对应值，则返回对应的颜色参数\n        if (m_stops[right].key() == t)\n        {\n            return m_stops[right].value();\n        }\n        // 计算新的渐变比例值\n        double target = (t - m_stops[left].key()) / (m_stops[right].key() - m_stops[left].key());\n        return computeColorByT(m_stops[left].value(), m_stops[right].value(), target);\n    }\n    ```\n\n11. `getColorByPadMode()`接口代码冗杂，同上\n\n    - 接口作用：这个接口和下面那个的区别在于，一个是`PadMode`，一个是`RepeatMode`，前者在超出区域使用边界值，后者在把超出区域视作另一个区域，进行重复\n\n    ```cpp\n    LColor LLinearGradient::getColorByPadMode(double t) const\n    {\n        if (t <= 1 && t >= 0)\n        {\n            return getColorByT(t);\n        }\n        else if (t < 0)\n        {\n            return LColor(m_stops.first().value());\n        }\n        else\n        {\n            return LColor(m_stops.last().value());\n        }\n    }\n    ```\n\n12. `getColorByRepeatMode()`接口代码冗杂，同上\n\n    ```cpp\n    LColor LLinearGradient::getColorByRepeatMode(double t) const\n    {\n        double pos;\n        if (t < 0)\n        {\n            pos = 1 - fabs(fmod(t, 1));\n        }\n        else\n        {\n            pos = fabs(fmod(t, 1));\n        }\n        return getColorByT(pos);\n    }\n    ```\n\n13. `computeColorByT()`接口代码冗杂，同上\n\n    - 接口作用：这个接口是在确定`pos`落在哪两个设置的颜色之间，根据新计算出的`pos`值得出最终的颜色\n\n    ```cpp\n    LColor LLinearGradient::computeColorByT(const LColor &startColor, const LColor &finalStopColor, double t)\n    {\n        int r = (1 - t) * startColor.red() + t * finalStopColor.red();\n        int g = (1 - t) * startColor.green() + t * finalStopColor.green();\n        int b = (1 - t) * startColor.blue() + t * finalStopColor.blue();\n        return LColor(r, g, b);\n    }\n    ```\n\n### 菜单\n\n#### LMenu\n\n1. 部分接口可以内联\n\n   ```cpp\n   // .cpp\n   LMenu::LMenu() : LPopupWindow(LMenu::DefaultWidth, LTopLevelWindow::MinHeight),\n       m_pointingItemIndex(-1)\n   {\n   }\n   \n   LMenu::~LMenu()\n   {\n       clear();\n   }\n   \n   ...\n       \n   bool LMenu::isEmpty() const\n   {\n       return m_items.count() == 0;\n   }\n   \n   ...\n       \n   void LMenu::handleShowEvent(LShowEvent *e)\n   {\n       grabMouse();\n   }\n   ```\n\n2. 静态成员变量命名不规范\n\n   - `3.18`更新：`Default`开头相关的表强调，使用的时候类似宏的感受，规定首字母大写\n\n   ```cpp\n   /**\n    * @brief 默认菜单项高度。\n    */\n   static const int DefaultItemHeight;\n   \n   /**\n    * @brief 默认分隔线区域高度。\n    */\n   static const int DefaultSeparatorHeight;\n   \n   /**\n    * @brief 默认菜单宽度。\n    */\n   static const int DefaultWidth;\n   \n   /**\n    * @brief 默认（竖直方向）内边距。\n    */\n   static const int DefaultPadding;\n   ```\n\n3. 代码中的`TODO`，`handleMouseMoveEvent()`\n\n   - `m_itemPos`是升序的，可以二分，查找到对应的区间\n\n   ```cpp\n   void LMenu::handleMouseMoveEvent(LMouseEvent *e)\n   {\n       ...\n   \n       // TODO: 可考虑使用二分查找法压榨效率\n       int i = 0;\n       while (i < m_itemPos.count() && y >= m_itemPos[i])\n       {\n           i++;\n       }\n   \n       if (m_pointingItemIndex != i)\n       {\n           m_pointingItemIndex = i;\n           repaint();\n       }\n       \n       ...\n   }\n   ```\n\n4. `repaint()`接口中，有一个地方没有看懂\n\n   - `3.14`更新，理解了为什么要进行重新填充？\n\n     - 对比了有这部分代码和没有这部分代码的`demo`效果，发现这是一个鼠标悬停效果，如下\n\n       <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240314095331865.png\" alt=\"image-20240314095331865\" style=\"zoom:85%;\" />\n\n     - 这样之后，`handleMouseMoveEvent()`就能解释了，实时判断鼠标位置来更新悬停效果\n\n     - 引申思考：菜单的重绘制有两种情况，第一是`show()`，第二是`handleMouseMoveEvent()`更新悬停效果，但是第二种情况还重绘整体效率会不会受很大的影响，个人认为可以将这两种情况区分开，第二种的时候就只管鼠标悬停，这样可能会好一点\n\n   ```cpp\n   void LMenu::repaint()\n   {\n       // 绘制背景\n       if (m_pDrawContext) \n       {\n           m_pDrawContext->clearFill(LColor(0xfafafa));\n   \n           // 绘制菜单项和分隔线\n           int y = LMenu::DefaultPadding;\n           for (int i = 0; i < m_items.count(); i++)\n           {\n               LMenuItem *pItem = m_items[i];\n               LMenuItemSeparator *pSeparator = dynamic_cast<LMenuItemSeparator *>(pItem);\n               if (pSeparator)\n               {\n                   ...\n               }\n               else\n               {\n                   // 这个地方为什么当绘制到鼠标所在的菜单栏的时候需要把这一个区域重新填充？\n                   if (i == m_pointingItemIndex)\n                   {\n                       m_pDrawContext->setBrushColor(LColor(0xe6e6e6));\n                       m_pDrawContext->fillRect(0, y, LMenu::DefaultWidth, LMenu::DefaultItemHeight);\n                   }\n                   \n                   ...\n               }\n           }\n           m_pDrawContext->flush();\n       }\n   }\n   ```\n\n5. 结合`repaint()`的逻辑，`DefaultPadding`的注释描述不对了，应该是四边的内边距\n\n   ```cpp\n   /**\n    * @brief 默认（竖直方向）内边距。\n    */\n   static const int DefaultPadding;\n   ```\n\n6. `handleMouseMoveEvent()`接口中，为什么每次都需要进行重绘？\n\n   - `3.14`更新，见上面`repaint()`\n\n   ```cpp\n   void LMenu::handleMouseMoveEvent(LMouseEvent *e)\n   {\n       int x = e->x();\n       int y = e->y();\n       if (x < 0 || x >= width() || y < LMenu::DefaultPadding || y >= height() - LMenu::DefaultPadding)\n       {\n           m_pointingItemIndex = -1;\n           repaint();\n   \n           return;\n       }\n   \n       // TODO: 可考虑使用二分查找法压榨效率\n       int i = 0;\n       while (i < m_itemPos.count() && y >= m_itemPos[i])\n       {\n           i++;\n       }\n   \n       if (m_pointingItemIndex != i)\n       {\n           m_pointingItemIndex = i;\n           repaint();\n       }\n       \n       // //鼠标进入菜单范围释放独占,独占时会自动触发一次进入事件，释放会自动触发移出，所以用移动事件处理\n       // LPoint pt(x, y);\n       // LRect bounds(0, 0, width(), height());\n       // if(bounds.contains(pt) && isGrabMouseFlagRaised())\n       // {\n       //     // 释放独占会调用离开事件，给指定的释放独占添加标记防止再次独占\n       //     m_isMoveRelease = true;\n       //     releaseMouse();\n       // }\n   }\n   ```\n\n#### LMenuItem\n\n1. 类当中并没有用到`LMenu`相关内容，但是`.h`中做了前置声明，`.cpp`中做了头文件引入\n\n   ```cpp\n   // .h\n   #ifndef _LMENUITEM_H_\n   #define _LMENUITEM_H_\n   \n   #include \"lobject.h\"\n   #include \"lsignal.h\"\n   #include \"lstring.h\"\n   \n   class LMenu;\n   \n   // .cpp\n   #include \"lmenuitem.h\"\n   \n   #include \"lmenu.h\"\n   ```\n\n2. 构造函数可以内联\n\n   ```cpp\n   // .cpp\n   LMenuItem::LMenuItem(const LString &text) : LObject(),\n       m_text(text)\n   {\n   }\n   ```\n\n#### LMenuItemSeparator\n\n1. 构造函数可以内联\n\n   ```cpp\n   LMenuItemSeparator::LMenuItemSeparator() : LMenuItem(LString())\n   {\n   }\n   ```\n\n# 3.18 - 3.29\n\n## 迭代任务\n\n1. 审核`LarkTestKit`部分代码，与陈冠杰同学对接，并且编写测试样例\n\n## 总结\n\n1. 已经完成工程的搭建，包括项目本地运行、`conan`打包和`gitlab CI`流程\n2. 和测试进行沟通，测试已经协调出两人进行测试，`bug`已上禅道\n3. 和陈冠杰进行沟通，确定`bug`细节和尚未完成的部分情况\n4. 问题陈述\n   - 未作`.h`和`.cpp`声明和定义的文件分开，目前都放在`.h`当中\n   - 功能实现不全，包括但不限于\n     - 值检查目前只支持整形\n     - 谓词断言目前只支持`1~5`个参数\n     - 目前仅有`TEST`宏而没有`TEST_F`、`TEST_P`等宏\n     - 键盘操作模拟为实现`KEY_RELEASE`相关宏\n     - 测试元语言目前暂未实现\n     - 个人感觉还缺少了很多宏，例如参照`GTEST`中的`EXPECT_THROW`、`EXPECT_NOTHROW`等（需求统一）\n   - 功能实现的很多细节存在问题，包括但不限于\n     - 测试的结果输出不合理，打印的`OK`过多，排版不合理等\n     - 执行失败的语句，未输出相关信息\n   - 上面的问题以及相关`bug`，具体可见禅道\n\n# 4.7 - 4.19\n\n## 迭代任务\n\n1. `LarkSDK-XML`代码走查（抽象，太抽象了）\n2. `FileSystem`代码走查（包含`LDir`和`LFileInfo`，暂不包括`LFile`）\n   - 该部分的主要工作是重新明确语义，指定重构设计方案，故该部分的内容归纳在一个课题中\n\n## 学习的点\n\n### XmlStream\n\n1. `xml`基础教程链接：[https://www.runoob.com/xml/xml-tutorial.html](https://www.runoob.com/xml/xml-tutorial.html)\n\n2. `xml`中的`CDATA`，参考链接：[https://www.w3school.com.cn/xml/xml_cdata.asp](https://www.w3school.com.cn/xml/xml_cdata.asp)\n\n   - 在`xml`文本中，所有文本均会被解析器解析，但`CDATA`区段的文本会被忽略\n\n   - `CDATA`部分由`<![CDATA[`开始，由`]]>`结束\n\n   - 某些文本里面，需要放非法字符例如`<`和`&`，但是又不能使用转移字符，例如传递**代码片段**，就可以使用`CDATA`区段\n\n     ```xml\n     <script>\n     <![CDATA[\n     function matchwo(a,b)\n     {\n     if (a < b && a < 0) then\n       {\n       return 1;\n       }\n     else\n       {\n       return 0;\n       }\n     }\n     ]]>\n     </script>\n     ```\n\n   - 补充：`xml`中预定义的实体引用\n\n     ![image-20240407174259533](https://cdn.davidingplus.cn/images/2025/02/01/image-20240407174259533.png)\n\n3. `xml Token`，参考链接：[https://xmlbeans.apache.org/docs/2.0.0/guide/conUnderstandingXMLTokens.html](https://xmlbeans.apache.org/docs/2.0.0/guide/conUnderstandingXMLTokens.html)\n\n   - 对于一个`xml`文件，可以根据起始标签、内容、结束标签、注释、文档开始、文档结束等，将整个文档进行划分，每个小块就是一个`token`，当游标`cursor`移动的过程中，每个位置就会对应一个`tokenType`\n\n     ![image-20240408113635297](https://cdn.davidingplus.cn/images/2025/02/01/image-20240408113635297.png)\n\n4. `xml DTD`，参考链接：[https://blog.csdn.net/gavin_john/article/details/51532756](https://blog.csdn.net/gavin_john/article/details/51532756)\n\n   - `xml`的标签是用户自定义的，例如我们可以在标签内嵌套标签，例如`<sport><ball>...</ball></sport>`，在这种情况下`sport`中嵌套的标签肯定不可能是随意的，显然不能放`math`，因此需要一个东西来进行约束，这个东西就是`DTD`文件\n\n   - `DTD`语法\n\n     ```dtd\n     <!DOCTYPE note\n     [\n         <!ELEMENT 班级 (学生+)>\n         <!ELEMENT 学生 (名字,年龄,介绍)>\n         <!ELEMENT 名字 (#PCDATA)>\n         <!ELEMENT 年龄 (#PCDATA)>\n         <!ELEMENT 介绍 (#PCDATA)>\n     ]>\n     ```\n\n   - 在`xml`中引入`DTD`文件，约束此`xml`\n\n     - 引入中写的`SYSTEM`，表示当前的`DTD`文件是本地\n     - 如果写的是`PUBLIC`，则表示引入的`DTD`文件是来自于网络\n\n     ```xml\n     <?xml version=\"1.0\" encoding=\"utf-8\"?>\n     <!--引入dtd文件，约束这个xml-->\n     <!DOCTYPE 班级 SYSTEM \"myClass.dtd\">\n     <班级>\n         <学生>\n             <名字>周小星</名字>    \n             <年龄>23</年龄>\n             <介绍>学习刻苦</介绍>\n         </学生>   \n         <学生>\n             <名字>林晓</名字> \n             <年龄>25</年龄>\n             <介绍>是一个好学生</介绍>\n         </学生>   \n     </班级>\n     ```\n\n5. `xml`中的`PCDATA`\n\n   - `PCDATA`，即`Parsed Character Data`，就是`xml`元素内部解析的文本数据，即作为元素的内容而存在的\n\n6. 关于`std::string`和`std::wstring`的联系\n\n   - `std::string`的底层是`char`，`std::wstring`的底层是`wchar_t`，前者不必多言，后者是代表宽字节，根据平台及编译器的是实现不同可以是`2`字节，也可以是`4`字节，`Linux`下的`gcc`是`4`字节\n   - 显然，更多的字节代表可以表示更多的字符集；例如`std::wstring`主要用于`utf-16`的编码字符，`std::string`主要用于存储单字节的字符（`ASCII`），也可以用来保存`utf-8`的字符（注意，这里说的都是主要，当然可以表示其他编码的字符，至于情况如何或者会不会乱码我就不知道了）\n   - 关于`unicode`\n     - `unicode`统一了所有字符的编码，是一个`Character Set`，也就是字符集\n     - **但是`unicode`字符集只是给所有的字符一个唯一编号，却没有具体规定如何用二进制存储**\n     - 因此有了不同的存储方式的设计，不同的编码方式就诞生了，最常见的就是`utf-32`，`utf-16`，`utf-8`\n     - 具体如何进行编码的，参考链接：[https://blog.csdn.net/hollis_chuang/article/details/110729762](https://blog.csdn.net/hollis_chuang/article/details/110729762)\n\n7. 在`c++`类中定义成员变量是一个引用，参考链接：[https://blog.csdn.net/weixin_42579072/article/details/102618771](https://blog.csdn.net/weixin_42579072/article/details/102618771)\n\n   - 以前听都没听过，今天搜了一下，发现这样在某些情况下，居然还真能通过编译，但是肯定不推荐这么用\n\n   - `c++`类内可以定义引用成员变量，但要遵循以下三个规则：\n\n     - **不能用默认构造函数初始化，必须提供构造函数来初始化引用成员变量。否则会造成引用未初始化错误**\n     - **构造函数的形参也必须是引用类型**\n     - **不能在构造函数里初始化，必须在初始化列表中进行初始化**\n\n   - **构造函数分为初始化和计算两个阶段，前者对应成员初始化链表，后者对应构造函数函数体。引用必须在初始化阶段，也即在成员初始化链表中完成，否则编译时会报错（引用未初始化）**\n\n   - 测试程序\n\n     ```cpp\n     #include <iostream>\n     \n     class A\n     {\n     public:\n         A(int &target) : a(target)\n         {\n             std::cout << \"构造函数\" << std::endl;\n         }\n         void printA()\n         {\n             std::cout << \"a is: \" << a << std::endl;\n         }\n     \n     private:\n         int &a;\n     };\n     int main()\n     {\n         int a = 20;\n         A r(a); // 依旧使用自定义的构造函数\n         r.printA();\n     \n         int &b = a;\n         A r1(b);\n         r1.printA();\n     \n         return 0;\n     }\n     \n     ```\n\n   - 执行结果\n\n     ![image-20240409170359574](https://cdn.davidingplus.cn/images/2025/02/01/image-20240409170359574.png)\n\n### FileSystem\n\n1. `linux`目录和`windows`目录\n\n   - 目录举例\n     - `linux`目录，例如`/usr/bin/../local/bin`，`./abc/../abc`\n     - `windows`目录，例如`c:\\a\\b\\..\\c`，`.\\a\\b\\..\\c`\n\n   - 相同点\n\n     - 都分为绝对路径和相对路径\n     - `.`表示本目录，`..`表示上级目录\n\n   - 不同点\n\n     - `windows`的目录名和文件名可以有空格，`linux`不行\n     - `windows`下使用的是反斜杠`\\`，`linux`使用的是正斜杠`/`\n     - `windows`由于具有盘符的概念，在根目录`\\`前面有一个盘符的标志，例如`c:`\n     - `linux`没有这个概念，最底层的根目录就是`/`\n\n   - 注意，`windows`下在`c/c++`代码中经常会见到在字符串中使用路径，当使用反斜杠的时候，由于反斜杠本身具有特殊含义，是作为转义字符的起始标志，因此需要在前面再加上一个反斜杠代表后面的反斜杠是其原本的意思；而`/`就不会有这个烦恼\n\n     ```cpp\n     std::string path = \"c:\\\\abc\\\\..\\def\";\n     ```\n\n     \n\n## 代码走查问题\n\n### XmlStream\n\n1. 整体代码冗杂，三个类的分工不同，建议放在三个文件中，而不是像现在冗杂放在一个文件中\n1. 整体的设计全部都是硬解析，一口气读取所有的数据，然后从头开始以字节为单位进行硬解析；按照目前的规划应当使用开源`expat`库，使用其提供的接口封装成为我们自己的解析器`Parser`，进而衍生出`Reader`和`Writer`\n\n#### Parser\n\n由于接口太多了，加上这个代码不用想，肯定是要重构的，因此问题的个数不用那么精确了，由于我怕忘了它的逻辑，所以就把逻辑也放在这里面了（这些逻辑一般都有问题。。。）\n\n1. 代码中的英文字符串前后未与中文字符想间隔一个空格，全篇都是，代码就不放了\n\n   - 同时，代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述\n\n2. 代码中的`std::vector`，`std::list`，`std::map`均都替换成为`LarkSDK`的对应类\n\n3. `.cpp`文件中函数定义的开头总是有一行英文注释，在代码中也是\n\n   ```cpp\n   // .cpp\n   ...\n       \n   // low-level - match character and advance cursor.\n   bool Parser::parseMatch(const LString chPattern)\n   {\n       bool bOK = peekMatch(chPattern);\n       if (bOK)\n           m_iCursor += chPattern.length();\n       return bOK;\n   }\n   \n   // get next character - but do not advance cursor.\n   LChar Parser::peek()\n   {\n       if (!eof())\n           return m_buffer[m_iCursor];\n       return LChar(\"\");\n   }\n   \n   ...\n   ```\n\n4. 采用结构体`struct`类型，但是确包含`private`成员，虽然合法，但是很抽象\n\n   ```cpp\n   struct Parser\n   {\n       ...\n   \n   private:\n       // 补充预读缓冲区\n       void more();\n       // 文档读到末尾标识符\n       bool m_bEOF;\n       // 预读缓冲器\n       std::vector<LChar> m_buffer;\n       // 当前缓冲区中的字符数\n       size_t m_iBuffer;\n   };\n   ```\n\n5. `m_buffer`读取的缓冲器建议使用`LByteArray`类型\n\n   ```cpp\n   // 预读缓冲器\n   std::vector<LChar> m_buffer;\n   ```\n\n6. 构造函数可以内联\n\n   - `m_pStream`是`LString`类型，但是却用`nullptr`赋值\n\n   ```cpp\n   // .cpp\n   Parser::Parser() : \n       m_bEOF(false), m_pStream(nullptr), m_iCursor(0), m_iBuffer(0)\n   {\n   }\n   ```\n\n7. `close()`函数做的是清理的工作，命名不规范\n\n   ```cpp\n   // close parsing\n   void Parser::close()\n   {\n       m_pStream = LString();\n       m_bEOF = true;\n       m_iCursor = 0;\n       m_iBuffer = 0;\n   }\n   ```\n\n8. `peekMatch()`函数参数混乱，有`const LString`，有`const LString*`，应该统一用`const LString&`\n\n   ```cpp\n   /**\n    * @brief 匹配文本但不前进光标。\n    * @param strPattern 需要匹配的文本\n    * @param iLen 模式长度引用\n    * @return true则匹配成功；否则失败\n    */\n   bool peekMatch(const LString *strPattern, size_t &iLen);\n   \n   /**\n    * @brief 匹配文本但不前进光标。\n    * @param strPattern 需要匹配的文本\n    * @return true则匹配成功；否则失败\n    */\n   bool peekMatch(const LString *strPattern);\n   \n   /**\n    * @brief 匹配字符但不推进光标。\n    * @param chPattern 需要匹配的字符\n    * @return true则匹配成功；否则失败\n    */\n   bool peekMatch(const LString chPattern);\n   ```\n\n9. `peekMatch`的逻辑混乱，两个函数的逻辑实现不一样\n\n   1. 指针版本\n\n      ```cpp\n      // low-level - match text but do not advance cursor.\n      bool Parser::peekMatch(const LString *strPattern, size_t &iLen)\n      {\n          size_t i = 0;\n          LString patternCopy = *strPattern; // 创建一个新的LString对象拷贝strPattern\n          while (true)\n          {\n              // 如果 i 超出 patternCopy 的大小，并且下面没有返回 false，则说明匹配成功\n              if (i >= patternCopy.length())\n              {\n                  iLen = i;\n                  return true;\n              }\n      \n              // 如果 i 超出当前缓冲区的大小，则调用 more() 函数从 m_stream 中拿去更多的字节\n              if ((m_iCursor + i) >= m_iBuffer)\n                  more();\n      \n              // 如果扩充完，i 还超出，就返回 false\n              if ((m_iCursor + i) >= m_iBuffer)\n                  return false;\n      \n              // 比较传入的字符串和缓冲区中的内容，如果有一个不满足比较条件则返回 false\n              // 一个字节一个字节比。。。\n              if (patternCopy.at(i) != LChar(m_buffer[m_iCursor + i]))\n                  return false;\n      \n              i++;\n          }\n      }\n      ```\n\n      - 为什么需要第二个参数`iLen`，并且需要传入引用呢？答案是为`parseMatch()`函数服务\n\n      ```cpp\n      // low-level - match text and advance cursor.\n      bool Parser::parseMatch(const LString *strPattern, size_t &iLen)\n      {\n          bool bOK = peekMatch(strPattern, iLen);\n          if (bOK)\n              m_iCursor += iLen; // 这里需要 iLen 移动游标的位置\n          return bOK;\n      }\n      \n      // 剩下两个同理\n      ...\n      ```\n\n   2. 传值版本\n\n      ```cpp\n      bool Parser::peekMatch(const LString chPattern)\n      {\n          bool match = false;\n          int n = chPattern.length();\n      \n          LString now;\n          for (int i = 0; i < n; i++)\n          {\n              // 把缓存中的比较字符串拷贝到 now 中，还是一个一个拷贝，然后进行比较\n              // 和前面对比而言，这样写 i 如果超出 m_buffer 边界就会出问题了\n              now.append(m_buffer[m_iCursor + i]);\n          }\n          match = now == chPattern;\n      \n          return !eof() && m_iCursor < m_iBuffer && match;\n      }\n      ```\n\n10. `consume()`函数命名不规范，并且逻辑有误\n\n       - 第一，名字为啥叫`consume`，这和前进有啥关系嘛？\n\n       - 返回了`bool`值，但是在整个文件中，并没有找到一处使用了这个返回值，这倒没什么；其次，`m_iCursor`超出边界以后，返回`false`，为什么不把`m_iCursor`重置到原来的位置呢？\n\n    ```cpp\n    // consume count characters.\n    bool Parser::consume(size_t iCount)\n    {\n        size_t iRemains = m_iBuffer - m_iCursor;\n        if (iRemains < iCount) // 如果剩下的长度小于想前进的长度，则补充缓冲区内容\n            more();\n        m_iCursor += iCount;\n        return m_iCursor <= m_iBuffer;\n    }\n    ```\n\n11. 接口逻辑：`readText()`和`readCDATAText()`\n\n    ```cpp\n    // consume characters up to the delimiter.\n    bool Parser::readText(LString &strText, char chDelimiter)\n    {\n        // 查看是否到达末尾\n        while (!eof())\n        {\n            // 一个一个字符的判断，考虑了跳过 CDATA 段的逻辑\n            readCDATAText(strText);\n            LChar ch = peek();\n            if (ch == LChar(chDelimiter))\n            {\n                return true;\n            }\n            // 加入 strText 。。。\n            strText.append(LChar(ch));\n            consume(1);\n        }\n        return strText.length() > 0;\n    }\n    \n    bool Parser::readCDATAText(LString &strText)\n    {\n        // 匹配 CDATA 段起始\n        if (peekMatch(LString(\"<![CDATA[\")))\n        {\n            consume(9); // Consume \"<![CDATA[\"\n            // 匹配 CDATA 段结束\n            while (!peekMatch(LString(\"]]>\")))\n            {\n                strText.append(peek());\n                consume(1);\n            }\n            // End of CDATA block\n            consume(3); // Consume \"]]>\"\n            return true;\n        }\n        return false;\n    }\n    ```\n\n12. 接口逻辑：`skipSpace()`\n\n    ```cpp\n    // skips / consumes whitespace.\n    int Parser::skipSpace()\n    {\n        int res = 0;\n        // 循环匹配这些字符，然后跳过\n        while (peekMatch(LString(\"\\t\")) || peekMatch(LString(\"\\r\")) || peekMatch(LString(\"\\n\")))\n        {\n            res++;\n            consume(1);\n        }\n        // （原注释）有点奇怪 一起放上面会有问题 会有时match上不该match的东西\n        // peekMatch 写的，一言难尽，所以才出现了这种问题\n        while (peekMatch(LString(\" \")))\n        {\n            res++;\n            consume(1);\n        }\n        return res;\n    }\n    ```\n\n13. 接口逻辑：`more()`\n\n    - 这个类里面的冗杂代码和边界条件的代码太多了，不放完整代码了\n\n    - 第一步：将`buffer`中`cursor`以后的部分移动到`buffer`头部\n\n    ```cpp\n    // unprocessed data in buffer.\n    size_t iCarry = m_iBuffer - m_iCursor;\n    // left over data?\n    if (iCarry > 0)\n    {\n        // yes: carry forward unprocessed data.\n        LChar *buf = &m_buffer[0];\n        memcpy(buf, buf + m_iCursor, iCarry);\n    }\n    // reset cursor to start of buffer.\n    // 不需重置?\n    // 对啊，这里注释也写了，为什么不需重置？\n    // m_iCursor = 0;\n    ```\n\n    - 示意图：\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240408095910960.png\" alt=\"image-20240408095910960\" style=\"zoom:75%;\" />\n\n    - 第二步：从`m_pStream`中读取内容\n\n    ```cpp\n    // 全都进来，what？？？？结合Reader，是一口气把文件的所有内容读进来，如果太大了怎么办\n    // 其次，按照这个逻辑，红色部分的内容还没有被读取，直接就从 0 开始赋值？\n    for (int i = 0; i < m_pStream.length(); i++)\n    {\n        ch = m_pStream.at(i);\n        m_buffer[i] = ch;\n    }\n    ```\n\n#### LXmlReader\n\n1. 代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述\n\n2. 代码中的`std::pair`，`std::vector`，`std::list`，`std::map`均都替换成为`LarkSDK`的对应类\n\n3. `LEntry`元素实体结构，完全没有注释，根本不知道里面的成员变量是什么意思\n\n   - 我只能猜测了\n     - `m_element`：元素内容\n     - `m_children`：是否具有子元素\n     - `m_skipped`：结合成员变量`m_iSkipped`是整个文档跳过的子元素个数，推断为在该元素实体内跳过的子元素个数\n     - `m_iComment`：元素内部注释内容\n     - `m_commentIndex`：根据`getComment()`函数可以猜测是当前注释的字符偏移量，也就是游标`curSor`\n\n   ```cpp\n   /**\n    * @struct LEntry\n    * @brief 元素实体，维护元素内容数据。\n    */\n   struct LEntry\n   {\n       LString m_element;\n       bool m_children;\n       size_t m_skipped;\n       LString m_iComment;\n       LString m_commentIndex;\n   \n       LEntry() : m_children(false), m_skipped(0){};\n       LEntry(const LEntry &copy)\n           : m_children(copy.m_children), m_element(copy.m_element), m_skipped(copy.m_skipped){};\n   };\n   ```\n\n4. 成员变量文档版本信息`m_nowVersion`在源文件中没有使用，可以删除\n\n   ```cpp\n   // xml文档版本信息\n   LString m_nowVersion;\n   LString m_Version;\n   ```\n\n5. `m_attributes`和`m_attributes2`一个使用`STL`的容器，一个使用`SDK`的容器，应统一\n\n   ```cpp\n   // 最近的 XML 元素的属性列表。\n   std::list<std::pair<LString, LString>> m_attributes;\n   LList<LPair<LString, LString>> m_attributes2;\n   ```\n\n6. 所有的构造函数通过初始化序列初始化成员变量，但是在函数体中又重复做了一次\n\n   ```cpp\n   // 默认构造\n   LXmlReader::LXmlReader() : m_bStart(false), m_iSkipped(0)\n   {\n       // 这里又重复赋值一次\n       m_bStart = false;\n       m_iSkipped = 0;\n       // LEntry enty;\n       // m_stack.push_back(enty);\n       bool open = m_parser.open(\"\");\n       if (!open)\n       {\n           std::cout << \"格式不正确，构造失败\" << std::endl;\n       }\n   }\n   \n   // 其他的同理\n   ...\n   ```\n\n7. 构造函数的使用参数`const LString&`，`const LByteArray&`，`const char*`时，可以代码复用，但是目前的实现冗杂\n\n   ```cpp\n   LXmlReader::LXmlReader(const LString &inputStream) : m_bStart(false), m_iSkipped(0)\n   {\n       m_bStart = false;\n       m_iSkipped = 0;\n       // LEntry enty;\n       // m_stack.push_back(enty);\n       bool open = m_parser.open(inputStream);\n       if (!open)\n       {\n           std::cout << \"格式不正确，构造失败\" << std::endl;\n       }\n   }\n   \n   LXmlReader::LXmlReader(const LByteArray &inputStream) : m_bStart(false), m_iSkipped(0)\n   {\n       m_bStart = false;\n       m_iSkipped = 0;\n       // LEntry enty;\n       // m_stack.push_back(enty);\n       bool open = m_parser.open(inputStream.toString());\n       if (!open)\n       {\n           std::cout << \"格式不正确，构造失败\" << std::endl;\n       }\n   }\n   \n   LXmlReader::LXmlReader(const char *inputStream) : m_bStart(false), m_iSkipped(0)\n   {\n       m_bStart = false;\n       m_iSkipped = 0;\n       // LEntry enty;\n       // m_stack.push_back(enty);\n       LString now(inputStream);\n       bool open = m_parser.open(now);\n       if (!open)\n       {\n           std::cout << \"格式不正确，构造失败\" << std::endl;\n       }\n   }\n   ```\n\n8. `LXmlReader`通过传入`LFile&`参数构造读取器的时候，将整个文件的所有内容一次性读进来，放入`m_parser`中\n\n   - 按照`expat`库的思路，应该是通过流式进行处理，例如读取一行处理一行，这样能够避免在内存中开辟过大的内存，这才是`stream`，而不是`tree`\n\n   ```cpp\n   LXmlReader::LXmlReader(LFile &inputStream) : m_bStart(false), m_iSkipped(0)\n   {\n   \t...\n           \n       LString file;\n       while (!inputStream.end())\n       {\n           file.append(inputStream.readLine().toString());\n       }\n   \n       bool open = m_parser.open(file);\n       if (!open)\n       {\n           std::cout << \"构造失败\" << std::endl;\n       }\n   \t...\n   }\n   ```\n\n9. `addData()`接口同样可以复用，同构造函数\n\n   - 并且函数可以内联\n\n   ```cpp\n   void LXmlReader::addData(const LString &data)\n   {\n       m_parser.m_pStream.append(data);\n   }\n   \n   void LXmlReader::addData(const LByteArray &data)\n   {\n       m_parser.m_pStream.append(data.toString());\n   }\n   \n   void LXmlReader::addData(const char *data)\n   {\n       m_parser.m_pStream.append(data);\n   }\n   ```\n\n10. 接口逻辑：`parseToken()`\n\n       - 局部变量`upIndex`没有什么作用\n\n    ```cpp\n    // parse a token\n    bool LXmlReader::parseToken(LString &strToken)\n    {\n        LChar ch = m_parser.peek();\n        LString nowString;\n        int upIndex = 0;\n        //?? 是否需要ch>=0\n        // 一个字符一个字符判断，目的是卡好一个 token 的范围（至于功能上能不能卡好我也无从验证）\n        while (ch != LChar('=') && ch != LChar('/') && ch != LChar('>') && ch != LChar('\"') && ch != LChar(' ') && ch != LChar('\\''))\n        {\n            nowString.append(ch);\n            m_parser.consume(1);\n            upIndex++;\n            ch = m_parser.peek();\n        }\n        strToken = nowString;\n        return strToken.length() > 0;\n    }\n    ```\n\n    - 为什么传递参数`strToken`，还是引用？最后返回的还是一个`bool`值；单从本函数的逻辑上来看，完全可以将`nowString`返回，如果为空就代表失败\n\n         - 查看了`parseToken()`调用的地方，就明白了，在源文件中有两处\n         - 无非就想把解析出的结果记录在`element`或者`pair`中，那直接用返回值记录啊\n    \n    ```cpp\n    // returns true start of an element is successfully consumed.\n    // if true, the element's attributes are available below through getAttribute.\n    bool LXmlReader::readStartElement()\n    {\n        LEntry element;\n        if (isStartElement() && parseToken(element.m_element))\n        {\n           ...\n        }\n        \n        ...\n    }\n    \n    // parse attribute=quoted-value sequence.\n    bool LXmlReader::parseAttribute()\n    {\n        std::pair<LString, LString> pair;\n        bool bOK = skipspace(true) && parseToken(pair.first);\n        \n        ...\n    }\n    ```\n\n11. 接口逻辑：`skipspace()`\n\n    - 接口命名不规范，应使用小驼峰`skipSpace`\n    - 参数`bInside`：判断是在元素声明内还是外部\n      - 在内部，跳过空格、注释等非正文内容，直到遇到正文内容或其他标记为止\n      - 在外部，除了上面的内容，还会处理一些文档声明，例如`XML`版本，编码信息，`DTD`声明等\n    - 这里面的所有匹配都是硬匹配的，这个函数就是一个非常经典的例子，单从匹配的角度来讲，可以考虑正则表达式而不是硬匹配\n    - 在内部处理注释的时候，应匹配注释开始`<!--`和注释结束`-->`而不是`--`\n    - `TODO`：`bInside`为`false`的时候处理注释的逻辑目前看不懂\n\n    ```cpp\n    // skips / consumes whitespace.\n    // bInside - true if inside an element declaration eg. between '<' and '>'.\n    bool LXmlReader::skipspace(bool bInside)\n    {\n        if (bInside)\n        {\n            while (true)\n            {\n                // 1. 匹配空格\n                m_parser.skipSpace();\n                // 2. 匹配注释\n                if (m_parser.peekMatch(\"--\"))\n                {\n                    m_parser.consume(2);\n                    // 在注释内部，跳过注释内容\n                    while (!m_parser.eof() && !m_parser.peekMatch(\"--\"))\n                        m_parser.consume(1);\n                    // 匹配到注释结尾\n                    if (m_parser.peekMatch(\"--\"))\n                        m_parser.consume(2);\n                }\n                else\n                    break;\n            }\n        }\n        else\n        {\n            while (true)\n            {\n                // 1. 匹配空格\n                m_parser.skipSpace();\n                // 2. 匹配注释\n                // 基本逻辑和上面是一样的，但是这里多了很多成员变量的修改\n                // 下面关于 m_Comment 和 m_stack 目前看不懂\n                if (m_parser.peekMatch(\"<!--\"))\n                {\n                    bool flag1 = (m_stack.size() != 0);\n                    m_parser.consume(4);\n                    if (flag1)\n                        m_stack.back().m_iComment = LString(\"\");\n                    m_Comment = LString(\"\");\n                    while (!m_parser.eof() && !m_parser.peekMatch(\"-->\"))\n                    {\n                        if (flag1)\n                            m_stack.back().m_iComment.append(m_parser.peek());\n                        m_Comment.append(m_parser.peek());\n                        m_parser.consume(1);\n                    }\n                    if (m_parser.peekMatch(\"-->\"))\n                        m_parser.consume(3);\n                    // m_stack.back().m_iComment.append(LString(\" \"));\n                    m_parser.skipSpace();\n                    if (flag1)\n                        m_stack.back().m_commentIndex = LString::fromInt(characterOffset());\n                }\n                // 3. 匹配版本号和编码信息\n                // <?xml version=\"1.0\" encoding=\"utf-8\"?> 匹配固定模式，逻辑固定\n                else if (m_parser.peekMatch(\"<?\"))\n                {\n                    m_parser.consume(2);\n                    while (!m_parser.eof() && !m_parser.peekMatch(\"?>\"))\n                    {\n                        // 获取版本信息\n                        if (m_parser.peekMatch(\"version\"))\n                        {\n                            ...\n                        }\n                        // 获取编码信息\n                        else if (m_parser.peekMatch(\"encoding\"))\n                        {\n                            ...\n                        }\n                    }\n                    if (m_parser.peekMatch(\"?>\"))\n                        m_parser.consume(2);\n                }\n                // 3. 匹配 DTD 声明\n                // <!DOCTYPE 班级 SYSTEM \"myClass.dtd\"> 匹配固定模式，逻辑固定\n                else if (m_parser.peekMatch(\"<!DOCTYPE\"))\n                {\n                   ...\n                }\n                else\n                    break;\n            }\n        }\n        return true;\n    }\n    ```\n\n12. 接口逻辑：`parseAttribute()`\n\n    - 关于`m_attributes`和`m_attributes2`，上面提到过，一个用的是`STL`，一个用的是`SDK`，但是在这里两个东西存储的数据是一模一样的，因此有理由怀疑这两个东西其实是一个东西，可以删除一个\n\n    ```cpp\n    // parse attribute=quoted-value sequence.\n    bool LXmlReader::parseAttribute()\n    {\n        std::pair<LString, LString> pair;\n        // 跳过空格并且解析 key\n        bool bOK = skipspace(true) && parseToken(pair.first);\n        if (bOK)\n        {\n            // 解析 = 号\n            bool FLag1 = skipspace(true) && m_parser.parseMatch(LString(\"=\")) && skipspace(true);\n            // 由于属性可能被单引号或者双引号扩充起来，因此两个都进行判断\n            // 由于 parseMatch 只有成功才会修改游标 curSor，因此这里的逻辑是没问题的\n            bool Flag2 = m_parser.parseMatch(LString(\"\\'\")) && m_parser.readText(pair.second, '\\'') && m_parser.parseMatch(LString(\"\\'\"));\n            bool Flag3 = m_parser.parseMatch(LString(\"\\\"\")) && m_parser.readText(pair.second, '\"') && m_parser.parseMatch(LString(\"\\\"\"));\n            bOK = FLag1 && (Flag2 || Flag3);\n            if (bOK)\n            {\n                m_attributes.push_back(pair);\n                LPair<LString, LString> pair2;\n                pair2.key() = pair.first;\n                pair2.value() = pair.second;\n                m_attributes2.append(pair2);\n            }\n        }\n        return bOK;\n    }\n    ```\n\n13. 接口逻辑：`readStartElement()`\n\n    - 两个重载版本，第一个的参数应该用`const LString&`\n    - 当前元素是否具有子元素`m_children`，代码中是直接判断是能否解析到`>`，从这个函数来看，这个逻辑是不合理的，应该判断这个起始标签的下一个位置是不是子元素的起始标签，这样才是合理的\n\n    ```cpp\n    // returns true if start of named element is successfully consumed.\n    // if true, the element's attributes are available below through getAttribute.\n    bool LXmlReader::readStartElement(const LString *strElement)\n    {\n        LEntry element;\n        size_t iLen = 0;\n        // 如果传入字符串为空，则失败\n        if (strElement == nullptr || strElement->isEmpty())\n            return false;\n        // 判断当前是否为起始标签，并且是否能够成功解析\n        if (isStartElement() && m_parser.parseMatch(strElement, iLen))\n        {\n            // element.Element.assign(strElement, iLen);\n            //??\n            LString a = *strElement;\n            // 修改元素实体的内容\n            element.m_element = a.substr(0, iLen);\n            // 修改属性\n            m_attributes.clear();\n            m_attributes2.clear();\n            while (parseAttribute())\n                ;\n            // 记录当前元素是否具有子元素，这个逻辑不对吧。。\n            element.m_children = m_parser.parseMatch(LString(\">\"));\n            // 加入嵌套的栈\n            m_stack.push_back(element);\n            m_bStart = false;\n            return true;\n        }\n        return false;\n    }\n    \n    // returns true start of an element is successfully consumed.\n    // if true, the element's attributes are available below through getAttribute.\n    bool LXmlReader::readStartElement()\n    {\n        // 思路和前面基本一致\n        LEntry element;\n        // 只是这里改为直接解析 token 去了\n        if (isStartElement() && parseToken(element.m_element))\n        {\n            m_attributes.clear();\n            m_attributes2.clear();\n            while (parseAttribute())\n                ;\n            element.m_children = m_parser.parseMatch(LString(\">\"));\n            m_stack.push_back(element);\n            m_bStart = false;\n            return true;\n        }\n        return false;\n    }\n    ```\n\n14. 接口逻辑：`isStartElement()`\n\n    - `TODO`：第一个函数的逻辑目前看不懂。。。\n    - 第二个重载版本的参数同理应当使用`const LString&`\n\n    ```cpp\n    // returns true if start of an element.\n    bool LXmlReader::isStartElement()\n    {\n        // 看不懂。。。\n    \t...\n    }\n    \n    // returns true if start of the named element.\n    bool LXmlReader::isStartElement(const LString *strElement)\n    {\n        if (strElement == nullptr)\n            return false;\n        return isStartElement() && m_parser.peekMatch(strElement);\n    }\n    ```\n\n15. 接口逻辑：`readUntilElement()`\n\n    - 参数同理应当使用`const LString&`\n    - 一来就来了一个`new`，我了个豆。。。\n    - `AllStream`，把目前缓冲区里面的数据全拿出来？？？\n\n    ```cpp\n    bool LXmlReader::readUntilElement(const LString strElement)\n    {\n        LString *s = new LString(strElement);\n        // 枚举了三种不同的标签\n        // 第三种代表了一个自闭合的标签，表示该元素存在但是没有内容\n        // <element ...>，<element>，<element/>\n        LString now(\"<\");\n        now.append(strElement);\n        now.append(\" \");\n        LString now1(\"<\");\n        now1.append(strElement);\n        now1.append(\">\");\n        LString now2(\"<\");\n        now2.append(strElement);\n        now2.append(\"/>\");\n        // 判断是否读取到末尾\n        while (!atEnd())\n        {\n            LString AllStream = m_parser.getBuffer();\n            // 查找是否含有上面三种模式的标签\n            if (AllStream.contains(now) || AllStream.contains(now1) || AllStream.contains(now2))\n            {\n                // 如果当前游标位置的标签是目标标签，读取并返回 true\n                if (isStartElement(s))\n                {\n                    readStartElement();\n                    return true;\n                }\n                // 又开始顺着刚才的位置读，读取（跳过）自由节点的内容\n                readStartElement();\n                readPCData();\n                if (readEndElement(false))\n                {\n                    // 如果读到了返回 true，否则循环再来。。。\n                    if (readStartElement(s))\n                        return true;\n                }\n            }\n            else\n                return false;\n        }\n        return false;\n    }\n    ```\n\n16. 接口逻辑：`isEndElement()`\n\n    - 一个元素就算没有子元素，也可以自身有内容啊，不一定就是自闭合标签，例如`<book>math</book>`\n\n    ```cpp\n    // returns true if current element is self-closing OR no more nested content remains\n    // eg. cursor is positioned at the closing tag.\n    bool LXmlReader::isEndElement()\n    {\n        if (m_stack.size() > 0)\n        {\n            // 查看该元素是否具有子元素\n            bool bChildren = m_stack.back().m_children;\n            skipspace(!bChildren);\n            if (bChildren)\n            {\n                // 有子元素则取匹配子元素\n                LString strTail;\n                strTail = \"</\";\n                strTail.append(m_stack.back().m_element);\n                strTail.append(\">\");\n                return m_parser.peekMatch(strTail);\n            }\n            // 没有则匹配自闭合？？？这里逻辑感觉不对\n            return m_parser.peekMatch(\"/>\");\n        }\n        return false;\n    }\n    ```\n\n17. 接口逻辑：`readEndElement()`\n\n    - 三个重载版本，第二个重载版本参数应使用`const LString&`\n\n    ```cpp\n    bool LXmlReader::readEndElement(bool bSkip, const LString *element)\n    {\n        if (element == nullptr)\n            return false;\n        return m_stack.size() &&\n               m_stack.back().m_element == (*element) &&\n               readEndElement(bSkip);\n    }\n    \n    // conclude self-closing element OR consume closing element.\n    bool LXmlReader::readEndElement(bool bSkip)\n    {\n        bool bOK = false;\n        int startSkip = m_iSkipped;\n        if (m_stack.size() > 0)\n        {\n            // 判断是否存在子元素\n            bool bChildren = m_stack.back().m_children;\n            skipspace(!bChildren);\n            if (bChildren)\n            {\n                LString strTail;\n                strTail = \"</\";\n                strTail.append(m_stack.back().m_element);\n                strTail.append(\">\");\n                // 不存在结尾元素，则返回 false\n                LString buffer = m_parser.getBuffer();\n                if (!buffer.contains(strTail))\n                    return false;\n                // 否则就开始循环查找末尾元素标签\n                // 循环里面的逻辑没看懂。。。\n                do\n                {\n                    bOK = m_parser.parseMatch(strTail);\n                    if (!bOK && bSkip)\n                    {\n                        // what the hell is doing here？？？\n                        readPCData();\n                        if (readStartElement())\n                        {\n                            m_stack.back().m_skipped++;\n                            m_iSkipped++;\n                            getElementName();\n                            readPCData();\n                            readEndElement();\n                            readPCData();\n                        }\n                        // else break;\n                    }\n                    else\n                        break;\n                } while (!bOK && !m_parser.eof());\n            }\n            // 没有子元素就匹配自闭合？？？又匹配自闭合？？？\n            else\n                bOK = m_parser.parseMatch(\"/>\");\n            if (bOK)\n            {\n                nowSkip = m_iSkipped - startSkip;\n                m_stack.pop_back();\n            }\n        }\n        if (m_parser.eof())\n        {\n            std::cout << \"已读到末尾。\" << std::endl;\n        }\n        return bOK;\n    }\n    \n    void LXmlReader::readEndElement()\n    {\n        // 和第二个重载代码结构类似\n        ...\n    }\n    ```\n\n18. 接口`readEndEleName()`，和`readEndElement()`功能类似，可以复用\n\n    - 一个返回解析的元素名，一个返回是否解析成功，完全可以复用\n\n    ```cpp\n    /**\n     * @brief 解析结束标签（end element）\n     * @param bSkip 控制是否跳过再解析，当 bSkip 为 true时，若解析当前标签的结束标签失败，则会跳过中间子节点直到解析到当前标签的结束标签；\n     * 如果bSkip为false，则表示要继续解析子节点，而不跳过内容。\n     * @return 如果函数返回 true，则表示找到了结束元素；如果函数返回 false，则表示没有找到当前标签的结束标签。\n     */\n    bool readEndElement(bool bSkip);\n    \n    /**\n     * @brief 解析结束标签并返回当前解析元素名\n     * @param bSkip 控制是否跳过再解析，当 bSkip 为 true时，若解析当前标签的结束标签失败，则会跳过中间子节点直到解析到当前标签的结束标签；\n     * 如果bSkip为false，则表示要继续解析子节点，而不跳过内容。\n     * @return 如果函数返回不为空的节点名，则表示找到了结束元素；如果函数返回空LString，则表示没有找到当前标签的结束标签。\n     */\n    LString readEndEleName(bool bSkip);\n    ```\n\n19. 接口逻辑：`readUntilEndEle()`\n\n    - `readUntilElement()`是碰到这个标签就可以了，`readUntilEndEle()`还需要这个标签是结束标签\n    - 参数应使用`const LString&`\n\n    ```cpp\n    bool LXmlReader::readUntilEndEle(const LString element)\n    {\n        if (element.isEmpty())\n            return false;\n        // 不存在结尾元素\n        LString strTail(\"</\");\n        strTail.append(element);\n        strTail.append(\">\");\n        // 又来了，又是经典的 getBuffer()\n        LString buffer = m_parser.getBuffer();\n        if (!buffer.contains(strTail))\n            return false;\n        // 从栈里面取出一个一个的元素，去和给定的值比较\n        bool Flag = false;\n        if (m_stack.size() > 0)\n        {\n            for (const auto &ele : m_stack)\n            {\n                if (ele.m_element == element)\n                    Flag = true;\n            }\n        }\n        // 如果有，就开始循环读取，直到找到目标\n        if (Flag)\n        {\n            while (m_stack.back().m_element != element)\n            {\n                readEndElement();\n            }\n            readEndElement();\n            return true;\n        }\n        return false;\n    }\n    ```\n\n20. 接口逻辑：`readPCData()`\n\n    - `readPCDataW`()是返回`std::wstring`的版本\n      - 目前两个函数的实现分开，可以复用，通过标准的`LString`进行中转，然后各自导出为`std::string`和`std::wstring`\n    - 函数声明中提到自由文本节点的概念，但是官方好像并没有这个概念，这样是否合理？\n\n    ```cpp\n    /**\n     * @brief 检索元素下的PC数据（即自由文本节点）\n     * @return 返回获取的PC数据，若为空则未获取到PC数据\n     */\n    LString readPCData();\n    ```\n\n    - 函数定义\n\n    ```cpp\n    // retrieve PC Data (free text nodes under an element).\n    LString LXmlReader::readPCData()\n    {\n        LString strData;\n        if (m_stack.size() > 0 && m_stack.back().m_children)\n        {\n            bool bOK = false;\n            LString strText;\n            // strText.reserve(128);\n            // 通过 Parser 的 readText() 函数从 < 开始读取文本内容\n            bOK = m_parser.readText(strText, '<');\n            if (bOK)\n                // 处理文本实体引用\n                readEntities(strText, strData);\n            // //未读取到pcdata\n            // if(strText.isEmpty()) bOK = false;\n        }\n        return strData;\n    }\n    ```\n\n21. 接口逻辑：`readStringElement()`\n\n    - `readStringElementW()`是该函数返回`std::wstring`的版本\n      - 问题同上\n    \n    ```cpp\n    // read text content: assumes element with text only - no child elements.\n    LString LXmlReader::readStringElement(const LString *strElement)\n    {\n        LString res;\n        LString now(*strElement);\n        int nowIndex = characterOffset();\n        // 如果现在读取的标签（m_stringName) 和传入参数匹配\n        if (m_stringName == *strElement)\n        {\n            // 读取文本内容\n            res = readPCData();\n            // 读取标签末尾\n            if (readEndElement(false, &res))\n                return res;\n            return LString(\"\");\n        }\n        // 不匹配则一直读取直到找到目标\n        else if (readUntilElement(now))\n        {\n            // 逻辑同上\n            res = readPCData();\n            if (readEndElement(false, strElement))\n            {\n                return res;\n            }\n            else\n            {\n                // 获取预前进光标数，将光标退回\n                int upIndex = characterOffset() - nowIndex;\n                m_parser.m_iCursor = m_parser.m_iCursor - upIndex;\n                res = LString(\"\");\n                return res;\n            }\n        }\n        return res;\n    }\n    ```\n\n22. `getAttribute()`和`getAttributeW()`同样可以复用\n\n    ```cpp\n    // retrieve text for the named attribute.\n    LString LXmlReader::getAttribute(const LString *strAttribute)\n    {\n        // strValue.resize(0);\n        LString strValue;\n        if (strAttribute == nullptr)\n            return strValue;\n        // 遍历 m_attributes 获得结果\n        std::list<std::pair<LString, LString>>::const_iterator it = m_attributes.begin();\n        while (it != m_attributes.end())\n        {\n            if ((*it).first == (*strAttribute))\n            {\n                // expand entities only when value is requested.\n                // 实体引用的转换\n                readEntities((*it).second, strValue);\n                return strValue;\n            }\n            it++;\n        }\n        return LString(\"\");\n    }\n    \n    // 另一个的逻辑一摸一样\n    ```\n\n23. `enumAttributes()`接口不知道设计的目的是什么，经全局搜索也没有在其他接口中使用到\n\n    ```cpp\n    // begin/end iterators for current element's attributes.\n    bool LXmlReader::enumAttributes(LList<LPair<LString, LString>>::iterator &itBegin, LList<LPair<LString, LString>>::iterator &itEnd)\n    {\n        // itBegin = m_attributes.begin();\n        // itEnd = m_attributes.end();\n        // return m_attributes.size() > 0;\n        LList<LPair<LString, LString>>::iterator m_begin(m_attributes2.begin());\n        LList<LPair<LString, LString>>::iterator m_end(m_attributes2.end());\n        // 把成员变量的首尾迭代器赋值给参数？？？\n        itBegin = m_begin;\n        itEnd = m_end;\n        // itBegin = m_attributes.begin();\n        // itEnd = m_attributes.end();\n        // 有数据就返回 true ？？？\n        return m_attributes.size() > 0;\n    }\n    ```\n\n24. 接口逻辑：`getComment()`\n\n    - `b.toInt()`这一样没有用，可以删去\n\n    ```cpp\n    LString LXmlReader::getComment()\n    {\n        // 防止影响其他接口\n        if (m_stack.size() == 0)\n            return LString(\"\");\n        skipspace(false);\n        if (m_stack.size() > 0 && !m_stack.back().m_iComment.isEmpty())\n        {\n            // 判断当前偏移量和 m_stack 中记录的偏移量是否一致\n            LString a = LString::fromInt(characterOffset());\n            LString b = m_stack.back().m_commentIndex;\n            b.toInt();\n            if (a.toInt() == b.toInt())\n            {\n                // 获取注释内容\n                LString now = m_stack.back().m_iComment;\n                now.trim();\n                return now;\n            }\n        }\n        return LString(\"\");\n    }\n    ```\n\n#### LXmlWriter\n\n1. 代码存在各种规范问题，例如换行不规范、注释不全、注释不规范，函数可以内联等等，统一列在这里，后续不赘述\n\n2. 成员变量`m_pStream`是一个引用（？？？），或许有这种用法，但是肯定不是在这里\n\n   ```cpp\n   // 输入流内容\n   LString &m_pStream;\n   ```\n\n3. 成员变量嵌套元素的栈应使用`LStack`类型\n\n   - 等等，前面是`std::stack`，这里又是`std::vector`？？\n\n   ```cpp\n   // 嵌套元素的堆栈。\n   std::vector<LEntry> m_stack;\n   ```\n\n4. 接口逻辑：`adopt`()\n\n   - `TODO`：没看懂。。。\n\n   ```cpp\n   void LXmlWriter::adopt()\n   {\n       if (m_stack.size() && !m_stack.back().m_children)\n       {\n           m_stack.back().m_children = true;\n           writeString(\">\");\n           writeString(\"\\n\");\n       }\n   }\n   ```\n\n5. `writeString()`接口，提供了多个重载版本，但是均可以做到复用，可通过`LString`进行统一\n\n   - 下面的做法都是将封装类型`LString`或者`std::wstring`转化为基础类型`const char*`和`const wchar_t`*在插入，个人认为虽然可行但不优雅，应像上面所说使用`LString`进行统一\n\n   ```cpp\n   void LXmlWriter::writeString(const char *strText)\n   {\n       // size_t iLen = strlen(strText);\n       // size_t iWrote = 0;\n       // m_pStream->Write((unsigned char *)strText, iLen, iWrote);\n       m_pStream.append(strText);\n   }\n   \n   void LXmlWriter::writeString(const wchar_t *strText)\n   {\n       std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n       std::string strTran = converter.to_bytes(strText);\n       writeString(strTran.c_str());\n   }\n   \n   void LXmlWriter::writeString(const LString &strText)\n   {\n       // 不是哥，你数据的类型是 LString ，你插入 LString 还先转化为 const char* ？？？\n       writeString(strText.toStdString().c_str());\n   }\n   \n   void LXmlWriter::writeString(std::wstring &strText)\n   {\n       writeString(strText.c_str());\n   }\n   ```\n\n6. `writeAttributeRaw()`和`writeAttribute()`函数\n\n   - `writeAttributeRaw()`的参数应使用`const LString&`\n   - 观察了这两个函数可以发现，`writeAttributeRaw()`函数是`writeAttribute()`函数实际做写入操作的函数\n   - 并且经过全局搜索后发现`writeAttributeRaw()`函数只在`writeAttribute()`函数中被调用，`writeAttribute()`其实是有很多重载版本\n   - 那么完全可以将`writeAttributeRaw()`函数合并到`writeAttribute()`中，做一个基础版本的`writeAttribute()`，比如就是`LString`，其他的重载都复用该版本即可\n   - 目前的重载版本只留了一个`LString`，其他的版本均注释掉，后续应考虑撤销注释\n\n   ```cpp\n   bool LXmlWriter::writeAttributeRaw(const LString *strAttribute, const LString *strValue)\n   {\n       // 真正调用 writeString() 做写入操作的函数\n       if (strAttribute == nullptr || strValue == nullptr)\n       {\n           return false;\n       }\n       writeString(\" \");\n       writeString(*strAttribute);\n       writeString(\"=\\\"\");\n       writeString(*strValue);\n       writeString(\"\\\"\");\n       return true;\n   }\n   \n   bool LXmlWriter::writeAttribute(const LString &strAttribute, const LString &strValue)\n   {\n       // 先做一些合法性的判断，然后调用 writeAttributeRaw() 进行实际的写入操作\n       // 判空\n       if (strAttribute.isEmpty() || strValue.isEmpty())\n       {\n           std::cout << \"写入属性不能为空\" << std::endl;\n           return false;\n       }\n       // 判断写入格式是否正确\n       if (!rightForm(strAttribute))\n       {\n           std::cout << \"写入格式错误,写入\" << strAttribute << \"失败\" << std::endl;\n           return false;\n       }\n       std::string strEntity;\n       // 将特殊符号替换为其对应的实体引用\n       insertEntities(strValue.toStdString().c_str(), strEntity);\n       const LString valueStr(strEntity);\n       // insertEntities(strValue, strEntity);\n       // return writeAttributeRaw(strAttribute, strEntity.c_str());\n       return writeAttributeRaw(&strAttribute, &valueStr);\n   }\n   ```\n\n7. 构造函数的实现\n\n   - `m_pStream`是一个`LString`，初始化先`new`一个`LString`，再解引用，然后赋值？？？\n   - 参数中`LString&`，`LByteArray&`，`LFile&`均是左值引用，应当加上`const`以保证能够传入`value`\n\n   ```cpp\n   LXmlWriter::LXmlWriter() : m_pStream(*(new LString(\"\"))) {}\n   \n   LXmlWriter::LXmlWriter(LString &inputStream) : m_pStream(inputStream) {}\n   \n   LXmlWriter::LXmlWriter(LByteArray &inputStream) : m_pStream(*(new LString(\"\")))\n   {\n       m_pStream = inputStream.toString();\n   }\n   \n   LXmlWriter::LXmlWriter(const char *inputStream) : m_pStream(*(new LString(inputStream))) {}\n   \n   LXmlWriter::LXmlWriter(LFile &inputStream) : m_pStream(*(new LString(\"\")))\n   {\n       if (!inputStream.exists())\n       {\n           std::cout << \"文件不存在\" << std::endl;\n       }\n   \n       inputStream.open(LFile::OpenMode::ReadOnly | LFile::OpenMode::Text);\n       LString file;\n       while (!inputStream.end())\n       {\n           file.append(inputStream.readLine().toString());\n       }\n       m_pStream = file; // 绑定引用成员变量与传入的对象\n   }\n   ```\n\n8. 接口逻辑：`writeStartElement()`\n\n   ```cpp\n   bool LXmlWriter::writeStartElement(const LString &strElement)\n   {\n       // 判空\n       if (strElement.isEmpty())\n           return false;\n       // 检查写入的值是否符合规范\n       if (!rightForm(strElement))\n       {\n           std::cout << \"写入格式错误,写入\" << strElement << \"失败\" << std::endl;\n           return false;\n       }\n       LEntry e;\n       e.m_element = strElement;\n       // call before pushing new element onto stack.\n       adopt();\n       m_stack.push_back(e);\n       // 执行写入操作\n       writeString(\"<\");\n       writeString(strElement);\n       return true;\n   }\n   ```\n\n9. 接口逻辑：`writeEndElement()`\n\n   ```cpp\n   bool LXmlWriter::writeEndElement()\n   {\n       if (m_stack.size())\n       {\n           if (m_stack.back().m_children)\n           {\n               // 写入一个标签\n               writeString(\"</\");\n               writeString(m_stack.back().m_element.toStdString().c_str());\n               writeString(\">\\n\");\n           }\n           else\n               // 没有子元素，又写入自闭合标签？？？\n               writeString(\" />\\n\");\n           m_stack.pop_back();\n           return true;\n       }\n       return false;\n   }\n   ```\n\n10. 接口逻辑：`writeStringElement()`\n\n    - 两个重载版本，一个带属性s，一个不带属性\n         - 解释一下四个参数的含义\n           - `strElement`：元素标签名\n           - `strValue`：元素文本内容\n           - `attributeName`：属性名\n           - `attributeValue`：属性内容\n    - 属性内容这里给的是泛型`T`，但是在函数内部写入的时候给他当成`LString`直接用了，这是不合理的，可以提供多个版本的重载，或者规定只能传入`LSring`，把数据类型转换的问题交给用户\n\n    ```cpp\n    template <typename T>\n    bool LXmlWriter::writeStringElement(const LString &strElement, const LString &strValue,\n                                        const LString &attributeName, T attributeValue)\n    {\n        // 判空\n        if (strElement.isEmpty())\n        {\n            std::cout << \"元素名为空，写入失败\" << std::endl;\n            return false;\n        }\n        if (attributeName.isEmpty())\n        {\n            std::cout << \"写入属性名为空，写入失败\" << std::endl;\n            return false;\n        }\n        // 判断格式是否正确\n        if (!rightForm(strElement))\n        {\n            std::cout << \"写入格式错误，写入失败\";\n            return false;\n        }\n        adopt();\n        // 写入起始标签\n        writeString(\"<\");\n        writeString(strElement);\n    \n        // 写入属性\n        if (!attributeName.isEmpty())\n        {\n            // 这个函数目前只有两个参数都是 LString 的重载版本，就直接把 T 类型的属性值当成 LString 传进去了？？？\n            writeAttribute(attributeName, attributeValue);\n        }\n    \n        writeString(\">\");\n    \n        // 写入文本内容\n        writeString(strValue);\n    \n        // 写入结束标签\n        writeString(\"</\");\n        writeString(strElement);\n        writeString(\">\\n\");\n        return true;\n    }\n    \n    bool LXmlWriter::writeStringElement(const LString &strElement, const LString &strValue)\n    {\n        // 逻辑类似\n        ...\n    }\n    ```\n\n11. 接口逻辑：`writePCData()`\n\n    ```cpp\n    bool LXmlWriter::writePCData(const LString &strPCData)\n    {\n        // 判空\n        if (strPCData.isEmpty())\n        {\n            std::cout << \"写入内容为空\" << std::endl;\n            return false;\n        }\n        std::string strEntity;\n        // insertEntities(strPCData, strEntity);\n        // 字符的实体引用替换\n        insertEntities(strPCData.toStdString().c_str(), strEntity);\n        adopt();\n        // 写入内容\n        writeString(strEntity.c_str());\n        writeString(\"\\n\");\n        return true;\n    }\n    ```\n\n12. 接口逻辑：`writeComment()`和`writeCommentOrigin()`\n\n    - 二者都是写入注释，只不过前者要求输入的是标准格式的注释，后者是输入的是纯注释内容\n\n    ```cpp\n    // 要求输入标准格式\n    bool LXmlWriter::writeComment(const LString &text)\n    {\n        LString comment = text;\n        // 对输入的字符串是否符合注释规范进行检测\n       \t// 是否包含注释标识\n        if (text.contains(\"<!--\") && text.contains(\"-->\"))\n        {\n            comment.trim();\n            // 注释标识的位置是否正确\n            if (comment.indexOf(\"<!--\") == 0 && comment.indexOf(\"-->\") == comment.length() - 3)\n            {\n                adopt();\n                comment.append(\"\\n\");\n                // 写入\n                writeString(comment);\n            }\n            else\n            {\n                std::cout << \"所输入注释格式不正确\" << std::endl;\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    // 输入纯注释内容\n    void LXmlWriter::writeCommentOrigin(const LString &text)\n    {\n        if (text.isEmpty())\n        {\n            return;\n        }\n        adopt();\n        // 构造注释标识然后写入\n        LString comment = LString(\"<!--\");\n        comment.append(text);\n        comment.append(\"-->\");\n        comment.append(\"\\n\");\n        writeString(comment);\n    }\n    ```\n\n13. 接口逻辑：`writeDTD()`\n\n    - 在`xml`中引入`DTD`文件\n\n    ```xml\n    <!DOCTYPE note SYSTEM \"Note.dtd\">\n    ```\n\n    - `DTD`文件内容\n\n    ```dtd\n    <!DOCTYPE note\n    [\n    <!ELEMENT note (to,from,heading,body)>\n    <!ELEMENT to (#PCDATA)>\n    <!ELEMENT from (#PCDATA)>\n    <!ELEMENT heading (#PCDATA)>\n    <!ELEMENT body (#PCDATA)>\n    ]>\n    ```\n\n    - 代码\n      - 看起来代码里的实现是让`DTD`文件的内容是内嵌在`xml`文件中\n      - 下面的逻辑根本不对啊，判断括号的个数是否匹配？？那万一他们的位置信息不对呢？？？想得出来哦。。\n\n    ```cpp\n    bool LXmlWriter::writeDTD(const LString &dtd)\n    {\n        if (dtd.isEmpty())\n            return false;\n        LString nowDTD = dtd;\n        nowDTD.trim();\n        // 先找固定的开头\n        if (nowDTD.indexOf(\"<!DOCTYPE\") == 0)\n        {\n            int left = 0;\n            int right = 0;\n            int mid = 0;\n            int mid2 = 0;\n            nowDTD = nowDTD.substr(8, -1);\n            // 一个一个匹配 ELEMENT 的格式\n            for (int i = 0; i < nowDTD.length(); i++)\n            {\n                // 由于最开始消耗了一个 < ，因此后续的 > 总会比 < 多一个\n                if (nowDTD.at(i) == LChar(\"<\"))\n                {\n                    i++;\n                    if (nowDTD.at(i) == LChar(\"!\"))\n                        left++;\n                }\n                else if (nowDTD.at(i) == LChar(\">\"))\n                    right++;\n                // 通过 mid 判断 ( 和 ) 个数一致\n                else if (nowDTD.at(i) == LChar(\"(\"))\n                    mid++;\n                else if (nowDTD.at(i) == LChar(\")\"))\n                    mid--;\n                // 同样，[ 和 ] 个数一致\n                else if (nowDTD.at(i) == LChar(\"[\"))\n                    mid2++;\n                else if (nowDTD.at(i) == LChar(\"]\"))\n                    mid2--;\n            }\n            if (mid == 0 && left == right - 1 && mid2 == 0)\n            {\n                writeString(dtd);\n                writeString(\"\\n\");\n                return true;\n            }\n        }\n    \n        std::cout << \"格式有误，写入错误\" << std::endl;\n        return false;\n    }\n    ```\n\n14. `writeStartDocument()`接口最后的`return`可以删除\n\n    - 整体逻辑没什么毛病\n\n    ```cpp\n    void LXmlWriter::writeStartDocument(const LString &version, const LString &encoding)\n    {\n        if (!version.isEmpty() && !encoding.isEmpty())\n        {\n            LString versionadd(\"<?xml version=\\\"\");\n            versionadd.append(version);\n            versionadd.append(\"\\\" encoding=\\\"\");\n            versionadd.append(encoding);\n            versionadd.append(\"\\\"?>\\n\");\n            m_pStream = versionadd + m_pStream;\n        }\n        else if (encoding.isEmpty() && !version.isEmpty())\n        {\n            LString versionadd(\"<?xml version=\\\"\");\n            versionadd.append(version);\n            versionadd.append(\"\\\"?>\\n\");\n            m_pStream = versionadd + m_pStream;\n        }\n    \n        return;\n    }\n    ```\n\n15. `writeFileAdd()`和`writeFileRewrite()`功能类似，可以考虑复用\n\n    - 二者功能差不多，只不过一个是`append`，一个是从头`write`\n\n    - 最后的`puts()`那里，代码太冗杂了，拿一个返回值记录即可；并且如果写入失败，也没有做日志输出或者抛出异常等相关处理\n    - `writeFileRewrite()`写入以前有`trim()`去除首位空格操作，`writeFileAdd()`却没有\n\n    ```cpp\n    bool LXmlWriter::writeFileAdd(LFile &file)\n    {\n        if (!file.exists())\n        {\n            std::cout << \"文件不存在，新建文件\" << std::endl;\n        }\n        file.open(LFile::OpenMode::Append | LFile::OpenMode::Text);\n        // what？？？。。。\n        if (file.puts(m_pStream))\n        {\n            file.close();\n            return true;\n        }\n        file.close();\n        return false;\n    }\n    \n    bool LXmlWriter::writeFileRewrite(LFile &file)\n    {\n        if (!file.exists())\n        {\n            std::cout << \"文件不存在，新建文件\" << std::endl;\n        }\n        file.open(LFile::OpenMode::WriteOnly | LFile::OpenMode::Text);\n        if (file.puts(m_pStream))\n        {\n            // 这里用了前面却不用\n            m_pStream.trim();\n            file.close();\n            return true;\n        }\n        file.close();\n        return false;\n    }\n    ```\n\n#### namespace\n\n1. `namespace`中的所有函数都声明的是静态函数，那为什么不直接声明成静态成员函数，就不用开命名空间了\n\n2. 里面有三个`append()`函数的重载版本，但是在整个文件中没有地方用到，可以删除\n\n   - `mbstate_t`和`mbrtowc()`是标准`C`库的函数，是跨平台的，这个没问题，由于这三个函数没啥用，就不细看了\n\n   ```cpp\n   // 根据需要处理转码以将字节字符附加到字符串。\n   static void append(std::wstring &strValue, char ch, mbstate_t &state)\n   {\n       wchar_t dest[4] = {0};\n       if (mbrtowc(dest, &ch, 1, &state) > 0)\n           strValue += dest;\n   }\n   \n   // 根据需要处理转码以将字节字符附加到字符串。\n   static void append(LString &strValue, char ch)\n   {\n       strValue.append(LChar(ch));\n   }\n   \n   static void append(std::string &strValue, char ch, mbstate_t &state)\n   {\n   #ifdef UNICODE\n       char dest[4] = {0};\n       size_t used = 0;\n       errno_t err = wcrtomb_s(&used, dest, sizeof dest, ch, &state);\n       if (err == 0)\n           strValue.append(dest, used);\n   #else\n       // state;\n       strValue += (char)ch;\n   #endif\n   }\n   ```\n\n3. 接口逻辑：`readEntities()`\n\n   - 函数的作用是把`xml`中的实体引用恢复成为其原本的文本的值\n\n   ```cpp\n   // 将五个标准 XML 实体扩展为其文本值。\n   // &amp; < &gt; ’ “\n   // 未识别的实体被保留。\n   static void readEntities(const LString &strValue, LString &strResult)\n   {\n       strResult = LString(\"\"); // 测试是否正确\n       bool bEntity = false;\n       LString strEntity;\n       // 更改为接收所有utf8字符\n       // 一个一个字节判断？？？\n       for (int i = 0; i < strValue.length(); i++)\n       {\n           LChar ch = strValue[i];\n           // 实体引用开始\n           if (ch == LChar(\"&\"))\n           {\n               bEntity = true;\n           }\n           // 实体引用结束\n           else if (ch == LChar(\";\"))\n           {\n        \t\t// 处理实体引用的转换\n               if (bEntity)\n               {\n                   // &\n                   if (strEntity.compare(\"amp\") == 0)\n                       strResult.append(LChar('&'));\n                   // 小于\n                   else if (strEntity.compare(\"lt\") == 0)\n                       strResult.append(LChar('<'));\n                   // 大于\n                   else if (strEntity.compare(\"gt\") == 0)\n                       strResult.append(LChar('>'));\n                   // 双引号\n                   else if (strEntity.compare(\"quot\") == 0)\n                       strResult.append(LChar('\"'));\n                   // 单引号\n                   else if (strEntity.compare(\"apos\") == 0)\n                       strResult.append(LChar('\\''));\n                   // 都不是，表示不是实体引用\n                   else\n                   {\n                       strResult.append(LChar('&'));\n                       strResult.append(strEntity);\n                       strResult.append(LChar(';'));\n                   }\n                   bEntity = false;\n               }\n           }\n           else\n           {\n               // 如果经过实体引用开始 & ，表示可能是实体引用，加入 strEntity，待后续转化\n               if (bEntity)\n                   strEntity.append(ch);\n               // 加入结果字符串\n               else\n               {\n                   strResult.append(ch);\n               }\n           }\n       }\n   }\n   \n   // 这个是返回字符串是 std::wstring 的版本\n   static void readEntities(const LString &strValue, std::wstring &strResult)\n   {\n       size_t size = strValue.length();\n       LString strMulti;\n       readEntities(strValue, strMulti);\n       strResult.resize(size);\n       std::string a = strMulti.toStdString();\n       std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;\n       strResult = converter.from_bytes(a);\n   }\n   ```\n\n4. 接口逻辑：`insertEntities()`\n\n   - 为什么一来要`reserve()`？`append()`会自动扩容的\n\n   ```cpp\n   static void insertEntities(const char *strText, std::string &strEntity)\n   {\n       strEntity.reserve(64);\n       while (*strText != '\\0')\n       {\n           // 将实体文本内容换成实体引用\n           char ch = *strText++;\n           switch (ch)\n           {\n           case '\\'':\n               strEntity += \"&apos;\";\n               break;\n           case '&':\n               strEntity += \"&amp;\";\n               break;\n           case '<':\n               strEntity += \"&lt;\";\n               break;\n           case '>':\n               strEntity += \"&gt;\";\n               break;\n           case '\"':\n               strEntity += \"&quot;\";\n               break;\n           default:\n               strEntity += ch;\n               break;\n           }\n       }\n   }\n   ```\n\n# 4.22 - 4.30\n\n## 迭代任务\n\n1. 完成`LFileSystemPath`和`LFileSystemEntry`的编写，自测无误后已经转测\n2. 对比`std::map`和`QMap`的接口，当然会延申出`std::multimap`和`QMultiMap`\n3. 同理处理`std::unordered_map`和`QHash`\n4. 帮助陈冠杰处理部分`LSet`部分的编写\n\n## 学习的点\n\n1. 关于`std::multimap`的模板参数中的`cmp`\n\n   - 可以传入自定义的排序规则的`functor`，但是由于自身内部是红黑树的设计，传入的`cmp`谓词的类型必须是`key`，而不能是其他的，比如`pair<key, data>`，即只能通过`key`来进行排序，没有办法`key`相同的时候通过`data`排序。因为内部对`functor`的类型做了检查，必须是`key`的类型才能编译通过，其实这样想也有道理，红黑树的结构需要保持，只通过`key`显然是最好的；对于上面的需求，可以使用`set`存储`pair`，然后自定义`cmp`谓词处理数据即可\n\n2. 关于`std::map`和`std::multimap`的二元谓词的思考\n\n   - 看到`less<int>`的内部实现，发现只是简单的`return x < y`\n\n   ```cpp\n   /// One of the @link comparison_functors comparison functors@endlink.\n   template<typename _Tp>\n   struct less : public binary_function<_Tp, _Tp, bool>\n   {\n     _GLIBCXX14_CONSTEXPR\n     bool\n     operator()(const _Tp& __x, const _Tp& __y) const\n     { return __x < __y; }\n   };\n   ```\n\n   - 现在我们构想一个排序的过程，例如冒泡排序，最重要的过程就是根据两个数的大小关系，然后判断是否发生交换，例如如果是升序排序，那么第一个数大于第二个数的时候就会发生交换。但是对于`less<int>`而言，里面是`x < y`，经过平时的使用我们知道，这个东西是对应升序的，那么`x < y`返回`true`，不是就应该交换了吗，也就是降序吗？\n   - 想到这里，就需要牵扯到谓词的逻辑了，我们假设二元谓词是`cmp(int val1,int val2)`，交换操作是`swap`，实际的逻辑用伪代码写就是这样\n\n   ```cpp\n   if(cmp(...))\n   {\n       swap(...)\n   }\n   ```\n\n   - 显然，`cmp`返回`true`的时候才会做后续的事情，不管是几元谓词的逻辑都是这样，因此，可以预见的是，在实际的`cmp`参数里面，是这样的，`cmp(val2, val1)`，第二个值在前面，第一个基准值在后面，这样才能保证正确的结果，也可以这样理解，后面的值需要同前面的值进行比较，所以排在前面\n   - 所以，对于自定义的二元谓词，**小于对应升序，大于对应降序**，这也是符合用户使用习惯的\n\n## QMap\n\n1. 构造函数\n\n   - `std::map`提供了很多版本，但是很多都和用户的使用没有关系，比如传入迭代器，分配器等，因此下面只看`QMap`\n   - 默认构造：略\n   - 带参构造、拷贝构造和移动构造：通过`initializer_list`构造，通过`std::map`和`QMap`进行拷贝和移动构造\n\n   ```cpp\n   QMap(std::initializer_list<std::pair<Key, T>> list);\n   QMap(const std::map<Key, T> &other);\n   QMap(std::map<Key, T> &&other);\n   QMap(const QMap<Key, T> &other);\n   QMap(QMap<Key, T> &&other);\n   ```\n\n2. 析构函数：略\n\n3. 迭代器：首尾，反转首尾\n\n   - 应该提供非常量迭代器和常量迭代器的版本，接口包括`begin()`、`end()`、`rbegin()`、`rend()`\n\n   ```cpp\n   QMap<Key, T>::iterator begin();\n   QMap<Key, T>::const_iterator begin() const;\n   QMap<Key, T>::const_iterator cbegin() const;\n   QMap<Key, T>::const_iterator cend() const;\n   QMap<Key, T>::const_iterator constBegin() const; // begin() 返回常量迭代器的别名\n   QMap<Key, T>::const_iterator constEnd() const; // cend() 返回常量迭代器的别名\n   ```\n\n4. `clear()`：略\n\n5. `contains()`：判断`key`是否在`map`中\n\n   ```cpp\n   bool contains(const Key &key) const;\n   ```\n\n6. `count()`：返回指定`key`的元素个数，在`map`中`key`无法重复，值只能是`0`或`1`\n\n   - 第二个重载，返回整个`map`的大小，即`size()`\n\n   ```cpp\n   QMap<Key, T>::size_type\tcount(const Key &key) const;\n   QMap<Key, T>::size_type\tcount() const;\n   ```\n\n7. `empty()`：判空，略\n\n   - `isEmpty()`是`empty()`的别名\n\n8. `equal_range()`：找到和给定`key`相同的迭代器的范围，满足左开右闭的规则\n\n   - 个人认为对`map`而言，这个接口没有意义，因为`key`是唯一的，因此匹配范围是没有意义的，对于`multimap`才有这个需求\n\n   ```cpp\n   std::pair<QMap<Key, T>::iterator, QMap<Key, T>::iterator> equal_range(const Key &key);\n   std::pair<QMap<Key, T>::const_iterator, QMap<Key, T>::const_iterator> equal_range(const Key &key) const;\n   ```\n\n9. `erase()`：删除元素\n\n   - 第二个重载版本，由于`map`默认是会自动排序的，因此遍历的结果是有序的（`unorder_map`的哈希的遍历结果不一定是有序的，因为经过插入或者删除的哈希桶结构会发生变化，因此两个`unorder_map`的元素是相同的情况下遍历的结果也可能会不同，但是`map`底层是红黑树，元素是有固定的顺序的，因此结果有序），因此可以通过迭代器删除区间的元素\n\n   ```cpp\n   QMap<Key, T>::iterator erase(QMap<Key, T>::const_iterator pos);\n   QMap<Key, T>::iterator erase(QMap<Key, T>::const_iterator first, QMap<Key, T>::const_iterator last);\n   ```\n\n10. `find()`：通过`key`，查找并返回迭代器\n\n    ```cpp\n    QMap<Key, T>::iterator find(const Key &key);\n    QMap<Key, T>::const_iterator find(const Key &key) const;\n    ```\n\n11. `constFind()`：通过`key`找到迭代器，返回常量迭代器，即`find`返回常量迭代器的重载版本的别名\n\n    ```cpp\n    QMap<Key, T>::const_iterator constFind(const Key &key) const;\n    ```\n\n12. `first()`、`firstKey()`：返回首元素或者首元素的`value`和`key`\n\n    - 对应的有`last`系列函数\n\n    ```cpp\n    T& first();\n    const T& first() const;\n    const Key& firstKey() const;\n    \n    T& last();\n    const T& last() const;\n    const Key& lastKey() const;\n    ```\n\n13. `insert()`：根据`key`和`value`插入到`map`中\n\n    - 第四个重载版本，个人认为没有必要，`const &`本身就是万能引用，既能接受左值，又能接受右值\n\n    ```cpp\n    QMap<Key, T>::iterator insert(const Key &key, const T &value);\n    QMap<Key, T>::iterator insert(QMap<Key, T>::const_iterator pos, const Key &key, const T &value);\n    void insert(const QMap<Key, T> &map);\n    void insert(QMap<Key, T> &&map);\n    ```\n\n14. `keys()`：返回`key`的列表\n\n    - 第二个重载版本，返回指定`value`对应的`key`列表，因为`key`不重复，`value`当然可能重复，所以返回的是一个列表\n\n    ```cpp\n    QList<Key> keys() const;\n    QList<Key> keys(const T &value) const;\n    ```\n\n15. `values()`：导出`value`列表，略\n\n16. `key()`：根据`value`找到对应第一个的`key`\n\n    - 第二个参数，用户可以自己给定如果`value`不存在，返回的`key`值，否则返回默认值\n    - 这个参数的作用在于用户可以通过这个接口判断指定的`value`对应的`key`存不存在，因为直接返回默认值作为参考的话，如果用户当前存储的刚好就是默认值，那么就没有办法正确判断`value`对应的`key`是否存在了，因此提供了一个`defaultKey`的参数，这个设计比较巧妙\n\n    ```cpp\n    Key key(const T &value, const Key &defaultKey = Key()) const;\n    ```\n\n17. `value()`：根据`key`找到对应的第一个`value`，第二个参数同上\n\n    ```cpp\n    T value(const Key &key, const T &defaultValue = T()) const;\n    ```\n\n18. `lowerBuond()`和`upperBound()`：通过二分有序查找指定的元素\n\n    - 例子：`1,2,2,2,3`（当然`map`是去重的，这里只是明确语义），`key=2`\n\n    - `lowerBound()`：找到大于等于`key`的第一个元素，这里就是第一个`2`\n    - `upperBound()`：个人认为是找到不大于`key`的最后一个元素，也就是最后一个`2`，但是根据标准库和迭代器的语义，返回的是`3`，也就是大于`key`的第一个元素\n    - 对于`map`而言，这两个接口同样没有意义，因为`key`是唯一的，该接口适用于`multimap`\n\n    ```cpp\n    QMap<Key, T>::iterator lowerBound(const Key &key);\n    QMap<Key, T>::const_iterator lowerBound(const Key &key) const;\n    QMap<Key, T>::iterator upperBound(const Key &key);\n    QMap<Key, T>::const_iterator upperBound(const Key &key) const;\n    ```\n\n19. `remove()`和`removeIf()`\n\n    - 第二个重载版本，根据传入的谓词进行删除\n\n    ```cpp\n    QMap<Key, T>::size_type remove(const Key &key);\n    QMap<Key, T>::size_type removeIf(Predicate pred);\n    ```\n\n20. `size()`：返回大小，略\n\n21. `swap()`：与另一个`map`对象进行交换，略\n\n22. `take()`：删除指定`key`对应的元素并返回对应的`data`\n\n    - 如果`key`不存在，那么返回默认的`data`\n\n    ```cpp\n    T take(const Key &key);\n    ```\n\n23. `toStdMap()`：导出为`std::map`，略\n\n    ```cpp\n    T value(const Key &key, const T &defaultValue = T()) const;\n    ```\n\n24. `operator=()`：拷贝和移动赋值函数\n\n    ```cpp\n    QMap<Key, T>& operator=(const QMap<Key, T> &other);\n    QMap<Key, T>& operator=(QMap<Key, T> &&other);\n    ```\n\n25. `operator[]()`：中括号`[]`运算符重载\n\n    - 个人认为第二个返回值的版本没有意义，这两个在实际接受的时候没有办法进行合理区分，建议改为`const T&`\n\n    ```cpp\n    T& operator[](const Key &key);\n    T operator[](const Key &key) const;\n    ```\n\n26. `key_iterator`\n\n    - `Qt`提供了一个专门用于遍历`key`的迭代器\n    - 个人认为完全没有必要，提供最普通的迭代器返回一个`pair`就完事了\n\n    ```cpp\n    QMap<Key, T>::key_iterator keyBegin() const;\n    QMap<Key, T>::key_iterator keyEnd() const;\n    ```\n\n27. `key_value_iterator`\n\n    - 经查询，`Qt`提供了一个`STL Style`的迭代器\n\n    ```cpp\n    QMap<Key, T>::key_value_iterator keyValueBegin();\n    QMap<Key, T>::const_key_value_iterator keyValueBegin() const;\n    QMap<Key, T>::key_value_iterator keyValueEnd();\n    QMap<Key, T>::const_key_value_iterator keyValueEnd() const;\n    QMap<Key, T>::const_key_value_iterator constKeyValueBegin() const;\n    QMap<Key, T>::const_key_value_iterator constKeyValueEnd() const;\n    ```\n\n28. 各种迭代器总结\n\n    - `iterator`：迭代器，解引用返回的是`data`，即`T`\n    - `const_iterator`：`iterator`的常量版本\n    - `key_value_iterator`：解引用返回的是`pair<key，T>`\n    - `key_iterator`：解引用返回的是`key`\n\n29. `asKeyValueRange()`\n\n    - 这个接口是在`Qt6.4`以后引入的，个人认为用不上\n    - 他让`for each`可以使用一个`pair`去接受，我觉得不如使用迭代器\n\n    ```cpp\n    QMap<QString, int> map;\n    map.insert(\"January\", 1);\n    map.insert(\"February\", 2);\n    // ...\n    map.insert(\"December\", 12);\n    \n    for (auto [key, value] : map.asKeyValueRange()) {\n        cout << qPrintable(key) << \": \" << value << endl;\n        --value; // convert to JS month indexing\n    }\n    ```\n\n## QMultiMap\n\n绝大部分接口和`Map`类似，下面只列出不同的几处。\n\n1. 构造函数\n\n   - 除了最基本的，`Qt6.0`以后可以支持从`QMap`构造成为`QMultiMap`\n\n   ```cpp\n   QMultiMap(const QMap<Key, T> &other);\n   QMultiMap(QMap<Key, T> &&other);\n   ```\n\n2. `map`中大部分传入`key`做查询，包含等操作的接口，在`multimap`中可以传入`key`和`value`\n\n   - 例如：`find()`、`constFind()`、`contains()`、`count()`、`remove()`\n\n   ```cpp\n   QMultiMap<Key, T>::const_iterator find(const Key &key, const T &value) const;\n   QMultiMap<Key, T>::const_iterator constFind(const Key &key, const T &value) const;\n   bool contains(const Key &key, const T &value) const;\n   QMultiMap<Key, T>::size_type count(const Key &key, const T &value) const;\n   QMultiMap<Key, T>::size_type remove(const Key &key, const T &value);\n   ```\n\n3. `replace()`\n\n   - 如果`multimap`中没有元素的`key`和传入`key`相同，则执行插入操作\n   - 如果有一个元素匹配，则将传入的`value`替换原元素的`value`\n   - 如果有多个元素匹配，则替换最后插入的那个元素\n\n   ```cpp\n   QMultiMap<Key, T>::iterator QMultiMap::replace(const Key &key, const T &value);\n   ```\n\n4. `uniqueKeys()`\n\n   - 返回所有的去重版本的`keys()`\n\n   ```cpp\n   QList<Key> QMultiMap::uniqueKeys() const;\n   ```\n\n5. `unite()`\n\n   - 将两个`multimap`合并，重复的元素保留不做处理，也就是新`multimap`的大小等于原两个`multimap`的大小之和\n   - 第二个移动构造的重载版本，个人认为没有必要\n\n   ```cpp\n   QMultiMap<Key, T> &QMultiMap::unite(const QMultiMap<Key, T> &other);\n   QMultiMap<Key, T> &QMultiMap::unite(QMultiMap<Key, T> &&other)\n   ```\n\n## QHash\n\n大部分接口和`QMap`是大同小异的，但是由于底层实现不同，`QHash`是哈希表，`QMap`是红黑树，因此细节上可能会有一些小区别，在下面会列出。\n\n1. `capacity()`：返回哈希桶的数量\n\n   - 在哈希表数组加链表的实现思路中，数组称为哈希桶，数组的长度称之为哈希桶的数量，每个数组下会接有链表，如果链表较长，代表`hashCode`取模以后相同，就会引发哈希冲突，查询效率就会退化，这是不可接受的。因此在下面会有`load_factor`负载因子的概念，负载因子需要保持在某个合理的范围才能够接受。当然实际的哈希表还有更多的细节\n\n   ```cpp\n   qsizetype capacity() const;\n   ```\n\n2. `load_factor()`：返回负载因子的值，即`size() / capacity()`\n\n   ```cpp\n   float load_factor() const;\n   ```\n\n3. `reserve()`：手动重新申请指定大小的内存空间\n\n   - 如果申请的空间比当前`size()`更大，那么相当于预申请了一块内存，后续就可以减少扩容的次数\n   - 如果申请的空间比当前`size()`更小，那么会申请能满足当前`size()`的最小的`capacity()`\n\n   ```cpp\n   void reserve(qsizetype size);\n   ```\n\n4. `squeeze()`：在保持性能的前提下尽量缩减哈希表的内存，减少哈希桶的数量\n\n   - 利用`reserve()`函数即可，重新申请特定大小的内存空间，并在当前存储数据的基础上尽量达到需求，也就是调用`reserve(0)`即可\n\n   ```cpp\n   void squeeze();\n   ```\n\n5. `emplace()`：当`data`是结构体，需要构造的情况下，通过传递右值引用，进行在位构造，减少一次拷贝的过程\n\n   ```cpp\n   QHash<Key, T>::iterator\templace(const Key &key, Args &&... args);\n   QHash<Key, T>::iterator\templace(Key &&key, Args &&... args);\n   ```\n\n## QMultiHash\n\n暂时不关心。\n\n## QSet\n\n在底层实现中，`unordered_map`中的索引和元素的值分别对应`Key`和`Data`，而`value_type`对应的`std::pair<const Key, Data>`，然后在哈希表中需要用到这个`Key`和`value_type`。这一点要分清，而在`unordered_set`中，`Key`和`value_type`都是输入的元素类型`T`，即`key means value`。这一点在以红黑树为基础的`map`和`set`中是一样的，具体实现当然有更多的细节。\n\n比较两个`unordered_set`是否相等，准确来讲是比较底层的哈希表两个对象是否相等，是去看存储的元素序列是否相等，与哈希表自身的结构无关，也就是两个哈希表的容量`capacity`不同的情况下，他们元素序列是一样的，他们就是相等的（当然，必须是模板实例化后相同的类才能作比较），这一点`std::unordered_set`已经做好了。\n\n1. `contains()`：多了一个重载版本，判断当前的集合是否包含另一个集合\n\n   ```cpp\n   bool contains(const T &value) const;\n   bool contains(const QSet<T> &other) const;\n   ```\n\n2. `intersect()`：求两个集合的交集\n\n   - 对应有重载`&=`运算符，可以考虑`&`运算符\n\n   ```cpp\n   QSet<T>& intersect(const QSet<T> &other);\n   bool intersects(const QSet<T> &other) const;\n   QSet<T>& operator&=(const QSet<T> &other);\n   QSet<T>& operator&=(const T &value);\n   ```\n\n3. `subtract()`：求两个集合的差集\n\n   - 对应有重载`-=`运算符，可以考虑`-`运算符\n\n   ```cpp\n   QSet<T>& subtract(const QSet<T> &other);\n   ```\n\n4. `unite()`：求两个集合的并集\n\n   - 对应有重载`+=`和`|=`运算符，可以考虑`+`和`|`运算符\n\n   ```cpp\n   QSet<T>& unite(const QSet<T> &other);\n   ```\n\n5. 重载`<<`运算符，等价于`insert()`操作\n\n   - 返回自身引用，满足链式调用关系\n\n   ```cpp\n   QSet<T>& operator<<(const T &value);\n   ```\n\n# 后续\n\n后面的工作内容大多数都是以课题研究的性质为主，相关文章[请点击这里跳转](/categories/实习/合迅科技/课题研究/)，不单独在此处赘述了。\n\n","categories":["实习","合迅科技","工作日志"]},{"title":"毛概 易混淆知识点和大题总结","url":"/posts/534a5aee.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 易混淆知识点\n\n1. 一些记忆的点\n\n   - 三大法宝：**统一战线、武装斗争、党的建设**\n     - 党的建设：**思想建设，组织建设，作风建设**\n       - **思想建设**：放在党的各项建设的**首位**，不仅组织上入党，更要思想上入党\n         - 但是从`19大`开始，**政治建设排在首位**了\n       - 组织建设：建设**民主集中制的根本组织原则和领导制度**\n\n   - 三大作风（**区别于其他政党的显著标志**）：**理论联系实际，紧密联系人民群众，批评与自我批评**\n     - 其中区别的**根本标志**：**群众路线**，或者密切联系群众\n\n   - 两个务必：务必继续保持**谦虚、谨慎、不骄、不傲**的作风；务必继续保持**艰苦奋斗**的作风\n\n<!-- more -->\n\n2. **邓小平**关于**发展社会主义**\n\n   - **改革是直接动力**\n\n   - **科学技术是第一生产力（邓小平提出）**\n\n   - **创新是第一动力（党的十八大提出）**\n\n3. 我国社会主义现代化建设的**三个支点**：**改革、发展、稳定**\n\n   - 改革是**动力**，发展是**关键**，稳定是**前提**\n\n4. 邓小平反复强调\n\n   - **四项基本原则**（`1979年`提出）\n     - 坚持**中国共产党的领导**\n     - 坚持**社会主义道路**\n     - 坚持**人民民主专政**\n     - 坚持**马克思列宁主义，毛泽东思想**\n\n   - **两条根本原则**（`1985年`提出）\n     - **以社会主义公有制经济为主体**\n     - **共同富裕**\n\n5. 改革开放是决定当代中国命运的**关键抉择**，是当代中国发展进步的**活力之源**，是我们党和人民大踏步赶上时代的**重要法宝**，是坚持和发展中国特色社会主义、实现中华民族伟大复兴的**必由之路**\n\n6. **实现祖国的完全统一**，是海内外中华儿女的**共同心愿**，是中华民族的**根本利益**，是中国共产党和中国人民不可动摇的**坚强意志**\n\n7. 两个解放思想、实事求是的**宣言书**\n\n   - `1978年12月`邓小平在**中央工作会议**上作的**《解放思想，实事求是，团结一致向前看》**的重要讲话\n\n   - `1992年`邓小平发表的**南方谈话**\n\n8. 关于中国革命\n\n   - **基本问题：农民问题**\n   - **首要问题：分清敌友**\n   - **根本问题：国家政权问题**\n   - **中心（核心）问题：领导权问题**\n   - **中心内容：没收地主阶级的土地归农民所有**\n\n9. 关于**精髓**的总结\n\n   - 马克思主义：**解放思想，实事求是，与时俱进**\n   - 马克思主义中国化理论成果：**实事求是**\n   - 毛泽东思想**只有活的灵魂（实事求是，群众路线，独立自主）**，**没有精髓**\n   - 邓小平理论：**解放思想，实事求是**\n   - \"三个代表\"重要思想：**解放思想，实事求是，与时俱进**\n   - 科学发展观：**解放思想，实事求是，与时俱进，求真务实**\n\n10. 两个**科学指南**\n\n    - **中国革命和建设**的科学指南：**毛泽东思想**\n    - **改革开放和社会主义现代化建设**的科学指南：**邓小平理论**\n\n11. 三大改造中的步骤\n\n    |                | 社会主义萌芽阶段       | 半社会主义性质                 | 社会主义性质                 |\n    | -------------- | ---------------------- | ------------------------------ | ---------------------------- |\n    | 农业           | 互助组                 | 初级农业生产合作社             | 高级社                       |\n    | 手工业         | 供销小组               | 供销合作社                     | 生产合作社                   |\n    | 资本主义工商业 | 初级形式的国家资本主义 | （高级形式）个别行业的公私合营 | （高级形式）全行业的公私合营 |\n\n12. 党的各大时间（重要的记，其他的有印象）\n\n    - **中共一大：1921**\n    - **中共二大：1922**\n    - **中共三大：1923**\n    - 中共四大：1925\n    - 中共五大：1927\n    - 中共六大：1928\n    - **中共七大：1945**\n    - **中共八大：1956**\n    - 中共九大：1969\n    - 中共十大：1973\n    - 中共十一大：1977\n    - **中共十二大：1982**\n    - **中共十三大：1987**\n    - 中共十四大：1992\n    - **中共十五大：1997**\n    - **中共十六大：2002**\n    - **中共十七大：2007**\n    - 中共十八大：2012\n    - **中共十九大：2017**\n    - **中共二十大：2022**\n\n13. 党执政兴国的\n\n    - **第一要务：发展**\n    - **最大底气：人民**\n    - **党克敌制胜、执政兴国的重要法宝：统一战线**\n\n14. 马克思主义**最重要的理论品质**\n\n    - **坚持一切从实际出发，理论联系实际，实事求是，在实践中检验和发展真理**\n    - 这种品质是**与时俱进**的（选择题遇到**不能选实事求是，选与时俱进**!!!）\n\n15. **社会主义**的**本质**：**解放和发展生产力，消除剥削，消除两极分化，最终达到共同富裕**\n\n16. 社会主义的**根本任务**：**解放和发展生产力**\n\n17. 社会主义的**根本目的**：**消灭剥削、消除两极分化、最终达到共同富裕**\n\n18. 社会主义的**根本原则**（联系两条根本原则）：**坚持公有制为主体，实现共同富裕**\n\n19. **社会主义民主政治**的本质和核心：**人民当家作主**\n\n    - 建设社会主义政治文明，根本需要坚持**党的领导、人民当家作主、依法治国**的有机统一\n      - **党的领导**是人民当家作主、依法治国的**根本保证**\n      - **人民当家作主**是社会主义民主政治的**本质要求**\n      - **依法治国**是党领导人民治理国家的**基本方略**\n    - 党在社会主义民主**形式方面**的伟大创造：**社会主义协商民主**\n\n20. **中国特色社会主义社会**的**本质属性**：**社会和谐**\n\n21. 四个**历史时期**\n\n    - **新民主主义革命**时期：`1921年7月` 建党 到 `1949年10月1日` 中华人民共和国成立\n    - **社会主义革命和建设**时期：新中国成立 到 `1978年12月` 十一届三中全会\n    - **改革开放和社会主义现代化建设**新时期（简称**新时期**）：十一届三中全会 到 `2012年` 党的十八大\n    - **中国特色社会主义新时代**：**党的十八大** 至今\n\n22. **近代**中国的**主要矛盾**\n\n    - **新民主主义革命**时期：**帝国主义和中华民族（近代中国最主要的矛盾），封建主义和人民大众的矛盾**\n\n    - **过渡**时期（**社会主义革命**时期）：**工人阶级与资产阶级**\n\n    - **社会主义**建设时期（`1956年`到`1978年`）\n      - **人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾**\n      - **人民对于建立先进的工业国的需求同落后的农业国的现实的矛盾**\n\n    - **改革开放和社会主义现代化建设新时期**：**人民日益增长的物质文化需要同落后的社会生产之间的矛盾**\n    - **中国特色社会主义新时代**：**人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾**\n\n23. 关于**一国两制**\n\n    - **提出是从解决台湾问题开始的**；台湾问题是国内战争遗留的问题，属于中国的**内政**\n    - **首先用于解决香港问题和澳门问题**\n      - **香港问题：中国和英国**\n      - **澳门问题：中国和葡萄牙**\n\n24. （**\"三个代表\"**）我们党必须解决好的两个**历史大课题**\n\n    - **党的领导水平和执政能力**\n    - **拒腐防变和抵御风险的能力**\n\n25. **坚持党的领导**，**关键（核心）**在于坚持党的**先进性**，**本质**在于**执政为民**\n\n# 大题\n\n## 导论\n\n1. 马克思主义中国化的**科学内涵**\n   - 把**马克思主义基本原理**同**中国实际**相结合，同**中华优秀传统文化**相结合\n   - 运用马克思主义的**立场、观点和方法**研究和解决**中国革命、建设、改革**中的实际问题\n   - 总结和提炼中国革命、建设、改革的**实践经验**，从而**认识和掌握客观规律**，为马克思主义中国理论成果**增加新的内容**\n   - 运用**民族语言**阐述马克思主义理论，使其具有**鲜明的中国特色**\n   - 马克思主义中国化是马克思主义**发展**的**内在要求**，是中国国情和实践的需要\n\n## 毛泽东思想\n\n1. 毛泽东思想形成和发展的**历史条件**\n   - 总的来讲：**近代中国的特殊国情**和**中国革命的特殊性**\n   - 时代条件和主题：**帝国主义战争**和**无产阶级革命**\n   - 理论基础：`19世纪中叶`，马克思、恩格斯提出唯物史观剩余价值学说，创立了科学社会主义，奠定了理论基础\n   - 国际背景：`1917年`俄国十月革命胜利，开辟了世界无产阶级革命的新时代，给中国送来了马克思主义\n   - 国内实践基础\n     - 中国**工人阶级的发展**，工人运动队伍的壮大\n     - 党领导人民进行**革命**和**建设**的实践\n2. 毛泽东思想的**主要内容、活的灵魂**\n   - 主要内容\n     - **新民主主义革命理论**\n     - **社会主义革命和社会主义建设理论**\n     - **革命军队建设和军事战略的理论**\n     - **政策和策略的理论**\n     - **思想政治工作和文化工作的理论**\n     - **党的建设理论**\n   - 活的灵魂：**实事求是、群众路线、独立自主**\n3. 什么是实事求是？怎样坚持实事求是？（`考过`）\n   - 实事求是：**一切从实际出发，理论联系实际，实事求是，坚持在实践中检验和发展真理**\n   - 怎样坚持\n     - 深入了解事物的**本来面貌**，把握**事物内在必然联系**\n     - 清醒认识和正确把握我国的**基本国情**，牢牢立足于基本国际这个最大实际\n     - 不断在**实践基础上进行理论创新**，这是**社会发展和变革的先导**\n4. 毛泽东思想的**历史地位**\n   - 马克思主义中国化**第一个**重大理论成果\n   - 中国**革命**和**建设**的**科学指南**\n   - 中国共产党和中国人民的**宝贵精神财富**\n\n## 新民主主义革命理论\n\n1. 新民主主义革命总路线的主要内容、首要对象、动力、实质、领导权、性质、前途等？\n\n   - 主要内容：`1948年`毛泽东在《**晋绥干部会议上的讲话**》完整表述，即**无产阶级领导的、人民大众的、反对帝国主义、封建主义和官僚资本主义的资产阶级民主革命**\n   - 首要对象：帝国主义\n   - 动力\n     - 无产阶级（最基本的动力，领导阶级）\n     - 农民（主力军，其中贫雇农是最可靠的同盟者，中农是可靠的同盟者）\n     - 城市小资产阶级（可靠的同盟者）\n     - 民族资产阶级（动力之一）\n   - 领导权：无产阶级及其先锋队，中国共产党\n   - 实质：**无产阶级领导下的农民革命**\n   - 性质：资产阶级民主革命\n   - 前途：社会主义\n\n2. 无产阶级的特点\n\n   - 与**先进的生产方式**相联系\n   - 富于**组织纪律性**\n   - 受到**三座大山的压迫**\n   - **分布集中**\n   - 与**农民有天然的联系**\n\n3. 对比**新旧民主主义革命**\n\n   - 相同点\n\n     - 社会背景：都发生在半殖民地半封建社会，主要矛盾都是帝国主义与中华民族、封建主义与人民大众的矛盾\n     - 革命任务：反对帝国主义和封建主义\n     - 革命性质：资产阶级民主主义革命\n\n   - 不同点\n\n     |                | 旧民主主义革命                                 | 新民主主义革命                       |\n     | -------------- | ---------------------------------------------- | ------------------------------------ |\n     | 领导力量       | 资产阶级                                       | 无产阶级                             |\n     | 指导力量       | 西方的资产阶级民主主义（平等、自由、民主共和） | 马克思列宁主义                       |\n     | 革命前途       | 资产阶级民主共和国                             | 社会主义                             |\n     | 发展与群众发动 | 纲领不彻底、群众发动不充分、土地问题未解决     | 纲领彻底、群众发动充分、土地问题解决 |\n     | 结果           | 失败                                           | 成功                                 |\n     | 所属革命范畴   | 世界资产阶级革命的一部分                       | 世界无产阶级革命的一部分             |\n\n   - 区分的**根本标志**：**革命领导权掌握在谁手中**\n\n4. 比较**新民主主义革命和社会主义革命**\n\n   - 相同点（那太多了，自己随便写几点就好了）\n   - 不同点\n     - 新民主主义革命仍然属于**资产阶级民主革命的性质范畴**\n       - 政治上争取和联合民族资产阶级反对共同的敌人\n       - 经济上保护民族工商业\n       - 建立**无产阶级领导的各革命阶级的联合专政**，而不是无产阶级专政\n     - 社会主义革命是**无产阶级性质**的革命，目标是**消灭资本主义剥削制度和改造小生产的所有制**\n   - 联系\n     - **互相联系、紧密衔接**的，是上篇与下篇的关系，**中间不允许插入资产阶级专政**\n     - 新民主主义革命是社会主义革命的**必要准备**，社会主义革命是新民主主义革命的**必然结果**\n\n5. 新民主主义革命的**基本纲领**\n\n   - **政治**纲领：推翻**帝国主义和封建主义**的统治，建立一个**无产阶级领导**的、以**工农联盟为基础**的、**各革命阶级联合专政**的新民主主义共和国\n   - **经济**纲领：**两没收、一保护**\n     - 没收封建地主阶级的**土地归农民**（**主要内容**）\n     - 没收官僚资产阶级的**垄断资本归国家**（**应有之义**，是**国营经济建立的主要途径**）\n     - 保护**民族工商业**（**最具特色**的）\n   - **文化**纲领：**无产阶级领导**的**人民大众**的**反帝反封建**的文化，即**民族的、科学的、大众的**文化\n\n6. 中国走农村包围城市、武装夺取政权的**现实可能性**\n\n   - **根本原因，最重要的客观条件**：近代中国是一个**政治、经济、文化发展不平衡的半殖民地半封建**的大国\n   - **群众基础，客观条件**：红色政权的地方往往是大革命群众运动高涨的地方，群众受尽压迫、剥削，**革命愿望强烈**\n   - **重要的客观条件**：**全国革命形势向前推进**\n   - **主观条件**：相当力量的正式**红军**存在（**必要**主观），以及**党的正确领导**（**重要**主观）\n\n7. 中国革命走**农村包围城市、武装夺取政权**的道路根本处理好哪几方面的问题？\n\n   - **土地革命、武装斗争、农村革命根据地建设**三者的问题\n   - 土地革命：是中国革命的**基本内容**\n   - 武装斗争：是中国革命的**主要形式**，是农民革命根据地建设和土地革命的**强有力保证**\n   - 农民革命根据地建设：是中国革命的**战略阵地**，是进行武装斗争和土地革命的**依托**\n\n8. 新民主主义革命的**三大法宝**及其关系\n\n   - 三大法宝：**统一战线、武装斗争、党的建设**\n   - 关系\n     - **统一战线和武装斗争**是中国革命的**基本特点和基本武器**\n     - **统一战线**是实行武装斗争的**统一战线**，**武装斗争**是统一战线的**中心支柱**，**党的组织**是掌握两个基本武器冲锋陷阵的**英勇战士**\n\n## 社会主义改造理论\n\n1. **为什么**说新民主主义社会是一个过渡性的社会？\n   - 从**社会的性质、阶级构成、主要矛盾、经济成分**等考虑\n   - 社会性质：新民主主义社会是一个**过渡性质**的社会，**不是一个独立的社会形态**\n   - 阶级构成：**工人阶级、农民阶级、其他小资产阶级、民族资产阶级**等\n   - 主要矛盾：**工人阶级**和**资产阶级**的矛盾\n   - 经济成分\n     - 五种成分\n       - **社会主义性质的国营经济**\n       - **半社会主义性质的合作社经济**（**个体经济向集体经济的过渡形式**）\n       - **农业和手工业者的个体经济**\n       - **私有资本主义经济**\n       - **国家资本主义经济**（**私人资本主义向社会主义国营经济的过渡形式**）\n     - 三种性质：**社会主义经济、个体经济、资本主义经济**\n2. 党在过渡时期总路线的**主要内容**及其基本关系\n   - 主要内容：**一化三改造**\n     - `1953年`形成完整表述\n     - 从中华人民共和国成立，到社会主义改造的基本完成，党在这个过渡时期的总路线和总任务是要**在一个相当长的时期内**，逐步实现国家的社会主义工业化，逐步实现国家对农业、手工业和资本主义工商业的社会主义改造\n   - 关系\n     - **一化是主体，三改是两翼**，两者**相辅相成、相互促进**\n     - 这是社会主义**建设和改造同时并举**的路线，体现了社会主义工业化和改造的紧密结合，体现了解放生产力与发展生产力、变革生产关系与发展生产力的**有机统一**\n3. 社会主义改造的**历史经验**是什么？存在什么**问题**？\n   - 经验\n     - **坚持社会主义工业化建设和社会主义改造同时并举**\n     - 采取**积极引导、逐步过渡**的方式\n     - 用**和平方法**进行改造\n   - 问题：个体商业的改造**要求过急、工作过粗、改变过快、形式过于简单**，以至于在长期内遗留了问题\n4. 社会主义基本制度的确立的**重大意义**\n   - 是中国历史上**最深刻最伟大的社会变革**，为中国特色社会主义制度的创新和发展提供了**重要前提**\n   - 极大地提高了工人阶级和广大劳动人民的**积极性、创造性**，极大地促进了我国社会**生产力的发展**\n   - 是**世界社会主义**发展史上有一个**历史性的伟大胜利**，**增强**了社会主义的**力量**，对**维护世界和平**产生了积极影响\n   - 是**马克思列宁主义关于社会主义革命理论**在中国的**正确运用和创造性发展**的结果\n\n## 社会主义建设道路初步探索的理论成果\n\n1. 党在社会主义建设道路初期探索中取得了哪些重要的**理论成果**？\n   - **调动一切有利因素为社会主义事业服务**\n   - **正确认识和处理社会主义社会矛盾**\n   - **走工业化道路**\n2. **如何**调用一切积极因素为社会主义事业服务？\n   - 坚持**中国共产党的领导**\n   - 发展**社会主义民主政治**\n   - 有一个**如何认识社会主义发展阶段和社会主义建设规律**的问题 \n3. 处理人民内部矛盾的**方针**\n   - 总方针：**民主方法说服教育**\n   - **政治思想领域：团结、批评、团结**\n   - **物质利益、分配方面：统筹兼顾、适当安排**\n   - **人民群众和政府机关：民主集中制原则**\n   - **科学文化：百花齐放、百家争鸣**\n   - **共产党和民主党派：长期共存、互相监督**\n   - **民族：民族平等、团结互助**\n4. 如何认识党在社会主义建设道路初步探索的**意义**?(与社会主义基本制度的确定联系记忆)\n\n   * **巩固和发展**了我国的社会主义制度\n   * 为开创**中国特色社会主义**提供了**宝贵经验、理论准备和物质基础**\n   * 丰富了**科学社会主义**的**理论和实践**\n\n## 邓小平理论\n\n1. 邓小平理论形成的**历史条件**\n   - **时代背景**：**和平与发展**是世界主题\n   - **历史依据**：**社会主义建设的经验教训**\n     - （补充）教训的部分：经济上急于求成、盲目求纯、急于过渡；政治上以阶级斗争为纲\n   - **现实依据**：**改革开放和社会主义现代化建设的实践**\n2. 社会主义的本质是什么？意义是什么？\n   - 本质：**解放和发展生产力，消除剥削，消除两极分化，最终实现共同富裕**\n   - 意义\n     - **立国之本，是我国一切进步和发展的基础**\n     - **为我们坚持，完善和发展公有制指明方向**\n     - 邓小平：两条根本原则，一条是以社会主义公有制经济为主体，另一条是共同富裕\n3. 解放思想，实事求是思想路线的**意义**\n   - 推动了**改革开放的进行**\n   - **体现了辩证唯物主义和历史唯物主义的根本的世界观和方法论**\n   - 体现了**革命胆略**和**科学精神**的统一\n   - 是邓小平理论的**精髓**和**活的灵魂**\n4. 邓小平理论的**主要内容**\n   * **社会主义初级阶段理论**\n   * **社会主义初级阶段基本路线**\n   * **社会主义根本任务的理论**\n   * **\"三步走\"战略**\n   * **改革开放理论**\n   * **社会主义市场经济理论**\n   * **“两手都要抓，两手都要硬”**（**物质**文明和**精神**文明）\n   * **\"一国两制\"和祖国统一**\n   * **中国特色社会主义外交和国际战略**\n   * **党的建设理论**\n5. 阐述社会主义初级阶段基本路线及其内涵\n   - **党的十三大**阐述了社会主义初级阶段基本路线\n   - **领导和团结全国各族人民，以经济建设为中心，坚持四项基本原则，坚持改革开放，自力更生、艰苦创业，为把我国建设成富强、民主、文明的社会主义现代化国家奋斗**\n   - 内涵\n     - 领导和团结全国各族人民：实现目标的**领导力量和依靠力量**\n     - 以经济建设为中心，坚持四项基本原则，坚持改革开放：**简称一个中心、两个基本点，最主要的内容；其中一个中心是关键**\n     - 自力更生、艰苦创业：**根本立足点**\n     - 为把我国建设成富强、民主、文明的社会主义现代化国家奋斗：**奋斗目标**\n6. 社会主义**市场经济理论**的要点\n   - 计划经济和市场经济**不是划分社会制度**的标志，计划经济不等于社会主义，市场经济也不等于资本主义\n   - 计划和市场都是**经济手段**，对经济活动的调节**各有优势和长处**，社会主义实行市场经济，要把两者**结合**起来\n   - **市场经济作为资源配置的一种方式本身不具有制度属性**，可以和不同的社会制度结合，从而表现出不同的性质；**坚持社会主义制度与市场经济的结合**，是社会主义市场经济的**特色所在、优势所在**\n7. **和平统一、一国两制**的主要内容和意义（`考过`）\n   * 主要内容：\n     * 核心：**坚持一个中国**\n     * 两制并存，在祖国统一的前提下，国家的**主体部分实行社会主义制度**，同时**在台湾、香港、澳门保持原有的社会制度和生活方式长期不变，高度自治**\n   * 意义：\n     * 一国两制是邓小平运用辩证唯物主义和历史唯物主义解决一个国家的统一问题\n     * 既体现了坚持祖国统一、维护国家主权的原则性，又体现了照顾历史实际和现实可能的灵活性\n     * 是对马克思主义国家学说的创造性发展\n     * 为解决国际争端提供新思路\n8. 邓小平理论的**历史地位**\n   - 马克思列宁主义、毛泽东思想的**继承和发展**\n   - **中国特色社会主义理论体系**的**开篇之作**\n   - **改革开放和社会主义现代化建设**的**科学指南**\n\n## \"三个代表\"重要思想\n\n1. \"三个代表\"重要思想的**形成条件**\n   - **世界背景：冷战结束后对世界局势科学判断**\n   - **党内背景：科学判断党的历史方位和总结历史经验**\n   - **国内背景：建设中国特色社会主义伟大实践的基础**\n2. \"三个代表\"重要思想的**核心观点**或集中概括\n   - 始终代表中国**先进生产力的发展要求**\n   - 始终代表中国**先进文化的前进方向**\n   - 始终代表中国**最广大人民的根本利益**\n3. \"三个代表\"重要思想的**主要内容**\n   - **发展是党执政兴国的第一要务**\n   - **建设社会主义市场经济体制**\n   - **全面建成小康社会**\n   - **建设社会主义政治文明**\n   - **推进党的建设的伟大工程**\n4. \"三个代表\"重要思想的**历史地位**\n   - 中国特色社会主义体系的**持续发展**，是我们党**立党之本、执政之基、力量之源**\n   - 加强和改进**党的建设、推进中国特色社会主义事业**的**强大理论武器**\n\n## 科学发展观\n\n1. 科学发展观的**形成条件**\n   - **现实依据**：**社会主义初级阶段的基本国情，新阶段新特征**\n     - **根本**依据：社会主义基本阶段的基本国情\n     - 新阶段新特征是指**发展关键期、改革攻坚期、矛盾凸显期**\n   - **实践基础**：**改革开放以来，特别是十六大以来的实践经验**\n   - **时代背景**：**当代世界发展大势、国外发展的经验教训**\n2. 科学发展观的**科学内涵**，**精神实质**\n   - **科学内涵：第一要义是发展，核心立场是以人为本，基本要求是全面协调可持续，根本方法是统筹兼顾**\n   - **精神实质（精髓，活的灵魂）：解放思想，实事求是，与时俱进，求真务实**\n3. 如何坚持**以人为本**？（`考过`）\n   - 坚持发展为了人民，始终**把最广大人民的根本利益放在第一位**\n   - 坚持发展依靠人民，**从人民群众的伟大创造中汲取智慧和力量**\n   - 坚持**发展成果由人民共享**，着力提高人民**物质文化生活水平**，实现人民的**全面发展**\n4. 科学发展观的**主要内容**\n   - **加快转变经济发展方式**\n   - **发展社会主义民主政治**\n   - **推进社会主义文化强国建设**\n   - **构建社会主义和谐社会**\n   - **推进生态文明建设**\n   - **全面提高党的建设的科学化水平**\n5. 科学发展观的**历史地位**和指导意义\n   - 中国特色社会主义理论体系的**持续和发展**\n   - **全面建成小康社会，加快推进社会主义现代化建设的根本指针**\n   - 发展中国特色社会主义必须坚持的**指导思想**\n\n","categories":["校内课程","毛概"]},{"title":"马原 易混淆知识点和大题总结","url":"/posts/4d3414b8.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 易混淆知识点\n\n1. 社会主义从什么到现实\n\n   - 马克思主义两个最重要的发现，即**唯物史观和剩余价值学说**，使社会主义**从空想变为了现实（科学）**\n   - **十月革命**，使社会主义**从理论变为了现实**\n\n2. 马克思主义产生的**条件**\n\n   - **客观**条件（社会阶级基础）：**无产阶级作为独立的政治力量登上历史舞台**\n   - **主观**条件：**工业革命的深入推动资本主义的迅速发展**\n\n<!-- more -->\n\n3. 马克思主义的\n\n   - **基石：世界的物质统一性原理**\n   - **经济理论的基石：剩余价值理论**\n   - **活的灵魂：具体问题具体分析**（马原这边是这个，毛概那边是：解放思想、实事求是、与时俱进）\n   - **根本观点：实事求是**\n   - **基本特征：科学性、革命性（人民性、实践性、发展性）**\n   - **本质属性：人民性**\n   - **区别于其他政党的根本特征：实践性**\n   - **生命力在于创新**\n\n4. 马克思主义政党的**执政立场和理念**：**以人民为中心**\n\n5. 马克思主义**最重要的理论品质**\n\n   - 内容：**坚持一切从实际出发，理论联系实际，实事求是，在实践中检验和发展真理**\n   - 这种品质是**与时俱进**的（选择题遇到**不能选实事求是，选与时俱进**!!!）\n\n6. 一些错误的观点\n\n   - **夸大静止**，否定运动，**形而上学**；**夸大运动**，否定静止，**诡辩论**\n   - **只看运动**，不看物质，**唯心主义**；**只看物质**，不谈运动，**形而上学**\n   - 仅停留在**感性认识**，**经验主义**、经验论；仅停留在**理性认识**，**教条主义**、唯理论\n   - **夸大真理的绝对性**，否定相对性，认为**可以穷尽真理**，**教条主义**；**夸大真理的相对性**，否定绝对性，认为**真理主观随意**，**相对主义（表现为怀疑主义、诡辩论）**\n\n7. **列宁**关于物质概念的概述\n\n   - 物质是**标志客观存在**的哲学范畴，这种客观实在是**人通过感觉感知**的，它**不依赖于我们的感觉而存在**，为我们的感觉所**复写、摄影、反映**\n   - 列宁从**物质与意识**的关系上把握物质\n   - 物质的唯一特性：**客观实在性**\n   - 补充：恩格斯关于物质概念的提法\n     - 物、物质无非是各种物的总和，而这个概念就是**从这一总和中抽象**出来的\n     - 明确指出哲学物质概念和自然科学关于具体的物质形态和物质结构概念之间的**共性与个性**的关系\n\n8. 哲学派别总结\n\n   - 哲学：**理论化、系统化**的世界观和方法论\n\n     - **不是**所有的哲学**都是科学的**世界观和方法论（比如唯心主义），**马哲是科学的**\n\n   - 哲学的基本问题：**思维和存在**的问题\n\n   - 思维、存在**何为第一性**\n\n     - 存在在前（物质决定意识）：唯物主义\n       - 古典朴素唯物主义\n       - 近代形而上学（机械）唯物主义\n       - 辩证唯物主义\n     - 思维在前（意识决定物质）：唯心主义\n       - 客观唯心主义：上帝或者某种精神、意志\n       - 主观唯心主义：人的主观意志、精神、感觉\n\n   - 思维、存在**是否具有同一性**\n\n     - 具有：可知论（世界可知）\n       - 可知论：唯物主义、彻底的唯心主义（这两也是一元论）\n     - 不具有：不可知论（世界不可知，或思维只能认识现象而不能认识事物本质）\n       - 不可知论：不彻底的唯心主义（也是二元论：物质和意识都是本源）\n\n   - 总结图\n\n     <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231231105030314.png\" alt=\"image-20231231105030314\" style=\"zoom:78%;\" />\n\n9. 比较辩证（思辨与实证相统一）唯物主义和近代形而上学唯物主义\n\n   1. 如何看待问题\n\n      - 辩证唯物主义：**联系、发展、全面**看待问题\n      - 近代形而上学唯物主义：**孤立、静止、片面**看待问题\n\n   2. **根本分歧**和斗争焦点：**是否承认矛盾**\n\n      - 辩证唯物主义：认为矛盾普遍存在，是事物发展的动力和源泉\n\n      - 近代形而上学唯物主义：不承认矛盾，认为事物发展是因为**外部力量的推动**\n\n   3. 近代形而上学唯物主义的其他局限\n\n      - 把一切运动归结为机械运动，**看不到人类的主观能动性和实践的作用**\n\n      - **割裂了自然界和人类社会的物质同一性**，用孤立、静止、片面的观点看待问题，**不符合客观实际**，在**历史观上是唯心主义**\n\n   4. 扩展：马哲与其他哲学的联系和区别总结\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231231151534555.png\" alt=\"image-20231231151534555\" style=\"zoom:78%;\" />\n\n10. 意识：**人脑特殊的机能和属性**（**生理**属性），是对**客观物质的主观反映**（**社会**属性），因此是**客观内容和主观形式**的统一\n\n11. 在马克思恩格斯创立的理论体系中，被**列宁**称为**\"科学思想中的最大成果**\"的是：**马克思主义哲学**\n\n12. **社会历史发展**的动力\n\n      - **直接动力：阶级斗争**\n        - **社会主义发展**的**直接动力**：**改革**\n\n      - **根本动力：社会基本矛盾**\n        - `tips`：选择题关于社会基本矛盾的，不拆开就两个矛盾一起选，拆开了就优先选生产力与生产关系\n        - **生产力和生产关系的矛盾**是**最为根本**的矛盾\n        - **生产力**是**最基本**的动力因素，**社会发展的最终决定力量**（注意这个最终的意义）\n          - 社会发展的**决定力量**：也可以答**物质生产方式**（生产方式是生产力和生产关系的有机结合）\n          - **社会生产**：分为**物质生产和精神生产**，有区别的!!!\n\n      - **重要动力：革命、改革、科学技术**\n        - 马克思说\n          - **革命**是历史的**火车头**\n          - **科学技术**是历史的**有力的杠杆**，是**最高意义的革命力量**\n\n        - 关于科学技术的易错点\n          - 在**生产**发展中或者**生产**劳动中，科学技术**日益成为决定性因素**（这句话是正确的）\n          - 在**社会历史**发展中，科学技术永远**不是根本动力**，只是一个重要动力\n\n      - **社会发展和变革的先导：实践基础上的理论创新**\n\n13. **物质**的一些属性\n\n      - **根本（固有）属性：运动**\n\n      - **唯一属性：客观实在性**\n\n14. 量变引起质变\n\n     - **两种**方式\n       - 一种是事物**数量上的增减**会引起质变\n\n       - 一种是事物**内部结构排列次序的变化**也能引起质变\n\n     - 度：**事物保持自己的质的量的界限**（这个量的含义除了数量还可以包含结构之类的）\n\n15. 一些特性\n\n    - 联系：**客观、普遍、多样、条件性**\n\n    - 价值：**主体、客观、多维、社会历史性**\n\n16. 两个**本质**区分\n\n    - **世界在本质上是物质的**，是多样性的物质统一\n\n    - **社会生活在本质上是实践的**\n\n17. 关于**唯物辩证法**\n\n    - 地位：**唯物辩证法**是**认识世界和改造世界的根本方法**\n      - **最根本的世界观和方法论**：**辩证唯物主义和历史唯物主义**\n      - 认识世界和改造世界的**根本目标**：**认识必然和争取自由**\n\n    - **总观点和总特征：联系（联系特征：客观、普遍、多样、条件）和发展的观点**\n\n    - **实质和核心：对立统一规律**\n\n    - 唯物辩证法中的**根本的认识方法：矛盾分析法**\n\n    - 矛盾问题的**精髓**：**共性和个性**的关系、**绝对和相对**的关系\n\n    - 事物发展的**方向**：向**对立面**转化\n\n18. **唯物辩证法**的**五大范畴**，**联系与发展**的**五大环节**\n\n    - **原因与结果**\n\n    - **必然与偶然**\n\n    - **可能与现实**\n\n    - **现象与本质**\n\n    - **内容与形式**\n\n19. **辩证思维**主要方法\n\n    - **归纳与演绎**\n\n    - **分析与综合**\n\n    - **抽象到具体**\n\n    - **逻辑与历史相统一**\n\n20. 一些思维能力：**辨证**思维能力、**历史**思维能力、**系统**思维能力、**战略**思维能力、**底线**思维能力、**创新**思维能力\n\n21. 关于实践\n\n    - 基本结构：主体、客体、中介\n      - 主体与客体相互作用的关系：**实践关系（最根本）、认识关系、价值关系**\n      - 基本结构历史地变化发展，主要表现：**主体客体化与客体主体化的双向运动**\n\n    - 形式：**物质生产实践（最基本）、社会政治实践、科学文化实践**，现在还有一个虚拟实践\n\n22. 认识的本质两条路线\n\n    - 一切认识的**起点是感觉**，这是二者的**共同**观点\n\n    - **唯物主义反映论**\n      - 二者**都**承认：**认识是主体对客体的反映**\n      - 分为：**直观**反映论（旧唯物主义）、**能动**反映论（辩证唯物主义）\n        - 旧唯物主义以**感性直观**为基础，把人的认识看成**消极地、被动地**反映和接收外界对象，看不到人的主观能动性的实践作用，因此在历史观上是唯心的\n        - 辩证唯物主义认为认识的本质：**主体在实践基础上对客体的能动反映**\n      - **认识的唯一来源：实践**\n        - 感性认识来源于社会实践，理性认识**仍然来源于社会实践**（是感性认识经过加工后的结果）\n        - 二者的**根本区别**：**感性认识**反映事物的**表象**，**理性认识**反映事物的**本质**\n        - 直接经验和间接经验的关系：**源和流**的关系\n\n    - **唯心主义先验论**\n\n23. **商品经济**的基本规律：**价值**规律\n\n24. **资本主义生产方式**的绝对规律：**剩余价值**规律\n\n25. 社会形态\n\n    - 定义：同生产力发展一定阶段适应的**经济基础和上层建筑的统一体（二者缺一不可）**\n\n    - 特点：**全面的、具体的（不是抽象的）、历史的**\n\n    - 社会形态**更替**的特点\n      - **统一性和多样性**\n      - **更替的必然性和人民的历史选择性**\n      - **前进性和曲折性**\n\n26. 关于人民群众创造历史常见的正确和错误说法\n\n    | 命题                                             | 正误                                               |\n    | ------------------------------------------------ | -------------------------------------------------- |\n    | 人人参与历史                                     | 对                                                 |\n    | 人人创造历史                                     | 错（人民群众的性质是先进的，不包含起阻碍作用的人） |\n    | 人人创造自己的历史                               | 对                                                 |\n    | 历史人物创造历史                                 | 错（英雄史观）                                     |\n    | 勇敢者创造历史                                   | 对（习大大原话）                                   |\n    | 英雄和人民群众共同创造历史                       | 错（英雄是人民群众的一部分）                       |\n    | 人民群众的**总体意愿和行动代表了历史发展的方向** | 对                                                 |\n    | 人民群众的**社会实践最终决定历史发展的格局**     | 对                                                 |\n    | 人们有意识的活动可以改变历史发展的基本进程       | 错（可以加速或者减缓，不能改变）                   |\n\n27. 一切物质在本质上都具有类似的感觉的反映特性，这是**辩证唯物主义**的观点\n\n    - 题干没说全...，原话是：假定**一切物质**都具有在本质上跟感觉相近的特性、**反映**的特性，这是合乎逻辑的，这样就看得懂了\n\n28. **商品经济**产生的历史条件\n\n    - **社会分工**\n    - **生产资料和劳动产品**属于**不同的所有者**\n\n29. **资本主义生产关系**产生的途径\n\n    - **小商品经济**分化\n    - **商人和高利贷者**转化，通过不断**竞争**，导致**贫富两极分化**\n\n30. 马克思对资本家全部预付资本的**三种划分**\n\n      - **不变**资本（`c`），**可变**资本（`v`）：是否**增殖**（产生**剩余价值**）\n      - **固定**资本，**流通**资本：资本的**周转方式**（是否需要**源源补充**）\n      - **货币**资本（**购买**过程），**生产**资本（**生产**过程），**商品**资本（**售卖**过程）：在资本**循环**中**执行的不同职能**\n        - 三者在**空间上并存，时间上继起**\n\n31. 不同环境下竞争的结果\n\n      - **同一个行业内，不同企业**之间的竞争：形成**超额剩余价值**和**相对剩余价值**\n      - **不同行业**之间的竞争：形成**平均利润**\n\n32. **相对过剩人口**的三种形式：**流动、潜在、停滞**的过剩人口\n\n33. **商品经济**的基本矛盾：**私有劳动与社会劳动的矛盾**\n\n34. **资本主义经济**的基本矛盾：**生产社会化与生产资料私有制的矛盾**\n\n35. 资本主义**经济危机**的**本质特征**：**生产相对过剩**\n\n      - 不是绝对过剩，**是对人民消费能力的相对过剩，不是对人民生活正常需求的绝对过剩**\n      - 意思是生产的可能没超过人民生活正常需求的数量，但是人民就是买不起\n      - 经济危机的可能性是**由货币作为支付手段和流通手段**引起的\n\n36. 资本主义**国家职能**\n\n      - 对内：**政治统治，社会管理**\n      - 对外：**国际交往，维护国家安全及利益**\n\n# 大题\n\n## 导论\n\n1. 什么是马克思主义\n   * 马克思主义是关于**自然、社会、人类思维一般发展规律**的学说，具有明显的**阶级性**\n   * 是关于**社会主义必然替代资本主义，最终实现共产主义**的学说\n   * 是关于**无产阶级解放、全人类解放，每个人自由而全面发展**的学说\n   * 是无产阶级政党的**指导思想**\n2. 马克思主义的当代价值\n   - 观察当代**世界变化的认识工具**\n\n   - 指引当代**中国发展的行动指南**\n\n   - 引领**人类社会进步的科学真理**\n\n   - 人类社会仍需马克思主义指引\n\n3. 当代青年如何学习和运用马克思主义\n\n   * 学习和掌握马克思主义的**基本立场、基本观点和基本方法**\n   * 学习和掌握马克思主义**中国化时代化的理论成果**\n   * 坚持**理论联系实际**的作风\n   * 自觉将马克思主义**内化于心、外化于行**\n\n## 第一章\n\n1. **世界的物质统一性原理**阐述\n   * 内容：\n     * 世界**统一于物质**\n     * 物质统一性原理在于它的**物质性**，即世界统一的基础是物质\n     * 是**多样性**的统一\n   * **意识统一于物质**\n     * 意识是物质世界**长期发展的产物**，是物质世界的一种**特殊存在**\n     * 意识是人脑特殊的**机能和属性**，是**客观世界的主观反映**\n     * 意识的能动性发挥必须**以尊重物质世界客观规律为前提**\n   * **人类社会统一于物质**\n     * 人类社会是**物质世界的组成部分**\n     * 人类**获取生活资料的活动**是**物质性的活动**\n     * 人类社会**存在和发展的基础**是**物质资料的生产方式**\n2. 如何处理好**主观能动性和客观规律性**的辩证统一关系\n   - 地位：是正确认识和把握**物质与意识的辩证关系**的**前提**\n   - 两方面\n     - **尊重客观规律**是正确发挥主观能动性的**前提**\n     - 只有发挥主观能动性，才能**正确认识和利用客观规律性**\n\n   - 正确发挥人的主观能动性，三个**前提和条件**\n\n     - **从实际出发是前提**\n\n     - **实践是根本途径**\n\n     - 需要一定的**物质条件和手段**\n3. 马克思主义**唯物论（物质观）**的内涵和现实意义（`考过`）\n\n   - 马克思主义物质观集中体现在**列宁**的经典论述中，即\"**物质是标志着客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在，为我们的感觉所复写、摄影、反映**\"\n\n   - 四点意义\n     - 坚持了物质的**客观实在性**原则，坚持了唯物主义**一元论**，同唯心主义一元论和二元论划清了界限\n\n     - 坚持了**能动的反映论和可知论**，有力地批判了**不可知论**\n\n     - 体现了**唯物论和辩证法**的统一，克服了**形而上学**唯物主义的缺陷\n\n     - 体现了唯物主义**自然观**与唯物主义**历史观**的统一，为**彻底的唯物主义**奠定了理论基础\n4. 意识的**能动作用**（`考过`）\n\n   - 意识具有**目的性**和**计划性**\n\n   - 意识具有**创造性**\n\n   - 意识具有**指导实践改造世界**的作用\n\n   - 意识具有**调控人的行为和生理活动**的作用\n\n   - 意识不仅反映事物的现象，还反映事物的本质和规律\n5. 矛盾的**基本**属性：**同一性和斗争性**\n\n   - 同一性的**作用**\n     - **事物存在和发展的基本前提**\n     - 使事物双方各自**汲取有利因素**\n     - 规定事物**转化的可能和发展的趋势**\n   - 斗争性的**作用**\n     - 促使双方**力量变化**，为**对立面的转化、事物质变**创造条件\n     - 一种矛盾体向另一种矛盾体**过渡的决定性力量**，新的矛盾统一体诞生，**旧事物发展成为新事物**\n   - 二者的**辩证关系**\n     - **相互联结，相辅相成**\n     - 同一性是**相对的、有条件**的，**不能脱离斗争性而存在**，同一是**包含差别和对立的同一**\n     - 斗争性是**绝对的、无条件**的，斗争性**以同一性为前提和基础**，**寓于同一性中**\n     - 同一性和斗争性相结合，构成了事物的矛盾运动，推动事物的变化发展\n6. **辩证否定观**的基本内容（`考过`）\n   - 选择题知识点：**肯定**方面是**维持事物存在**的方面，**否定**方面是**促进事物灭亡**的方面\n\n   - 四点\n\n     - 否定是事物的**自我否定、自我发展**，是事物**内部矛盾**运动的结果\n\n     - 否定是事物发展的**必要环节**，是旧事物向新事物的转变，是旧质到新质的飞跃\n\n     - 否定是新旧**事物联系的环节**，新事物在否定中产生，旧事物在否定中灭亡\n\n     - 辩证否定的实质是**\"扬弃\"**，既批判又继承，既克服消极因素又保留积极因素\n7. 关于**客观辩证法与主观辩证法**\n\n   - 概念\n     - 客观辩证法是指**客观事物或客观存在**的辩证法，即**客观事物以相互作用、相互联系**的形式呈现出的**各种物质形态**的辩证运动和发展规律\n     - 主观辩证法是指**人类认识和思维运动**的辩证法，即**以概念作为思维细胞**的**辩证思维运动和发展**的规律\n   - 唯物辩证法既**包括客观辩证法也包括主观辩证法**，体现了**唯物主义、辩证法、认识论**的统一\n\n   - 客观辩证法与主观辩证法在**本质上是统一**的，但在**表现形式上不同**\n\n     - 客观辩证法采取**外部必然性的**形式，离开人的意识、思维而独立存在，**不以人的意志为转移**\n\n     - 主观辩证法则采取**观念的、逻辑**的形式，是同人类思维的自觉活动相联系的，是**以概念为基础**的辩证思维规律，因此，可以简要地把主观辩证法称为**概念辩证法**\n\n\n## 第二章\n\n1. 实践对认识的**决定性**作用\n\n   - **实践决定认识**，实践是认识的**来源和基础**\n   - 实践是认识的**发展的动力**\n   - 实践是认识的**目的**\n   - 实践是检验认识**真理性的唯一性标准**\n2. 实践与认识的**辩证**运动\n\n   * **实践 到 认识 到 实践**；即由感性认识到理性认识，再由理性认识到实践的飞跃\n   * 辩证运动是实践，认识，再实践，再认识的**循环往复以致无穷**过程\n   * 该辩证运动过程中，**主观必须统一于客观，认识必须统一于实践**\n   * 这种统一是认识和实践的矛盾在**发展**中的统一，是**具体的，历史**的统一\n3. **感性认识和理性认识**的辩证统一（`考过`）\n   - 感性认识是理性认识的基础，理性认识依赖于感性认识\n   - 感性认识有待于发展和深化为理性认识\n   - 感性认识和理性认识相互包含，相互渗透\n4. 认识两次飞跃的**基本条件**\n\n   1. 第一次，实践到认识\n      - **勇于实践，深入调查**， 获取丰富和切合实际的感性材料\n      - **经过理性思考**，将感性材料加工制作、去粗取精、去伪存真、由此及彼、由表及里\n   2. 第二次，认识到实践（**更重要**的一次飞跃）\n      - 需要经过一定的**中介环节**，包括确定实践目的、形成实践理念、制定实践方法、进行中间实验、运用科学实践方法等\n      - **从实际出发，坚持理论和实际结合**，让理论为群众掌握，转化为改造社会、改造自然的物质力量，让理论发挥**指导**作用，并且随着实践的发展而发展\n5. **真理绝对性和相对性**的辩证统一\n   - 绝对性：**主客观的统一性，发展的无限性**\n     - 真理是对客观事物及规律的**正确反映**，包含不依赖于人和人的意识的客观内容，**同谬误有原则的界限**。这一点是无条件的，绝对的\n     - 对人类而言，认识客观世界的每一步，都是**对无限发展的物质世界的接近**，这一点是无条件的，绝对的；承认世界的可知性，也就承认了真理的绝对性\n   - 相对性：**在一定条件下**对客观事物及规律的认识是有**限度**的\n     - 任何真理只是对客观世界某阶段、某部分的认识，认识的**广度**是有限度的，认识有待扩展\n     - 任何真理只是对客观对象某方面、某程度的认识，认识的**深度**是有限度的，认识有待深化\n   - 辩证关系\n     - **绝对真理和相对真理不是两种不同的真理，而是同一客观真理的两个不同方面、两种不同属性**\n     - 相互**依存**\n       - 人们的正确认识，都是在一定范围和条件下的，因此是相对的、有条件的；但是在这个范围和条件内，是对客观对象的正确反映，这时候又是无条件的、绝对的\n     - 相互**包含**，相互**渗透**\n       - 真理的**绝对性寓于相对性中**\n       - 真理的**相对性包含并表现绝对性**\n     - 相对真理向绝对真理**辩证转化**\n   - 选择题知识点补充\n     - 真理的客观性（**本质属性**）：真理是对客观事物及规律的**正确反映**，包含不依赖于人和人的意识的客观内容\n     - 客观性决定了真理的**一元性**，即同一条件下对特定客体的真理性认识**只有一个**\n6. **实践标准的确定性和不确定性**的辩证统一\n\n   - 实践作为检验真理的唯一标准，既是确定的，又是不确定的，是确定性和不确定性的统一\n   - 确定性（绝对性）：除了这个标准外，再没有其他标准\n   - 不确定性（相对性）\n     - 任何实践都会受**主客观条件**的制约，都**不能完全证实或驳倒一切认识**\n     - 任何实践都会受**历史条件**的限制，**不能绝对、永恒、一劳永逸的验证**\n7. **真理和价值的辩证**统一\n\n   - 真理是制约实践的客观尺度，是实践追求的价值目标之一；**价值是实践追求的根本目标**\n   - 实践活动受**真理尺度**和**价值尺度**制约，任何实践都是二者的统一，是**规律性**和**目的性**的统一\n     - 真理尺度：人们必须遵循真理，按照真理办事，才能在实践中取得成功\n     - 价值尺度：人们还需要按照自己的需要去认识世界和改造世界，体现了目的性\n   - 真理和价值在实践和认识活动中是相互制约、相互引导、相互促进的\n8. **为什么**实践能够成为检验真理的唯一标准？\n   * （从真理的本性和实践的特点来回答）\n   * 从真理的本性\n     * 真理是对客观事物及其规律的正确反映，本性在于**主客观相符合**，只有**作为主客观联系桥梁的实践才能检验其唯一标准**\n   * 从实践的特点\n     * 实践是人们改造客观世界的物质活动，主观应用到客观上去，具有直接现实性\n\n## 第三章\n\n1. **生产力与生产关系**的辩证关系\n   - 生产力：人类在生产实践中形成的**改造和影响自然**使其适合社会需要的**客观物质力量**\n     - 基本要素\n       - **劳动资料**：人们在劳动过程中所运用的物质资料或物质条件，其中**最重要的是生产工具**\n       - **劳动对象**：劳动对象是现实生产的**必要前提**\n       - **劳动者**：生产力中**最活跃的因素**\n   - 生产关系：人们在物质生产中形成的**不以人的意志为转移的经济关系**\n     - 包括：**生产资料所有制关系（生产关系中最基本的、决定性的）、生产中人与人的关系、产品分配关系**\n   - 辩证关系\n     - **生产力**是生产的**物质内容**，**生产关系**是生产的**社会形式**，二者**有机统一构成生产方式**\n     - **生产力决定生产关系**（**生产力状况**决定**生产关系性质**，**生产力发展**决定**生产关系变化**）\n     - 生产关系具有**能动的反作用**（适合推动，不适合阻碍）\n   - 选择题知识点补充\n     - **生产工具**：衡量生产力发展水平和社会经济水平的**客观依据**\n     - **科学技术：先进生产力的集中体现和主要标志，即第一生产力**\n2. **经济基础与上层建筑**的辩证关系\n\n   - 经济基础：社会一定发展阶段的**生产力决定的生产关系的总和**\n   - 上层建筑：建立在一定经济基础上的**意识形态以及相应的制度、组织和措施**\n     - 分为\n       - **意识形态（观念上层建筑）**：政治法律、道德、艺术、宗教、哲学等思想观点\n       - **政治上层建筑**：政治法律制度及设施和政治组织\n     - 二者关系：政治上层建筑是在一定意识形态指导下建立的，是**统治阶级意志的体现**；一旦形成，就成为一种现实的力量，影响并且制约人们的思想理论观点\n     - **政治上层建筑占主导地位，核心是国家政权**\n     - **国家的实质：一个阶级统治另一个阶级的工具**\n   - 辩证关系\n     - 经济基础**决定**上层建筑\n       - 经济基础的**需要**决定上层建筑的**产生**\n       - 经济基础的**性质**决定上层建筑的**性质**\n       - 经济基础的**变化发展**决定上层建筑的**变化发展以及方向**\n     - 上层建筑对经济基础有**反作用**，**集中表现**在**为经济基础服务**（适合推动，不适合阻碍）\n3. **社会存在与社会意识**的辩证关系（两大点 + 分别三小点）\n   - **社会存在决定社会意识**，社会意识是社会存在的**反映**，并**反作用**于社会存在\n     - 社会存在是社会意识内容的**客观来源**，社会意识是社会物质生活过程及其条件的**主观反映**\n     - 社会意识是人们**进行社会物质交往的产物**\n     - 社会意识是**具体的、历史的**，会跟**随着社会存在的发展相应地或迟或早的进行变化和发展**\n\n   - 社会意识的**相对独立性**\n\n     - 社会意识与社会存在发展具有**不完全同步性和不平衡性**\n\n     - 社会意识内部各种形式之间**存在相互影响**且各自具有**历史继承性**\n\n     - 社会意识对社会存在具有**能动的反作用**，这是**社会意识相对独立性的突出表现**\n4. **社会形态更替**的**一般规律**及其**特殊形式**\n   * **多样性和统一性**\n   * **必然性和社会历史性**\n   * **前进性和曲折性**\n5. **文化**的作用（`考过`）\n   - 为社会发展提供\n     - **思想保证**\n     - **精神动力**\n     - **凝聚力量**\n     - **智力支持**\n   - 选择题知识点补充\n     - 文化是一个国家、民族的灵魂\n     - **文化的核心是价值观**\n6. **人民群众**在历史中的作用\n\n   - 人民群众在历史发展中起**决定性**的作用，是社会历史**实践的主体**，是**历史的创造者**\n     - 创造社会**物质**财富\n     - 创造社会**精神**财富\n     - 是**社会变革的决定力量**\n     - 既是**先进生产力和先进文化的创造主体**，也是实现**自身利益的根本力量**\n   - 人民群众的**总体意愿和行动**代表了**历史发展的方向**，人民群众的**社会实践**最终决定**历史发展的格局**\n   - 人民群众创造历史受**社会历史条件**的制约，包括**经济、政治和精神文化**条件\n7. **为什么**说**物质生产方式**是社会发展的决定性力量？\n   * 是社会存在和发展的基础及决定力量，是**人类其他一切活动的前提**\n   * 决定了**社会性质、面貌和结构**，制约人们的**经济、文化等全部社会生活**\n   * 决定了**社会历史的变化发展**，决定了社会形态**从低级向高级的更替和发展**\n8. 科学技术对经济和社会发展的作用（`材料题考过`）\n\n   * 对生产方式产生了深刻影响\n     * 改变了社会生产力的构成要素\n     * 改变了人们的劳动形式\n     * 改变了社会的经济结构\n   * 对生活方式产生了巨大影响\n     * 为人的自由而全面的发展创造了更多条件\n   * 促进了思维方式的变革\n     * 通过影响思维主体、思维客体和思维工具，引起思维方式的变革\n\n## 第四章\n\n1. **使用价值和价值**的**对立统一**关系\n   - 使用价值：商品满足人们某种需要的属性，自然属性，构成社会财富的物质内容\n   - 价值：凝结在商品中的无差别的人类一般劳动，社会属性\n   - **使用价值是价值的物质承担者，也是交换价值的物质承担者（交换价值是价值的表现形式）**\n   - **价值是交换价值的基础，价值寓于使用价值中**\n   - 对立性：**相互排斥**的，二者不可兼得\n   - 统一性：**二者缺一不可**\n     - **没有使用价值，即使付出再多的劳动，也没有价值**\n     - 一个物品如果**只有使用价值**，但如果**不以交换为目的**，**也没有价值**\n2. **劳动二重性理论**以及**二者的对立统一**关系\n   - 劳动的二重性：**具体劳动**和**抽象劳动**（对立统一）\n   - 具体劳动：是指**生产一定使用价值的具体形式**的劳动。具体劳动创造了商品的使用价值\n   - 抽象劳动：人类**无差别的劳动**，创造商品的价值\n   - 两者是同一劳动的两种规定。任何一种劳动，**一方面是特殊的具体劳动，另一方面又是一般的抽象劳动**，这就是劳动的二重性。劳动的二重性**决定了商品的二因素**\n   - 对立性：两者反应的是劳动的不同属性，**自然属性**和**社会属性**\n   - 统一性：二者是同一劳动不可分割的两个方面，二者在**时间上和空间上是统一**的\n3. **价值规律**的作用\n   - 价值规律：**商品经济的基本规律**\n   - 基本内容和内在要求：商品的价值量由生产商品的**社会必要劳动时间**决定，商品交换以**价值量为基础**，按照**等价交换**的原则进行\n   - 积极作用\n     - 自发调节**生产资料**和**劳动力**在社会各生产部门的**分配比例**\n     - 自发刺激社会**生产力的发展**\n     - 自发调节社会**收入分配**\n   - 消极作用\n     - 导致社会**资源浪费**\n     - 导致收入**两极分化**\n     - **阻碍技术进步**\n4. **马克思劳动价值论**的意义\n   - 扬弃了**英国古典政治经济学**的观点，为**剩余价值理论**的创立奠定**基础**\n   - 揭示了**私有制下商品经济的基本矛盾**（私有劳动与社会劳动的矛盾），为从**物与物的关系揭示人与人的关系**提供了理论依据\n   - 揭示了**商品经济的一般规律**，为理解**社会主义市场经济**具有**指导**意义\n5. **劳动力商品的价值**的表现（`考过`）（与一般商品是不同的）\n   - 三点\n     - 维持**自身生存**所需**生活资料**的价值\n     - 维持**家属生存**所需**生活资料**的价值\n     - 接收**教育和训练所支出的费用**\n   - 补充：劳动力商品的**使用价值是价值的源泉**，在生产过程中能够**创造新价值**，并且**这个新价值比劳动力本身的价值更大**，这就是剩余价值，货币也就这样转化为了资本\n6. **马克思剩余价值理论**的意义\n   - 深刻揭露了资本主义生产关系的**剥削本质**，阐明资产阶级与无产阶级之间**阶级斗争的经济根源**，指出了无产阶级**革命的必然性**\n   - 是马克思**经济理论的基石**，是无产阶级反对资产阶级、揭示资本主义制度剥削本质的**锐利武器**\n   - 由于唯物史观和剩余价值理论的发现，**社会主义由空想变为现实（科学）**\n   - 揭示了资本主义经济特殊规律的同时，也揭示**商品经济和社会化生产的一般规律**\n\n","categories":["校内课程","马原"]},{"title":"毛概 期末复习","url":"/posts/93794ec.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 分值分布\n\n- `单选 30个 30分`\n- `多选 5个 10分`\n- `简答题 5个 40分`\n- `材料题 3个 20分`\n\n# 思维导图\n\n![思维导图](https://cdn.davidingplus.cn/images/2025/02/01/思维导图.jpg)\n\n<!-- more -->\n\n# 导论\n\n## 马克思主义中国化时代化的内涵\n\n- **马克思主义中国化时代化，就是立足中国国情和时代特点，坚持把马克思主义基本原理同中国具体实际相结合，同中华优秀传统文化相结合**\n- 三个科学内涵\n  - **运用马克思主义的立场、观点和方法，观察时代、把握时代、引领时代，解决中国革命、建设、改革中的实际问题**\n  - **总结和提炼中国革命、建设、改革的实践经验并将其上升为理论**，不断丰富和发展马克思主义的理论宝库，赋予马克思主义以新的时代内涵\n  - **运用民族语言来阐述马克思主义**，使其植根于中华优秀传统文化的土壤之中，具有**中国特色**，中国风格，中国气派\n\n## 马克思主义中国化的历史性飞跃\n\n- `2次`\n  - **新民主主义革命时期（第一次历史性飞跃）**\n    - **毛泽东思想：什么是马克思主义中国化？为什么要马克思主义中国化？怎样实现马克思主义中国化？**\n\n  - **改革开放和社会主义现代化建设新时期（新的飞跃）**\n    - **邓小平理论：什么是社会主义，怎样建设社会主义**\n    - **\"三个代表\"重要思想（江泽民）：建设什么样的党，怎样建设党**\n    - **科学发展观（胡锦涛）：新形势下实现什么样的发展，怎样发展**\n    - **习近平新时代中国特色社会主义思想：新时代坚持和发展什么样的中国特色社会主义，怎样坚持和发展中国特色社会主义，建设什么样的社会主义现代化强国，怎样建设社会主义现代化强国，建设什么样的长期执政的马克思主义政党，怎样建设长期执政的马克思主义政党**\n      - 如果把习总书记这一条**单独划开**，就是`3次`飞跃，第三次也是新的飞跃\n\n\n## 马克思主义中国化时代化理论成果及其关系\n\n- 马克思主义**中国化时代化的理论成果**是**一脉相承**又**与时俱进**的关系\n  - 毛泽东思想蕴含的马克思主义的立场、观点和方法，为中国特色社会主义理论体系**提供了基本遵循**\n  - 中国特色社会主义理论体系**在新的历史条件下进一步丰富和发展了**毛泽东思想\n- 都是马克思主义**在中国的运用和发展**\n- 都以**独创性的理论成果**丰富和发展了马克思主义的理论宝库\n- **同马克思主义一起，都是党和国家必须长期支持的指导思想，是全国各族人民团结奋斗的共同思想基础**\n\n# 第一章 毛泽东思想\n\n- **`1945年`党的七大**，将**毛泽东思想**写入党章\n\n## 毛泽东思想的形成和发展\n\n### 历史条件\n\n- `19世纪`中叶，马克思、恩格斯提出**唯物史观和剩余价值学说**，为社会主义思想奠定了**科学理论基础**，创立了**科学社会主义**\n\n- `19世纪末20世纪初`，世界进入**帝国主义战争**和**无产阶级革命**的时代\n\n- `1917`年**俄国十月革命**胜利开辟了**世界无产阶级社会革命的新时代**，**也给中国送来了马克思主义**\n\n- 中国革命胜利后，经历了第二次世界大战之后两大阵营的对立和斗争，西方国家对中国实行持续的**封锁禁运、和平演变**\n\n- 对革命和建设的丰富实践，对经验和教训的深刻总结\n  - **没有中国革命和建设的丰富实践，没有对中国革命和建设经验的深刻总结，就不可能有毛泽东思想**。正是经过长期实践的反复比较，党和人民选择了毛泽东作为自己的领袖，选择了毛泽东思想作为自己的指导思想\n\n### 形成发展的过程\n\n#### 形成\n\n- **第一次国内革命战争时期**\n  - 国共第一次合作，`1924年到1927年`，打袁世凯的北洋军阀\n  - 毛泽东发表**《中国社会各阶级的分析》《湖南农民运动考察报告》**等，提出**新民主主义革命的基本思想**，**标志着**毛泽东思想**开始萌芽**\n\n- **土地革命时期**\n  - **第二次**国内革命战争时期，`1927年到1937年`，党把工作重点由城市转入农村，在革命根据地开展打地主、分田地、废除封建剥削和债务，满足农民土地要求的革命\n  - 毛泽东发表《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》《反对本本主义》等，提出并阐述**农村包围城市，武装夺取政权**的思想，**标志着**毛泽东思想的**初步形成**，对红军和农村革命根据地的建立、巩固和发展发挥着根本指导作用\n\n\n#### 成熟\n\n- **`1935年`遵义会议**\n  - 具有**伟大转折**意义的历史会议\n    - 开始确立以**毛泽东同志为主要代表**的马克思主义正确路线在党中央的**领导地位**，毛泽东思想成熟的**根本政治保证**\n    - 开始形成以**毛泽东同志为核心**的党的**第一代中央领导集体**\n    - 开启了党**独立自主解放中国革命实际问题**的新阶段\n    - 在最危急关头**挽救了党、挽救了红军、挽救了中国革命**\n- **遵义会议后**(成熟)\n  - 毛泽东总结了党领导中国革命，特别是全民族抗日战争以来的历史经验，深入分析中国革命具体实际，发表《实践论》《矛盾论》《<共产党人>发刊词》《中国革命和中国共产党》《新民主主义论》《改造我们的学习》《论联合政府》等，提出了**新民主主义革命的总路线**，制定了**经济、政治、文化纲领**，指明了**新民主主义革命的具体目标**\n  - 毛泽东在对革命实践经验和教训科学总结的基础上，**系统阐述了新民主主义革命理论**，实现了**马克思主义与中国革命实践相结合的历史性飞跃**，**标志着**毛泽东思想得到多方面展开并**趋于成熟**\n- **`1945`年，党的七大**，将毛泽东思想**写入党章**，确定为党必须**长期坚持的指导思想**\n\n#### 继续发展\n\n- **解放战争和新中国成立之后**\n  - 先后提出**人民民主专政理论，社会主义改造理论**等，党把马克思列宁主义基本原理同中国具体实际进行**\"第二次结合，找出在中国怎样建设社会主义的道路\"**，对开辟适合中国国情的社会主义建设道路进行了艰辛探索\n    - 第二次结合：毛泽东**提出**第二次结合，邓小平**开始**第二次结合，但是**到现在为止都没有完成**第二次结合\n  - 毛泽东发表《在中国共产党第七届中央委员会第二次全体会议上的报告》**《论人民民主专政》《论十大关系》**《关于正确处理人民内部矛盾的问题》等，是**毛泽东思想的丰富和发展**\n\n## 毛泽东思想的主要内容和活的灵魂\n\n### 主要内容\n\n- **新民主主义革命理论**\n- **社会主义革命和社会主义建设理论**\n- 革命军队建设和军事战略的理论\n- 政策和策略的理论\n- 思想政治工作和文化工作的理论\n- **党的建设理论**\n\n### 活的灵魂\n\n- 三个基本方面：**实事求是、群众路线、独立自主**\n\n#### 实事求是\n\n- **一切从实际出发，理论联系实际，坚持在实践中检验真理和发展真理**\n- 由毛泽东确立于**民主革命时期**\n- 三点\n  - 深入实际了解**事物的本来面貌**，把握**事物内在必然联系**，按照**客观规律**办事\n  - 清醒认识和正确把握**我国基本国情**\n  - 不断推进**实践基础上的理论创新**\n\n#### 群众路线\n\n- **一切为了群众，一切依靠群众，从群众中来，到群众中去，把党的正确主张变为群众的自觉行动**\n- 是**党的根本工作路线**，**党的生命线**，是我们党永葆青春活力和战斗力的**重要传家宝**\n- 三点\n  - 坚持人民是**推动历史发展**的**根本力量**\n  - 坚持**全心全意为人民服务**的**根本宗旨**\n  - 保持党同人民群众的**血肉联系**\n\n#### 独立自主\n\n- **坚持独立思考，走自己的路，就是坚定不移地维护民族独立，捍卫国家主权，把立足点放在依靠自己力量的基础上，同时积极争取外援，开展国际经济文化交流，学习外国一切对我们有益的先进事物**\n- 独立自主是中华民族的**优良传统**，是中国共产党、中华人民共和国**立党立国的重要原则**\n- 独立自主是毛泽东针对党内存在的**\"左\"倾教条主义**，从中国革命遭受的挫折的教训中提出的正确思想主张\n- 两点\n  - 坚持中国的事情必须**中国人民自己主张，自己来处理**\n  - 坚持独立自主的**和平外交政策**，坚定不移走**和平发展道路**\n- 独立自主是**中华民族之魂**\n\n## 毛泽东思想的历史地位\n\n- 三点\n\n  - **马克思主义中国化时代化的第一个重大理论成果**\n    - 马克思主义中国化**第一次历史性飞跃**的理论成果\n    - 为中国特色社会主义理论体系的形成**奠定了理论基础**；尤其是关于**社会主义建设**的理论，为**开创和发展中国特色社会主义**作了重要的**理论准备**\n    - 做到了**理论表达的通俗化**，以通俗的言语解释深刻道理，在表达方式上具有**鲜明的民族特色**\n    - 毛泽东思想确立的马克思主义中国化时代化的**前进方向、基本原则和基本方法**，指导着我们党**不断推进马克思主义中国化时代化，不断开辟马克思主义中国化时代化新境界**\n\n  - **中国革命和建设的科学指南**\n\n  - **中国共产党和中国人民宝贵的精神财富**\n\n\n- 如何科学评价毛泽东和毛泽东思想？\n\n  - 关系到如何看到党和国家过去几十年奋斗和前进的历史\n\n  - 关系到党的团结，国家的安定\n\n  - 关系到党和国家的命运和未来发展\n\n\n# 第二章 新民主主义革命理论\n\n## 新民主主义革命理论形成的依据\n\n### 近代中国国情和中国革命的时代特征\n\n- **认清中国国情，是解决中国革命问题的基本前提**\n\n- 近代中国国情：**半殖民地半封建社会**\n\n- 时代特征（遇到\"时代\"，既要答中国的，也要答世界的）\n\n  - **俄国十月革命**，以此为标志，**中国资产阶级民主革命的时代背景发生了根本转换**\n    - 使中国的资产阶级民主革命，从原来的**旧的世界资产阶级民主革命**转变为**新的资产阶级民主革命的范畴**，从旧的世界资产阶级民主革命转变为世界无产阶级社会主义革命的一部分\n\n  - **五四运动，以先进青年知识分子为先锋、广大人民群众参加的彻底反帝反封建的伟大爱国革命运动（外争国权，内惩国贼）**\n\n    - 是**中国新民主主义革命的开端**\n\n  - 中国革命两步走\n\n    - 第一步：**完成反帝反封建的新民主主义革命**\n    - 第二步：**完成社会主义革命**\n\n### 实践基础\n\n- **旧民主主义革命的失败**呼唤新的革命理论\n- **新民主主义革命的艰辛探索**奠定了革命理论形成的**实践基础**（**理论来源于实践**）\n\n## 新民主主义革命的总路线和基本纲领\n\n### 新民主主义革命的总路线\n\n- 指导路线：无产阶级领导的、人民大众的，反对资本主义、封建主义和官僚资本主义的革命\n- 反映了中国革命的**基本规律**，指明了中国革命的对象、动力、领导力量、性质和前途\n\n#### 对象\n\n主要敌人：**帝国主义、封建主义和官僚资本主义**\n\n- **帝国主义是中国革命的首要对象**；是近代中国贫弱的总根源，推翻帝国主义的压迫是中国走向独立自强的前提\n\n- 帝国主义和封建主义相互勾结，中国革命主要就是打击这两个敌人\n\n- **对外推翻帝国主义压迫的民族革命，对内推翻封建地主压迫的民主革命**\n- 最后就是推翻依靠帝国主义、勾结封建主义的官僚资本主义\n\n#### 动力\n\n动力包括：**无产阶级，农民，城市小资产阶级，民族资产阶级**\n\n- 无产阶级：中国革命**最基本的动力**，中国革命的**领导力量**\n\n- 农民：中国革命的**主力军**\n\n  - **贫雇农**是**最可靠**的同盟军，**中农**是**可靠**的同盟军\n  - 农民占比大，深受剥削和压迫，所以说说农民是最可靠的同盟军也可以\n\n- 城市小资产阶级：无产阶级的**可靠同盟者**\n\n- 民族资产阶级：中国革命的**动力之一**\n\n  - 在经济上实行**保护民族工商业**的政策\n  - 在政治上争取它，**对动摇性和妥协性进行批评和斗争，又斗争又联合**，因此具有**两面性**\n\n\n#### 领导力量\n\n领导阶级：有且只能是**无产阶级**\n\n- **无产阶级的领导权是中国革命的中心问题，也是新民主主义革命的核心问题**\n- 无产阶级及其政党的领导，是中国革命取得胜利的**根本保证**\n- 区分新旧民主主义革命的**根本标志**是：**革命的领导权掌握在无产阶级手中还是资产阶级手中**\n- 中国新民主主义革命实质上是**无产阶级领导下的农民革命**\n\n#### 性质和前途\n\n性质：**资产阶级民主主义革命**（重点！！！一定不要弄错了）\n\n- 近代中国半殖民地半封建社会的性质，革命的任务是推翻帝国主义，封建主义和官僚资本主义这几座大山，**决定了革命的性质**\n\n前途：**社会主义**\n\n- 中国的新民主主义革命不是旧式的一般的资产阶级民主主义革命，而是**新式的特殊的资产阶级民主主义革命**\n- **新民主主义革命和社会主义革命的性质不同，新民主主义革命仍然属于资产阶级民主主义革命的范畴**\n- 新民主主义革命与社会主义革命**相互联系，紧密衔接**，中间不容横插一个资产阶级专政补充\n\n关于新民主主义革命和其他的对比\n\n- 和旧民主主义革命对比\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231219194314911.png\" alt=\"image-20231219194314911\" style=\"zoom:90%;\" />\n\n  ![image-20231219194335566](https://cdn.davidingplus.cn/images/2025/02/01/image-20231219194335566.png)\n\n- 和社会主义革命对比\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231219194357891.png\" alt=\"image-20231219194357891\" style=\"zoom:85%;\" />\n\n### 新民主主义的基本纲领\n\n- **一个政党的纲领，是公开树立起来的一面旗帜，是表明党的性质的重要标志**\n\n注意：以下的所有纲领**都是我国在新民主主义时期的纲领，而不是进入社会主义之后的纲领**，这二者有共同的地方，但是仍有区别！！！\n\n#### 政治纲领\n\n政治纲领：**推翻帝国主义和封建主义的统治，建立一个无产阶级领导的、以工农联盟为基础的、各革命阶级联合专政的新民主主义共和国**\n\n- 国体：**无产阶级领导的、以工农联盟为基础的，包括小资产阶级，民族资产阶级和其他反帝反封建的人们在内的各革命阶级联合专政**\n  - 注意：新民主主义这里是无产阶级领导，而社会主义当中是工人阶级领导，注意严谨！！\n\n- 政体：**实行民主集中制的人民代表大会制度**\n\n#### 经济纲领\n\n经济纲领（**两没收，一保护**）：**没收封建地主阶级的土地归农民所有，没收官僚资产阶级的垄断资本归国家所有；保护民族工商业**\n\n- 没收封建地主阶级的土地归农民所有\n\n  新民主主义革命的**主要内容**\n\n- 没收官僚资产阶级的垄断资本归新民主主义的国家所有\n\n  新民主主义革命的**应有之义**\n\n- 保护民族工商业（**最具特色的**）\n\n  需要保护和发展的资本主义，是有利于而不是有害于国计民生的私人资本主义经济，是不能操纵国计民生的资本主义\n\n#### 文化纲领\n\n新民主主义文化：是无产阶级领导的**人民大众**的**反帝反封建**的文化，即**民族的、科学的、大众的**文化\n\n- 为什么文化需要民族化？\n  - 自己的传统文化，不能全盘西化\n  - 反对文化侵略，保持自己文化的独立性\n  - 马克思主义传入中国，赋予了民族化、中国化的特点\n\n## 新民主主义革命的道路和基本经验\n\n### 革命道路\n\n- **农村包围城市、武装夺取政权的革命道路**\n\n#### 提出\n\n- `1927年`第一次国内革命战争失败，党的工作重心开始**由城市转向农村**\n- 秋收起义失败，毛泽东率领创建了井冈山革命根据地，把革命的主攻方向首先指向农村\n- 毛泽东发表《中国的红色政权为什么能够存在？》《井冈山的斗争》《星星之火，可以燎原》，**提出了\"工农武装割据\"思想，初步形成了农村包围城市的革命道路理论**\n- 红军长征到达陕北后，进一步丰富了整体战略思想\n- **`1938年11月`，毛泽东在党的六届六中全会提出**\n\n#### 必然性\n\n- **中国革命必须走农村包围城市、武装夺取政权的道路，这是由中国所处的时代特点和具体国情决定的**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231219201309226.png\" alt=\"image-20231219201309226\" style=\"zoom:90%;\" />\n\n- **为什么**能够走这样的道路？（重点）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231219201349124.png\" alt=\"image-20231219201349124\" style=\"zoom:90%;\" />\n\n#### 内容及意义\n\n- **中国革命走农村包围城市、武装夺取政权的道路，根本在于处理好土地革命、武装斗争、农村革命根据地建设三者的关系**\n- 土地革命：中国革命的**基本内容**\n- 武装斗争：中国革命的**主要形式**，是农村根据地建设和土地革命的**强有力保证**\n- 农村革命根据地：中国革命的**战略阵地**，是进行武装斗争和开展土地革命的**依托**\n\n### 三大法宝\n\n三大法宝：**统一战线，武装斗争，党的建设**\n\n#### 统一战线\n\n- **统一战线是无产阶级政党策略思想的主要内容（第一位!!!）**\n\n- 必须把**农民，小城市资产阶级，其他中间阶级**都团结起来，结成最广泛的统一战线\n\n- 两个联盟\n\n  - **工农联盟（基础）**：工人阶级与农民阶级、广大知识分子及其他劳动者的联盟\n  - **与民族资产阶级的联盟（保障）**：工人阶级与非劳动人民的联盟，主要是民族资产阶级\n\n- 先后经历了\n\n  - **第一次国共合作**的统一战线（国民革命联合战线）\n\n  - **工农民主**统一战线\n\n  - **抗日民族**统一战线\n\n  - **人民民主**统一战线\n\n- 经验\n\n  - **建立巩固的工农联盟**\n\n  - **正确对待资产阶级（最根本的经验）**\n    - 尤其是民族资产阶级，采取既联合又斗争的策略\n\n  - **采取区别对待的方针**\n    - 坚持发展进步势力，争取中间势力，孤立顽固势力的策略方针\n\n  - **坚持独立自主的原则**\n\n    - 在政治，组织，思想上独立\n\n#### 武装斗争\n\n- **武装斗争是中国革命的特点和优点之一**\n\n- 经验\n\n  - **坚持党对军队的绝对领导**\n  - 这是**建设新型人民军队的根本原则**，是保持人民军队无产阶级性质和建军宗旨的根本前提，也是毛泽东建军思想的核心\n\n- **建设全心全意为人民服务的军队**\n\n  - 坚持全心全意为人民服务的**根本和唯一宗旨**，是**建设新型军队的基本前提**\n\n- 开展革命的政治工作\n\n- 坚持正确的战略战术原则\n\n#### 党的建设\n\n- 加强党的**思想建设、组织建设和作风建设**\n\n- 经验\n\n  - **必须把思想建设放在所有建设的首位**\n    - 但是从`19大`开始，**政治建设排在首位**了\n    - 关键是以无产阶级思想克服和改造各种非无产阶级思想\n\n  - **必须在任何时候都重视党的组织建设**\n    - **根本：要贯彻民主集中制的根本组织原则**\n\n  - **必须重视党的作风建设**\n    - 三大作风（复习）：理论联系实际，密切联系群众，批评与自我批评\n\n  - **必须联系党的政治路线加强党的建设**\n\n- 自身建设的作用\n\n  - 必须不断加强党的思想建设、组织建设和作风建设，才能取得胜利\n  - 加强党的组织、作风建设，才能使得党组织不松散、不涣散，能成为坚强有力的战斗堡垒\n\n#### 三者的关系\n\n- **统一战线，武装斗争**是**两个基本特点，两个基本武器**\n- 统一战线是实行武装斗争的统一战线，武装斗争是统一战线的中心支柱\n- **党的组织**是掌握统一战线，武装斗争这两个武器对敌进行冲锋陷阵的**英勇战士**\n\n### 意义\n\n- 新民主主义革命理论，**解决了**在一个以农民为主体的、落后的半殖民地半封建的东方大国里**进行革命的一系列理论问题**，正确地解决了中国革命的**发展阶段问题**，揭示了**近代中国革命的发展规律**，极大地**丰富了马克思主义的理论宝库**\n- 在新民主主义革命理论的指导下，中国共产党领导中国人民取得了新民主主义革命的**伟大胜利**，实现了民族独立和国家的**基本统一**，根本改变了中国社会的**发展方向**，从而为实现由新民主主义向社会主义的转变、建立社会主义制度**创造了条件**\n- 中国新民主主义革命的伟大胜利有力地支持了世界人民**反对帝国主义的斗争**，增强了世界人民争取世界和平的力量\n\n# 第三章 社会主义改造理论\n\n## 从新民主主义到社会主义的转变\n\n### 过渡性的社会\n\n- **从中华人民共和国成立（`1949年10月1日`）到社会主义改造（`1956年`）基本完成，我国从新民主主义社会过渡到社会主义社会**\n\n- 过渡时期我国社会的性质：**新民主主义社会**\n\n- **新民主主义社会属于社会主义社会体系**\n\n- 新民主主义社会**不是一个独立**的社会形态，而是**由新民主主义向社会主义转变的过渡性社会**形态\n\n- 经济成分\n\n  - 五种\n    - **社会主义性质的国营经济**（国营包含国有，但是国有不一定是国营）\n    - **半社会主义性质的合作社经济**（过渡性成分）\n    - **农民和手工业者的个体经济**\n    - **私人资本主义经济**（是剥削阶级）\n    - **国家资本主义经济**（过渡性的成分）\n  - 半社会主义性质的合作社经济：**个体经济向社会主义集体经济**的过渡形式\n    - **个体**->**合作社-**>**集体**\n  - 国家资本主义经济：**私人资本主义经济向社会主义国营经济**的过渡形式\n    - **私人资本**主义->**国家资本**主义->**社会主义**国营经济\n  - 主要的经济成分（三种）：**社会主义经济，个体经济，资本主义经济**\n    - 经济现状：**社会主义国营经济处于领导地位，个人经济占绝对优势**\n    - 发展目标：逐步将资本主义经济和个人经济改造为社会主义经济\n\n- 阶级构成\n\n  - **工人阶级**\n    - 社会主义经济\n\n  - **农民阶级**\n    - 可以自发走向资本主义，也可以被引导走向社会主义；其本身不代表一种独立的发展方向\n\n  - **其他小资产阶级**\n\n  - **民族资产阶级**\n    - 资本主义\n\n- 经济成分和与之对应的基本阶级力量之间存在矛盾\n\n  - **新民主主义社会**的主要矛盾：**土地改革基本完成**之后（`1950年`），**工人阶级和资产阶级**的矛盾\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231219223048405.png\" alt=\"image-20231219223048405\" style=\"zoom:90%;\" />\n\n### 总路线及其依据\n\n- `1952年`国民经济得以恢复，在农村和城市开始逐步进行社会主义改造已经成为必要并有可能实现的可能，开始向社会主义过渡的时机已经到来\n- `1953年6月`，毛泽东在中央政治局会议上**正式提出过渡时期的总路线和总任务**\n- `1953年12月`形成了**完整表述**\n  - **从中华人民共和国成立，到社会主义改造基本完成，这是一个过渡时期。党在这个过渡时期的总路线和总任务，是要在一个相当长的时期内，逐步实现国家的社会主义工业化，并逐步实现国家对农业、手工业和资本主义工商业的社会主义改造**\n- 简称：**一化三改造**\n  - 一化：社会主义工业化\n  - 三改造：农业，手工业，资本主义工商业的社会主义改造\n- 二者相互联系，不可分离\n  - **\"主体\"（一化）和\"两翼\"（三改造）**\n\n- 依据（了解）：理论依据、现实依据\n\n## 社会主义改造道路和历史经验\n\n###  适合中国特点的社会主义道路\n\n#### 农业、手工业社会主义改造\n\n- **农业**的社会主义改造\n  - 对**农业**的社会主义改造，是三大改造中**首先进行**的\n  - 措施\n    - 道路：积极引导农民**组织**起来，走**互助合作**道路\n    - 原则：**自愿互利、典型示范和国家帮助**\n    - 政策：正确**分析农村的阶级和阶层状况**，制定正确的**阶级政策**\n    - 方针：坚持**积极领导、稳步前进**的方针\n    - 步骤：采取**循序渐进**的步骤\n  - 三个发展阶段\n    - **互助组**：发展互助组，同时试办初级社（**社会主义萌芽**阶段）\n    - **初级农村生产合作社**：建立初级农业生产合作社（**半社会主义**性质）\n    - **高级社**：发展高级农业生产社（**完全社会主义**性质）\n      - 比初级社规模大，特点是**生产资料归集体所有，取消了土地报酬，实行按劳分配**的原则\n- **手工业**的社会主义改造\n  - 通过**合作化**道路，把个人手工业经济改造为社会主义经济\n  - 方针：**积极领导，稳步前进**\n  - 三个步骤\n    - 手工业**供销小组**（**社会主义萌芽**性质）\n    - 手工业**供销合作社**（**半社会主义**性质）\n    - 手工业**生产合作社**（**社会主义性质的集体经济**组织）\n\n#### 资本主义工商业社会主义改造\n\n- 是中国社会主义改造当中**最具特色**的\n\n- 两点\n\n  - 用**和平赎买**的方法改造资本主义工商业（**和苏联，欧洲都不一样**）\n\n    - 所谓赎买，就是国家**有偿**地将私营企业改变为国营企业，将资本主义所有制改变为社会主义所有制\n\n    - 赎买的具体方式**不是由国家支付一笔巨额补偿资金**，而是让**资本家在一定年限内从企业经营所得中获取一部分利润**\n\n    - 和平赎买的**可能性**\n\n      - 首先，**民族资产阶级**具有两面性\n      - 其次，中国共产党与民族资产阶级长期保持着**统一战线**的关系，为敌我矛盾转化为按人民内部矛盾来处理**提供了前提**\n      - 再次，我国已经有了以工人阶级为领导、工农联盟为基础的**人民民主专政的国家政权**， 建立了**强大的社会主义国营经济**并掌握了国家的经济命脉，这就造成了私人资本主义在政治上、经济上对社会主义的依赖\n      - 最后，当时国家对粮食和工业原料的统购包销；以及，资本主义企业中工人群众对资本家的监督等因素\n\n    - 意义\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231220202426599.png\" alt=\"image-20231220202426599\" style=\"zoom:80%;\" />\n\n  - **采取从低级到高级的国家资本主义的过渡形式**（**和苏联一样**）\n\n    - 国家资本主义：**国家直接控制和支配**的资本主义经济（特殊的资本主义经济，**新式**的国家资本主义经济）\n      - 是在人民政府管理下的，用各种形式和国营社会主义经济联系着，并受工人监督的资本主义经济\n      - 目的不是为了资本家的利润，而是为了**供应人民和国家的需要**，这种资本主义带有很大的社会主义性质\n      - 分为：**初级形式，高级形式**\n        - 初级形式：国家对**私营工商业**实行**委托加工、计划订货、统购包销、经销代销**等\n          - \"四马分肥\"：国家所得税、企业公积金、工人福利费、资方红利（肥是利润，不是资产）\n        - 高级形式：**公私合营**，包括个别企业的公私合营和全行业的公私合营\n          - 个别企业的公私合营\n            - 国家向私营企业投资入股，企业利润的分配认为\"四马分肥\"\n          - 全行业的公私合营\n            - 标志着国家对资本主义工商业的**改造基本完成**\n\n- 三个步骤\n\n  - 实行**初级形式的国家资本主义**（分配方式为“四马分肥”，**具有社会主义因素**）\n\n  - 实行**个别企业的公私合营**（分配方式为“四马分肥”，**半社会主义性质**）\n\n  - 实行**全行业的公私合营**，把资本主义工商业者改造为自食其力的社会主义劳动者（按企业资本的股份额，每年定息`5%`，共计`10年`（`56-66年`），**社会主义国营性质**）\n\n### 社会主义改造的历史经验\n\n- 坚持**社会主义工业化建设与社会主义改造同时并举**\n  - 改造的目的是适应工业化建设的要求\n- 采取**积极引导、逐步过渡**的方式\n- 用**和平方法**进行改造\n\n## 社会主义基本制度在中国的确立\n\n### 社会主义基本制度的确立及其理论依据\n\n- **`1956年底`，农业、手工业、资本主义工商业的社会主义改造基本完成，我国社会经济结构发生根本变化**，**全民所有制**和**劳动群众集体所有制**经济两种社会主义经济占据绝对优势，社会主义公有制成为了我国社会的经济基础，标志着我国**阶级剥削制度的结束**和**社会主义基本制度的确立**\n- 政治上\n  - **`1954年`，《中华人民共和国宪法》颁布**\n  - **国体：工人阶级领导的、以工农联盟为基础的人民民主专政的社会主义国家**（直接说人民民主专政也可以）\n  - **根本制度：社会主义制度**\n  - **根本政治制度（政体）：人民代表大会制度**\n  - **基本政治制度：人民代表大会制度、中国共产党领导的多党合作和政治协商制度、民族区域自治制度以及基层群众自治制度**\n  - 表明我国由**新民主主义国家**转变为**社会主义国家**\n- 阶级上\n  - **工人阶级：领导阶级**\n  - 农民和城市小资产阶级：已变为社会主义的**集体劳动者**\n\n- 经济上\n  - 社会主义公有制成为我国社会的**基础**\n  - 社会主义经济成分占据**绝对优势**\n- 我国社会**当时**的主要矛盾\n  - **人民对于经济文化迅速发展的需要当前经济文化不能满足人民需要的状况之间的矛盾**\n\n- 党和人民的主要任务\n  - 集中力量发展**社会生产力**，把我国尽快从落后的**农业国**建设成先进的**工业国**\n\n\n### 重大意义\n\n- 社会主义基本制度的确立是中国历史上**最深刻、最伟大的社会变革**，为当代中国的一切发展奠定了**制度基础**，也为中国特色社会主义制度的创新和发展提供了**重要前提**\n- 答题可以答的几点\n  - 极大提高了工人阶级和广大劳动人民的**积极性，创造性**。促进了**生产力的发展**\n  - 奠定了我国社会主义工业化的**初步基础**\n  - 使**广大劳动人民真正成为国家的主人**\n  - 改变了世界政治经济格局，增强了社会主义的力量，对维护世界和平产生积极影响\n  - 证明了马克思列宁主义的真理性，总结丰富和发展了科学社会主义理论\n\n# 第四章 社会主义建设道路初步探索的理论成果\n\n## 初步探索的重要理论成果\n\n### 调动一切积极因素为社会主义服务\n\n- **`1956年4月25日`，毛泽东作了《论十大关系》的报告**\n\n- 关于《论十大关系》\n\n  - **初步总结**了我国社会主义建设的**经验**\n  - 明确提出\"**以苏为鉴，独立自主**\"地探索**适合中国状况**的社会主义道路\n  - 明确了**根本思想**：建设社会主义**必须根据本国情况**走自己的道路\n  - 这是党探索中国特色社会主义道路的**良好开端**\n\n- 《论十大关系》的**基本方针**\n\n  - 努力把党内党外、国内国外的**一切积极的因素**，直接的、间接的积极因素，全部调动起来，**为建设社会主义服务**\n  - **一半经济，一半政治外交**\n  - 前五条主要讨论**经济问题**，着眼于调动经济各个领域各个方面的积极因素（经济问题）\n    - 前三条讲重工业和轻工业、农业的关系；沿海工业和内地工业的关系；经济建设和国防建设的关系\n    - 第四、五条讲国家、生产单位和生产者个人的关系；中央和地方的关系\n  - 后五条讲汉族和少数民族的关系、党和非党的关系、革命和非革命的关系、是非关系、中国和外国的关系（**政治生活和思想文化生活领域**）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231220212651867.png\" alt=\"image-20231220212651867\" style=\"zoom:75%;\" />\n\n- 毛泽东认为，社会主义建设中的积极因素与消极因素是一对矛盾，这一矛盾呈现出既统一又斗争的关系\n\n- 调用一切积极因素为社会主义事业服务，必须坚持中国共产党的领导\n\n### 正确认识和处理社会主义社会矛盾的思想\n\n- 全面建设社会主义面临的**重大问题**\n  - 社会主义**是否还存在着矛盾**\n  - 存在**什么性质的矛盾**\n  - 如何**正确认识和解决这些矛盾**\n\n#### 社会主义社会的基本矛盾\n\n- 毛泽东在`1957年`《**关于正确处理人民内部矛盾的问题**》，系统论述了社会主义矛盾的理论\n\n  - 矛盾是**普遍存在**的，社会主义也同样充满了矛盾；正是这些矛盾**推动着**社会主义社会不断向前发展\n\n- 我国社会主义的**基本矛盾**\n\n  - 基本矛盾仍然是**生产关系和生产力的矛盾，上层建筑和经济基础的矛盾**\n\n  - 同以往社会的基本矛盾具有**根本不同的性质和情况**\n\n  - 以往社会的基本矛盾，生产关系与生产力之间存在着一定程度的对抗和冲突；而社会主义的基本矛盾是在**生产关系和生产力基本适应，上层建筑和经济基础基本适应**条件下的矛盾，是在**人民根本利益一致基础上**的矛盾\n\n  - 不是对抗性的矛盾，是**非对抗性的矛盾**；所以由于是非对抗性的矛盾，所以这一基本矛盾是**可以解决**的\n\n  - 特点：**相适应又相矛盾**\n\n    - **社会主义生产关系的建立和生产力的发展**相适应\n\n    - 很不完善，**不完善的方面和生产力的发展**是矛盾的\n\n    - **相适应的基本方面，相矛盾是非基本方面**\n\n    - 总结\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231220221810885.png\" alt=\"image-20231220221810885\" style=\"zoom:83%;\" />\n\n#### 我国社会主要矛盾和根本任务\n\n- **党的八大（`1956年`）**分析**社会主义改造后**我国社会主要矛盾的变化\n  - 届时，我国的主要矛盾**不再是工人阶级和资产阶级的矛盾**\n\n  - 而是：\n    - **人民对于经济文化迅速发展的需要同当前经济文化不能满足人民需要的状况之间的矛盾**\n\n    - **人民对于建立先进的工业国的需求同落后的农业国的现实的矛盾**\n\n- **根本任务**：**技术革命和社会主义建设**\n\n#### 社会主义社会的社会矛盾\n\n- 两种社会矛盾：**敌我矛盾，人民内部矛盾**\n\n- 敌我矛盾\n\n  - **人民同反抗社会主义革命、敌视和破坏社会主义建设的社会势力和社会集团的矛盾**\n  - **根本利益对立**基础上的矛盾，**对抗性**的矛盾\n  - 处理的基本方法：**分清敌我**\n  - **用专政方法强制改造**\n\n- 人民内部矛盾\n\n  - 包括\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231220223405852.png\" alt=\"image-20231220223405852\" style=\"zoom:85%;\" />\n\n  - **人民根本利益一致**基础上的矛盾，**非对抗性**的矛盾\n\n  - 处理的基本方法：**分清是非**\n\n  - **用民主方法说服教育**\n\n### 走工业化道路的思想\n\n- **实现工业化是中国近代以来历史发展的必然要求，也是民族独立和国家富强的必要条件**\n\n- 毛泽东**《论十大关系》中的第一大关系**\n\n  - **重工业和轻工业、农业**的关系\n  - 强调走一条**有别于苏联**的中国工业化道路\n  - 目标\n    - 以农业为基础，以工业为主导，把**重工业作为我国经济建设的重点**，建立起独立的比较完整的**基础工业体系和国防工业体系**\n    - 但是同时必须**充分注意发展农业和轻工业**；发展工业和发展农业同时并举，重工业和轻工业同时并举\n      - \"只有农业发展了，工业才有原材料和市场\"\n  - 总结\n    - **以农业为基础，以工业为主导，以农、轻、重为序发展国民经济的总方针**\n    - \"**两条腿走路\"**方针：重工业和轻工业、中央工业和地方工业、沿海工业和内地工业、大型企业和中小型企业同时并举\n  - 走工业化道路，中国必须（前三点是书上的，后两点是总结的）\n    - 采取正确的**经济建设方针**\n    - 调整和完善**所有制结构**\n    - 积极探索适合我国情况的**经济体制和运行机制**\n    - 发展科学技术和文化教育\n    - 重视知识分子工作\n\n- **\"两步走\"**的发展战略\n\n  - 第一步，建成一个**独立的、比较完整**的工业体系和国民经济体系\n  - 第二步，**全面实现**工业、农业、国防、科学技术现代化\n\n- 党的八大，提出**既反保守、又反冒进，在综合平衡中稳步前进**的经济建设方针；毛泽东阐述**既要统筹兼顾，又要突出重点**的方针\n\n- 三个主体，三个补充\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231221194818635.png\" alt=\"image-20231221194818635\" style=\"zoom:78%;\" />\n\n## 初步探索的意义和经验教训\n\n### 意义\n\n- 巩固和发展了我国的**社会主义制度**\n- 为开创中国特色社会主义提供了**宝贵经验、理论准备、物质基础**\n- 丰富了**科学社会主义**的**理论和实践**\n\n### 经验教训\n\n- 六个必须\n\n  - 必须**把马克思主义与中国实际结合**，探索符合中国特点的社会主义道路\n\n  - 必须正确认识社会主义社会的**主要矛盾和根本任务**，集中力量发展**生产力**\n\n  - 必须从实际出发进行社会主义建设，建设**规模和速度要与国力相适应**，**不能急于求成**\n\n  - 必须发展社会主义民主，健全社会主义**法制**\n\n  - 必须坚持党的**民主集中制和集体领导制度**，加强执政党建设\n\n  - 必须坚持**对外开放**，借鉴和吸收人类文明成果建设社会主义、不能关起门来搞建设\n\n- 补充\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231221195733161.png\" alt=\"image-20231221195733161\" style=\"zoom: 85%;\" />\n\n# 第五章 中国特色社会主义理论体系的形成发展\n\n## 形成发展的社会历史条件\n\n### 国际背景\n\n- `20世纪70年代`，**和平和发展**成为时代主题，世界多极化和经济全球化深入发展，综合国力竞争日益激烈\n- `20世纪80年代末90年代初`，东欧剧变、苏联解体，**国际局势发生深刻变化**\n- **党的十八大以来，世界百年未有之大变局加速演进**\n\n### 历史条件\n\n- 国家在建设社会主义的道路上，犯了不少错误，走了不少弯路\n\n  - 哪些？\n    - **在经济上急于求成，盲目求纯和急于过渡**\n    - **在政治上以阶级斗争为纲**\n  - 原因\n    - **偏离了党的实事求是的思想路线**，对国际国内的形势、对我国社会主义发展所处历史阶段及其社会主要矛盾作了错误的估量和判断\n    - **对什么社会主义和怎么建设社会主义完全没有弄清楚**，因此不可能集中精力发展生产力，也不可能对社会主义的某些制度和体制进行有效的改革\n\n- `20世纪80年代末90年代初`，东欧剧变，苏联解体，**世界社会主义出现严重曲折**\n\n  - **如何加快推进社会主义现代化**，把一个繁荣发展的社会主义中国带入`21世纪`，是对我们党的重大考验\n\n- 新世纪新阶段，我国进入**发展关键期、改革攻坚期和矛盾凸显期**（了解）\n\n  - 第一，经济实力显著增强，同时生产力水平总体上还不高，自主创新能力还不强，长期形成的结构性矛盾和粗放型增长方式尚未得到根本的改变\n  - 第二，社会主义市场经济体制初步建立，同时影响发展的体制体制障碍依然存在，改革攻坚面临深层次矛盾和问题\n  - 第三，人民生活水平总体上达到小康水平，同时收入分配差距拉大趋势还未根本扭转，城乡贫困人口和低收入人口还有相当数量统筹兼顾，各方面利益难度加大\n  - 第四，协调和发展取得显著成绩，同时农业基础薄弱，农村发展滞后的局面尚未改变，缩小城乡区域发展差距和促进经济社会协调发展任务艰巨\n  - 第五，社会主义民主政治不断发展，依法治国基本方略，扎实贯彻同时民主法制建设和扩大人民民主和经济社会发展的要求，还不完全适应政治体制改革需要继续深化\n  - 第六，社会主义文化更加繁荣，同是人民神文化需求日记旺盛，人民思想活动的独立性，选择性，多样性，差异性明显增强，对发展社会主义先进文化提出了更高需求\n  - 第七，社会活力显著增强，同时社会结构，社会组织形式，社会利益格局发生深刻变化，社会建设和管理面临诸多新课题\n  - 第八，对外开放日益扩大，同时面临的国际竞争日趋激烈，发达国家在经济科技上占优势的压力长期存在，可以预见和难以预见的风险增多，统筹国内发展和对外开放要求更高\n\n- **党的十八大以来**，中国特色社会主义进入**新时代**，这是我国发展**新的历史方位**\n\n  - 中国特色社会主义是承前启后、继往开来、在新的历史条件下继续夺取中国特色社会主义伟大胜利的时代，是决胜全面建成小康社会、进而全面建设社会主义现代化国家共同富裕的时代，是全体中华儿女戮力同心、奋力实现中华民族伟大复兴中国梦的时代，是我国不断为人类作出更大贡献的时代\n\n- 中国共产党百年奋斗的宝贵历史经验\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231221205051810.png\" alt=\"image-20231221205051810\" style=\"zoom:75%;\" />\n\n### 实践基础\n\n- **实践是理论创新的源泉**\n\n- 改革开放和社会主义现代化建设时期，党面临的主要任务是：继续探索中国建设社会主义的正确道路，解放和发展社会生产力，使人民摆脱贫困，尽快富裕起来，为实现中华人民伟大复兴提供充满新的活力的体制保证和快速发展的物质条件\n\n- 党的十三届四中全会之后，国际局势风云变幻，我国改革开放和现代化建设的进程波澜壮阔\n\n- 党的十六大之后，中国特色社会主义事业进入发展的关键期\n\n  - 改革开放《十个结合》的宝贵经验\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231221205833397.png\" alt=\"image-20231221205833397\" style=\"zoom:78%;\" />\n\n- 党的十八大以来，党面临的主要任务是：实现第一个百年奋斗目标，开启实现第二个百年奋斗目标新征程，朝着实现中华民族伟大复兴的宏伟目标继续前进\n\n  - **第一个百年奋斗目标：到中国共产党成立100年时（2021年），全面建成小康社会的目标一定能实现**\n  - **第二个百年奋斗目标：到新中国成立100年（2049年）时，建成富强、民主、文明、和谐、美丽的社会主义现代化强国**\n\n## 形成发展的过程\n\n### 形成（邓小平）\n\n- 党的十一届三中全会后，**解放思想，实事求是，改革开放**\n- `1982年`邓小平在党的十二大开幕词中：**走自己的道路，建设有中国特色的社会主义**\n- 回答：**什么是社会主义，怎样建设社会主义**\n\n### 跨世纪发展（江泽民）\n\n- **\"三个代表\"重要思想是以江泽民同志为代表**，在**开创全面改革开放的新局面**，推进党的建设新的伟大工程，成功把中国特色社会主义推向`21世纪`的伟大实践中形成和发展起来的\n\n- 回答：**建设什么样的党，怎样建设党**\n\n- 建设中国特色社会主义的十条基本经验\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231221210355898.png\" alt=\"image-20231221210355898\" style=\"zoom: 85%;\" />\n\n### 新世纪新阶段的新发展（胡锦涛）\n\n- **科学发展观是以胡锦涛同志为代表**，在**新世纪新阶段全面建设小康社会**进程中，在新的历史起点上推进中国特色社会主义事业的过程中形成和发展起来的\n- 回答：**新形势下实现什么样的发展，怎样发展**\n\n### 新时代的新篇章（习近平）\n\n- **党的十八大以来，以习近平同志为代表**，统筹把握**中华民族伟大复兴战略全局和是世界百年未有之大变局**，坚持毛泽东思想、邓小平理论、“三个代表”重要思想、科学发展观，深刻总结并充分运用党成立以来的历史经验，从新的实际出发，创立了习近平新时代中国特色社会主义思想\n- 回答：**新时代坚持和发展什么样的中国特色社会主义，怎样坚持和发展中国特色社会主义，建设什么样的社会主义现代化强国，怎样建设社会主义现代化强国，建设什么样的长期执政的马克思主义政党，怎样建设长期执政的马克思主义政党**\n\n# 第六章 邓小平理论(形成)\n\n- **什么是社会主义，怎样建设社会主义**\n\n- **党的十五大**，将**邓小平理论**写入党章\n\n\n## 形成条件\n\n- **和平与发展**成为时代主题，是邓小平理论的**时代背景**\n  - 时代的发展提供了难得的机遇，也提出了尖锐的挑战\n- **社会主义建设的经验教训**，是邓小平理论形成的**历史依据**\n  - 十一届三中全会之后，邓小平为代表的共产党人，纠正了**急于求成、政治上阶级斗争**为纲等错误\n- **改革开放和现代化建设的实践**是邓小平理论形成的**现实依据**\n\n## 形成过程\n\n- 开端\n  - `1978年12月`，**党的十一届三中全会**，重新确立了**解放思想、实事求是的思想路线**。确定把**全党工作重点转移到社会主义现代化建设**上来。作出**改革开放的重大决策**，是一次具有**深远意义的伟大转折**\n- 系统阐述社会主义初级阶段理论\n  - `1987年`**党的十三大**，**第一次**较为系统地阐述了我国**社会主义初级阶段理论**，标志着邓小平理论**轮廓的形成**\n- `1992年`南巡，南方谈话\n  - 社会主义的本质：**解放生产力，发展生产力，消除剥削，消除两极分化，最终达到共同富裕**\n  - 三个\"有利于\"标准\n  - **南方谈话**是邓小平理论的**集大成之作**，邓小平理论**逐步走向成熟**\n- `1997年`党的十五大\n  - **正式提出\"邓小平理论\"的概念**\n  - 把邓小平理论同马克思列宁主义、毛泽东思想一起确立为党的**指导思想**\n\n## 首要的基本的理论问题和精髓\n\n- 社会主义的科学含义概括\n  - 社会主义的本质：解放生产力，发展生产力，消除剥削，消除两极分化，最终达到共同富裕\n  - 包括了**生产力和价值目标**\n  - 提出始终坚持的**两项基本原则**\n    - **以社会主义公有制为基础**\n    - **实现共同富裕**\n- 精髓\n  - 邓小平理论的**精髓、活的灵魂：解放思想，实事求是**\n  - 四点作用\n    - 有力推动和保证了拨乱反正的进行\n    - 破除了僵化的社会主义模式观念，坚持走自己的路\n    - 一切从社会主义初级阶段的实际出发\n    - 坚持以\"三个有利于\"作为检验一切工作是非得失的根本标准\n  - 解放思想和实事求是是辩证统一的关系\n    - 只有解放思想才能达到实事求是\n    - 只有实事求是才是真正的解放思想\n\n## 主要内容\n\n### 社会主义初级阶段理论\n\n- **党的十三大（1987年）**\n\n  - 系统地阐述了社会主义初级阶段的**科学内涵**\n    - 社会主义初级阶段\n      - 我国**生产力落后，商品经济不发达**条件下建设社会主义**必须经历的特定阶段**\n      - 我国**从进入社会主义到基本实现社会主义现代化的整个历史阶段**（仅我国需要此阶段）\n    - 两层含义\n      - 我国社会**已经是社会主义社会**；必须**坚持而不能离开**社会主义\n      - 我国的社会主义社会**还处于初级阶段**，必须**正视而不能超越**初级阶段\n  - 强调了社会主义初级阶段的**长期性**\n    - **特指**我国在生产力落后，商品经济不发达下建设社会主义必然需要经历的初级阶段\n\n- **党的十五大**\n\n  - 将邓小平理论**写入党章**，作为党的**指导思想**\n\n  - 进一步阐述了社会主义初级阶段的**基本特征**\n\n    - 这一阶段是**摆脱不发达状态，基本实现社会主义现代化**的历史阶段\n\n    - 是**农业人口占很大比重**、主要依靠手工劳动的**农业国**转变为**非农业人口大多数**、包含现代农业和现代服务业的**工业化国家**的历史阶段\n\n    - 书上的其他总结\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231221222308004.png\" alt=\"image-20231221222308004\" style=\"zoom:80%;\" />\n\n### 党在社会主义初级阶段的基本路线\n\n- 党的十三大提出了党在社会主义初级阶段的基本路线\n\n  - **领导和团结全国各族人民**\n  - **以经济建设为中心**\n  - **坚持四项基本原则**\n  - **坚持改革开放，自力更生，艰苦创业，为把我国建设成富强、民主、文明、和谐的社会主义现代化国家奋斗**\n  - 简要概括：一个中心，两个基本点\n    - 再具体点：以经济建设为中心，坚持四项基本原则，坚持改革开放\n\n- 一个中心，两个基本点\n\n  - 社会主义初级阶段**基本路线的主要内容**\n\n  - 以经济建设为中心\n\n    - 回答了社会主义的根本任务，体现了发展生产力的本质要求\n\n  - 坚持四项基本原则\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231221223422583.png\" alt=\"image-20231221223422583\" style=\"zoom:80%;\" />\n\n  - 坚持改革开放\n\n### 社会主义根本任务的理论\n\n- 生产力是社会发展的**根本的决定性因素**，马克思主义始终高度重视生产力的发展\n- **十一届三中全会**之后，我们党**把工作重心转移到经济建设**上来，强调**社会主义的根本任务是发展生产力**\n- `1979年3月`，邓小平指出：\"我们目前的生产力发展水平很低，远远不能达到人民和国家的需要，这就是我们目前时期的主要矛盾，解决这个主要矛盾就是我们的中心任务\"\n- `1981年6月`以后，我国需要的主要矛盾是**人民日益增长的物质文化需要同落后的社会生产之间的矛盾**\n- **党的十九大报告**，提出中国特色社会主义进入新时代，我国社会主要矛盾已经转化为**人民日益增长的美好生活需要和不平衡不充分的发展之间的矛盾**\n- 中国解决所有问题的关键是靠自己的发展；发展生产力离不开科学技术\n\n### \"三步走\"战略\n\n- 新中国成立后，毛泽东同志为代表提出**\"四个现代化\"**目标\n  - 建设起强大的现代化的工业、现代化的农业、现代化的交通运输业和现代化的国防\n- **党的十三大**确定邓小平提出的**\"小康社会\"**构想和**\"三步走\"**的发展战略构想\n- 哪三步\n  - 第一步，到`1990年`，实现国民生产总值比`1980年`**翻一番**，解决人民的**温饱问题**\n  - 第二步，到`20世纪末`，国民生产总值再增长一倍，人民生活达到**小康水平**\n  - 第三步，到`21世纪中叶`，**人均**国民生产总值达到**中等发达国家水平**，人民生活比较富裕，**基本实现现代化**。然后，在这个基础上继续前进\n- \"三步走\"发展战略，把我国社会主义现代化的目标**具体化为切实可行的步骤**，为基本实现现代化明确了**发展方向**，展现了**美好的前景**，成为全国人民团结奋斗的**行动纲领**\n\n### 改革开放理论\n\n- **新时期最鲜明的特征**：**改革开放**\n- 党的十一届三中全会把党和国家的工作中心转移到经济建设上来、实行改革开放的历史性决策，实现了新中国成立以来党的历史上具有深远意义的伟大转折，开启了改革开放和社会主义现代化的伟大征程\n- 改革是一场深刻的社会变革，是中国的**第二次革命**，是实现中国现代化的**必经之路**\n  - 把一个**经济文化比较落后的社会主义中国**变成一个**现代化的社会主义国家**\n- 改革是一场革命，是社会主义制度的**完善和发展**\n- **改革不是对原有经济体制细枝末节的修补，而是对体制的根本性变革**\n- 改革的实质和目标是**从根本上改变束缚我国生产力发展的经济体制，建立充满升级和活力的社会主义新经济体制，同时相应地改革政治体制和其他方面的体制**\n- 判断改革是否得失的标准（**三个有利于**）\n  - 是否有利于发展社会主义社会的**生产力**\n  - 是否有利于增强社会主义国家的**综合国力**\n  - 是否有利于提高**人民的生活水平**\n\n- **开放也是改革**，对外开放是建设中国特色社会主义的一项**基本国策**，和改革开始成为新时代最鲜明的特征\n- 对外开放是**对世界所有国家的开放**，包括对发达国家的开放，也包括对发展中国家的开放；**不仅是经济领域的开放，也包括科技、教育、文化等领域的开放**\n- 对外开放中邓小平特别强调两点\n  - **正确对待资本主义社会**创造的现代文明成果，结合新的实践进行新的创造，为我所用，加快发展\n  - 高度珍惜并且坚决维护中国人民经过长期奋斗得来的**独立自主权利**\n- 改革开放是决定当代中国命运的**关键抉择**，是当代中国发展进步的**活力之源**，是我们党和人民大踏步赶上时代的**重要法宝**，是坚持和发展中国特色社会主义的**必由之路**\n\n### 市场经济理论\n\n- **社会主义也可以搞市场经济；资本主义也有计划经济**\n- 社会主义经济是“公有制基础上有计划的商品经济\"\n- `1992年`邓小平**南方谈话**，标志着邓小平的社会主义市场经济理论的**形成**\n  - 指出：计划多一点还是市场多一点，**不是社会主义与资本主义的本质区别**。计划经济不等于社会主义，资本主义也有计划；市场经济不等于资本主义，社会主义也有市场。计划和市场都是经济手段\n- 丰富内涵\n  - 计划经济和市场经济**不是划分经济制度的标志**，计划经济不等于社会主义，市场经济不等于资本主义\n  - 计划和市场都是经济手段，对经济活动的调节各有优劣，社会主义实行市场经济是要**把二者优势结合起来**\n  - 市场经济作为资源配置手段**不具有制度属性**，可以和不同的社会制度结合，表现出不同的性质\n  - 坚持社会主义制度与市场经济的结合，是社会主义市场经济的特色所在、优势所在\n\n### \"两手抓，两手都要硬\"\n\n- **一手抓物质文明，一手抓精神文明**\n- **一手抓建设，一手抓法制**\n- **一手抓改革开放，一手抓惩治腐败**\n\n### \"一国两制\"与祖国统一\n\n- **和平统一，一国两制**\n- **实现祖国的完全统一**，是国家繁荣富强和民族伟大复兴的**基础**，是海内外中华儿女的**共同心愿**，是中华民族的**根本利益**所在，是中国共产党和中国人民不可动摇的**坚强意志**\n- **反对分裂，坚持统一，是中华民族自古以来的光荣传统**\n- 基本内容\n  - **坚持一个中国**；这是\"和平统一，一国两制\"的**核心**，是发展两岸关系和实现和平统一的基础\n  - **两制并存，在祖国统一的前提下，国家的主体部分实行社会主义制度，同时在香港、澳门、台湾保持原有的社会制度和生活方式长期不变**\n  - **高度自治**，祖国完全统一后，香港、澳门、台湾作为中央政府全面管辖下的特别行政区，享有不同于中国其他省、市、自治区的高度自治权，台湾、香港、澳门同胞各种合法权益将得到切实尊重和维护\n  - 尽最大努力争取**和平统一**，但**不承诺放弃使用武力**\n  - 解决台湾问题，实现祖国完全统一，**寄希望于台湾人民**\n\n### 中国特色社会主义外交和国际战略\n\n- **和平问题是东西问题，发展问题是南北问题；南北问题是核心问题**\n  - 东西问题：上世纪`50年代`到`90年代初`，以美国、西欧为代表的**西方资本主义阵营**和以苏联为代表的**东方社会主义阵营**的对峙\n  - 南北问题：**南半球的发展中国家和北半球的发达国家发展不平衡的问题**\n- **`1987年`党的十三大**提出了当今世界的两大主题：**和平与发展**\n- 和平共处五项原则（**周恩来**提出）：**互相尊重主权和领土完整、互不侵犯、互不干涉内政、平等互利、和平共处**\n\n### 党的建设理论\n\n- **党章是最根本的党规党法**\n- 加强党的建设，是我们党领导人民取得革命和建设胜利的法宝\n- 重视马克思主义理论学习是加强党的建设，从而增强我们工作中的原则性、系统性、预见性和创造性的必修课\n- 加强组织建设是党的建设的重要环节\n- 加强领导班子建设，培养和选拔德才兼备的各级领导干部，是加强党的建设，保证党的路线的连续性和国家长治久安的根本大计\n- 加强党的建设必须打好党风建设这场硬仗\n- 加强党的建设一定要重视制度建设\n\n## 历史地位\n\n- **马克思列宁主义、毛泽东思想的继承和发展**\n- **中国特色社会主义理论体系的开篇之作**\n  - 邓小平是中国特色社会主义理论体系的创立者，抓住\"什么是社会主义，怎样发展社会主义\"这一基本问题，**提出\"走自己的道路，建设有中国特色的社会主义\"这一重大命题（`1982年`党的十二大提出）**\n- **改革开放和社会主义现代化建设的科学指南**\n\n# 第七章 \"三个代表\"重要思想(跨世纪发展)\n\n- **建设什么样的党，怎样建设党**\n- **党的十六大**，将**\"三个代表\"重要思想**写入党章\n\n## 形成条件\n\n- `20世纪80年代末90年代初`，国内发生**严重政治风波**，国际上**东欧剧变、苏联解体**，**世界社会主义发生严重曲折**，我国社会主义的发展面对**空前巨大的困难和压力**，党和国家处于**决定前途命运的历史关头**\n\n- 三个条件\n\n  - 在**冷战结束后国际形势科学判断**的基础上形成（世界背景）\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231222221148123.png\" alt=\"image-20231222221148123\" style=\"zoom:80%;\" />\n\n  - 在**科学判断党的历史方位和总结历史经验**的基础上提出（党内背景）\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231222221250995.png\" alt=\"image-20231222221250995\" style=\"zoom:80%;\" />\n\n  - **建设中国特色社会主义伟大实践**的基础上提出（国内背景）\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231222221333847.png\" alt=\"image-20231222221333847\" style=\"zoom: 80%;\" />\n\n## 形成过程\n\n- 党的十三届四中全会提出大力加强党的建设，坚决惩治腐败的要求\n- 党的十五大，江泽民将新时期党的建设新的伟大工程的总目标概括为：把党建设用邓小平理论武装起来，全心全意为人民服务，思想上政治上组织上完全巩固\n- `2000年2月25日`，江泽民在**广州**考察工作，**首次**对\"三个代表\"进行了**比较全面的阐述**\n- `2000年6月29日`，江泽民回答\"**建设什么样的党，怎样建设党**\"的问题\n- `2001年7月1日`，江泽民在庆祝中国共产党成立`80周年`大会**全面阐述\"三个代表\"重要思想的科学内涵和基本内容**\n- **党的十六大**，全面阐述了三个代表形成的时代背景、历史地位、精神实质和指导意义\n  - 将\"三个代表\"重要思想与马克思列宁主义、毛泽东思想、邓小平理论**写入党章**，确立为党的**指导思想**\n\n## 核心观点\n\n- 下面的副标题就是具体的三个代表\n\n### 始终代表中国先进生产力的发展要求\n\n- 社会主义的根本任务是发展生产力\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231222222651346.png\" alt=\"image-20231222222651346\" style=\"zoom:85%;\" />\n\n### 始终代表中国先进文化的前进方向\n\n- 必须努力体现发展面向现代化、面向世界、面向未来的、面向民族的科学的大众的社会主义文化的要求\n- 几点\n  - 发展先进文化，是实现社会主义现代化的战略任务\n  - 发展先进文化，就是发展中国特色社会主义的文化，就是建设社会主义精神文明\n  - 发展先进文化，就是发展面向现代化、面向世界、面向未来的，民族的科学的大众的社会主义文化\n  - 发展先进文化，要把弘扬主旋律和提倡多样化统一起来，支持健康有益文化，努力改造落后文化，坚决抵制腐朽文化\n  - 弘扬民族精神是发展先进文化极为重要的任务\n  - 加强社会主义思想道德建设，是发展先进文化的重要内容和中心环节\n  - 做好思想政治工作是发展先进文化的重要任务\n  - 教育是发展先进文化、建设物质文明和精神文明建设的基础工程\n  - 繁荣发展哲学社会科学，是发展先进文化、建设社会主义精神文明的重要组成部分\n  - 发展先进文化，需要充分发挥新闻媒体的作用\n  - 发展先进文化，需要重视社会主义文艺事业的繁荣发展\n  - 发展先进文化，必须大力推进文化体制改革\n\n### 始终代表中国最广大人民的根本利益\n\n- 指党的理论、路线、纲领、方针、政策和各项工作，必须坚持**把人民的根本利益作为出发点和归宿**，充分发挥人民群众的**积极性、主动性、创造性**，在社会不断发展进步的基础上，使人民群众不断获得切实的经济、政治、文化利益\n- **人民是国家的主人，是决定我国前途和命运的根本力量，是历史的真正创造者**\n- **人民才是创造的主体**\n- 关心群众、代表群众利益，必须十分具体地落实到解决群众生产和生活的**实际问题**\n\n### 三者的内在联系\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231222223841916.png\" alt=\"image-20231222223841916\" style=\"zoom:90%;\" />\n\n## 主要内容\n\n### 发展是党执政兴国的第一要务\n\n- **发展才是硬道理**，中国解决所有问题的关键在于依靠自己的发展\n\n- 中国特色社会主义是靠**发展**来不断巩固和推进的\n\n- 发展是国际竞争中赢得主动的需要；只有加快发展，增强经济实力，提高综合国力，才能在风云变幻的国际形势中处于主导地位，立于不败\n\n- 用发展的方法解决前进中的问题，是改革开放以来我们的一条重要经验\n\n- **发展是社会主义物质文明、政治文明和精神文明的协调发展**\n\n- 发展包括人的全面发展\n\n- 正确处理改革、发展、稳定的关系\n\n  - **改革是动力，发展是目的，稳定是前提**\n\n- 发展必须**毫不动摇地坚持**党在社会主义初级阶段的基本路线\n\n- 正确处理社会主义现代化建设中的若干重大关系\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231223151907339.png\" alt=\"image-20231223151907339\" style=\"zoom:75%;\" />\n\n### 建立社会主义市场经济体制\n\n- 江泽民根据**邓小平南方谈话**的精神，**党的十四大**，正式把**建立社会主义市场经济体制确立为我国经济体制改革的目标**\n- **`20世纪末`，我国初步建立了社会主义市场经济体制**\n- 社会主义市场经济体制是同社会主义基本制度**结合**的，既可以发挥**市场经济的长处**，又可以发挥**社会主义制度的优越性**\n- 要坚持**市场在资源配置中的基础性作用**\n- 建立社会主义市场经济体制，必须坚持和完善**公有制为主体、多种所有制经济共同发展**的**社会主义基本经济制度**\n  - 毫不动摇地巩固和发展公有制经济\n  - 毫不动摇地鼓励、支持和引导非公有制经济发展\n- 进一步探索**公有制特别是国有制**的**多种有效实现方式**\n  - 实现形式可以多样化，一切反映社会化生产规律的经营方式和组织形式都可以利用\n- **发挥市场经济的作用和国家宏观调控，是社会主义市场经济体制的本质要求**\n- 完善适应社会主义市场经济体制的**分配关系**\n  - 分配制度：**按劳分配为主体，多种分配方式并存**\n- 建立和完善**社会保障体系**，是建立社会主义市场经济体制的重要内容\n\n### 全面建设小康社会\n\n- 全面建设小康社会，是基于我国的基本国情提出的\n- `20世纪末`，我国已经实现了\"三步走\"战略的第一步、第二步，人民生活**总体达到小康水平**\n- **党的十五大**，勾画了**第三步战略**的蓝图：第一个十年实现国民生产总值比`2000年`翻一番，使人民小康生活更加富裕，形成比较完善的社会主义市场经济体制；再经过十年的努力，到建党`100周年`时，国民经济更加发展，各项制度更加完善；到`21世纪`中叶建国`100周年`时，基本实现社会主义现代化，建成富强民主文明的社会主义国家\n- 全面建成小康社会，是实现现代化建设第三步战略目标必经的**承上启下**的发展阶段，也是完善社会主义市场经济体制和扩大对外开放的关键阶段\n\n### 建设社会主义政治文明\n\n- 社会主义现代化全面发展的三大目标：建设社会主义**物质文明、精神文明和政治文明**\n- **建设社会主义政治文明，发展社会主义民主政治**，是社会主义现代化建设的重要目标\n- 几点\n  - 必须发展社会主义民主\n  - 必须坚持和完善中国特色社会主义政治制度\n  - 必须坚持依法治国，建设社会主义法治国家\n  - 必须进行政治体制改革\n  - 必须推进决策的科学化民主化\n  - 必须尊重和保障人权\n\n### \"引进来\"和\"走出去\"相结合的对外开放战略\n\n- 对外开放是一项长期的基本国策\n- `2001年11月10日`，中国成功加入**世界贸易组织`WTO`**\n- **办好经济特区**，是继续推进改革开放和现代化建设的重大举措\n- \"引进来\"和\"走出去\"，既要**向外国开放我们的市场（引进来）**，同时**我们自身也要开拓国外市场（走出去）**，双向兼顾\n\n### 推进党的建设新的伟大工程\n\n- **任何时候，坚持中国共产党的领导**\n  - 核心：坚持党的**先进性**\n- 推进党的建设新的伟大工程，重点是加强**党的执政能力建设**\n- 几点\n  - 坚持用马克思主义武装全党\n  - 把党的**最低纲领和最高纲领**统一起来\n    - 党的最低纲领，即党在**民主革命阶段**的纲领是：消除内乱，打倒军阀，建立国内和平；推翻国际帝国主义的压迫，达到中华民族完全独立；统一中国为真正的民主共和国\n    - 党的最高纲领：在**最低纲领实现之后**，建立劳农专政的政治，铲除私有财产制度，渐次达到共产主义\n  - 坚持**民主集中制**\n    - 地位：我们党一贯坚持的**根本组织制度和领导制度**\n  - 坚持正确的用人导向\n  - 领导干部一定要讲学习、讲政治、讲正气\n  - 坚持党要管党、从严治党的方针\n  - 坚决反对和防止**腐败**\n    - 地位：全党一项重大的政治任务\n\n## 历史地位\n\n- 中国特色社会主义理论体系的**丰富发展**\n- 马克思主义中国化的**继承与发展**\n- 加强和改进**党的建设**、推进**中国特色社会主义事业**的**强大理论武器**\n\n# 第八章 科学发展观（新世纪新阶段的新发展）\n\n- **新形势下实现什么样的发展，怎样发展**\n- **党的十七大**，将**科学发展观**写入党章\n- 补充：**党的十九大**，将**习近平新时代中国特色社会主义思想**写入党章\n\n## 形成条件\n\n- 科学发展观是我们党以马克思列宁主义、毛泽东思想、邓小平理论、\"三个代表\"重要思想为**指导**，准确把握**世界发展趋势**，认真总结**我国发展经验**、深入分析**我国发展阶段性特征**的基础提出\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231223160403249.png\" alt=\"image-20231223160403249\" style=\"zoom:80%;\" />\n\n## 形成过程\n\n- 科学发展观是在**抗击非典疫情和探索完善社会主义市场经济体制**的过程中逐步形成的\n- `2003年`，非典疫情；`2003年10月`，指出**以人为本**，树立**全面、协调、可持续的发展观**\n- `2004年3月`，界定了**以人为本、前面发展、协调发展、可持续发展的深刻内涵**\n- `2004年`宏观经济环境开始紧绷，科学发展观也在调控中不断丰富\n- `2006年`**第十届全国人大四次会议**，要以邓小平理论和\"三个代表\"重要思想为**指导**，以科学发展观**统领经济社会、发展全局**\n- **党的十七大**标志科学发展观**走向成熟**\n  - 十七大将科学发展观和马克思列宁主义、毛泽东思想、邓小平理论、\"三个代表\"重要思想一道确立为党的指导思想，并写入党章\n  - 十七大将邓小平理论、\"三个代表\"重要思想、科学发展观都作为中国特色社会主义理论体系的重要组成部分\n\n## 科学内涵\n\n### 推动经济发展是科学发展观的第一要义\n\n- **以科学发展为主题，是时代的要求，关系改革开放和现代化建设全局**\n- 几个必须\n  - 必须加快转变经济发展方式\n  - 必须推动科学技术的跨越式发展\n  - 必须培养高素质创新型人才\n  - 必须善于抓住和用好机遇\n- **全面建成小康社会，是我们党对人民的庄严承诺，是全国各族人民的根本利益所在**\n\n### 以人为本是科学发展观的核心立场\n\n- 集中体现了马克思主义的基本原理，体现了我们党**全心全意为人民服务的根本宗旨**和**推动经济社会发展的根本目的**，是**社会主义的本质特征**\n- 以人为本的人，就是**人民群众**\n  - 以**工人、农民、知识分子**等劳动者为主体，包括社会各阶层人民在内的**中国最广大人民**\n- 三个坚持\n  - 坚持发展为了人民，始终把最广大人民的根本利益放在第一位\n  - 坚持发展依靠人民，从人民群众的伟大创造中汲取智慧和力量\n  - 坚持发展成果由人民共享，着力提高人民物质文化生活水平\n\n### 全面协调可持续是科学发展观的基本要求\n\n- 把全面协调可持续发展作为科学发展观的基本要求的原因\n  - 经过长期发展，积累了**较为雄厚的物质技术条件**，可以在全面协调可持续发展上有更大作为\n  - **城乡区域发展不平衡、经济社会发展不协调、经济发展与人口资源环境不适应**等问题更突出，促使我们全面协调\n    - 发展具有**全面性**，不仅是经济发展，其他方面也更要注重发展\n    - 协调是**发展要均衡**，各个环节要相互适应和促进\n    - 可持续发展，要具有**持久性、连续性**；保证**长远发展**\n\n### 统筹兼顾是科学发展观的根本方法\n\n- 深刻体现了唯物辩证法在发展问题上的科学运用，深刻揭示了实现科学发展、促进社会和谐的基本途径，是正确处理经济社会发展中重大关系的方针原则\n- 四点\n  - 必须正确认识和妥善处理中国特色社会主义事业中的重大关系\n  - 必须认真考虑和对待各方面的发展需要，正确反映和兼顾各阶层各群体的利益要求\n  - 要牢牢掌握统筹兼顾的科学思想方法，努力提高战略思维、创新思维、辩证思维能力，不断增强统筹兼顾的本领，更好地推动科学发展\n  - 要求我们既立足当前，又着眼长远，做到兼顾各方，综合平衡\n\n## 主要内容\n\n### 加快转变经济方式\n\n- 推动经济持续发展，必须坚持以科学发展为主题，**以加快转变经济发展方式为主线**\n- 思想观点\n  - 全面深化经济体制改革是加快转变经济发展的方式\n  - 实施创新驱动发展战略，是转变经济发展方式的重大战略决策\n  - 推动经济结构战略性调整，是提升国民经济整体素质、赢得国际经济竞争主动权的根本途径\n  - 促进区域协调发展是我国现代化建设中的一个重大战略\n  - 积极稳妥推进城镇化是优化城乡经济结构、促进国民经济良心循环和社会协调发展的重要措施\n  - 推动城乡发展一体化，是解决\"三农\"问题的根本途径\n  - 实现工业化、信息化、城镇化、农业现代化，是我国社会主义现代化建设的战略任务，也是加快形成新的经济发展方式、促进经济持续健康发展的重要动力\n\n### 发展社会主义民主政治\n\n- 人民民主是社会主义的生命，是我们党始终高扬的光辉旗帜\n- **社会主义民主政治的本质和核心是人民当家作主**\n- 坚持和完善社会主义政治制度\n- 健全社会主义协商民主制度\n- 坚定不移推进**依法治国基本方略**，这是国家长治久安的重要保障\n- 积极稳妥推进政治体制改革\n- 巩固和发展最广泛的爱国统一战线\n\n### 推进社会主义文化强国建设\n\n- 建设社会主义文化强国，是我们党把握时代和形势发展变化，积极回应各族人民精神文化需求作出的重大战略决策\n- 坚定不移走中国特色社会主义文化发展道路\n- 建设**社会主义核心价值体系**\n  - **社会主义核心价值体系是兴国之魂，决定中国特色社会主义发展方向**\n- 坚持不懈用中国特色社会主义理论体系武装全党、教育人民\n- 加强新闻宣传工作\n- 繁荣文化创作\n\n### 构建社会主义和谐社会(重点)\n\n- **胡锦涛：社会和谐是中国特色社会主义的本质属性**\n- 什么是社会主义和谐社会？\n  - **经济建设、政治建设、文化建设、社会建设、生态文明建设**协调发展的社会\n  - **人与人、人与社会、人与自然整体**和谐的社会\n- 社会主义和谐社会的总要求\n  - **民主法治、公平正义、诚信友爱、充满活力、安定有序、人与自然和谐相处**\n- 保障和改善民生\n  - 优先发展教育\n  - 积极扩大就业\n  - 合理收入分配\n  - 完善社会保障\n- 加快和创新社会管理\n\n### 推进生态文明建设\n\n- 建设生态文明，是关系人民福祉、关乎民族未来的长远大计\n- 实质：**建设以资源环境承载力为基础、以自然规律为准则、已持续发展为目标的资源节约型、环境友好型社会**\n- 推动形成人与自然和谐发展现代化建设新格局\n\n### 全面提高党的建设科学化水平\n\n- 党的建设是党领导的伟大事业不断取得胜利的重要法宝\n- **执政能力的建设**是党执政后的一项**根本建设**\n- 保持和发展党的先进性是马克思主义政党自身建设的根本任务和永恒课题\n- 党的优良作风是党始终利于不败之地的重要保证\n\n## 历史地位\n\n- 中国特色社会主义理论体系在**新世纪新阶段**的**持续发展**\n- 全面建设小康社会、加快推进社会主义现代化的**根本指针**\n- 发展中国特色社会主义必须**长期坚持的指导思想**\n\n","categories":["校内课程","毛概"]},{"title":"马原 期末复习","url":"/posts/e27863b7.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 分值分布\n\n- 通知：各位同学请注意马原课期末相关事宜如下\n\n  - 期末考试时间为`1月4日`，请在教务系统中查阅详细时间地点。\n  - 关于课程成绩主要构成情况。期末成绩`50`分，平时成绩`50`分。平时作业须完成的部分包括：`2次`随堂作业，`1次`研学报告（即课程实践），`1次`慕课期末考试（考试开放时间为`2023年12月26日-2024年1月3日`，随机抽题）。\n  - 期末考试为闭卷，基本题型包括单选题（`40分`）、判断题（`10分`）、简答题（`36分`）、材料题（`14分`）。\n  - 课件将以`pdf`形式存放在群文件中，同学们可自行下载，涉及知识产权请勿外传！\n\n<!-- more -->\n\n- 分值具体分布\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231217110444453.png\" alt=\"image-20231217110444453\" style=\"zoom: 80%;\" />\n\n# 导论\n\n## 马克思主义的创立与发展\n\n- 马克思主义诞生于`19世纪40年代`，产生于**资本主义由自由竞争发展到垄断**的时代（选择题选**自由资本主义时代**）\n- 标志：**`1848年`马克思、恩格斯发表的《共产党宣言》**\n\n### 什么是马克思主义\n\n#### 科学内涵\n\n- **马克思主义是由马克思、恩格斯所创立并为后继者所不断发展的科学理论体系**\n\n  - 是关于**自然、社会和人类思维发展一般规律**的学说\n\n  - 是关于**社会主义必然代替资本主义、最终实现共产主义**的学说\n\n  - 是关于**无产阶级解放、全人类解放和每个人自由而全面发展**的学说\n\n  - 是无产阶级政党和社会主义国家的**指导思想**，是指引人民创造美好生活的**行动指南**\n\n- 恩格斯突出重申了马克思作为理论主要创始人的地位和贡献\n\n  - 恩格斯：\"绝大部分基本指导思想(特别是经济和历史领域内)，尤其是对这些指导思想的最后的明确的表述，都是属于马克思的\"\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231217144424494.png\" alt=\"image-20231217144424494\" style=\"zoom:67%;\" />\n\n- 马克思主义的主要内容\n\n  - **马克思主义哲学**（**理论基础**）\n    - 作为科学的世界观和方法论，是马克思主义的理论基础\n\n  - **马克思主义政治经济学**（**理论论证**）\n    - 科学揭示了资本主义生产方式的本质和资本主义剥削的秘密，是马克思主义的深刻论证\n\n  - **科学社会主义**（**理论归宿**）\n    - 指明了无产阶级获得彻底解放的历史条件和历史革命，是马克思主义的目标归宿\n  - 除此之外，还包含着如历史学、政治学、法学、文化学、新闻学、军事学等其他知识领域，并随着实践和科学的发展不断丰富\n\n#### 基本原理\n\n- 马克思主义基本原理是对马克思主义**立场、观点、方法**的集中概括，是马克思主义在其形成、发展和运用过程中**经过实践反复检验**而确立起来的具有**普遍真理性**的理论\n- 马克思主义基本原理体现了马克思主义的**根本性质和整体特征**。相对于特定历史条件下所作的个别理论判断和具体结论，马克思主义基本原理具有**普遍的，根本的和长远的**指导意义\n- 从基本立场，基本观点，基本方法的有机统一中把握马克思主义基本原理\n  - **基本立场**：以无产阶级的解放和全人类的解放为己任，以人的自由全面发展为美好目标，以人民为中心，坚持一切为了人民，一切依靠人民，全心全意为人民谋幸福；它是马克思主义观察，分析和解决问题的根本立足点和出发点\n  - **基本观点**：是关于自然，社会和人类思维发展一般规律的科学认识，是对人类思想成果和社会实践经验的科学总结\n  - **基本方法**：是建立在辩证唯物主义和历史唯物主义世界观方法论基础上，指导我们正确认识，改造世界的思想方法和工作方法\n\n### 马克思主义产生的时代背景\n\n#### 社会根源\n\n- **工业革命和科技进步**极大提高了**劳动生产率**，促进了**生产力的发展**\n\n- 资本主义一方面带来了社会化大生产的**迅猛发展**，另一方面又造成了**严重的社会灾难**\n\n  - **社会两级分化，工人极端困苦**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231217144546457.png\" alt=\"image-20231217144546457\" style=\"zoom:67%;\" />\n\n  - **周期性经济危机频繁爆发**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231217144531794.png\" alt=\"image-20231217144531794\" style=\"zoom: 67%;\" />\n\n\n#### 阶级基础\n\n- 无产阶级反抗资产阶级的主要形式：捣毁机器，经济斗争，政治斗争\n\n- 在无产阶级**反抗资产阶级剥削和压迫**的斗争中，**逐步走向自觉**\n\n- 无产阶级为马克思主义的产生提供了**阶级基础**；无产阶级反对资产阶级的**斗争**为马克思主义的产生提供了**现实需要和实践基础**\n\n- `19世纪`欧洲**三大工人**运动\n\n  - 无产阶级作为**独立的政治力量**登上历史舞台\n\n  - 觉醒了的无产阶级迫切需要总结和升华自身的斗争经验，形成科学的革命理论，以**科学指导**自身的解放斗争\n\n  - 三大工人运动：**`1831年`法国里昂工人运动、`1836年`英国宪章运动、`1844年`德国西里西亚纺织工人运动**\n\n  - 意义和教训\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231217145614840.png\" alt=\"image-20231217145614840\" style=\"zoom:67%;\" />\n\n#### 思想渊源\n\n- 思想来源（**重点**）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231217145705225.png\" alt=\"image-20231217145705225\" style=\"zoom: 80%;\" />\n\n##### 直接理论来源的具体内容（了解）\n\n- 德国古典哲学\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218101703135.png\" alt=\"image-20231218101703135\" style=\"zoom:67%;\" />\n\n- 英国古典政治经济学\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218101721491.png\" alt=\"image-20231218101721491\" style=\"zoom:67%;\" />\n\n- 英、法空想社会主义\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218101747313.png\" alt=\"image-20231218101747313\" style=\"zoom: 67%;\" />\n\n### 马克思主义的形成和完善\n\n- 图\n\n  ![image-20231227164443773](https://cdn.davidingplus.cn/images/2025/02/02/image-20231227164443773.png)\n\n- 两个伟大的发现：**唯物史观**和**剩余价值学说**（揭开资本主义生产的秘密），归功于马克思\n\n  - 由于这两个发现，社会主义**由空想变为了现实**\n\n### 发展历程\n\n#### 第一国际时期和第二国际时期在德国的发展\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218102148307.png\" alt=\"image-20231218102148307\" style=\"zoom:67%;\" />\n\n#### 第三国际时期在德国的发展\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218102236010.png\" alt=\"image-20231218102236010\" style=\"zoom:67%;\" />\n\n#### 列宁对马克思主义的发展\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227165746860.png\" alt=\"image-20231227165746860\" style=\"zoom: 83%;\" />\n\n- **十月革命**是马克思主义指导下的一次**伟大实践**，**使社会主义由理论开始变为现实**\n- 十月革命胜利之后，对于经济文化相对落后的国家如何向社会主义过渡和建设社会主义，列宁又作了有益的探索\n- 列宁在领导俄国革命和社会主义建设过程中将**马克思主义基本原理与俄国具体实际相结合**，创立了**列宁主义**，把马克思主义发展到一个新的历史阶段；列宁去世后，斯大林领导苏联党和人民继承了列宁开创的事业，进行了巩固和建设世界上第一个社会主义国家的创造性探索，取得了辉煌的成就\n- 没有革命的理论，就没有革命的行动\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218102825747.png\" alt=\"image-20231218102825747\" style=\"zoom: 60%;\" />\n\n- **列宁主义是帝国主义和无产阶级革命时代的马克思主义**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218102911420.png\" alt=\"image-20231218102911420\" style=\"zoom:67%;\" />\n\n#### 马克思主义在中国的发展\n\n- 马克思主义在中国的发展过程就是马克思主义中国化的过程\n- **马克思主义中国化 == 马克思主义基本原理 + 中国具体实际 + 中华优秀传统文化**\n- `3次`飞跃（毛概那边把习近平和前面的合起来了，作为`第2次`新的飞跃）\n  - **革命和建设时期的中国化**\n  - **改革开放时期的中国化**\n  - **新时代的中国化（习近平）**\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218103513622.png\" alt=\"image-20231218103513622\" style=\"zoom:67%;\" />\n\n## 努力学好用好马克思主义\n\n### 基本特征\n\n- **科学性，人民性，实践性，发展性**\n- 这些特征体现了马克思主义的本质和使命，展现出马克思主义的理论形象\n\n#### 科学性\n\n- **马克思主义是科学的理论，创造性地揭示了人类社会发展规律**\n- 马克思创建了**唯物史观**和**剩余价值学说**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227170608941.png\" alt=\"image-20231227170608941\" style=\"zoom:80%;\" />\n\n#### 人民性\n\n- **马克思主义是人民的理论，第一次创立了人民实现自身解放的思想体系**\n- 以科学的理论为**最终建立一个没有压迫，没有剥削，人人平等，人人自由的理想社会**指明方向\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227170636159.png\" alt=\"image-20231227170636159\" style=\"zoom:80%;\" />\n\n#### 实践性\n\n- **马克思主义是实践的理论，指引着人民改造世界的行动**\n- **实践性是马克思主义区别于其他理论的显著特征**；实践的观点、生活的观点是马克思主义认识论的基本观点\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227170652137.png\" alt=\"image-20231227170652137\" style=\"zoom:80%;\" />\n\n#### 发展性\n\n- **马克思主义是不断发展的开放的理论，始终站在时代前沿**\n- 马克思主义理论不是教条，而是行动指南，必须随着实践的变化而发展\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227170705684.png\" alt=\"image-20231227170705684\" style=\"zoom:80%;\" />\n\n#### 基本特征的内在关系\n\n- **科学性与革命性的统一**（一句话概括马克思主义的鲜明特征）\n\n  ![image-20231218104510136](https://cdn.davidingplus.cn/images/2025/02/02/image-20231218104510136.png)\n\n### 当代价值\n\n- 总结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227170924457.png\" alt=\"image-20231227170924457\" style=\"zoom:82%;\" />\n\n#### 观察当代世界变化的认识工具\n\n- **马克思主义是科学的世界观和方法论（基础是辩证唯物主义和历史唯物主义），是无产阶级和全人类解放的科学指南**，能够站在科学和时代的制高点上观察事物和现象，具有宏大的视野\n- 马克思主义掌握了人类社会发展的规律，具有唯物辩证的科学方法，善于透过现象看本质，能够从破朔迷离的复杂现象中把握住问题的实质，从局部的变幻中把握住总体和大局\n\n#### 指引当代中国发展的行动指南\n\n- 马克思主义\n\n  - **是中国共产党诞生的理论前提**\n\n  - **为中国共产党提供了思想指导**\n\n  - **为中国共产党提供了精神支柱**\n\n  - **决定了中国共产党的根本宗旨和工作路线**\n\n\n#### 引领人类社会进步的科学真理\n\n- **从运动中看到变化，从变化中看到发展**，这是马克思主义辩证思想的深邃目光；用这样的目光观察当今世界，从中发现其运行和演化的趋势和方向\n- 面对纷繁复杂的当代世界情势，我们必须冷静观察、保持定力，不为流言所惑、不为现象所迷，始终以处理好中国问题为立足点，坚定走我们自己的道路\n\n#### 人类未来仍需马克思主义指引\n\n- 马克思主义致力于：**探寻人类社会的奥秘，揭示人类历史的规律，指明人类前进的方向**\n- 我们依然处在马克思主义所指明的历史时代，要坚持和运用马克思主义立场观点方法观察时代、把握时代、引领时代，回答好\"世界怎么了\"，\"人类向何处去\"的时代之问，推动人类文明发展进步，引领人类走向更加美好的明天\n\n### 对青年成长的指导意义\n\n为青年\n\n- 铸就科学的**理想信念**\n- 提供科学的**思维方法**\n- 提供科学的**实践方法**\n\n### 当代青年如何学习和运用马克思主义\n\n- 学习和掌握马克思主义的基本立场，观点和方法\n- 学习和掌握马克思主义中国化的理论成果\n- 坚持理论联系实际的马克思主义学风\n- 自觉将马克思主义内化于心，外化于行\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218105806112.png\" alt=\"image-20231218105806112\" style=\"zoom: 80%;\" />\n\n# 第一章 世界的物质性\n\n##  马克思主义唯物论\n\n- 世界是全部时间与空间的总称\n- 世界观：**人们对世界的总的看法和根本观点**（世界是什么、世界怎么样的根本观点）\n- 方法论：**人们认识世界和改造世界的根本原则和根本方法**\n\n### 以往的人类如何看世界\n\n#### 演化轨迹\n\n- 注意具体科学和哲学的联系\n\n  - **具体科学揭示的是自然、社会和思维某一具体领域的规律；哲学对其进行概括和升华，从中抽象出最一般的本质和最普遍的规律**\n  - **哲学为具体科学研究提供世界观和方法论的指导**\n\n  ![image-20231227201859170](https://cdn.davidingplus.cn/images/2025/02/02/image-20231227201859170.png)\n\n- 世界观的演化轨迹：神话，宗教，哲学\n\n- 神话世界观\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218112844739.png\" alt=\"image-20231218112844739\" style=\"zoom:67%;\" />\n\n- 宗教世界观\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218112901399.png\" alt=\"image-20231218112901399\" style=\"zoom:67%;\" />\n\n- 哲学世界观\n\n  - 思考和探索**根本性的问题**\n  - 既是理论化与系统化的世界观，又是方法论，即**世界观与方法论的统一**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218112916324.png\" alt=\"image-20231218112916324\" style=\"zoom: 67%;\" />\n\n  - 探究哲学究竟为何物的唯一途径就是**从事哲学研究**\n\n#### 哲学的基本问题：思维和存在的关系问题\n\n- 全部哲学，尤其是近代哲学的重大的基本问题，是**思维和存在的关系问题**\n- **思维和存在何者为第一性的问题：本体论；唯物主义，唯心主义**\n- **思维和存在有无同一性的问题：认识论；可知论，不可知论**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218151936921.png\" alt=\"image-20231218151936921\" style=\"zoom:67%;\" />\n\n- 思维和存在何为第一性的问题\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218152003386.png\" alt=\"image-20231218152003386\" style=\"zoom:67%;\" />\n\n##### 唯物主义\n\n- 唯物主义认为**物质是世界的本原**，意识是派生的，先有物质后有意识，**物质决定意识**\n\n- 三种理论形态：**古代朴素唯物主义，近代形而上学唯物主义，辩证唯物主义**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218152456840.png\" alt=\"image-20231218152456840\" style=\"zoom: 80%;\" />\n\n###### 古典朴素唯物主义\n\n- **物质 == 具体的物质形态**\n\n- 意义和局限\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218152857053.png\" alt=\"image-20231218152857053\" style=\"zoom: 80%;\" />\n\n- 希腊三贤：**苏格拉底，柏拉图，亚里士多德**\n\n  - 苏格拉底\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218154108031.png\" alt=\"image-20231218154108031\" style=\"zoom:67%;\" />\n\n  - 柏拉图\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218154121501.png\" alt=\"image-20231218154121501\" style=\"zoom:67%;\" />\n\n  - 亚里士多德\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218154141554.png\" alt=\"image-20231218154141554\" style=\"zoom:67%;\" />\n\n###### 近代形而上学(机械)唯物主义\n\n- 对宇宙结构的革命性认识\n\n  - 哥白尼《日心说》；伽利略的研究\n\n- 世界本体论认识的革新\n\n  - 道尔顿提出原子论；拉美特利《人是机器》\n\n- **原子就是物质，就是世界的本原**\n\n- **物质 == 原子**\n\n- 意义和局限\n\n  ![image-20231227203312793](https://cdn.davidingplus.cn/images/2025/02/02/image-20231227203312793.png)\n\n###### 辩证唯物主义 \n\n- 列宁关于物质的经典表述（从**物质和意识的关系**出发）：**物质是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，它不依赖于我们的感觉而存在**，为我们的感觉所**复写，摄影，反映**\n\n- **马克思主义物质观**的**理论意义**（重点）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218155029363.png\" alt=\"image-20231218155029363\" style=\"zoom:80%;\" />\n\n##### 唯心主义\n\n- 德国哲学唯心主义的三个重要阶段\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218155408961.png\" alt=\"image-20231218155408961\" style=\"zoom: 80%;\" />\n\n###### 客观唯心主义\n\n- 客观唯心主义把世界的本原归结于**某种独立存在的、客观的精神**，认为物质世界是这种\"精神\"或\"理\"的体现或产物\n\n- 复杂万物的全体归于\"绝对精神\"\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218155647613.png\" alt=\"image-20231218155647613\" style=\"zoom: 80%;\" />\n\n- 理学(道学)：义理之学\n\n###### 主观唯心主义\n\n- 主观唯心主义把**人的主观精神**（意识，观念等）作为认识世界的出发点，认为物质世界是人的主观意识的体现或产物\n\n- \"存在即被感知\"\n\n  ![image-20231218160817971](https://cdn.davidingplus.cn/images/2025/02/02/image-20231218160817971.png)\n\n##### 不可知论\n\n- 认识的合法性基础\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218161620815.png\" alt=\"image-20231218161620815\" style=\"zoom: 80%;\" />\n\n- 康德否认认识与世界的一致性\n\n  - 世界：现象界 + \"物自体\"\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218161645573.png\" alt=\"image-20231218161645573\" style=\"zoom:80%;\" />\n\n##### 可知论\n\n- **人（主体）有认识的能力（能知），物（客体）有可认识的性质（所知）**\n- 哲学认识论：认知主体在认识过程中具有**能动**作用\n\n### 马克思主义唯物论如何看世界\n\n- 马克思以**实践观为基础**，批判了包括**费尔巴哈在内的旧唯物主义**以及以往的一切旧哲学，提出了**新唯物主义的基本构想**，开启了哲学史上革命性变革的序幕\n\n#### 认识和把握世界的两个出发点\n\n- 新唯物主义的世界观，划清两个界限：**同唯心主义的根本对立**和**同包括费尔巴哈在内的旧唯物主义的原则区别**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218163235090.png\" alt=\"image-20231218163235090\" style=\"zoom: 80%;\" />\n\n- 旧唯物主义（**纯客体原则**）：对物质世界只从**纯客体或直观**的形式去理解，而<u>**没有在作客体性把握的同时也作主体方面的把握**</u>，导致了人在物质世界面前的主体能动性的消解；没有看到人的实践活动是对象性活动，不了解实践活动的意义\n\n- 唯心主义（**纯主体原则**）：从**主体**的方面去理解对象，肯定人的活动对对象的能动作用，<u>**但只承认人的意识活动具有能动性，否认人及其意识对对象的受动性和依赖性**</u>，且这种能动作用**仅仅停留在观念地改造对象**，而**不是现实地改变世界**，因而只是抽象地发展了主体能动的方面\n\n- 新唯物主义（**把受动性和能动性辩证统一起来**），并非仅仅是旧唯物主义的\"升级版\"，也非仅仅与唯心主义的彻底决裂，而是对包括费尔巴哈在内的旧唯物主义和能动的唯心主义的双重超越\n\n- 马克思主义唯物论如何认识和把握世界\n\n  - 从**实践**和**主体**出发\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218164213895.png\" alt=\"image-20231218164213895\" style=\"zoom:67%;\" />\n\n- 新唯物主义世界观充分体现了**改变世界的价值追求**\n\n  - 马克思：\"哲学家们只是用不同的方式解释世界，而问题在于改变世界\"\n\n\n#### 马克思主义运动观和时空观\n\n##### 运动\n\n- **运动是物质的根本属性和存在方式**\n\n- 运动是一切事物和现象的变化及其过程的**哲学范畴**\n\n- 运动与物质不可分割\n\n  - **物质是运动的物质，凡是物质都是运动的**\n  - **运动是物质的运动，物质是运动的载体**\n\n- 一些总结\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218165009834.png\" alt=\"image-20231218165009834\" style=\"zoom:80%;\" />\n\n##### 时间和空间\n\n- **时间和空间是物质运动的存在形式**\n\n  - **时间**标志物质运动过程的**持续性、顺序性**，特点是**一维性**，即**不可逆性、一去不复返**\n  - **空间**是指运动着的物质的**广延性、伸张性**，特点是**三维性**\n\n- 时间和空间与物质运动**不可分离**\n\n  - 时间和空间离不开物质的运动，离开物质运动的时间和空间是不存在的\n  - 物质运动也离不开时间和空间，离开空间和时间的物质运动也是不存在的\n\n- 时间和空间的**特性**随着**物质运动的特性的变化而变化**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231218165508382.png\" alt=\"image-20231218165508382\" style=\"zoom: 80%;\" />\n\n#### 马克思主义哲学观\n\n##### 人工智能\n\n- 优势：高效性，可靠性，个性化服务，自主学习，持续发展，可扩展性\n- 局限：有限的尝试和因果推理，有限的自然语言和逻辑推理，缺乏在现实世界中的基础，性能不可靠且无法预测\n- 实质：把人的部分**智能活动机器化**，让机器具有**完成某种复杂目标**的能力，实质上是对**人脑组织结构与思维运行机制**的模仿，是人类智能的物化\n- 本质：**人的意识能动性**的一种特殊体现，是人的本质力量的**对象化和现实化**，不能取代或超越**人类智能**\n- 四点总结\n  - 人类意识是**知情意的统一体**，人工智能只是对人类的理性智能的模拟和拓展，**不具备情感、信念、意志**等人类意识形式\n  - **社会性是人的意识所固有的本质属性**，而人工智能**不可能真正具备人类的社会属性**\n  - 人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能**难以完全具备理解自然语言真实意义**的能力\n  - 人工智能能够获得人类意识中可以**化约为数字信号**的内容，但人脑中总有许多东西**无法被化约**的\n- 人工智能还在发展中，应以**开放、客观**的态度观察、思考和把握其未来发展及其对社会的影响，并引导、规范其向更有利于人类生存和发展的方向发展\n\n##### 物质和意识的辩证关系\n\n- 物质与意识的关系是**辩证统一**的\n\n###### 物质决定意识\n\n- 人类意识的**普遍性**\n\n  - **意识，使世界二重化为客观世界和主观世界**\n\n- 意识的**起源**\n\n  - **自然界长期发展**的产物\n  - **社会历史发展**的产物\n\n- 意识的**本质**\n\n  - **意识是人脑的机能和属性（生理本质），是客观世界的主观映象（社会本质）**\n\n    - **意识是客观内容和主观形式的统一**\n    - 注意：无论是**正确意识还是错误意识**，**都是**对客观物质世界的主观反映\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219102550291.png\" alt=\"image-20231219102550291\" style=\"zoom:67%;\" />\n\n  - **意识在内容上是客观的，在形式上是主观的，是客观内容和主观形式的统一**\n\n  - **意识是物质的产物，但又不是物质本身**\n\n###### 意识对物质具有反作用\n\n- 人能够**能动地认识世界**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219102734326.png\" alt=\"image-20231219102734326\" style=\"zoom:80%;\" />\n\n- 人能够**能动地改造世界**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219102745813.png\" alt=\"image-20231219102745813\" style=\"zoom:67%;\" />\n\n- 意识的**能动作用**（`21年`考了）\n\n  - 意识具有**目的性**和**计划性**\n  - 意识具有**创造性**\n  - 意识具有**指导实践改造世界**的作用\n  - 意识具有**调控人的行为和生理活动**的作用\n  - 意识不仅反映事物的**现象**，还反映事物的**本质和规律**\n\n###### 主观能动性和客观规律性的辩证统一\n\n- 处理好主观能动性和客观规律性的辩证统一关系是正确认识和把握物质与意识的辩证关系的**前提**\n\n  - **尊重客观规律**是正确发挥主观能动性的**前提**\n\n  - 只有发挥主观能动性，才能**正确认识和利用客观规律性**\n\n  - 客观规律性和主观能动性的统一的**基础**是**实践**\n\n- 正确发挥人的主观能动性，三个前提和条件\n\n  - **从实际出发是前提**\n  - **实践是根本途径**\n  - 需要一定的**物质条件和手段**\n\n##### 世界的物质统一性\n\n- 世界的真正统一性在于它的**物质性**，**世界统一于物质**\n\n  - **自然界是物质的**\n\n  - **人类社会**本质上是生产实践基础上形成的物质体系，也是**物质**的\n\n  - **人的意识统一于物质**\n\n- 世界的物质统一性是**多样性的统一**\n\n- 世界的物质统一性原理是**辩证唯物主义最基本、最核心的观点**，是马克思主义的**基石**\n\n- **实践性**是社会生活的**本质**\n\n  - 实践是使物质世界**分化为自然界与人类社会**的历史前提，又是使**自然界与人类社会统一起来**的现实基础\n\n  - 实践是**人类社会的基础**\n\n- 世界的物质性统一原理的**意义**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219105512600.png\" alt=\"image-20231219105512600\" style=\"zoom:67%;\" />\n\n### 为什么要用马克思主义唯物论看世界\n\n- 马克思主义唯物论为人们**把握人与自然、人与社会历史的关系**提供了新的思路\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219105724723.png\" alt=\"image-20231219105724723\" style=\"zoom:80%;\" />\n\n- 马克思主义唯物论的**意义**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219105923896.png\" alt=\"image-20231219105923896\" style=\"zoom: 77%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219105955223.png\" alt=\"image-20231219105955223\" style=\"zoom:80%;\" />\n\n## 唯物辩证法总特征\n\n### 辩证法与形而上学的对立\n\n- 形而上学：用**孤立的、静止的、片面的**观点去观察、认识事物和处理问题\n- 唯物辩证法：用**联系的、发展的、全面的**观点去观察、认识事物和处理问题\n- 对立的焦点：是否认为**矛盾**是客观事物**运动和发展**的动力和源泉\n\n####  形而上学\n\n- 人们通常在两种不同的意义上使用\"形而上学\"的概念\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219110539271.png\" alt=\"image-20231219110539271\" style=\"zoom: 67%;\" />\n\n- **黑格尔第一次**在现代意义上使用形而上学的概念\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227214851059.png\" alt=\"image-20231227214851059\" style=\"zoom:80%;\" />\n\n#### 辩证法\n\n- **苏格拉底最早**提出辩证法的概念\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219110758282.png\" alt=\"image-20231219110758282\" style=\"zoom:76%;\" />\n\n- 黑格尔辩证法\n\n  - 主要贡献\n    - 阐述了自然、社会、思维都处于联系和发展中\n    - 提出了联系、发展的三大规律及基本范畴\n    - 提出了辩证法、逻辑学、认识论相一致的观点\n\n- **黑格尔第一次**把联系、发展、前面和矛盾的内涵**赋予辨证法**\n\n- 严重缺陷\n\n  ![image-20231219111015277](https://cdn.davidingplus.cn/images/2025/02/02/image-20231219111015277.png)\n\n- 辩证法\n\n  - 关于物质世界**普遍联系**的科学\n\n  - 关于物质世界**变化发展**的科学\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219111151678.png\" alt=\"image-20231219111151678\" style=\"zoom:80%;\" />\n\n  - 一个核心问题：**是否承认矛盾？**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219111250777.png\" alt=\"image-20231219111250777\" style=\"zoom:77%;\" />\n\n### 物质世界的普遍联系\n\n- 联系地看问题：遵循事物之间的客观联系\n\n- 事物的重要性源于彼此之间的联系\n\n- 联系是指事物内部各要素之间和事物之间的**相互影响、相互制约、相互作用**的关系\n\n- 联系的特点：**客观性、普遍性、多样性、条件性**\n\n  - **客观性**：从客观事物**本身固有的联系**出发去认识事物\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219113124249.png\" alt=\"image-20231219113124249\" style=\"zoom: 80%;\" />\n\n  - **普遍性**：确立**整体性、系统性、开放性**的观念\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219113137053.png\" alt=\"image-20231219113137053\" style=\"zoom: 67%;\" />\n\n  - **多样性**：要善于分析和把握事物的**具体联系**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219113150490.png\" alt=\"image-20231219113150490\" style=\"zoom:67%;\" />\n\n  - **条件性**：注重分析和把握事物存在和发展的**各种条件**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219113212061.png\" alt=\"image-20231219113212061\" style=\"zoom: 80%;\" />\n\n- **联系的观点**是唯物辩证法的**总特征之一**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219114033430.png\" alt=\"image-20231219114033430\" style=\"zoom: 67%;\" />\n\n### 事物的变化发展\n\n- 事物的**相互联系**构成了运动、变化和发展\n- **对立面的统一和斗争**推动事物的发展\n- **实质：新事物的产生和旧事物的灭亡**\n- 在新陈代谢的发展过程中，**新事物是不可战胜的**\n  - 第一，就新事物**和旧事物的关系**而言，新事物是在旧事物的**基础上**孕育成熟的，是对旧事物的**继承和扬弃**\n  - 第二，就新事物**与环境的关系**而言，新事物之所以新，是因为有**新的要素、结构和功能**，能**适应**已经变化了的环境和条件\n  - 第三，虽然**新事物必然战胜旧事物**，但是新事物的强大也是**从弱小成长起来的**，战胜的**过程充满曲折**\n- **发展的观点是维护辩证法的总特征之一**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219114057440.png\" alt=\"image-20231219114057440\" style=\"zoom:67%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219114241738.png\" alt=\"image-20231219114241738\" style=\"zoom:80%;\" />\n\n## 维护辩证法基本规律\n\n- 基本规律：事物发展中本身所固有的、本质的、必然的、稳定的联系\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219144248321.png\" alt=\"image-20231219144248321\" style=\"zoom:80%;\" />\n\n- 辩证法的规律归结于三大规律\n\n  - **对立统一规律（根本规律）**\n  - **量变质变规律**\n  - **否定之否定规律**\n\n### 对立统一规律\n\n- 是唯物辩证法的**实质和核心**\n\n- 提供了**矛盾分析法**，是**认识世界和改造世界的根本方法**\n\n- **一切对立只具有相对的意义，只有放到特定过程中才能被理解**\n- 意义\n  - 揭示了事物普遍联系的根本内容和变化发展的**内在动力**\n  - 是理解唯物辩证法其他规律和范畴的**一把钥匙**\n  - **提供了认识世界和改造世界的根本方法：矛盾分析法**\n\n#### 矛盾的同一性和斗争性\n\n- 矛盾：事物**内部**和事物**之间**的**对立统一**\n\n- **矛盾的对立属性称为斗争性，统一属性称为同一性**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219145815659.png\" alt=\"image-20231219145815659\" style=\"zoom: 80%;\" />\n\n- 同一性：矛盾着的对立面**相互依存、相互贯通**的性质和趋势\n\n  - 矛盾着的对立面**相互依存**，**互为存在的前提**\n  - 矛盾着的对立面**相互贯通**，**在一定条件下可以相互转化**\n\n- 斗争性：矛盾着的对立面**相互排斥、相互分离**的性质和趋势\n\n  - 两种基本形式：**对抗性（激烈的），非对抗性（不激烈的）**\n\n- 同一性和斗争性并非时而时而的关系，而是**始终的关系**\n\n- 辩证关系\n\n  - **相互联结，相辅相成**\n  - **同一性是有条件、相对的**\n  - **斗争性是无条件、绝对的**\n  - 同一性和斗争性结合，构成了事物的矛盾运动，推动着事物的变化发展\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228094408781.png\" alt=\"image-20231228094408781\" style=\"zoom:80%;\" />\n\n- 同一性的**作用**（重点）\n\n  - 是事物**存在和发展的前提**\n  - 使矛盾双方相互**吸取有利于自身的因素**\n  - 规定着事物**转化的可能**和**发展的趋势**\n\n- 斗争性的**作用**（重点）\n\n  - 促使矛盾双方**力量的变化**，为对立面的转化、事物的质变**创造条件**\n  - 是一种矛盾统一体向另一种矛盾统一体**过渡的决定性力量**，新的矛盾统一体产生，旧事物发展成为新事物\n\n- 关于同一性和斗争性，可以通过生命的一生可以进一步的理解\n\n  - 整个一生各个阶段本身就是矛盾中斗争的过程，但是整体具有矛盾中的同一性\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219151042404.png\" alt=\"image-20231219151042404\" style=\"zoom: 80%;\" />\n\n- 方法论意义\n\n  - 观察和处理问题中，把斗争性和同一性结合起来，**在斗争性中把握同一性，在同一性中把握斗争性**\n\n- 和谐：矛盾的一种特殊表现形式，体现矛盾双方的**相互依存，相互促进，共同发展**\n\n  - 和谐**并不意味**着矛盾的**绝对同一**，和谐是**相对的、有条件的**，只有双方处于平衡、协调、合作的条件下，事物才展现出和谐状态\n\n\n#### 矛盾的普遍性和特殊性\n\n- 普遍性\n\n  - 矛盾存在于一切事物中，**事事有矛盾**\n  - 矛盾存在于一切事物发展过程的始终，**时时有矛盾**\n\n- 特殊性\n\n  - 各个**具体事物**的矛盾，每一个矛盾的**各个方面**在发展的**不同阶段**上各有特点\n\n  ![image-20231219152420781](https://cdn.davidingplus.cn/images/2025/02/02/image-20231219152420781.png)\n\n  - 关于根本矛盾和主要矛盾的区别\n\n    - **根本矛盾**贯穿事物发展过程的**始终**，规定着**事物的性质**，属于定性方面\n    - **主要矛盾**是矛盾体系中处于支配地位，对事物**发展起决定作用的矛盾**，是对一个事物的定量\n\n    - 非根本矛盾、次要矛盾是处于**服从地位的矛盾**，在每一对矛盾中又有矛盾的主要方面与矛盾的次要方面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228095412723.png\" alt=\"image-20231228095412723\" style=\"zoom:78%;\" />\n\n- 辩证关系\n\n  - **普遍性：矛盾的共性；无条件的、绝对的**\n  - **特殊性：矛盾的个性；有条件的、相对的**\n\n  ![image-20231219152636094](https://cdn.davidingplus.cn/images/2025/02/02/image-20231219152636094.png)\n\n- 关于主要矛盾和次要矛盾\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227222938805.png\" alt=\"image-20231227222938805\" style=\"zoom:78%;\" />\n\n  - 方法论意义\n\n    - 坚持 **两点论 和 重点论 相结合**的方法\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219153056343.png\" alt=\"image-20231219153056343\" style=\"zoom:80%;\" />\n\n\n### 量变质变规律\n\n- 事物是质、量、度三种规定性的**统一**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228102146044.png\" alt=\"image-20231228102146044\" style=\"zoom:88%;\" />\n\n- **事物的质和量是统一的，在度中得到体现**\n\n- 定义\n\n  - 量变：事物**数量的增减和组成要素排列次序**的变动，是保持事物**质的相对稳定性的不显著变化**，体现事物发展渐进过程的连续性\n  - 质变：事物**性质的根本变化**，是事物由一种质态向另一种质态的**飞跃**，体现事物发展的渐进过程和连续性的中断\n\n- 辩证关系\n\n  - **量变是质变的必要准备**\n  - **质变是量变的必然结果，并为量变开辟新的道路**\n  - 量变和质变是**相互渗透**的\n    - 在总的量变过程中有阶段性和局部性的部分质变\n    - 在质变过程中有**旧质在量上的收缩和新质在量上的扩张**\n  - 量变和质变是**相互依存、相互贯通**的，量变引起质变，在新质的基础上，事物又开始新的量变，如此交替循环，构成了事物的发展过程；量变质变规律体现了事物发展的渐进性和飞跃性的统一\n\n- 量变引起质变，在新质的基础上，事物又开始新的质变，如此交替循环，构成了事物的发展过程\n\n- 方法论意义\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219155350677.png\" alt=\"image-20231219155350677\" style=\"zoom:80%;\" />\n\n### 否定之否定规律\n\n#### 肯定与否定的相互作用\n\n- 肯定与否定\n\n  - 事物内部都存在肯定因素和否定因素\n\n  - 肯定因素是**维持事物存在的**因素\n\n  - 否定因素是**促使现存事物灭亡**的因素\n\n  - 二者是**对立统一**的\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219160330068.png\" alt=\"image-20231219160330068\" style=\"zoom: 80%;\" />\n\n- **唯物辩证否定观**（重点）\n\n  - 否定是事物的**自我否定、自我发展**，是事物内部**矛盾**运动的结果\n  - 否定是事物**发展的必要环节**，是旧事物向新事物的转变，是**旧质到新质的飞跃**\n  - 否定是**新旧事物联系的环节**，新事物在否定中产生，旧事物在否定中灭亡\n  - 辩证否定的实质是**\"扬弃\"**，既批判又继承，既克服消极因素又保留积极因素\n\n#### 辩证否定观\n\n- **肯定 --> 否定 --> 否定之否定**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219160910298.png\" alt=\"image-20231219160910298\" style=\"zoom: 80%;\" />\n\n  - 结合例子理解\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219161045046.png\" alt=\"image-20231219161045046\" style=\"zoom:80%;\" />\n\n- 否定之否定规律揭示了事物发展的**前进性与曲折性的统一**\n\n  - 前进性体现在**每一次否定都是质变，都把事物推进到新阶段上**；每一个周期都是**开放**的，前一个周期的终点是下一个周期的起点\n  - 否定性体现在**回复性上，其中有暂时的停顿甚至倒退**。这表明，事物的发展**不是直线式上升，而是螺旋式上升**的\n\n- 方法论意义\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227223925845.png\" alt=\"image-20231227223925845\" style=\"zoom:74%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219161525895.png\" alt=\"image-20231219161525895\" style=\"zoom:80%;\" />\n\n## 辩证思维方法\n\n### 唯物辩证法基本范畴\n\n- 唯物辩证法除了**基本规律**（上面的三大规律），还有**基本范畴**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219164714900.png\" alt=\"image-20231219164714900\" style=\"zoom:80%;\" />\n\n- 五大基本范畴（记忆）\n\n  - **内容与形式**\n  - **本质与现象**\n  - **原因与结果**\n  - **必然与偶然**\n  - **现实与可能**\n\n- 基本范畴的**比较分析**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219164934400.png\" alt=\"image-20231219164934400\"  />\n\n- **马克思、恩格斯揭示**\n\n  - **客观辩证法和主观辩证法的统一**\n\n    ![image-20231219165947487](https://cdn.davidingplus.cn/images/2025/02/02/image-20231219165947487.png)\n\n  - 唯物辩证法的**本质特征**：**批判的、革命的**\n\n### 学会运用辩证思维方法\n\n- 学习运用思维辨证方法\n\n- 四个思维辨证方法（记忆）\n\n  - **归纳与演绎**\n  - **分析与综合**\n\n  - **抽象与具体**\n\n  - **逻辑与历史相统一**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219170250102.png\" alt=\"image-20231219170250102\" style=\"zoom:80%;\" />\n\n- 辩证思维方法与现代科学思维方法\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219170316897.png\" alt=\"image-20231219170316897\" style=\"zoom: 80%;\" />\n\n- **辩证思维方法是现代科学思维方法的基础和原则，现代科学思维方法是辩证思维方法的深化和展开，二者相互联系、相互补充**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219170438102.png\" alt=\"image-20231219170438102\" style=\"zoom:80%;\" />\n\n### 不断增强思维能力\n\n- 在实践中不断增强思维能力\n\n- 六大思维能力\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219170653251.png\" alt=\"image-20231219170653251\" style=\"zoom:80%;\" />\n\n- **辩证思维能力**\n\n- **历史思维能力**\n\n- **系统思维能力**\n\n- **战略思维能力**\n\n- **底线思维能力**\n\n- **创新思维能力**\n\n- 补充\n\n  - 关于辩证思维能力\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219170837581.png\" alt=\"image-20231219170837581\" style=\"zoom: 67%;\" />\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219170846980.png\" alt=\"image-20231219170846980\" style=\"zoom: 67%;\" />\n\n  - 矛盾分析方法\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219170907038.png\" alt=\"image-20231219170907038\" style=\"zoom:67%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231219171016177.png\" alt=\"image-20231219171016177\" style=\"zoom:80%;\" />\n\n# 第二章 实践与认识\n\n- **实践性**是马克思主义理论**区别于其他理论**的**根本特征**\n- 人如何面对世界？我们为何要认识世界，为何能认识世界，如何认识世界？还有我们如何改造世界？等这涉及到马克思主义认识论的基本立场和观点，即**科学实践观、认识本质论和认识过程论**\n\n## 实践与认识\n\n### 科学的实践观及其意义\n\n实践是\n\n- 感性的、对象化的物质活动\n- **人类能动地改造世界的社会性的物质活动（内涵）**\n- 人类**所特有**的对象化活动\n\n#### 创立与发展\n\n- 在**《关于费尔巴哈的提纲》**中，马克思系统论述了**实践**的观点，创立了**科学的实践观**，揭示了人类实践的本质和作用\n\n  - 马克思批判费尔巴哈以及其他旧唯物主义的**直观性和不彻底性**\n  - 强调了实践的重要意义，强调了实践在检验认识真理性中的**决定**作用\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220104735488.png\" alt=\"image-20231220104735488\" style=\"zoom:85%;\" />\n\n  - 该提纲的作用\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220105319225.png\" alt=\"image-20231220105319225\" style=\"zoom:80%;\" />\n\n- 科学的实践观是**不断丰富发展**的\n\n  - 列宁在《唯物主义和经验批判主义》中，阐述了实践基础上认识的辨证运动和发展\n  - 毛泽东对社会实践在人类认识过程中的重要地位和决定性作用作了系统阐述\n  - 邓小平坚持真理标准问题大讨论，强调实践是检验真理的唯一标准，强调思想和实际上符合，主管和客观相符合\n  - 习近平重视实践第一的观点，强调实践创新的重要意义\n\n- 一张图总结\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228195154524.png\" alt=\"image-20231228195154524\" style=\"zoom:78%;\" />\n\n#### 意义\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220105355527.png\" alt=\"image-20231220105355527\" style=\"zoom: 78%;\" />\n\n### 实践的本质与基本结构\n\n#### 本质\n\n- 本质：**实践是感性的、对象化的，人类能动地改造世界的社会性的客观物质活动**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220105609599.png\" alt=\"image-20231220105609599\" style=\"zoom:90%;\" />\n\n- 基本特征\n\n  - **客观实在性**\n\n    - 实践是人类改造世界的客观物质活动，虽然是人类有目的、有意识的行为，但是**本质上是客观的、物质的活动**\n\n  - **自觉能动性**\n\n    - 人的实践活动是一种有目的、有意识的活动，**目的性是能动性的主要表现**\n    - 而**动物活动是本能的、被动的适应性活动**\n\n  - **社会历史性**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220105916340.png\" alt=\"image-20231220105916340\" style=\"zoom:82%;\" />\n\n#### 基本结构\n\n- 人的实践活动是以**改造客观世界为目的**的客观过程，是实践的**主体与客体之间的相互作用**，这种相互作用必须借助于**一定的手段和工具**，即实践的**中介**。三者有机统一构成实践的基本结构\n\n- 基本结构：实践的**主体，中介，客体**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228201254019.png\" alt=\"image-20231228201254019\" style=\"zoom:73%;\" />\n\n- 三者的联系\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220110401586.png\" alt=\"image-20231220110401586\" style=\"zoom:73%;\" />\n\n- 实践的主体和客体相互作用\n\n  - 主体和客体的关系：**实践关系，认识关系，价值关系**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228202115154.png\" alt=\"image-20231228202115154\" style=\"zoom:77%;\" />\n\n- 实践的主体、客体和中介是不断**变化发展**的\n\n  - 主要表现：**主体客体化**和**客体主体化**的**双向运动**\n  - 这种双向运动是人类实践活动中两个不可分割的方面，它们互为前提，互为媒介，人类通过这种方式不断解决现实世界的矛盾\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228204520032.png\" alt=\"image-20231228204520032\" style=\"zoom:75%;\" />\n\n#### 多样性\n\n- 三种基本类型\n\n  - **物质生产实践**\n\n    - **人类最基本的实践活动**；解决**人与自然**的矛盾，满足人们的物质生活资料和生产劳动资料的需要\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220111810681.png\" alt=\"image-20231220111810681\" style=\"zoom:80%;\" />\n\n  - **社会政治实践**\n\n    - 解决**人与人**的矛盾\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220111821339.png\" alt=\"image-20231220111821339\" style=\"zoom:75%;\" />\n\n  - **科学文化实践**\n\n    - 解决**人对精神文化产品**的需求\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220111833873.png\" alt=\"image-20231220111833873\" style=\"zoom:80%;\" />\n\n- 三种实践形式之间的联系\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220111924397.png\" alt=\"image-20231220111924397\" style=\"zoom:80%;\" />\n\n- 虚拟实践\n\n  - **现代信息技术的发展**催生的一种新的实践形式\n  - 实质：主体和客体之间通过**数字化中介系统**在**虚拟空间**进行的双向对象化的活动\n  - 主要活动范围：**网络世界**\n  - 具有**交互性、开放性、间接性**等特点\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220112742156.png\" alt=\"image-20231220112742156\" style=\"zoom:80%;\" />\n\n#### 实践对认识的决定性作用\n\n- 辩证唯物主义认为：**在实践和认识之间，实践是认识的基础，实践对认识起决定性的作用**\n\n- 表现在四个方面\n\n  - **实践是认识的来源**\n\n    - **认识的内容是在实践活动的基础上产生和发展的**，人们只有通过实践实际地改造和变革对象，才能准确把握对象的属性、本质和属性，形成正确的认识\n    - 离开实践的认识是不可能产生的，一切真知都是从直接经验发源的\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220113427516.png\" alt=\"image-20231220113427516\" style=\"zoom:80%;\" />\n\n  - **实践是认识发展的动力**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220113650100.png\" alt=\"image-20231220113650100\" style=\"zoom:80%;\" />\n\n  - **实践是认识的目的**\n\n    - 人们通过实践获得认识，最终目的是**为实践服务、指导实践，以满足人们生活和生产的需要**\n\n  - **实践是检验认识真理性的唯一标准**\n\n    - 认识的真理性，不能从认识本身得到证实，也不能从实践对象中得到回答，**只有在实践中才能得到验证**\n\n### 认识的本质与过程\n\n#### 两条不同的认识路线\n\n- 派别分为唯物主义和唯心主义\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228205551667.png\" alt=\"image-20231228205551667\" style=\"zoom:80%;\" />\n\n- 唯心主义对认识本质的回答\n\n  - 主观唯心主义：认为人的认识是**主观自生**的，是**生而自知**\n  - 客观唯心主义：认为人的认识是**上帝的启示或者某种客观精神的产物**\n\n- 唯物主义对认识本质的回答\n\n  - 唯物主义：认为**认识是主体对客体的反映**，人的一切认识都是**从外部世界中得来**的，都是对外部世界的反映，**不承认\"生而知之\"**\n  - 旧唯物主义\n    - 基本特点：以**感性直观**为基础，把人的认识看成**消极的、被动地反映和接受外界对象**，又称为**直观的、消极被动的反映论**\n    - 缺陷\n      - **离开实践**考察问题，不了解实践对认识的决定作用\n      - 不了解认识是一个辨证发展的过程\n  - 辩证唯物主义\n    - 两个突出特点\n      - 把**实践**的观点引入认识论\n      - 把**辩证法**应用于考察认识过程\n    - 建立在**实践基础**上的**能动的反映论**\n\n#### 认识的本质\n\n- 认识：主体在**实践**基础上对客体的**能动反映**\n\n- 两个基本特征：**反映性，能动性**\n\n- 反映性\n\n  - 是人类认识的**基本规定性**\n  - 反映性是指人的认识必然要以客观事物为原型和摹本，在思维中再现或摹写客观事物的状态、属性和本质\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220150202469.png\" alt=\"image-20231220150202469\" style=\"zoom:80%;\" />\n\n- 能动性\n\n  - 认识是一种在思维中的**能动的、创造性的活动**，而**不是**主观对客观对象简单、直接的描摹或照镜子式的**原物反映**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220150721848.png\" alt=\"image-20231220150721848\" style=\"zoom:85%;\" />\n\n- 反映性和创造性的辩证统一\n\n  - 反映和创造不是人类认识的两种不同的本质，而是**同一本质的两个不同方面**\n    - **创造离不开反映，创造存在于反映当中**，创造过程是在相互联系的多个方面的反映基础上实现的\n    - **反映离不开创造，反映是在创造过程中实现的**\n  - 人的认识是反映性与创造性的辩证统一\n\n### 实践与认识的辨证运动\n\n- 人们认识一定事物的过程，是一个**从实践到认识，再从认识到实践**的过程\n\n#### 第一次飞跃：从实践到认识\n\n- 认识的过程首先是从实践到认识\n\n- 在实践基础上，由**感性认识能动地飞跃到理性认识**，也就是\"从生动的直观到抽象的思维\"，这是第一次飞跃\n\n- **感性认识**\n\n  - 形式：**感觉、知觉、表象**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220152839763.png\" alt=\"image-20231220152839763\" style=\"zoom:75%;\" />\n\n  - 如果仅停留在感性认识 --> **经验主义**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231230115847834.png\" alt=\"image-20231230115847834\" style=\"zoom:77%;\" />\n\n  - 当然，如果仅停留在理性认识 --> **教条主义**\n\n- **理性认识**\n\n  - 形式：**概念，判断，推理**\n    - 内容：事物的**本质、全体、内部联系和自身规律性**\n    - 特征：**间接性，抽象性**\n    - 地位：认识的**高级阶段**\n\n- 感性认识向理性认识**飞跃的两个条件**\n\n  - **投身实践，深入调查**，获取十分丰富和合乎实际的感性材料\n  - 经过思考的作用，运用**理论思维和科学抽象**，将丰富的感性材料加以去粗取精、去伪取真、由此及彼、由表及里的改造制作，形成系统的概念和理论\n\n- 不管是感性认识还是理性认识，都存在**非理性因素**的作用\n\n  - 非理性因素的作用\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228210723157.png\" alt=\"image-20231228210723157\" style=\"zoom:77%;\" />\n\n- 感性认识和理性认识的**辩证关系**（重点，注意谁依赖于谁，谁发展为谁这些细节，可能选择题误导人）\n\n  - **理性认识依赖于感性认识**\n  - **感性认识有待于发展和深化为理性认识**\n  - **感性认识和理性认识相互渗透、相互包含**\n\n#### 第二次飞跃：从认识到实践\n\n- 从认识到实践的飞跃，是**更为重要的飞跃**，意义**更加重大**\n  - 第一，认识世界的**目的是改造世界**\n  - 第二，理性认识只有回到实践中，才能**发挥对实践的能动作用**，指导人们的实践活动，转化为改造世界的物质力量，实现认识的目的；也只有将理性认识回到实践之中,才能使认识得到检验、完善、丰富和发展\n\n#### 认识运动的不断反复和无限循环\n\n- 既完成了，又没有完成\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228210925840.png\" alt=\"image-20231228210925840\" style=\"zoom:75%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220162620374.png\" alt=\"image-20231220162620374\" style=\"zoom:85%;\" />\n\n## 真理与价值\n\n### 真理的客观性、绝对性、相对性\n\n- 实践、认识、再实践、再认识的过程，也就是通过实践而发现真理，又通过实践而证实和发展真理的过程\n- 真理的**含义**\n  - 标志**主观与客观相符合**的哲学范畴\n  - 对**客观事物及其规律**的**正确反映**\n\n#### 客观性\n\n- 真理是不是客观的，这是真理观中的首要问题；关于这个问题，一切唯物主义都做了肯定回答，一切唯心主义都做了否定回答\n\n- **客观性**（**真理的本质属性**）：**真理的内容是对客观事物及其规律的正确反映，真理中包含着不依赖于人和人的意识的客观内容**（最后这个客观是说真理是客观的）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220164900808.png\" alt=\"image-20231220164900808\" style=\"zoom:65%;\" />\n\n- 真理的**一元性**\n\n  - **真理的客观性决定了真理的一元性**\n  - 指：在**同一条件下**对于**特定的认识客体**的真理性认识**只有一个**，而不可能有多个；即与特定的认识客体的状态、本质和规律相一致的认识才是真理，真理是一元的是针对真理的客观内容而言的\n\n- 真理是**内容上的一元性**与**形式上的多样性**的统一\n\n  - 真理的**表现形式**是**主观**的\n    - 真理通过感觉、感知、表象，概念、判断、推理等主观形式表达\n\n    - 真理的主观形式是**一切认识固有**的\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231220165243098.png\" alt=\"image-20231220165243098\" style=\"zoom: 67%;\" />\n\n- 既不能因真理的客观性而把真理等同于客观实在，也不能因为真理具有主观形式而把真理认为主观产物\n\n#### 绝对性与相对性\n\n- 真理具有**客观性**，这是**真理问题上的唯物论**\n\n- 真理是一个**过程**。就真理的发展过程以及人们对它的认识和掌握程度来说，真理既具有绝对性，又具有相对性，他们是同一客观真理的两种属性，这是真理问题上的**辩证法**\n\n- 任何真理都是**绝对性和相对性的统一**。二者相互联系，不可分割\n\n- 绝对性\n\n  - 绝对性：**真理主客观统一的确定性和发展的无限性**\n\n  - 两个方面的含义\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221095033805.png\" alt=\"image-20231221095033805\" style=\"zoom:67%;\" />\n\n- 相对性\n\n  - 相对性：**人们在一定条件下对客观事物及其本质和发展规律的正确认识总是有限的，不完善的**\n\n  - 两个方面的含义\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221095143988.png\" alt=\"image-20231221095143988\" style=\"zoom:67%;\" />\n\n- 辩证关系\n\n  - **二者相互依存，相互包含**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221095543583.png\" alt=\"image-20231221095543583\" style=\"zoom:75%;\" />\n\n- 真理发展的规律\n\n  - 真理永远处在由**相对向绝对**的转化和发展中\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221100137219.png\" alt=\"image-20231221100137219\" style=\"zoom:67%;\" />\n\n  - 真理的绝对性与相对性根源于**人认识世界的能力的无限性与有限性、绝对性与相对性**的矛盾\n\n- 两种错误\n\n  - 割裂真理的绝对性与相对性的辩证关系，就会走向**形而上学的真理观**，即**绝对主义与相对主义**\n  - 绝对主义片面夸大真理的绝对性，否认真理的相对性\n  - 相对主义片面夸大真理的相对性，否认真理的绝对性\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221100444653.png\" alt=\"image-20231221100444653\" style=\"zoom:75%;\" />\n\n- 马克思主义是**绝对性与相对性的统一**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221100603043.png\" alt=\"image-20231221100603043\" style=\"zoom: 70%;\" />\n\n#### 真理与谬误\n\n- 谬误：是同客观事物及其发展规律**相违背的认识**，是对客观事物及其发展规律的**歪曲反映**\n\n- 坚持和发展真理，就必须同谬误斗争\n\n- **真理和谬误**是人类认识中的一对**永恒矛盾**，既对立又统一\n\n  - 真理与谬误**相互对立**\n    - 在**确定的对象和范围**内，真理与谬误的**对立是绝对**的。与对象相符合的认识就是真理，不符合的认识就是谬误。在确定的条件下，一种认识不能既是真理又是谬误，他们之间有着原则界限，否认这一点就会混淆是非，颠倒黑白\n  - 真理与谬误的**对立是相对的**，在一定条件下能**相互转化**\n    - 对立只在非常有限的范围才具有绝对的意义，超出这个范围，就是相对的，它们二者之间在一定条件能相互转化\n\n- **真理总是同谬误比较而存在，是相互斗争而发展的**\n\n- 结合例子理解\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221101424759.png\" alt=\"image-20231221101424759\" style=\"zoom:70%;\" />\n\n### 真理的检验标准\n\n#### 哲学史上关于真理标准问题的争论\n\n- 主观真理标准论\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221103512180.png\" alt=\"image-20231221103512180\" style=\"zoom:67%;\" />\n\n- 旧唯物主义真理标准\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221103534200.png\" alt=\"image-20231221103534200\" style=\"zoom:75%;\" />\n\n#### 实践是检验真理的唯一标准\n\n- 实践之所以能作为检验真理的唯一性标准，是由**真理的本质和实践的特点**决定的\n- 从真理的本质看\n  - 真理是人们对客观事物及其发展规律的正确反映，它的**本性在于主观和客观相符合**\n- 从实践的特点看\n  - 实践是人们改造世界的客观的物质性活动，具有**直接现实性**的品格\n- 在实践检验真理的过程中，**逻辑证明**可以起到重要的**补充作用**\n  - 逻辑证明：运用**已知**的正确概念和判断，通过一定的**推理**，**从理论上**确定另一个判断的正确性的方法\n  - **逻辑证明只能回答前提与结论的关系是不是符合逻辑的问题，不能回答结论是不是符合客观实际的问题**\n    - 已经逻辑证明了的东西，必须要经过实践的检验才能说是结论符合客观实际\n  - 因此，**只有实践是检验真理的唯一标准**\n\n#### 实践标准的确定性与不确定性\n\n- 实践作为检验真理的标准，既是确定性的，又是不确定性的，是二者的统一\n\n- 确定性\n\n  - **确定性即绝对性**\n  - 指实践作为检验真理标准的**唯一性、归根到底性、最终性**；**离开实践，再也没有其他合理的标准**\n  - 由实践标准的**客观性和唯一性**决定\n\n- 不确定性\n\n  - **不确定性即相对性**\n\n  - 指实践作为检验真理标准的**条件性**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228213515958.png\" alt=\"image-20231228213515958\" style=\"zoom:95%;\" />\n\n- 实践是检验真理的唯一标准，但实践对真理的检验不可能一次性完成，实践检验真理是一个**永无止境的发展过程**\n\n- 实践对真理的检验，是人类社会历史的实践对真理的检验。**实践不断发展，真理也不断发展**，在发展的实践中不断验证认识的真理性。这就是实践检验真理的**辩证发展过程**\n\n- 坚持实践是检验真理的唯一标准，既要看到实践标准的**确定性**，防止和反对否认真理标准问题的**唯心主义、怀疑主义和相对主义**，又要看到实践标准的**不确定性**，防止和反对**教条主义和独断论错误**\n\n### 真理与价值的辩证统一\n\n#### 价值\n\n- 含义：作为哲学范畴，是指在**实践基础**上形成的**主体和客体**之间的**意义关系**，是**客体**对个人、群体乃至整个社会的生活和活动所具有的**积极意义**\n- 在价值的本质问题上，存在**客观**主义价值论和**主观**主义价值论的对立\n  - 客观主义价值论：价值是可以本身固有的，与主体无关\n  - 主观主义价值论：价值就是主体的欲望、情感和兴趣，与客体无关\n- 本质：价值体现的是**主体和客体之间的一种特定关系**，表现为**人与满足其某种需要的客体之间的意义关系**\n  - 价值离不开**主体的需要**，也离不开**客体的特性**，即客体的某种性质、结构和属性\n  - 价值既具有**主体性特征**又具有**客观基础**\n\n##### 基本特性\n\n- 实践是以满足人类需要，以**建立价值**为目的的活动\n\n- 四个特性\n\n  - **主体性**\n\n    - **主体的需要是价值的现实构造因素**\n      - 价值关系的形成依赖于**主体存在**\n      - 价值关系的形成依赖于**主体创造**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228215127086.png\" alt=\"image-20231228215127086\" style=\"zoom:72%;\" />\n\n  - **客观性**\n\n    - 指**一定条件下客体对主体的意义不依赖于主体的主观意识而存在**\n    - **客体的属性是价值的基础和载体**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228215145066.png\" alt=\"image-20231228215145066\" style=\"zoom:71%;\" />\n\n  - **多维性**\n\n    - 每个主体的价值关系都具有多样性\n    - 同一客体相对于主体的**不同需要**会产生**不同的价值**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228215159896.png\" alt=\"image-20231228215159896\" style=\"zoom:72%;\" />\n\n  - **社会历史性**\n\n    - 主体和客体的**不断变化**决定了价值的社会历史性特点\n    - 哲学上的价值概念具有最大的普遍性，是对各种特殊的价值现象的本质概括\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231228215213752.png\" alt=\"image-20231228215213752\" style=\"zoom:72%;\" />\n\n#### 价值评价及其特点\n\n- 价值评价\n  - 指**主体对客体的价值以及价值大小所作的评判或判断**，也叫做价值判断\n  - 是对客观价值关系的**主观反映**，因此评价的**差异性是无法避免**的\n- 特点\n  - 评价以**主客体之间的价值关系**为认识对象\n  - 评价结果与**评价主体直接相关**\n  - 评价结果正确与否依赖于对**客体状况和主体需要**的认识\n  - 价值评价有**科学和非科学**之分\n    - 评价作为一种价值判断活动，虽有主观性，但**不是一种主观随意的认识活动**，只有**正确反映价值关系的评价**才是正确的评价\n- 价值评价要**以真理为依据**，与**社会历史发展的客观规律**一致，要以**人民群众的需要和利益**为根本，这是价值评价的**根本特征**，是应该遵循的**基本原则**\n\n#### 价值观与核心价值观\n\n- 价值观：人们关于**价值本质的认识**以及对**任何事物的评价标准、评价原则和评价方法**的观点的**体系**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221130143216.png\" alt=\"image-20231221130143216\" style=\"zoom:75%;\" />\n\n- 社会主义核心价值观：富强，民主，文明，和谐，自由，平等，公正，法治，爱国，敬业，诚信，友善\n\n#### 真理与价值在实践中辩证统一\n\n- 人们的实践活动总是受**真理尺度**和**价值尺度**制约\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221130730112.png\" alt=\"image-20231221130730112\" style=\"zoom:70%;\" />\n\n- 任何成功的实践都是**真理尺度和价值尺度的统一**，是**规律性和目的性的统一**\n\n- 真理与价值或真理尺度与价值尺度是紧密联系、不可分割的辩证统一关系\n\n- 真理尺度与价值尺度的统一是**具体的、历史的**，会随着实践的发展不断发展到更高级的程度\n\n- 价值尺度必须以真理为前提；人类自身需要的内在尺度，推动者人们不断发现新的真理\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221131057495.png\" alt=\"image-20231221131057495\" style=\"zoom:75%;\" />\n\n## 认识世界和改造世界\n\n- 认识世界和改造世界是人类创造历史的两种基本活动，是相辅相成，辩证统一的\n\n### 认识世界的目的在于改造世界\n\n#### 客观世界与人类的存在状态\n\n- 人类的需要与客观世界始终处于矛盾状态中。人类若满足自身需要，**必须解决主观和客观的矛盾**，即进行认识世界和改造世界的活动\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221131757280.png\" alt=\"image-20231221131757280\" style=\"zoom:75%;\" />\n\n#### 认识世界和改造世界\n\n- 认识世界：**主动能动地反映客体，获得关于事物的本质和发展规律的科学知识，探索和掌握真理**\n\n- 改造世界：**人类按照有利于自己生存和发展的需要，改变事物的现存形式，创造自己的理想世界和生活方式**\n\n- **相互依赖，相互制约**的**辩证统一**的关系\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229102317242.png\" alt=\"image-20231229102317242\" style=\"zoom:75%;\" />\n\n#### 改造客观世界和改造主观世界\n\n- 认识世界的目的是改造世界，改造世界又包括**改造客观世界**和**改造主观世界**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229103051393.png\" alt=\"image-20231229103051393\" style=\"zoom:73%;\" />\n\n- 客观世界和主观世界的关系\n\n  - 二者是**对立的**\n    - 客观世界与主观世界具有不同的**存在方式**，二者发展也具有**不完全同步性**\n  - 二者是**统一的**\n    - 主观世界与客观世界在反映与被反映的意义上具有**同构性**，主观世界的运动规律与客观世界的运动规律也具有**同一性**\n  - 客观世界和主观世界在一定条件下可以**相互转化**；二者**相辅相成、相互促进**，缺一不可\n\n- 方法论**意义**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221150150677.png\" alt=\"image-20231221150150677\" style=\"zoom:75%;\" />\n\n#### 认识世界和改造世界的过程是必然走向自由的过程\n\n- 错误的自由观\n\n  - 倡导消极地顺应自然，抹杀人类自由可能性的**宿命论**\n  - 强调人的意志或某种精神力量绝对自由的**唯意志论**，否定客观必然性，片面强调主体性的毫无限制\n\n- 马克思主义的自由观\n\n  - 自由是表示**人的活动状态的范畴**，是指人在活动中**通过认识和利用必然所表现出的一种自觉自主的状态**\n  - 人**不能摆脱必然性的制约**，只有**在认识必然性的基础上才有自由的活动**，这就是人的自由限度，也是自由和必然的辨证规律\n\n- 实现自由的三重含义\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221151018104.png\" alt=\"image-20231221151018104\" style=\"zoom: 70%;\" />\n\n- 获得**真正自由**的条件\n\n  - **认识条件（获得自由的前提）**：对客观事物运动发展**规律性、必然性**的**正确认识**\n  - **实践条件（真正实现自由）**：能够将获得的规律性认识**运用于指导实践**，实现改造世界的目的\n\n- **认识必然和争取自由**，是人类认识世界和改造世界的**根本目标**；是一个历史的过程\n\n- 自由是**相对的**，不是绝对的，随着实践的深入，自由会不断扩大\n\n- 人类在不断追求自由中完善自己，也在不断**解决必然与自由的矛盾**过程中推动社会发展\n\n### 一切从实际出发，实事求是\n\n#### 一切从实际出发是马克思主义认识论的根本要求\n\n- 一切从实际出发，就是要把**客观存在的事物**作为观察和处理问题的**根本出发点**，这是马克思主义认识论的**根本要求和具体体现**\n  - 即从客观事物存在和发展的规律出发，在实践中按照客观规律办事\n- 运用马克思主义，必须**从实际出发**\n- 从实际出发，关键是注重事实，**从事实出发**\n\n#### 实事求是是中国共产党思想路线的核心\n\n- 基本内涵：**一切从实际出发，理论联系实际，实事求是，在实践中检验和发展真理**\n- 这条思想路线是中国共产党对马克思主义理论发展作出的重大贡献，其**核心是实事求是**\n\n### 坚持守正创新，实现理论创新和实践创新的良性互动\n\n- 人类认识世界和改造世界的过程，就是一个不断坚持守正创新、实现理论创新和实践创新的良性互动的过程\n\n#### 坚持守正创新\n\n- 坚持**守正不动摇**\n  - 守正：坚持实事求是，坚持真理性认识，坚持正确政治方向\n- 坚持**创新不停步**\n  - 创新：坚持解放思想，破除与客观事物进程不相符合的旧观念、旧模式、旧做法，发现和运用事物的新联系、新属性、新规律，更有效地认识世界和改造世界\n- 守正创新就是坚持守正与创新的辩证统一\n  - 守正与创新是相辅相成的\n  - 守正是创新的前提和基础\n  - 创新是守正的目的和路径\n\n#### 努力实现理论创新和实践创新\n\n- **理论创新和实践创新**集中体现了人类在认识世界和改造世界过程中的**两个基本方面**\n\n- **实践基础上的理论创新**，是**社会发展和变革的先导**，是引领国家和民族不断前进的灯塔\n\n- 三点\n\n  - **实践创新为理论创新提供不竭的动力源泉**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221153619177.png\" alt=\"image-20231221153619177\" style=\"zoom:70%;\" />\n\n  - **理论创新为实践创新提供科学的行动指南**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221153632347.png\" alt=\"image-20231221153632347\" style=\"zoom:73%;\" />\n\n  - 理论创新和实践创新不是孤立进行的，而是在与另一方的**互动中完成**，二者相互促进、辩证统一，不断实现更高阶段的创新发展\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221153653816.png\" alt=\"image-20231221153653816\" style=\"zoom:73%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221153828810.png\" alt=\"image-20231221153828810\" style=\"zoom:73%;\" />\n\n# 第三章 人类社会\n\n## 人类社会的存在与发展\n\n### 社会存在与社会意识\n\n- 社会历史观，是人们对社会的**起源、本质和发展**等一般问题的总的看法和根本观点\n- **社会历史观的基本问题：社会存在与社会意识的关系问题**\n\n#### 两种根本对立的历史观\n\n- **唯物史观**和**唯心史观**的**根本对立**\n\n- 唯心史观\n\n  - 主张**社会意识决定社会存在**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221161856055.png\" alt=\"image-20231221161856055\" style=\"zoom:85%;\" />\n\n  - 主要缺陷\n\n    - 最多就只考察人们活动的**思想动机**，而**没有进一步追究**思想动机背后的**物质动因**\n    - **只看到个人**在历史上的作用，而**忽视人民群众**创造历史的决定作用\n\n- 马克思科学地解决了**社会存在与社会意识**的关系问题，创立了**唯物史观**\n\n  - 唯物史观主张**社会存在决定社会意识**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221162352984.png\" alt=\"image-20231221162352984\" style=\"zoom: 80%;\" />\n\n  - 不是人们的意识决定人们的存在，相反，是人们的社会存在决定人们的意识\n\n  - 补充\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221162728590.png\" alt=\"image-20231221162728590\" style=\"zoom:80%;\" />\n\n#### 社会存在\n\n- 社会存在：**社会物质生活条件，是社会生活的物质方面**；主要包括**自然地理环境、人口因素和物质生产方式**\n\n- 自然地理环境\n\n  - 指人类社会所处的地理位置相联系的**自然条件的总和**\n\n  - 包括气候、土壤、地形地貌、狂藏和动植物资源等\n\n  - 四点作用\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221164948261.png\" alt=\"image-20231221164948261\" style=\"zoom:84%;\" />\n\n  - **自然地理环境不能决定社会发展方向**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221165137303.png\" alt=\"image-20231221165137303\" style=\"zoom:65%;\" />\n\n- 人口因素\n\n  - 指与人类社会生存和发展相关的**人口条件的总和**\n\n  - **一定数量**的人口是社会物质生产的**必要前提**\n\n  - 人口数量、素质、结构等状况对社会发展有**加速（适度）或延缓（过密或过疏）**的作用\n\n  - 人口决定论：人口是决定社会性质和社会制度更替的根本原因（这个不对，这个是人口决定论的观点）\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221165832707.png\" alt=\"image-20231221165832707\" style=\"zoom:85%;\" />\n\n- 物质生产方式\n\n  - 即\"物质生活的生产方式\"，指人们为了获得**物质生活资料**而进行的生产活动的方式，是**生产力和生产关系的统一体**\n  - **物质生产方式**是社会历史发展的**决定力量**\n    - 物质生产活动及生产方式是人类社会赖以产生和存在的**基础**，是一切其他社会活动的**首要前提**\n    - **生产方式决定社会的性质、结构和面貌**，制约着人们的社会生活\n    - 生产方式的变化决定**整个社会历史的变化**\n\n- 历史发展的真正动因\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221170939897.png\" alt=\"image-20231221170939897\" style=\"zoom:75%;\" />\n\n#### 社会意识\n\n- 是**社会存在的反映，社会生活的精神方面**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231221171118552.png\" alt=\"image-20231221171118552\" style=\"zoom:80%;\" />\n\n- 社会心理\n\n  - **低层次的社会意识，人们在日常生活中自发形成的不系统的、不定型的社会意识**\n  - 表现为人们的感知、情绪、情感、心态、习俗等，以**感性认识**为主\n\n- 社会意识形式\n\n  - **高层次的社会意识，自觉的、系统的、相对稳定的社会意识**\n\n  - 包括政治法律思想、道德、艺术、宗教、哲学、科学等，以**理性认识**为主\n\n  - 有意识形态和非意识形态之分\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229113635575.png\" alt=\"image-20231229113635575\" style=\"zoom:78%;\" />\n\n    - 意识形态的具体内容\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229113822024.png\" alt=\"image-20231229113822024\" style=\"zoom:73%;\" />\n\n- 社会意识形式**以社会心理为基础**，并对社会心理起**指导和影响**作用\n\n#### 辩证关系（重点）\n\n- （两个大点加上每个的三个小点）\n\n- **社会存在决定社会意识**，社会意识是社会存在的**反映**，并**反作用**于社会存在\n\n  - 社会存在是社会意识内容的**客观来源**，社会意识是社会物质生活过程及其条件的**主观反映**\n  - 社会意识是人们**进行社会物质交往的产物**\n  - 社会意识是**具体的、历史的**，会跟**随着社会存在的发展相应地或迟或早的进行变化和发展**\n\n- 社会意识的**相对独立性**\n\n  - 社会意识与社会存在发展具有**不完全同步性和不平衡性**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222102522457.png\" alt=\"image-20231222102522457\" style=\"zoom:75%;\" />\n\n  - 社会意识内部各种形式之间**存在相互影响**且各自具有**历史继承性**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222102712956.png\" alt=\"image-20231222102712956\" style=\"zoom:70%;\" />\n\n  - 社会意识对社会存在具有**能动的反作用**，这是**社会意识相对独立性的突出表现**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222102818148.png\" alt=\"image-20231222102818148\" style=\"zoom:75%;\" />\n\n#### 辩证关系原理的重要意义\n\n- 理论意义：在人类思想史上**第一正确回答**了**社会历史观的基本问题**，宣告了**唯心史观的彻底破产**\n- 实践意义：对于社会发展包括社会文化建设具有重要**指导意义**，我国社会改革和发展的顶层设计和方针政策等，都必须**从我国现实的社会存在出发**\n\n### 社会基本矛盾及其运动规律\n\n- 社会发展的动力（重点）\n\n  - **根本动力：社会基本矛盾；其中生产力是最基本的动力因素，是社会发展的最终决定力量**\n  - **直接动力：阶级斗争**\n\n- 人类社会的基本矛盾：**生产力与生产关系、经济基础与上层建筑**的矛盾\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229123737711.png\" alt=\"image-20231229123737711\" style=\"zoom:77%;\" />\n\n#### 生产力与生产关系的矛盾运动\n\n- 生产力：人类在生产实践中形成的**改造和影响自然**以使其**适合社会需要**的**客观物质力量**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229124236418.png\" alt=\"image-20231229124236418\" style=\"zoom:84%;\" />\n\n  - 基本要素\n    - **劳动资料**\n    - 人们在劳动过程中所运用的物质资料或物质条件，其中**最重要的是生产工具**\n    - **劳动对象**\n    - 劳动对象是现实生产的**必要前提**\n    - **劳动者**\n    - 生产力中**最活跃**的因素\n  - **科学技术**\n    - 生产力中的**重要因素**，与劳动资料、劳动对象和劳动者等因素结合转化为实际生产能力\n    - 科学技术是先进生产力的集中体现和主要标志，是**第一生产力**\n\n- 生产关系：人们在物质生产过程中形成的**不以人的意志为转移的经济关系**\n\n  - 包括：**生产资料所有制关系，生产中人与人的关系，产品分配关系**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222105350377.png\" alt=\"image-20231222105350377\" style=\"zoom:75%;\" />\n\n- 辩证关系\n\n  - 生产力是生产的**物质内容**，生产关系是生产的**社会形式**，二者的有机统一构成社会的**生产方式**\n  - **生产力决定生产关系**\n    - 生产力**状况**决定生产关系的**性质**\n    - 生产力的**发展**决定生产关系的**变化**\n  - 生产关系对生产力具有**能动的反作用**\n    - 当生产关系**适合**生产力发展的客观要求时，对生产力的发展起**推动**作用\n    - 当生产关系**不适合**生产力发展的客观要求时，会**阻碍**生产力的发展\n\n- 意义：理论意义和实践意义\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229124851910.png\" alt=\"image-20231229124851910\" style=\"zoom:73%;\" />\n\n#### 经济基础与上层建筑的矛盾运动\n\n- 经济基础：社会一定发展阶段的**生产力所决定的生产关系的总和**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222111017981.png\" alt=\"image-20231222111017981\" style=\"zoom:83%;\" />\n\n- 上层建筑：建立在一定经济基础上的**意识形态**以及与之相适应的**制度、组织和措施**\n\n  - 结构：**观念上层建筑、政治上层建筑**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229125857024.png\" alt=\"image-20231229125857024\" style=\"zoom:84%;\" />\n\n  - 政治上层建筑\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222113006025.png\" alt=\"image-20231222113006025\" style=\"zoom:75%;\" />\n\n  - 马克思主义根据国家的性质和政权的组织形式，相应地将国家分为**国体和政体**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222113312659.png\" alt=\"image-20231222113312659\" style=\"zoom:70%;\" />\n\n- 辩证关系\n\n  - **经济基础决定上层建筑**，上层建筑一定要适合经济基础状况\n\n    ![image-20231222113621736](https://cdn.davidingplus.cn/images/2025/02/02/image-20231222113621736.png)\n\n  - 上层建筑对经济基础有**反作用**\n\n  - 经济基础与上层建筑的**相互作用**构成二者的**矛盾运动**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222113650280.png\" alt=\"image-20231222113650280\" style=\"zoom:75%;\" />\n\n  - 经济基础和上层建筑之间的**内在联系**构成了**上层建筑一定要适应经济基础状况**的规律\n\n### 人类普遍交往与世界历史的形成发展\n\n#### 交往及其作用\n\n- 交往时唯物史观的重要范畴\n\n- 指在一定历史条件下的个人、群体、阶级、民族、国家之间**在物质和精神上相互往来、相互作用、彼此联系**的活动\n\n- 分类：物质交往，精神交往\n\n  - 物质交往：人们在物质生产实践中发生的交往，**物质产品**是其交往内容\n  - 精神交往：一定的历史条件下，人们在涉及**思想、意识、观念、情感和情绪等精神性的领域**中进行的交往\n  - 关系：物质交往是精神交往的**基础和根源**，精神交往是物质交往的**产物**，**渗透**于物质交往中\n\n- 交往是人类实践的重要组成部分。**交往具有实践的基本特征，即客观存在性、自觉能动性、社会历史性**\n\n- 交往对社会生活的影响\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222144822737.png\" alt=\"image-20231222144822737\" style=\"zoom:75%;\" />\n\n#### 世界历史的形成与发展\n\n- 世界历史的内涵：唯物史观的世界历史指各民族、国家通过**普遍交往，打破鼓励隔绝**的状态，进入**相互依存、相互联系**的世界整体化的历史\n\n- **生产方式的发展变革**是世界历史形成和发展的**基础**\n\n- **普遍交往**是世界历史的**基本特征**\n\n- 世界历史的形成与发展**为共产主义的实现提供了条件和路径**\n  - 马克思：\"共产主义是以生产力的普遍发展和与此相联系的世界交往为前提的\"\n  - 在世界历史的不断深化中，交往和竞争也不断扩大，生产力获得空前发展，为共产主义代替资本主义奠定了坚实的物质基础\n\n- 今天，人类交往比以往任何时候都更加深入、频繁，马克思的世界历史理论为我们观察、分析当今世界发展特别是经济全球化问题提供了**科学的理论指导**\n\n  - 同时也推动构建了**\"人类命运共同体\"**\n\n\n### 社会进步与社会形态更替\n\n- 社会的发展和进步集中表现为**社会形态的更替**\n- 社会形态的更替**既遵循一般规律，又具有一些特殊形式**，人类社会就是这样从低级到高级向前发展，同时不断实现着人的发展，并**最终实现人类解放**\n\n#### 社会进步与人的发展\n\n- 社会进步表现在两个方面\n  - 社会形态**从低级到高级**的发展\n  - **同一社会形态内部**的发展\n- 社会进步**促进人的发展**\n  - 人的发展指人的体力、智力、个性和交往能力等的发展，**最根本的是人的自由程度的提高**\n  - 唯物史观把人的发展概括为三个阶段\n    - **人的依赖关系占统治地位**的阶段\n    - **以物的依赖关系为基础的人的独立性**的阶段\n    - **自由个性**的阶段\n  - 在以私有制为基础的社会，人的自由和发展不可能得到彻底的解放\n  - 只有在共产主义社会，人才能真正得到自由而全面的发展\n\n#### 社会形态的内涵\n\n- 社会形态：关于社会运动的**具体形式、发展阶段和不同质态**的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体\n\n- 包括：**经济形态、政治形态、意识形态**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222151329502.png\" alt=\"image-20231222151329502\" style=\"zoom:75%;\" />\n\n- 人类社会是不断发展的，社会的根本性变革和进步就是通过**社会形态的更替**实现的\n\n#### 社会形态更替的统一性和多样性\n\n- 依据经济基础特别是生产关系的不同性质，可分为五种社会形态\n\n  - **原始社会、奴隶社会、封建社会、资本主义社会和共产主义社会**\n  - 社会主义社会是共产主义社会的**第一阶段**，也叫**初级阶段**或者低级阶段\n\n- 统一性和多样性\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222151804073.png\" alt=\"image-20231222151804073\" style=\"zoom:75%;\" />\n\n#### 更替中的必然性与选择性\n\n- **更替的客观必然性**和**人们的历史选择性**\n\n- 更替的客观必然性\n\n  - 指社会形态依次更替的过程和规律是**客观**的，其发展的**趋势是确定不移**的\n  - 社会形态的更替归根结底是**社会基本矛盾运动的结果**，**生产力的发展具有最终的决定意义**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222152127195.png\" alt=\"image-20231222152127195\" style=\"zoom:75%;\" />\n\n- 人们的历史选择性\n\n  - 社会形态更替的规律是人们自己的**社会行动**的规律\n  - 三层意思\n    - 社会发展的客观必然性造成了**一定历史阶段社会发展的基本趋势**，为人们的历史选择提供了基础、范围和可能性空间\n    - 社会形态更替的过程是一个**主观能动性与客观规律性相统一**的过程（合目的性与合规律性的统一）\n    - 人们的历史选择性归根结底是**人民群众的选择性**\n\n### 文明及其多样性\n\n- 文明：人类创造的所有**物质成果、精神成果和制度成果**的总和，是标志社会进步程度的范畴，反映了人类社会实践活动的积极结果\n\n- 每种文明都是在特定的自然环境、历史背景、民族传统中生长起来的，体现着独特的生产、生活、交往方式，代表着一方文化的沃土和绿洲，是**人类文明的重要组成部分**\n\n- 文明形态的划分\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222152843847.png\" alt=\"image-20231222152843847\" style=\"zoom:75%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222152909292.png\" alt=\"image-20231222152909292\" style=\"zoom:80%;\" />\n\n## 社会历史发展的动力\n\n### 社会基本矛盾\n\n- 社会发展动力是一个系统，其中**社会基本矛盾是基础性和根本性的动力**\n\n#### 社会基本矛盾是历史发展的根本动力\n\n- 矛盾是基本动力，社会领域也不例外\n\n- 社会矛盾：基本矛盾和非基本矛盾\n\n- 社会基本矛盾：**贯穿历史发展始终**，规定社会发展过程的**基本性质和基本趋势**，并对社会历史发展过程**起根本推动作用**的矛盾\n\n  - 生产力和生产关系的矛盾，经济基础和上层建筑的矛盾\n\n- 社会基本矛盾在历史发展过程的作用\n\n  - **生产力**是社会基本矛盾运动中最**基本的动力因素**，是人类社会发展和进步的**最终决定力量**\n  - **生产力**是社会进步的**根本内容**，是衡量社会进步的**根本尺度**\n  - 社会基本矛盾特别是生产力和生产关系的矛盾，**决定着社会中其他矛盾**的存在和发展\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222155435096.png\" alt=\"image-20231222155435096\" style=\"zoom:75%;\" />\n\n  - 社会基本矛盾具有不同的表现形式和解决方式，并**从根本上**影响和促进社会形态的变化和发展\n\n#### 社会基本矛盾和社会主要矛盾\n\n- 社会基本矛盾和社会主要矛盾不是同一个概念，也不是同一层次的矛盾\n\n- 社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展\n\n- **社会主要矛盾是社会基本矛盾的具体体现**\n\n- 社会主要矛盾和非主要矛盾\n\n  - 社会主要矛盾处于支配地位，在社会发展过程一定阶段上起主导作用\n  - 社会主要矛盾的存在和发展，规定或影响着社会非主要矛盾的存在和发展\n\n- 总结\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222160827314.png\" alt=\"image-20231222160827314\" style=\"zoom:80%;\" />\n\n- **社会主要矛盾不是一成不变的，在一定条件下会进行转化**\n\n  - 两种变化\n\n    - 社会主要矛盾双方的内容发生变化\n    - 矛盾地位变化，原来的主要矛盾转化为从属地位的矛盾，而原来的某个非主要矛盾上升为支配地位的主要矛盾\n\n- 新时代中国主要矛盾转化的依据\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222161747325.png\" alt=\"image-20231222161747325\" style=\"zoom: 65%;\" />\n\n### 阶级斗争、社会革命\n\n- 阶级斗争：**社会基本矛盾在阶级社会中的表现**\n- 社会革命：**社会基本矛盾引起的广泛而深刻的社会变革的统称**，包括推翻旧制度旧社会、建立新制度新社会的革命，也包括虽然不变更根本制度，但对体制机制进行深刻改造并对社会进步有深远影响的改革\n\n#### 阶级斗争是阶级社会发展的直接动力\n\n- 阶级是一个经济范畴，也是一个历史范畴\n- 阶级的产生、存在和发展同经济发展过程联系在一起的\n- 一切社会历史都是阶级斗争的历史\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222162628783.png\" alt=\"image-20231222162628783\" style=\"zoom:72%;\" />\n\n- 阶级斗争：阶级**利益根本冲突**的对抗阶级之间的对立和斗争\n  - 在阶级社会中，生产力和生产关系、经济基础和上层建筑的矛盾必然会通过阶级斗争表现出来\n  - 阶级斗争对阶级社会发展的推动作用突出表现在**社会形态的更替**\n  - 阶级斗争及其作用**受到一定社会历史条件的制约**\n\n#### 社会革命\n\n- **社会革命是阶级斗争的最高形式**\n\n- 社会革命的本质：**革命阶级推翻反动阶级的统治，用新的社会制度代替旧的社会制度，解放生产力，推动社会发展**\n\n- 社会革命的根源：社会基本矛盾的**尖锐化**\n\n  - 根本原因：生产力的发展和旧的生产关系、经济基础的发展和旧的上层建筑之间出现矛盾冲突\n\n- 社会革命是**推动社会发展**特别是**社会形态更替**的**重要动力**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222163428080.png\" alt=\"image-20231222163428080\" style=\"zoom:75%;\" />\n\n#### 马克思主义的阶级分析方法\n\n- 认识阶级社会的科学方法\n\n- 阶级分析方法是马克思主义政党制定正确路线、方针、政策的**重要依据**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222163722512.png\" alt=\"image-20231222163722512\" style=\"zoom:78%;\" />\n\n#### 改革\n\n- 改革：社会为了解决社会基本矛盾而面对生产关系和上层建筑进行的深刻**改变和革新**，是对社会制度的自我调整和完善，是同一种社会形态发展过程中的**量变和部分质变**，是推动社会历史发展的**重要动力**之一\n\n- 改革是**一定程度**上解决社会基本矛盾、促进生产力发展、推动社会进步的有效途径和手段\n\n- **改革的根源：社会基本矛盾的运动**\n\n- 中国的社会主义改革\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222164413984.png\" alt=\"image-20231222164413984\" style=\"zoom:74%;\" />\n\n#### 改革和革命的关系\n\n- 改革与革命\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222164215777.png\" alt=\"image-20231222164215777\" style=\"zoom:70%;\" />\n\n- 人们有时也在一定意义上称改革为\"革命\"或\"社会革命\"\n\n  - 就**改革的深刻性和对社会的深远影响**而言的\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222164250013.png\" alt=\"image-20231222164250013\" style=\"zoom:80%;\" />\n\n### 科学技术\n\n- **科学技术是第一生产力**\n\n- 科学技术作为**先进生产力**的**重要标志**，是**推动社会文明进步**的**重要力量**\n\n- 科学技术的内涵（复合概念）\n\n  - 科学：**对自然、社会和人类思维的正确认识，是反映客观事实和客观规律的知识体系及其相关的活动**\n\n    - 主要分为：**自然科学、社会科学和思维科学**\n\n  - 技术：广义和狭义之分\n\n    - 广义：包括**生产技术和非生产技术**\n    - 狭义：生产技术，即人类改造自然、进行生产的方法与手段\n\n  - 科学和技术是辩证统一的\n\n    - 当今时代，科学活动与技术互动的联系越来越频繁，出现了科学技术化和技术科学化的趋势，科学与技术日益融为一体\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222165530391.png\" alt=\"image-20231222165530391\" style=\"zoom:70%;\" />\n\n#### 科学技术是推动经济和社会发展的强大杠杆\n\n- 对**生产方式**产生了深刻影响\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222165718689.png\" alt=\"image-20231222165718689\" style=\"zoom:75%;\" />\n\n- 对**生活方式**产生了巨大影响\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222165748811.png\" alt=\"image-20231222165748811\" style=\"zoom:75%;\" />\n\n- 促进了人们**思维方式的变革**\n\n#### 正确把握科学技术的社会作用\n\n- 科学技术能够促进经济和社会发展造福人类，但是在一定条件下，可能受**一定客观条件**如社会制度、利益关系，也受**一定主观条件**如观念和认识水平的影响，可能给人类带来**不利影响**\n\n- 把握科学技术的社会作用\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222170115320.png\" alt=\"image-20231222170115320\" style=\"zoom:78%;\" />\n\n- 科学技术的社会制约性\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231222170137443.png\" alt=\"image-20231222170137443\" style=\"zoom:71%;\" />\n\n### 文化\n\n- 文化是推动社会发展的重要力量\n\n- 分为广义和狭义\n\n  - 广义的文化：**人类的社会实践活动及其产物**，即人类在物质、精神和制度等方面的创造性活动及其结果，包括人们在实践中创造的物质文明、政治文明和精神文明等\n  - 狭义的文化：**人类的精神生产活动及其结果**\n\n  ![image-20231222170540121](https://cdn.davidingplus.cn/images/2025/02/02/image-20231222170540121.png)\n\n- 四点作用\n\n  - 为社会发展提供**思想指引**\n  - 为社会发展提供**精神动力**\n  - 为社会发展提供**智力支持**\n  - 为社会发展提供**凝聚力量**\n\n### 小结\n\n![image-20231222170709095](https://cdn.davidingplus.cn/images/2025/02/02/image-20231222170709095.png)\n\n## 人民群众在历史发展中的作用\n\n- 唯物史观：群众史观\n- 唯心史观：英雄史观\n\n### 人民群众：历史的创造者\n\n#### 两种历史观在历史创造者问题的对立\n\n##### 英雄史观（唯心史观）\n\n- 唯心主义英雄史观\n\n  - 从社会意识决定社会存在的基本前提出发，**否认物质资料的生产方式是社会发展的决定力量**，抹杀人民群众的历史作用，宣扬**少数英雄人物创造历史**\n\n  - 产生有深刻的根源\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223200507692.png\" alt=\"image-20231223200507692\" style=\"zoom:75%;\" />\n\n- 唯心主义宿命论观\n\n  - 认为：决定社会历史的是**某种神秘的力量**，如上帝、天命、宇宙精神等\n\n- 两种唯心史观的实质\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231229162227875.png\" alt=\"image-20231229162227875\" style=\"zoom:76%;\" />\n\n##### 群众史观（唯物史观）\n\n- **人民群众是历史活动的主体，是历史的创造者**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223201117194.png\" alt=\"image-20231223201117194\" style=\"zoom:80%;\" />\n\n##### 二者比较\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231230131522578.png\" alt=\"image-20231230131522578\" style=\"zoom:75%;\" />\n\n##### 唯物史观的方法论原则（记忆）\n\n- 四点原则\n\n  - 立足于**现实的人及其本质**来把握历史的创造者\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223201349479.png\" alt=\"image-20231223201349479\" style=\"zoom:75%;\" />\n\n    - 人与动物相比，**劳动是人类的本质活动**\n    - **人的现实本质是一切社会关系的总和**\n    - 人的**本质属性是社会属性**，不是自然属性\n    - 人的本质属性表现在各种社会关系中\n    - 人的本质是**变化、发展**的，而不是永恒不变的\n\n  - 立足于**整体的社会历史过程**来探究谁是历史的创造者\n\n    - 创造个体的历史不等于创造社会历史\n\n  - 从**社会历史发展的必然性**入手来考察和说明谁是历史的创造者\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223201635824.png\" alt=\"image-20231223201635824\" style=\"zoom:75%;\" />\n\n  - 从**人与历史关系的不同层次**上考察谁是历史的创造者\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223201923193.png\" alt=\"image-20231223201923193\" style=\"zoom:70%;\" />\n\n- 唯物史观深入考察群体与个体的历史作用，区分了创造历史过程的决定力量和非决定力量、主导力量与非主导力量，科学地解决了谁是历史创造者的问题\n\n#### 人民群众\n\n- **人民群众是社会历史的主体，是历史的创造者**\n\n- 从质上看，人民群众指一切对**社会历史发展起推动作用**的人\n\n- 从量上看，人民群众指**社会人口中的绝大多数**\n\n- 在不同历史时期，包含不同阶级、阶层和社会集团，其中**最稳定的主体**始终是**从事物质资料生产的劳动群众及其知识分子**\n\n- 人民群众的作用（重点）\n\n  - 社会**物质财富**的创造者\n  - 社会**精神财富**的创造者\n  - **社会变革的决定力量**\n  - 既是**先进生产力和先进文化的创造主体**，也是**实现自身利益的根本力量**\n\n- 创造历史的作用收到各种社会条件的制约\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223202325868.png\" alt=\"image-20231223202325868\" style=\"zoom:80%;\" />\n\n#### 无产阶级政党的群众路线\n\n- 群众观点：坚信人民群众自己解放自己的观点，全心全意为人民服务的观点，一切向人民群众负责的观点，虚心向群众学习的观点\n- 群众路线：**一切为了群众，一切依靠群众，从群众中来，到群众中去**\n- 群众路线是中国共产党坚持马克思主义群众史观形成的**重要理论成果**\n- 群众路线：我们党的**生命线和根本工作路线**，党在革命、建设、改革中不断取得胜利的法宝\n\n### 个人在社会历史中的作用\n\n- 唯物史观既明确了人民群众是历史的创造者，**也不否认个人在历史上的作用**\n\n#### 杰出人物\n\n- 历史人物：一定历史事件的主要倡导者、组织领导者或思想理论、科学文化的重要代表人物，对历史发展有着深刻影响\n- 杰出人物：历史人物中对推动历史发展**作重要贡献或起重要作用**的历史人物\n- 杰出人物比一般人站得高、看得远，解决历史任务的意愿更强烈，但**终究不能改变历史发展的基本方向**\n  - 他们的作用性质取决于思想、行为是否符合社会发展规律，是否符合人民群众的意愿\n\n#### 辩证理解评价个人的历史作用\n\n- 任何历史人物的出现都是**必然性与偶然性的统一**\n\n- 评价历史人物的方法：**历史**分析方法，**阶级**分析方法\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223203251455.png\" alt=\"image-20231223203251455\" style=\"zoom:75%;\" />\n\n### 群众、阶级、政党、领袖\n\n- **群众是划分阶级的**\n  - 一个阶级在群众乃至社会中的地位，取决于多种因素，其中该阶级在**生产关系中的地位是主要因素**\n- **阶级通常由政党领导**\n- **政党是由领袖主持的**\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231223203602343.png\" alt=\"image-20231223203602343\" style=\"zoom:75%;\" />\n\n# 第四章 资本主义的本质\n\n- 简单商品经济（资本主义之前）\n- 高度发达的商品经济（资本主义及其之后的商品经济）\n\n## 马克思劳动价值论及当代价值\n\n- 劳动创造价值的观点，马克思之前的资产阶级经济学家已经提出过\n  - 这些观点，成为了马克思劳动价值论的重要思想来源\n- 但是这些观点**并不科学**，并且无法形成科学的劳动价值论\n  - 他们**没有对劳动进行科学认识**，而马克思提出的**\"劳动二重性\"**学说，彻底解决了这个问题\n  - 他们代表**资产阶级利益**，决定了他们**不可能承认劳动是价值的唯一源泉**；而马克思站在无产阶级的立场，敢于把劳动创造价值的真理坚持到底\n\n### 马克思如何分析劳动创造价值\n\n#### 商品和商品经济\n\n- 商品：用来**交换、满足人的某种需要**的劳动产品\n\n  - **只有以交换为目的**的劳动产品才是商品，不是所有的劳动产品都是商品\n\n- 自然经济：生产的目的是直接满足生产者个人或经济单位的需要，而**不是作为交换**的经济形式\n\n  - 自然经济是同**社会生产力水平低和社会分工不发达**相适应的\n\n- 商品经济：**生产的目的是为了交换**的经济形式\n\n  - 商品经济不是从来就有的，是在一定历史条件下，作为**自然经济的对立物**而产生和发展起来的\n\n- 商品经济产生的两个历史条件\n\n  - **社会分工**：各行各业的生产者为了满足自身的需要，就需要交换，获得对方的产品\n  - **生产资料和劳动产品属于不同所有者**：在**私有制**下，生产资料和劳动产品**归私人所有**，一个人想得到别人的产品满足自己的需求，就**只能进行交换**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224145302058.png\" alt=\"image-20231224145302058\" style=\"zoom:75%;\" />\n\n  - 商品经济的发展阶段\n    - 出现于**原始社会末期**，在**奴隶社会和封建社会有所发展**，但不占主导地位\n    - 在资本主义社会，商品经济成为**普遍**的经济形式\n\n#### 商品二要素：使用价值和价值\n\n- 商品是**使用价值和价值的矛盾统一体**\n\n- 使用价值\n\n  - 指**商品能满足人的某种需要的有用性**\n  - 反映**人与自然的物质关系**，是商品的**自然属性**，是**一切劳动产品共有的属性**，离开了商品就不复存在\n  - 商品的使用价值与一般劳动产品的使用价值的区别：前者是以交换为目的满足他人需要，后者是满足生产者自身的需要\n\n- 交换价值\n\n  - 指**两种不同性质的使用价值交换的时候量的比例关系**\n  - **使用价值是交换价值的物质承担者，使用价值构成社会财富的物质内容**\n  - **决定商品交换的比例**不是商品的使用价值，**而是价值**（通过无差别的人类劳动进行衡量）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224151150923.png\" alt=\"image-20231224151150923\" style=\"zoom:75%;\" />\n\n  - 交换价值由什么决定？\n    - \"使用价值决定\"论：决定商品交换价值的是商品的用途\n      - 例子：（钻石与水悖论）没什么比水更有用，但水能交换的货物却非常有限；相反钻石没啥用，但却能换到大量的货品\n    - \"效用决定\"论：决定商品交换价值的是因为商品有满足人们欲望的能力\n    - \"供求关系决定\"论：决定交换比例的是供给和需求数量的变化，后者会影响交换比例的波动\n\n- 价值\n\n  - 两种不同使用价值的商品能够按照一定比例进行交换，中间必然存在着**共同的可以相互比较的东西**\n  - 定义：**凝结在商品中的无差别的一般人类劳动，即人的脑力和体力的耗费**\n  - 价值是商品的**特有的社会属性**\n  - 本质：商品的价值是劳动创造的，商品交换实际上是**商品生产者之间的劳动交换**，**本质体现了生产者之间的一定社会关系**，即**物质利益关系**\n  - **价值是交换价值的基础，交换价值是价值的表现形式**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224153039115.png\" alt=\"image-20231224153039115\" style=\"zoom:70%;\" />\n\n- 使用价值和价值是**对立统一**的\n\n  - **使用价值是价值的物质承担者，价值寓于使用价值之中**\n  - **使用价值是价值的前提条件，没有使用价值也就没有价值，也就没有商品**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224153133654.png\" alt=\"image-20231224153133654\" style=\"zoom:76%;\" />\n\n- 哲学上的价值和经济学上的价值对比\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224153345216.png\" alt=\"image-20231224153345216\" style=\"zoom:78%;\" />\n\n#### 劳动二重性：具体劳动和抽象劳动\n\n- **劳动二重性理论：政治经济学枢纽**\n- 劳动的二重性：生产商品的劳动**既是具体劳动过程，又凝结抽象劳动**\n- **具体劳动创造了商品的使用价值；抽象劳动创造了商品的价值**\n\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224153518217.png\" alt=\"image-20231224153518217\" style=\"zoom:75%;\" />\n\n- 二者的**对立统一**关系\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224153619380.png\" alt=\"image-20231224153619380\" style=\"zoom:78%;\" />\n\n- **劳动的二重性决定商品的二因素**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224153700228.png\" alt=\"image-20231224153700228\" style=\"zoom:75%;\" />\n\n#### 商品价值量的决定、变动和比较\n\n- 商品价值量的规定包括：**质的规定，量的规定**\n\n  - 质的规定：回答**价值的实体**是什么\n  - 量的规定：回答**价值的大小由什么决定和怎样决定**\n\n- 社会必要劳动时间：在现有社会的正常的生产条件下，在社会的**平均的劳动熟练程度和劳动强度**下制造某种使用价值需要的劳动时间\n\n  - **社会必要劳动时间决定商品的价值量**，关系到每个商品生产者的命运\n\n    -  比例关系：在相同的条件下，社会必要劳动时间越长（耗费的社会必要劳动越多月辛苦），商品的价值量越高\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224163738386.png\" alt=\"image-20231224163738386\" style=\"zoom:78%;\" />\n\n    - 个别劳动时间：个别商品生产者或个别企业生产某种商品的劳动时间\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224164148044.png\" alt=\"image-20231224164148044\" style=\"zoom: 75%;\" />\n\n- 生产商品的社会必要劳动时间随着**劳动生产率的变化**而变化\n\n  - 劳动生产率：**劳动者生产使用价值的效率**\n\n    - 高低可以用单位劳动时间内生产的商品数量测量，也可以用单位商品中耗费的劳动时间测量\n\n    - 影响劳动生产率的因素\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224164632641.png\" alt=\"image-20231224164632641\" style=\"zoom:76%;\" />\n\n  - **劳动生产率越高**，单位时间内生产的**商品数量越多**，生产每件商品的**社会必要劳动时间就越小**，单位商品的**价值量越小**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224164810321.png\" alt=\"image-20231224164810321\" style=\"zoom:78%;\" />\n\n- 商品价值量的比较\n\n  - 简单劳动：**不需要经过专门训练和培养**的一般劳动者都能从事的活动\n    - 商品的价值量的计算是**以简单劳动为尺度**的\n  - 复杂劳动：需要经过专门训练和培养，具有**一定文化知识和技术专长**的劳动者从事的活动\n  - 复杂劳动等于**自乘的或多倍**的劳动；少量的复杂劳动等于多量的简单劳动\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224165501952.png\" alt=\"image-20231224165501952\" style=\"zoom:75%;\" />\n\n### 如何理解\"金银天然不是货币，但货币天然是金银\"\n\n#### 价值形式的发展\n\n- 四个阶段：**简单的、偶然的价值形式；总和的、扩大的价值形式；一般价值形式；货币形式**\n\n  - 简单的或偶然的价值形式\n\n    - 一种商品的价值**简单地、偶然地**通过**另一种商品**表达出来\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224171915822.png\" alt=\"image-20231224171915822\" style=\"zoom:70%;\" />\n\n  - 总和的或扩大的价值形式\n\n    - 一种商品的价值被表现在**一系列商品**中，使它**真正成为无差别的人类劳动的凝结**\n    - 交换比例也更加合理，比简单的或偶然的价值形式**前进了一大步**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224172052710.png\" alt=\"image-20231224172052710\" style=\"zoom:65%;\" />\n\n  - 一般价值形式\n\n    - 通过**一般等价物**，就是人们在交换中**都愿意接收的某种商品**\n    - 相比之前实现了**质的飞跃**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224172214938.png\" alt=\"image-20231224172214938\" style=\"zoom:70%;\" />\n\n  - 货币形式\n\n    - **一般等价物表现为货币形式**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224172242473.png\" alt=\"image-20231224172242473\" style=\"zoom:67%;\" />\n\n#### 货币\n\n- 演变过程：从贵金属（黄金和白银），到铸币、纸币、信用货币、电子货币等\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224172443265.png\" alt=\"image-20231224172443265\" style=\"zoom:75%;\" />\n\n- 本质：长期交换过程中形成的**固定充当一般等价物**的商品\n\n  - 是商品经济内在矛盾发展的产物，体现了一种社会关系\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224172630409.png\" alt=\"image-20231224172630409\" style=\"zoom:70%;\" />\n\n  - **使用价值和价值的矛盾转化为商品和货币的矛盾**\n\n    - **商品经济的基本矛盾：私人劳动和社会劳动的矛盾**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224172738083.png\" alt=\"image-20231224172738083\" style=\"zoom:65%;\" />\n\n- 职能：**价值尺度、流通手段、贮藏手段、支付手段、世界货币**\n\n  - 两个**基本职能**：**价值尺度、流通手段**\n\n  - 价值尺度\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224173154358.png\" alt=\"image-20231224173154358\" style=\"zoom:75%;\" />\n\n  - 流通手段\n\n    - 货币可以充当媒介，使商品流通\n\n      - 货币执行流通手段时**必须是现实的货币**\n\n      - 货币执行流通手段时可以**不足值**，因此可以是纸币\n        - 纸币是国家发行强制使用的**货币符号**，可以认为纸币不是货币，也不是商品，因为没有价值\n        - **马克思主义认为纸币没价值（但是有使用价值），不具有价值尺度的职能，一般只能代替金属货币执行流通手段和支付手段的功能**\n\n    - 图\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224173020107.png\" alt=\"image-20231224173020107\" style=\"zoom:65%;\" />\n\n  - 贮藏手段\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224173037191.png\" alt=\"image-20231224173037191\" style=\"zoom:75%;\" />\n\n  - 支付手段\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224173100067.png\" alt=\"image-20231224173100067\" style=\"zoom:73%;\" />\n\n  - 世界货币\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224173128375.png\" alt=\"image-20231224173128375\" style=\"zoom:73%;\" />\n\n### 价值规律：商品经济的基本规律\n\n#### 价值规律\n\n- 价值规律：**商品生产和交换的基本规律**\n\n  - 商品的价值量由生产商品的**社会必要劳动时间**决定\n  - 商品交换以价值量为基础，按照**等价交换的原则**进行\n\n- **价值决定规律支配商品生产**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224191640354.png\" alt=\"image-20231224191640354\" style=\"zoom:78%;\" />\n\n- 两种社会必要劳动时间\n\n  - 在商品经济社会，一种商品的价值量不由生产者主观的意识决定，而通过市场上的**交换和竞争**形成的，**社会只承认这种商品的社会必要劳动时间**\n  - 第一种含义在**生产同商品的不同生产者之间**形成，涉及的是同种商品上的劳动耗费\n  - 第二种含义在**生产不同商品的生产者之间**形成的社会必要劳动时间\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224190942359.png\" alt=\"image-20231224190942359\" style=\"zoom:75%;\" />\n\n- **价值实现规律支配商品流通**\n\n  - 商品交换以商品的价值量为基础，实行等价交换，这是价值实现的规律，对商品交换起着决定性作用\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224191413069.png\" alt=\"image-20231224191413069\" style=\"zoom:74%;\" />\n\n- 表现形式\n\n  - 表现形式：**商品的价格围绕商品的价值自发波动**\n  - 价值规律**既是价值决定规律，又是价值实现规律**\n  - **价值规律是商品经济的基本规律**\n\n- **作用**（重点）\n\n  - 积极作用\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224191841170.png\" alt=\"image-20231224191841170\" style=\"zoom:78%;\" />\n\n  - 消极作用\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224191857614.png\" alt=\"image-20231224191857614\" style=\"zoom:78%;\" />\n\n#### 以私有制为基础的商品经济的基本矛盾\n\n- 在私有制为基础的商品经济中，既有社会性质的**社会劳动**，这是由**社会分工**决定的；又有私有性质的**私人劳动**，这是**生产资料私有化（生产资料和劳动产品属于不同的所有者）**决定的\n\n- 商品经济的基本矛盾：**私人劳动与社会劳动** \n\n  - 形成的条件\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224165726810.png\" alt=\"image-20231224165726810\" style=\"zoom:70%;\" />\n\n\n  - **为什么私人劳动和社会劳动是商品经济的基本矛盾？**（重点）\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224165806705.png\" alt=\"image-20231224165806705\" style=\"zoom:75%;\" />\n\n  - 商品拜物教产生的必然性\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225222803121.png\" alt=\"image-20231225222803121\" style=\"zoom:73%;\" />\n\n### 马克思劳动价值论过时了吗？\n\n- 内容：商品的二因素和劳动的二重性及其相互关系、价值量的规定性及其变化规律、价值形式的发展和货币起源、商品经济的基本矛盾和基本规律及其作用等理论\n\n#### 理论和实践意义\n\n- 马克思主义**扬弃了英国古典政治经济学**的观点，为**剩余价值理论的创立**奠定了基础\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224192450074.png\" alt=\"image-20231224192450074\" style=\"zoom:75%;\" />\n\n- 马克思主义**创立了劳动二重性理论（具体劳动和抽象劳动），第一次确定什么样的劳动形成价值、为什么形成价值以及怎样形成价值**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224192639414.png\" alt=\"image-20231224192639414\" style=\"zoom:77%;\" />\n\n- 马克思主义劳动价值论**揭示了商品经济的一般规律**，对社会主义市场经济的建立具有指导意义\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224192711081.png\" alt=\"image-20231224192711081\" style=\"zoom:78%;\" />\n\n- 马克思劳动价值论揭示了**私有制条件下商品经济的基本矛盾（私有劳动与社会劳动的矛盾）**，为从物与物的关系背后揭示人与人的关系提供了理论依据\n\n\n#### 为什么没有过时？\n\n- 进一步拓展和深化马克思劳动价值论\n\n  - 深化对**创造价值的劳动**的认识，对**生产性劳动做出新的界定**\n  - 深化对**科研人员、经营管理人员在社会生产和价值创造**中所起作用的认识\n  - 深化对**价值创造与价值分配关系**的认识\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224194134363.png\" alt=\"image-20231224194134363\" style=\"zoom:74%;\" />\n\n- 当今劳动形式发生新变化\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224194210346.png\" alt=\"image-20231224194210346\" style=\"zoom:75%;\" />\n\n- 对劳动和劳动价值论的新认识\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224194233506.png\" alt=\"image-20231224194233506\" style=\"zoom:73%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224194336255.png\" alt=\"image-20231224194336255\" style=\"zoom:80%;\" />\n\n## 马克思剩余价值理论与经济危机\n\n### 资本家和劳动者为何对立\n\n#### 资本主义生产关系的产生\n\n- 前资本主义社会形态的演进和更替\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231226100854540.png\" alt=\"image-20231226100854540\" style=\"zoom:80%;\" />\n\n- 资本主义关系的产生**（最初从小商品经济分化出来）**\n\n  - 产生的原因：封建社会末期，**生产力与生产关系的矛盾**引起了农村自然小农经济和（欧洲封建社会中的）城市行会组织的瓦解，导致城乡资本主义生产关系的产生\n\n  - 小商品经济：**简单商品经济**，以**生产资料的个人私有制和个体劳动为基础**的商品经济形式\n\n  - 封建社会末期，小商品生产者不断**竞争**，发生**贫富两极分化**，从而导致资本主义生产关系的产生\n\n  - **商人和高利贷者直接支配生产**（从商人和高利贷者转化而来），成为工业资本家\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224195922437.png\" alt=\"image-20231224195922437\" style=\"zoom:77%;\" />\n\n- 资本主义的确立\n\n  - 背景：随着生产力和生产关系的发展，在地主和农民阶级矛盾尖锐的情况下，对于上层建筑的彻底变革提出了要求。新型资产阶级带领农民和其他劳动者，在政治上完成**资产阶级革命**，用**资产阶级政权**代替封建地主阶级政权\n  - 形成：**英、法完成工业革命，机器代替手工**，促进了社会生产力的**空前发展**，**资本主义生产关系的支配地位**得到确立\n  - 标志：**政治上**资产阶级政权的建立和**经济上**资本主义生产关系占据支配地位\n\n- **世界贸易**为资本主义开辟**世界市场**\n\n  - 资本主义**萌芽**，最早于`14世纪末15世纪初`，在地中海沿岸的**威尼斯、佛罗伦萨**和西北欧洲的**尼德兰**等地出现\n  - 直到**英、法两国完成资产阶级革命**，资本主义生产关系在欧洲得到确立\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224200218635.png\" alt=\"image-20231224200218635\" style=\"zoom:75%;\" />\n\n#### 资本的原始积累\n\n- 指**通过暴力手段，使生产者与生产资料相分离**，资本迅速集中于**少数人手中**，从而资本主义得以发展的历史过程\n  - 暴力手段：**剥削农民的土地，掠夺货币财富，利用国家政权的力量进行殖民掠夺**\n  - **剥削农民的土地是形成资本主义原始积累的基础**\n- 原始积累的原因：`15世纪末`，**新航路的开辟，世界市场扩大**，促进了资本主义生产的发展，资产阶级通过暴力手段进行资本的原始积累，为资本主义的发展迅速发展创造条件\n- 劳动者和劳动条件分离\n  - 资本家：**主观劳动条件（生活资料）和客观劳动条件（生产资料）的所有者**\n    - 少数人手里集中了大量的**为组织资本主义必须的货币财富**\n  - 劳动者：**除了劳动力之外一无所有，不占有任何劳动条件**\n    - 大量的**有人生自由但丧失一切生产资料**的无产者（有人生自由，但是自由得一无所有，只能靠出卖劳动力给资本家为生）\n  - 正是在劳动者**自由得一无所有**的条件下，劳动条件作为资本存在，成为**劳动者的统治者**，在生产过程中吮吸着劳动者的活动\n\n#### 资本主义所有制的确立\n\n- 资本主义所有制\n\n  - 含义：**生产资料归资本家所有**的一种**私有制**形式。在资本主义所有制条件下，资本家与工人的关系变成**雇佣劳动关系**\n\n  - 本质：资本与雇佣劳动的关系具有**剥削与被剥削**的对抗性质。资本主义所有制是雇佣劳动赖以存在的基础，本质是资本与雇佣劳动之间剥削与被剥削关系的体现\n\n- 生产资料所有制：**生产资料归谁所有、归谁支配**，并凭借这种所有和支配实现生产和获得剩余产品\n\n  - **生产资料所有制 决定 生产关系**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224201948584.png\" alt=\"image-20231224201948584\" style=\"zoom:73%;\" />\n\n- 两种规律：**商品生产所有权规律**和**资本主义所有权占有规律**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224202259971.png\" alt=\"image-20231224202259971\" style=\"zoom:75%;\" />\n\n  - 在资本主义中，商品生产所有权规律**转变为**资本主义所有权占有规律\n\n    - 从历史上看，资本主义生产方式主体和客体颠倒了，即物支配人，而不是人支配物\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224202548497.png\" alt=\"image-20231224202548497\" style=\"zoom:75%;\" />\n\n### 资本增值的秘密\n\n- 秘密的关键在于：**剩余价值理论**\n  - **马克思主义政治经济学的基石**\n\n#### 流通领域的等价交换使资本增值成为秘密\n\n- **资本首先表现为一定量的货币，也就是货币是资本的最初表现形式，但是货币本身不是资本**\n\n- 作为**商品**流通的货币，流通形式：（**消费者**的心态模式）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225100252973.png\" alt=\"image-20231225100252973\" style=\"zoom:75%;\" />\n\n- 作为**资本**流通的货币，流通形式：（**资本家**的消费模式）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225100332252.png\" alt=\"image-20231225100332252\" style=\"zoom:74%;\" />\n\n- 货币转化为资本（`G-W-G'`)\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225100614453.png\" alt=\"image-20231225100614453\" style=\"zoom:75%;\" />\n\n- **劳动力成为商品**的条件以及特点\n\n  - 作为资本流通的货币，流通方式如下：\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225100756894.png\" alt=\"image-20231225100756894\" style=\"zoom:78%;\" />\n\n  - 劳动力成为商品的**基本条件**（劳动力：人的**劳动能力**，是人的**脑力和体力**的总和）\n\n    - 两点\n      - 劳动力是法律意义上的**完全自由人**\n      - 劳动者**不具有任何生产资料，也没有任何的生活资料来源，因此不得不出卖劳动力为生（自由得一无所有）**\n    - 劳动力成为商品，标志着**简单商品生产发展到资本主义商品发展**的新阶段\n    - **劳动力的使用价值是价值的源泉（这是劳动力商品使用价值的突出特点）**：劳动力对资本家的使用价值就是劳动力能劳动生产商品，价值就是生产出的商品凝结着无差别的一般人类劳动；劳动力能够在生产中创造新的价值，资本家就是靠剥削劳动力创造的剩余价值赚钱的\n\n  - 劳动力商品的价值构成\n\n    - 劳动力商品是特殊的商品，它的价值和使用价值不同于普通商品（三个部分）\n\n      - 维持**劳动者本人生存**所必需的生活资料的价值\n      - 维持**劳动者家属的生存**所必需的生活 资料的价值\n      - 劳动者**接受教育和训练所支出**的费用\n\n    - 货币购买的劳动力带来了**剩余价值，货币就会转化为资本**\n    - 劳动力价值的**最低界限**是**生活上不可缺少的生活资料**的价值决定的，最起码能让劳动力养活自己吧\n\n  - 劳动力商品价值构成的**特殊性**\n\n    - 价值决定包含**历史和道德**的因素\n    - 雇佣劳动者必要的生活资料的种类和数量，不只是取决于劳动者的**生理需要**，并且取决于**社会经济和文化发展水平以及各个国家风俗习惯**\n\n  - 劳动力商品使用价值的特殊性\n\n    - 对于一般商品\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225102208158.png\" alt=\"image-20231225102208158\" style=\"zoom:75%;\" />\n\n    - 对于劳动力商品\n\n      - **劳动力商品的使用价值是价值的源泉，他在消费过程中能创造新的价值，而且这个价值比劳动力本身的价值更大**\n\n#### 生产剩余价值是资本主义生产方式的绝对规律\n\n- 资本主义生产的**二重性**\n\n  - 两重性：**生产物质资料的劳动过程**和**生产剩余价值的价值增殖过程**的统一\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225102626617.png\" alt=\"image-20231225102626617\" style=\"zoom:75%;\" />  \n\n- **价值形成**过程\n\n  - **生产资料价值转移**的过程\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225103533684.png\" alt=\"image-20231225103533684\" style=\"zoom:83%;\" />\n\n  - **活劳动创造新价值**的过程\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225103625017.png\" alt=\"image-20231225103625017\" style=\"zoom:78%;\" />\n\n- **价值增殖**过程\n\n  - **劳动力价值和劳动力创造的新价值之间的差额**\n\n    - 工人的两种劳动：工作时间的一部分用来偿还资本家预付给他的工资，这部分称为必要劳动；但是在这之后，还必须继续工作，这段时间没有工钱，为资本家提供剩余价值，称为剩余劳动\n    - 工人工作更长时间，付出更多的社会必要劳动时间，却获得与劳动时间不匹配的更少的工钱，多的剩余价值被资本家赚取了\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225103733307.png\" alt=\"image-20231225103733307\" style=\"zoom:77%;\" />\n\n- 资本在资本主义生产过程中的两种形态\n\n  - `不变资本C（constant capital）`（以**生产资料**形式存在的资本）和`可变资本V（variable capital）`（用来**购买劳动力**的那部分资本）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225104200028.png\" alt=\"image-20231225104200028\" style=\"zoom:75%;\" />\n\n- 剩余价值率\n\n  - 剩余价值：**可变资本的增值额**\n    - **劳动者的剩余劳动是剩余价值的唯一源泉，资本家赚的钱有且只是剩余价值**\n\n  - 剩余价值率就是**剩余价值（`m，德语mehrwert`）同可变资本（`v`）的比率**，剩余价值率是**工人受剥削程度的准确表现**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225104848363.png\" alt=\"image-20231225104848363\" style=\"zoom:78%;\" />\n\n- 剩余价值生产的两种基本方式\n\n  - **绝对剩余价值**的生产\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225105638008.png\" alt=\"image-20231225105638008\" style=\"zoom:75%;\" />\n\n    - 在资本家看来，工人一天工作时间越长越好\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225110020094.png\" alt=\"image-20231225110020094\" style=\"zoom:77%;\" />\n\n  - **相对剩余价值**的生产\n\n    - 理解：随着**技术的发展和生产率的提高**，**工人花费更少的时间就能为资本家创造之前时间的价值**，这样对于资本家而言，还是付相同的钱，劳动者的必要劳动时间就少了，劳动力价值补偿点往前移动，**多出的时间成为了剩余劳动时间**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225110052270.png\" alt=\"image-20231225110052270\" style=\"zoom:75%;\" />\n\n    - **相对剩余价值是整个社会劳动生产率普遍提高的结果，整个社会劳动生产率的提高又是个别资本家为追逐超额剩余价值带来的（内卷）**\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225110209582.png\" alt=\"image-20231225110209582\" style=\"zoom:76%;\" />\n\n    - 如何提高社会劳动生产率\n\n      - 理解：比如某个资本家引入了更高级的技术，提高了个别的社会劳动生产率，他的剩余价值就大大提高了，但是这样的情况肯定只能是暂时的，这样只会引起整个社会资本家们的内卷的恶性循环，导致劳动者被剥削的越来越厉害，而资本家赚的钱越来越多\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225110334177.png\" alt=\"image-20231225110334177\" style=\"zoom:77%;\" />\n\n- 绝对剩余价值和相对剩余价值的**联系和区别**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225110701072.png\" alt=\"image-20231225110701072\" style=\"zoom:75%;\" />\n\n- 例题\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225111057771.png\" alt=\"image-20231225111057771\" style=\"zoom:77%;\" />\n\n#### 如何认识资本主义扩大再生产\n\n- **剩余价值的资本化**，就是资本积累\n\n- 资本积累的过程\n\n  - **资本主义简单再生产**\n\n    - 资本主义简单再生产是**物质资料再生产和资本主义生产关系再生产的统一**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225112439844.png\" alt=\"image-20231225112439844\" style=\"zoom:76%;\" />\n\n  - **资本主义扩大再生产**\n\n    - 资本积累是资本主义扩大再生产的源泉\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225112512416.png\" alt=\"image-20231225112512416\" style=\"zoom:71%;\" />\n\n    - 实质（滚雪球）\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225113213061.png\" alt=\"image-20231225113213061\" style=\"zoom:73%;\" />\n\n- 影响资本积累的**因素**\n\n  - 资本积累的源泉是剩余价值，积累规模的大小取决于以下四点：\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225113708048.png\" alt=\"image-20231225113708048\" style=\"zoom:78%;\" />\n\n  - 所用资本：预付资本，资本家为榨取剩余价值而预先垫支的货币资本，包括用于购买生产资料和劳动力的全部资本\n\n  - 所费资本：生产商品中耗费的资本量，包括耗费的不变资本和耗费的可变资本之和，在量上相当于生产成本\n\n- 资本的**构成形式**\n\n  - 技术构成：**生产的技术水平决定的生产资料和劳动者的比例**，比例越大，生产力水平越高\n\n  - 价值构成：资本从价值形式上可分为不变资本和可变资本，就是**不变资本和可变资本的比例**\n\n  - 有机构成：**由资本的技术构成决定 并且 反映技术构成变化的资本价值构成**\n\n    - 注意有机构成**强调技术的变化影响**比例关系，如果是其他因素影响的就不能叫有机构成了\n\n  - 价值构成，有机构成是**体现**，是手段；而技术构成是**根本**\n\n  - 关于三者的理解（重点）\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231226200840101.png\" alt=\"image-20231226200840101\" style=\"zoom:75%;\" />\n\n  - 例题\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225114515410.png\" alt=\"image-20231225114515410\" style=\"zoom:73%;\" />\n\n- 资本积累的**影响**\n\n  - 资本追逐剩余价值会引起**资本有机构成（C、V）的提高**，造成大量**失业人口**，并加剧财富占有**两极分化**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225152510863.png\" alt=\"image-20231225152510863\" style=\"zoom:78%;\" />\n\n  - 资本积累：单个资本依靠**剩余价值的资本化**来增大自己的资本总额\n\n  - 资本集中：把原来分散的**众多中小资本合并为少数大资本**；是借助**竞争**和**信用**两个强有力杠杆实现的\n\n  - 相对过剩人口：**劳动力供给超过资本对它的需要**\n\n    - 三种形式：**流动的、潜在的、停滞的过剩人口**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225152824800.png\" alt=\"image-20231225152824800\" style=\"zoom:77%;\" />\n\n    - 例子\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225152848931.png\" alt=\"image-20231225152848931\" style=\"zoom:75%;\" />\n\n    - 但是**劳动力的供给（想要打工的人越来越多）却日益绝对的增加**，同时**需求减少**，所以导致了大量劳动者的**失业**\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225153529714.png\" alt=\"image-20231225153529714\" style=\"zoom:70%;\" />\n\n\n#### 资本是在运动中增值的\n\n- 资本不是静止的，而是**运动的**\n- 资本通过运动不断变换自己的使用价值形态\n- 资本在运动中实现**保值和增殖**\n- 资本运动要求**三种资本**在空间上并存和在时间上继起\n  - 三种资本：货币资本、生产资本、商品资本\n\n##### 资本的流通过程\n\n###### 资本循环\n\n- 资本循环的三个阶段\n\n  - 购买阶段：购买生产资料和劳动力（**货币资本**的职能）\n\n  - 生产阶段：生产资料与劳动力按照比例结合进行生产（**生产资本**的职能）\n\n  - 售卖阶段：**商品资本向货币资本转化**（**商品资本**的职能）\n\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231226201933560.png\" alt=\"image-20231226201933560\" style=\"zoom:73%;\" />\n\n- 三种循环形式的**统一**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225154732262.png\" alt=\"image-20231225154732262\" style=\"zoom:78%;\" />\n\n- 正常循环的**前提条件**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225154834590.png\" alt=\"image-20231225154834590\" style=\"zoom:75%;\" />\n\n###### 资本周转\n\n- **周而复始、不断重复**的资本循环；而资本循环**只是一次**的资本周转\n\n  ![image-20231226202612474](https://cdn.davidingplus.cn/images/2025/02/02/image-20231226202612474.png)\n\n- 将生产资本划分为**固定资本和流动资本**（与不变资本和可变资本不同，是另一种划分标准）\n\n  ![image-20231225155951868](https://cdn.davidingplus.cn/images/2025/02/02/image-20231225155951868.png)\n\n- 比较\n\n  - 通过这张图通俗理解\n\n    - 可变和不变的区分：**是否能产生剩余价值**\n    - 固定和流动的区分：**买了之后是否需要进行源源不断的补充**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225161113953.png\" alt=\"image-20231225161113953\" style=\"zoom:50%;\" />\n\n  - 总结\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225160105067.png\" alt=\"image-20231225160105067\" style=\"zoom:78%;\" />\n\n###### 预付资本总周转\n\n- 资本周转的快慢取决于两个方面\n\n  - 固定资本和流动资本本身的**周转速度**的影响\n  - 生产资本中**固定资本和流动资本的比例**的影响\n\n- 计算**公式**（记忆）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225160435638.png\" alt=\"image-20231225160435638\" style=\"zoom:75%;\" />\n\n- 例子\n\n  ![image-20231225160456757](https://cdn.davidingplus.cn/images/2025/02/02/image-20231225160456757.png)\n\n- 资本周转速度对剩余价值生产的影响（理解）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225161702141.png\" alt=\"image-20231225161702141\" style=\"zoom:75%;\" />\n\n###### 社会总资本再生产和流通\n\n- 以上的分析都是在**个别资本**的基础上的，在这之上，马克思对**社会总资本的再生产和流通**作了分析\n\n- 再生产\n\n  - 社会总产品分为：**生产性消费的生产资料，生活消费的消费资料**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225162007206.png\" alt=\"image-20231225162007206\" style=\"zoom:75%;\" />\n\n- 社会总产品的**实现**\n\n  - 简单理解就两点：**补充补充生产资料和劳动力**（实物替换）和**卖出商品获得资本**（价值补偿）\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225162047148.png\" alt=\"image-20231225162047148\" style=\"zoom:73%;\" />\n\n- 总结\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231227164741032.png\" alt=\"image-20231227164741032\" style=\"zoom:76%;\" />\n\n\n##### 产品资本和产品利润\n\n- 资本主义下的工资\n\n  - 工资的本质：**劳动力的价值或者价格**\n\n- 剩余价值转化为利润\n\n  - 一张图\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225162316099.png\" alt=\"image-20231225162316099\" style=\"zoom:68%;\" />\n\n  - **剩余价值率转化为利润率**（重点）\n\n    - 关于剩余价值和利润以及剩余价值率和利润率的理解\n      - 剩余价值和利润\n        - 数值上看 `m == p`（资本家就是靠剩余价值赚钱的）\n        - 本质：**剩余价值是利润的本质，利润是剩余价值的转化形式，是用来迷惑世人的**（资本家对工人讲：我自己投资我挣钱还不行嘛，蒙蔽工人的双眼，使其看起来合情合理）\n      - 剩余价值率和利润率\n        - 剩余价值率：通俗来看是**劳动者多劳动的时间比上必要的劳动时间**，通过剥削来赚钱\n        - 利润率：资本家在计算的时候，在分母上加上`c`，就是生产资料的成本，比如机器、原料等，这样就导致利润率一定小于剩余价值率，这样给世人看来就是**利润率低**，钱赚的少，但是实际上**剩余价值率非常高**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225162340888.png\" alt=\"image-20231225162340888\" style=\"zoom:72%;\" />\n\n- 利润转化为平均利润\n\n  - 资本主义生产的目的是**获取利润**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225164950007.png\" alt=\"image-20231225164950007\" style=\"zoom:74%;\" />\n\n  - 结果：不同部门的竞争，**资本自由转移**的结果使利润趋于平均化\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225165111528.png\" alt=\"image-20231225165111528\" style=\"zoom:73%;\" />\n\n  - 两点\n\n    - 利润转化为平均利润，是**剩余价值理论和竞争规律作用**的必然结果，体现不同部门的资本家要求等量利润瓜分剩余价值\n    - 利润转化为平均利润，**价值转化为生产价格**。价格是商品价值的转化形式，是**生产成本与平均利润之和**\n\n#### 剩余价值理论的意义\n\n- 深刻揭露了资本主义生产关系的**剥削本质**，阐明了资产阶级与无产阶级阶级**斗争的经济根源**，指出了无产阶级**革命的历史必然性**\n- 是马克思主义经济理论的**基石**，是无产阶级反对资产阶级、揭示资本主义制度剥削本质的**锐利武器**。由于唯物史观和剩余价值理论的发展，社会主义**由空想变得科学**\n\n#### 资本主义基本矛盾：经济危机的根源\n\n- 资本主义基本矛盾：**生产社会化与生产资料私有制之间的矛盾**\n\n- 经济危机：经济发展过程中周期性爆发的社会经济的大混乱\n\n  - 实质：生产过剩，并且是**相对过剩**，即生产的太多了，劳动人民买不完，并且自己的钱**能买到的数量也远不及自己的需求**（所以不是绝对过剩）\n  - 表现：大量**商品积压**，大量企业、工厂停工，大量金融机构倒闭，社会经济一片混乱\n\n- 经济危机的实质是生产**相对过剩**的危机\n\n  - 根本原因\n    - **生产无限扩大的趋势**与**劳动人民支付能力不断减小**的矛盾\n\n    - **单个企业内部生产的有组织性**和**整个社会生产的无政府状态**的矛盾\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225165724908.png\" alt=\"image-20231225165724908\" style=\"zoom:73%;\" />\n\n- 资本主义经济周期性爆发：**社会资本再生产周期性**\n\n  - 经济危机在资本主义国家已经常态化，虽然会通过改革缓和经济危机，但是这些改革不能解决资本主义基本矛盾，也就**不能从根源上解决经济危机**，只能是苟延残喘\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225165945617.png\" alt=\"image-20231225165945617\" style=\"zoom:75%;\" />\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231225170015794.png\" alt=\"image-20231225170015794\" style=\"zoom:75%;\" />\n\n## 资本主义上层建筑\n\n- 现在资产阶级本身是一个长期发展过程的产物，是生产方式和交换方式的一系列变革的产物\n\n### 政治制度\n\n#### 国家的职能和本质\n\n- 本质：资产阶级进行**阶级统治的工具**\n\n  - 经济上：自由竞争、等价交换\n  - 政治上：自由、民主、平等、人权\n  - 与奴隶制度和封建制度相比，是人类政治生活的一大进步\n  - **并没有改变资本主义国家作为剥削阶级对人民群众进行阶级统治和阶级压迫的工具的性质**\n\n- 职能\n\n  - 对内：**政治统治，社会公共管理**\n  - 对外：**国际交往，维护国家安全及利益**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224210826133.png\" alt=\"image-20231224210826133\" style=\"zoom:75%;\" />\n\n#### 民主制度\n\n- 主要内容：**资本主义法律制度、资本主义政权组织形式、资本主义国家的选举制度、资本主义政党制度**\n\n- 法律制度\n\n  - **宪法**是资本主义国家法律制度的**核心**\n\n  - 宪法建立的基本原则\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224212250935.png\" alt=\"image-20231224212250935\" style=\"zoom:75%;\" />\n\n- 政权组织形式\n\n  - 三权分立：**立法权、行政权、司法权**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224212339831.png\" alt=\"image-20231224212339831\" style=\"zoom:75%;\" />\n\n- 选举制度\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224213555027.png\" alt=\"image-20231224213555027\" style=\"zoom:75%;\" />\n\n- 政党制度\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224213613655.png\" alt=\"image-20231224213613655\" style=\"zoom:78%;\" />\n\n  - 主要类型\n    - 两党制，如英国、美国、加拿大\n    - 多党制，如法国、德国、意大利\n\n- 资本主义**政治制度的本质**\n\n  - 资本主义**上层建筑的集中体现**\n  - 资产阶级**政治统治和社会管理**的手段\n  - 为资产阶级**利益服务**的工具\n\n- **辩证**看待资本主义在历史发展中的作用\n\n  - 积极作用\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224213857397.png\" alt=\"image-20231224213857397\" style=\"zoom:75%;\" />\n\n  - 不可避免的局限性\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224213921314.png\" alt=\"image-20231224213921314\" style=\"zoom:75%;\" />\n\n### 意识形态\n\n- **辩证**地分析资本主义意识形态\n\n  - 一方面，资本主义在**反对封建主义和宗教神学**，推动**资本主义发展**过程中起到积极作用\n\n    - 例子：文艺复兴、启蒙运动\n\n- 另一方面，**资本主义意识形态具有欺骗性和虚伪性**\n\n  - 例子：美国的霸权主义\n\n- 本质\n\n  - 资本主义意识形态是资本主义社会的**观念上层建筑**，为资本主义的**经济基础**服务，因而是为资本主义的政治上分层建筑服务的\n  - 资本主义意识形态是**资产阶级的阶级意识的集中体现**\n\n  ![image-20231224214319149](https://cdn.davidingplus.cn/images/2025/02/02/image-20231224214319149.png)\n\n### 小结\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231224214432104.png\" alt=\"image-20231224214432104\" style=\"zoom:80%;\" />\n\n","categories":["校内课程","马原"]},{"title":"搭建自己的博客","url":"/posts/8cbc2e0b.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n本文是一个`搭建自己的博客`的简要教程。\n\n# 效果预览\n\n我们每个人都想拥有自己的博客网站，那么问题来了，搭建一个博客需要什么呢？前后端加服务器。\n\n那么问题又来了，前后端我不会啊，服务器我也没有。不用担心，前端我们是有模板的，需要实现自己的功能去模板当中修改即可，服务器我们可以选择`Gitee`或者`GitHub`的`GitPages`服务，帮我们部署我们的静态网站，对于我们的学习网站，不需要那么花哨，静态页面完全够用，所以后端的部分我们也可以省去，需要的数据放在前端整合为静态博客即可。\n\n这是我的博客，我使用的是`Github Pages`服务，因为可以绑定自己的域名；没使用`Gitee Pages`服务，因为不能绑定自定义域名并且需要手动部署给我劝退了，虽然国内的访问速度确实快。\n\n链接：[https://blog.davidingplus.cn](https://blog.davidingplus.cn)\n\n![image-20231223105515106](https://cdn.davidingplus.cn/images/2025/02/01/image-20231223105515106.png)\n\n<!-- more -->\n\n# Hexo框架简介\n\n前端的模块，我选择的是`Hexo`框架，`Hexo` 就是一个专门用于博客类网站的开源项目，使用`Node.js`语言开发，现在网上大多数的个人博客都是使用这个框架搭建的。`Hexo`不仅搭建过程简单快捷，配置灵活，可定制型非常高，因此众多大佬开发者为它开发了丰富的主题库，而作为菜鸟我们只需要选择一个符合自己审美的主题直接用就行了，当然如果你懂前端和`js`，也可以自己修改定制，或者自己制作主题并分享到互联网上。\n\n注意：**以下的所有操作都是在`Linux`系统下完成的，`Windows`下同理即可。**\n\n# Hexo依赖环境：node.js\n\n这是它的官网：[Node.js](https://nodejs.org/zh-cn)\n\n由于我使用的是`Linux`系统，所以我们通过系统包安装命令就可以安装`node.js`，我的`Linux`发行版本是`Ubuntu`，所以我用`apt`包管理\n\n~~~bash\nsudo apt install nodejs\n~~~\n\n完成后使用如下命令，如果出现预期的效果代表安装成功：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230929111248640.png\" alt=\"image-20230929111248640\" style=\"zoom:67%;\" />\n\n# Hexo依赖环境：Git\n\n作为码农，`Git`是什么应该不陌生，`Git`是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。简单理解就是下载代码的工具，因为`Hexo`是一个托管于`GitHub`上的开源项目，所以安装`Hexo`的时候需要使用`Git`来下载源码和依赖代码，而且后面要将自己的博客发布到`GitHub pages`或者`Gitee pages`上面也需要使用`Git`。\n\n对于`Linux`系统而言，`Git`一般是自带的，如果没有，可以用如下命令安装：\n\n~~~bash\nsudo apt install git\n~~~\n\n安装完成之后同理可以查看版本检查是否安装成功。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230929111644452.png\" alt=\"image-20230929111644452\" style=\"zoom: 80%;\" />\n\n至此，你可以进行后续的一系列`Git`操作了。\n\n# 安装Hexo\n\n完事具备，只欠东风，我们现在可以正式安装我们的`hexo`框架了。\n\n我们在本地(我这里指的是`Linux`的目录里面)里创建一个空文件夹，里面存放`hexo`的文件和以后我们自己的博客文件，注意最好不要有中文路径，避免出现一些奇奇怪怪的问题。\n\n在终端中进入这个文件夹，输入一下命令：\n\n~~~bash\n# 安装 hexo 框架\nnpm install -g hexo-cli\n# 初始化文件夹\nhexo init\n# 安装 hexo 依赖包\nnpm install\n~~~\n\n## 可能遇到的问题\n\n- 在这一步可能会出现一些问题，安装完成`hexo`框架之后可能系统会找不到`hexo`命令，例如：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230929112334776.png\" alt=\"image-20230929112334776\" style=\"zoom:80%;\" />\n\n  但是这个时候正常情况下我们的`hexo`框架是已经安装好了的，系统识别不到这个命令大概率是`hexo`没有被添加到环境变量里面，为了解决这个问题，我们在之后的`hexo`命令前面都加上`npx`，也就是：\n\n  ~~~bash\n  npx hexo ...\n  ~~~\n\n  解释一下，为啥要在前面加上`npx`。\n\n  在大牛阮一峰的网络日志中，他是这么描述的：“`npx` 想要解决的主要问题，就是调用项目内部安装的模块”，所以可以理解为在命令行下调用，可以让项目内部安装的模块用起来更方便，`npx`运行的时候，会到`node_modules/.bin`路径和环境变量`$PATH`里面，检查命令是否存在，所以系统命令也可以调用，即上面的命令安装不成功的时候加上`npx`的话也许就可以成功了。\n\n  这说的没毛病，如果我们单纯执行`hexo`，系统会去全局寻找该命令，由于我们可能是通过`npm install`安装（没有加`-g`参数）在本目录的`node_modules`中的，全局安装了也有可能失败，因此加上`npx`来帮忙查找，后续使用`gulp`压缩文件也是同样的道理。\n\n  为了验证，我们还可以查看`hexo`的版本：\n\n  可以看出我这里有权限的问题，所以以后的执行最好我们还是加上`sudo`或者切换成为`root`用户(`sudo su`)，为了方便，后续的命令当中我还是使用`hexo`，前面的修饰我就不加了\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230929112808923.png\" alt=\"image-20230929112808923\" style=\"zoom:80%;\" />\n\n- `hexo init`会去`GitHub`上`hexo`的开源项目里面上拉取对应的到本地\n\n  链接：[https://github.com/hexojs/hexo-starter](https://github.com/hexojs/hexo-starter)\n\n  如果是因为用户权限问题报错，建议切换为root用户，但是这可能导致后后续文件编写的权限问题，但是这也是迫不得已的事情；如果是因为网络问题卡住，我们可以直接克隆这个仓库到本地，他和这个命令是等价的效果：\n\n  ~~~bash\n  git clone git@github.com:hexojs/hexo-starter.git\n  ~~~\n\n  克隆完成之后会得到类似于我的这一系列文件，当然我这里面多了一些文件，这是我自己添加的，有特别作用。\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230929113510909.png\" alt=\"image-20230929113510909\" style=\"zoom:67%;\" />\n\n- `npm install`会在当前目录下安装`hexo`的依赖包，在上面的图中是`node_modules`文件夹，**注意一定要在博客文件的根目录安装**\n\n## npm换源\n\n如果觉得觉得`npm`在国内下载的慢的话，可以使用镜像网站，这里推荐使用配套的`cnpm`命令代替`npm`命令以后\n\n~~~bash\nnpm install -g cnpm -registry=https://registry.npmmirror.com\n~~~\n\n这样以后，`cnpm`就安装好了，我们查看`npm`的版本\n\n~~~bash\ncnpm --version\n~~~\n\n可能得到如下的结果，这样就安装成功了，以后都是用`cnpm`命令代替`npm`即可\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203160959298.png\" alt=\"image-20231203160959298\" style=\"zoom:80%;\" />\n\n# 更换博客主题\n\n`hexo`框架默认提供的博客主题是`landscope`，这个有点寒碜，我们当然可以选择自己喜欢的主题。\n\n- 链接：[https://hexo.io/themes](https://hexo.io/themes)\n\n例如，我选择的就是主题`stun`，点击可以进入对应的`GitHub`链接。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203161650101.png\" alt=\"image-20231203161650101\" style=\"zoom: 50%;\" />\n\n下面以我的主题为例，来安装并且替换掉默认的主题\n\n进入你的博客项目，也就是`Hexo`根目录\n\n~~~bash\ngit clone https://github.com/liuyib/hexo-theme-stun.git themes/stun\n~~~\n\n该指令会将本仓库中的所有文件克隆下来，其中有很多文件仅用于项目开发，对于普通用户来说完全用不到。因此，如果你想仅克隆主题运行所必需的文件，请用下面的指令代替上面的指令\n\n~~~bash\ngit clone -b dist https://github.com/liuyib/hexo-theme-stun.git themes/stun\n~~~\n\n安装依赖`hexo-renderer-pug`(这个是`GitHub`上给的，不同的主题可能没有这一步，看各自的`Git`文档吧)\n\n~~~bash\nnpm install hexo-renderer-pug --save \n~~~\n\n这样以后，你会发现你的`theme`目录下多了`stun`的目录\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203162105728.png\" alt=\"image-20231203162105728\" style=\"zoom: 80%;\" />\n\n然后打开项目根目录下的`_config.yml`文件，对主题参数进行修改\n\n~~~yml\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: stun #请将这里改为你想要的主题名字\n~~~\n\n# 本地部署\n\n做好这一切之后我们就可以本地部署了\n\n我们需要部署整个项目，需要在终端执行如下命令\n\n~~~bash\nsudo npx hexo clean # 清理，只有清理需要加上sudo，其他的都不需要，别问，问就是我试验过了\nnpx hexo g # 生成\nnpx hexo s # 启动本地服务器\n~~~\n\n如果一切没有问题的话，终端应该会提示在`4000`端口开放了本地博客\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203162517610.png\" alt=\"image-20231203162517610\" style=\"zoom:67%;\" />\n\n- `node_modules`\n\n  构建的过程中可能会报`node_modules`相关依赖的错误，例如\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203162701520.png\" alt=\"image-20231203162701520\" style=\"zoom:67%;\" />\n\n  这个时候我们根据建议运行命令安装依赖即可，必要时候加上`sudo`\n\n  ~~~bash\n  rm -rf node_modules && npm install --force\n  ~~~\n\n然后我们就能看到本地部署的博客页面了\n\n# 关于主题的其他设置\n\n这些可以参考主题的相关文档进行更多个性化的设置，这里略\n\n- `stun`官方文档：[快速开始 | hexo-theme-stun](https://theme-stun.github.io/docs/zh-CN/guide/quick-start.html)\n\n# Git Pages服务\n\n本地部署的博客当然要上传到服务器才能被人们看到啊，可以部署到自己的服务器上\n\n当然，抠门的我们肯定想白嫖啊，因此`Git Pages`服务就是不二的选择\n\n我之前使用的是`Gitee Pages`服务，因为在国内访问的比较快，写这篇文章的时候我还没有购买域名，也就没有办法把`GitHub`上面的做`CDN`加速，所以还是用`Gitee Pages`服务好一点\n\n- `12.23`更新：我`GitHub`学生认证了，嫖了一年域名，所以换`GitHub Pages`了!!!\n\n## 创建Gitee仓库\n\n登录账号后，点击页面右上角的`+`，选择新建仓库\n\n![image-20231203163853210](https://cdn.davidingplus.cn/images/2025/02/01/image-20231203163853210.png)\n\n点击之后页面如下\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203164027489.png\" alt=\"image-20231203164027489\" style=\"zoom:50%;\" />\n\n- 仓库名称随意\n- **路径**这里建议填写`你的用户名`，这样生成出来的网页地址是比较纯净的形式，如`https://<你的用户名>.gitee.io`。当然也可以自定义名称，比如`blog `，但是这样后面生成出来的网页地址会带一个子目录，像`https://<你的用户名>.gitee.io/blog`这样\n- 介绍自己填\n- **开源，记得一定开源!!!**\n- 初始化仓库，可以不用，就是添加个许可证，还有`.gitignore`这些，这个后面自己添加都可以\n- 设置模板里面还是选一个`README.md`吧，一个仓库最好还是简单写一个说明文档吧，养成习惯\n- 分支模型选择`master`即可，后面自己创建更多的分支即可\n\n最后点击下面的创建即可\n\n然后点击页面右上角的服务，选择`Gitee Pages`\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203164329313.png\" alt=\"image-20231203164329313\" style=\"zoom:67%;\" />\n\n勾选`强制使用HTTPS`，点击启动。\n\n- 这个的部署分支就是你博客构建出来的文件存放的分支，我的是`Site`\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203164345096.png\" alt=\"image-20231203164345096\" style=\"zoom: 67%;\" />\n\n## 部署到远端\n\n现在我们只剩下最后一个问题，如何把本地构建出来的成品文件部署到远端，很简单，都在用`Git`了，直接传上去不就好了\n\n- `Tips`：为什么这里我不像其他教程使用`hexo d`命令来部署，我们直接上传`Git`和使用`hexo`提供的命令是一样的，都是传到`Git`的分支，没有区别，但是我在配置`hexo`这个的时候碰到了很多问题，所以我就没用这个了\n\n我们现在来看一下构建出来的文件在项目的哪里\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231203164654321.png\" alt=\"image-20231203164654321\" style=\"zoom: 80%;\" />\n\n这个`public`里面的文件就是构建出来的可以发布的成品，可以看到里面有一个主页面`index.html`，我们的`npx clean`其中删除的文件就有`public`目录\n\n因此，后续就很简单了，只需要把`public`目录中的文件拷贝出来到我们需要部署的仓库或者分支覆盖掉然后上传到`Git`即可\n\n关于`Git`的使用，本文不再赘述，可以参考我的其他文章或者自行搜索\n\n具体可以参考我的仓库配置，链接：[https://github.com/DavidingPlus/DavidingPlus.github.io](https://github.com/DavidingPlus/DavidingPlus.github.io)\n\n# GitHub Pages服务\n\n## 创建GitHub仓库\n\n登录账号后，点击页面右上角的`+`，新建仓库\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231223112125325.png\" alt=\"image-20231223112125325\" style=\"zoom:75%;\" />\n\n点击之后页面如下\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231223112219108.png\" alt=\"image-20231223112219108\" style=\"zoom: 67%;\" />\n\n- `Repository name`：`你的名字.github.io`，比如我的就是`DavidingPlus.github.io`\n- `public`：**开源，开源，开源**!!!\n- `README`，`license`，`.gitignore`，`Description`看自己需求来即可\n\n完事之后点击`Settings/pages`选择你自己的分支和路径（一般就`/root`）部署就好了\n\n和`Gitee`不同的是，`GitHub`传上去会自己自动部署相关分支，所以很方便\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231223112529840.png\" alt=\"image-20231223112529840\" style=\"zoom:67%;\" />\n\n记得开启强制`https`\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231223114027133.png\" alt=\"image-20231223114027133\" style=\"zoom:80%;\" />\n\n## 部署到远端\n\n在`Gitee Pages`中，由于当时我的`hexo d`出现了问题，所以我是直接硬推的，现在我找到问题了，所以这里使用`hexo d`来进行部署\n\n- `tips`：`hexo`的命令中，只有`hexo clean`前面建议加上`sudo`，因为清理可能需要`root`权限，其他命令一律不加，否则权限过高也可能会出现问题\n\n找到项目根目录的`_config.yml`文件，找到如下\n\n- `type`：`git`\n- `repo`：你自己仓库的地址，可以是通过`http`，也可以是通过`ssh`，就是`git clone`后面跟着的那个\n- `branch`：部署的分支，我给定的默认分支`master`，建议就用`master`，不然部署的时候可能会出现奇奇怪怪的问题\n- `message：git` `commit`的信息\n- `ignore_hidden`：下面写清楚了这个是干啥的\n\n![image-20231223113355905](https://cdn.davidingplus.cn/images/2025/02/01/image-20231223113355905.png)\n\n最后会在项目目录生成一个`.deploy_git`的目录，链接到你的仓库的部署分支，我的就是`master`\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20231223113616332.png\" alt=\"image-20231223113616332\" style=\"zoom:75%;\" />\n\n完整的部署命令\n\n~~~bash\nsudo npx hexo clean\nnpx hexo g\nnpx hexo d\n~~~\n\n可以参考我的仓库配置，链接：[https://github.com/DavidingPlus/DavidingPlus.github.io](https://github.com/DavidingPlus/DavidingPlus.github.io)\n\n# 总结\n\n通过以上，去搭建你自己的博客吧。当然如果是全栈大佬请当乐子看，你们应该有自己的更好的方式。\n\n任何问题，可以在评论中提出或者联系我！\n\n","categories":["一些技巧"]},{"title":"智能控制 期末复习","url":"/posts/4966c01c.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n这门课以前是交通方向的选修的，但是到我们这一届就变成必修了。。。还要考试，还学不懂，头大。。。\n\n考完了，复习到的都做出来了，没复习到的也自己分析尽量写满了，尽力就行！\n\n# 第一章 计算机控制系统概述\n\n- 计算机控制技术：把**计算机技术**和**自动化控制系统技术**融为一体\n\n## 控制系统组成\n\n### 控制系统概念\n\n- 计算机控制系统：**常规仪表控制系统**演变而来\n\n- 常规仪表控制系统：**闭环控制**，**开环控制**\n\n<!-- more -->\n\n  - 闭环控制系统：**按偏差进行控制**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231122140302855.png\" alt=\"image-20231122140302855\" style=\"zoom:67%;\" />\n\n  - 开环控制系统：**按给定值直接进行控制**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231122140315987.png\" alt=\"image-20231122140315987\" style=\"zoom:67%;\" />\n\n  - 计算机**闭环**控制系统：**把常规仪表闭环控制系统的控制器用计算机和`D/A`转换接口代替**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231122140437329.png\" alt=\"image-20231122140437329\" style=\"zoom:67%;\" />\n\n  - 监控过程步骤：**实时数据采集，实时数据处理，实时输出控制**\n\n### 硬件组成\n\n- **主机**：`CPU`+`RAM`(随机存储器)+`ROM`(只读存储器)+系统总线\n\n- **常规外部设备(外设)**：输入/输出设备 + 外存储器\n\n- **过程输入输出通道**：`AI`，`AO`，`DI`，`DO`\n\n- **操作台**：`CRT`，`LED`，`LCD`\n\n- **通信设备**：交换机，`modem`，集线器\n\n  图如下：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231122141611445.png\" alt=\"image-20231122141611445\" style=\"zoom:67%;\" />\n\n### 软件组成\n\n- 硬件仅为计算机控制系统的**躯体**\n- **软件是完成各种功能的计算机程序的总和，是完成计算机控制系统的神经中枢，整个系统的动作都是在软件程序的指挥下协调工作的**\n- 分类：**系统软件，应用软件**\n\n## 控制系统分类\n\n- 一个总的图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204142830507.png\" alt=\"image-20231204142830507\" style=\"zoom: 67%;\" />\n\n- **数据采集系统(`DAS`)**：**所有计算机控制系统的基础**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201161927415.png\" alt=\"image-20231201161927415\" style=\"zoom:67%;\" />\n\n- 操作指导控制系统(`OGC`)：基于数据采集系统的一种开环结构\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162018857.png\" alt=\"image-20231201162018857\" style=\"zoom:67%;\" />\n\n- 直接数字控制系统(`DDC`)：用一台计算机完成对多个被控参数的数据采集，且按一定的控制规律进行实时决策，并通过输出通道发出控制信号以实现对生产过程的闭环控制\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162046292.png\" alt=\"image-20231201162046292\" style=\"zoom:67%;\" />\n\n- 监督计算机控制系统(`SCC`)：`OGC`操作指导控制系统 与 常规仪表系统或与`DDC`直接数字控制系统综合而成的两级系统\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162159481.png\" alt=\"image-20231201162159481\" style=\"zoom:67%;\" />\n\n- 分散控制系统(`DCS`)：以微处理器为基础，借助于计算机网络对生产过程进行集中管理和分散控制的先进计算机控制系统\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162212109.png\" alt=\"image-20231201162212109\" style=\"zoom:67%;\" />\n\n- 现场总线控制系统(`FCS`)：一种全数字化、全分散式、可互操作的和全开放式的新型控制系统\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162229453.png\" alt=\"image-20231201162229453\" style=\"zoom:67%;\" />\n\n- 计算机集成制造系统(`CIMS`)：计算机技术、网络技术、自动化技术、信号处理技术、管理技术和系统工程技术等新技术发展的结果，它将企业的生产、经营、管理、计划、产品设计、加工制造、销售及服务等环节和人力、财力、设备等生产要素集成起来，进行统一控制，求得生产活动的最优化\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162240936.png\" alt=\"image-20231201162240936\" style=\"zoom:67%;\" />\n\n## 控制装置种类\n\n- 一个总的图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204143347659.png\" alt=\"image-20231204143347659\" style=\"zoom:67%;\" />\n\n- 可编程控制器(`PLC`)\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162535360.png\" alt=\"image-20231201162535360\" style=\"zoom:67%;\" />\n\n- 可编程调节器\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162543567.png\" alt=\"image-20231201162543567\" style=\"zoom:67%;\" />\n\n- 总线式工控机\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162554855.png\" alt=\"image-20231201162554855\" style=\"zoom:67%;\" />\n\n- 嵌入式计算机系统\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231201162605130.png\" alt=\"image-20231201162605130\" style=\"zoom:67%;\" />\n\n- 其他控制装置：**分散控制系统与现场总线控制系统**\n\n# 第二章 模拟量输出通道\n\n## 引言\n\n- 模拟量输出通道的**任务**：**把计算机处理后的数字量信号转换成模拟量电压或电流信号，去驱动相应的执行器，从而达到控制的目的**\n\n- 模拟量输出通道(称为`D/A`通道或`AO`通道)**构成**：**一般是由接口电路、数/模转换器(简称`D/A`或`DAC`)和电压/电流变换器等构成**\n\n- 核心：`D/A`**转换器**，所以模拟量输出通道又叫`D/A`通道\n\n- 模拟量输出通道**基本构成**：**多`D/A`结构，共享`D/A`结构**\n\n  多`D/A`结构：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231122143856168.png\" alt=\"image-20231122143856168\" style=\"zoom:67%;\" />\n\n  共享`D/A`结构：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231122143917400.png\" alt=\"image-20231122143917400\" style=\"zoom:67%;\" />\n\n## D/A转换器\n\n### 工作原理与性能指标\n\n#### 工作原理\n\n图如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231122144654634.png\" alt=\"image-20231122144654634\" style=\"zoom:67%;\" />\n\n- **转化过程公式推导(这个还是记一下吧)**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231202171609447.png\" alt=\"image-20231202171609447\" style=\"zoom: 67%;\" />\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231202171628834.png\" alt=\"image-20231202171628834\" style=\"zoom:67%;\" />\n\n#### 性能指标\n\n- 分辨率：`D/A`**转换器能分辨的最小输出模拟增量，即当输入数字发生单位数码变化时所对应输出模拟量的变化量**。它取决于能转换的二进制位数，**数字量位数越多，分辨率也就越高，但是对应的分辨率的值越小，因为能分辨的增量变小了，肯定就代表精度越高了**\n\n  公式如下，其中`n`代表这个`D/A`是多少位的\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231202171832325.png\" alt=\"image-20231202171832325\" style=\"zoom:67%;\" />\n\n- 转换精度：转换后所得的实际值和理论值的接近程度\n\n- 偏移量误差：输入数字量时，输出模拟量对于零的偏移值\n\n- 线性误差：是`D/A`转换器偏移理想转换特性的最大偏差与满量程之间的百分比\n\n- 稳定时间：描述`D/A`转换速度快慢的一个参数，指**从输入数字量变化到输出模拟量达到终值误差**`1/2 LSB`**时所需的时间**，`LSB`**指输入二进制数的最低有效位**\n\n### 8位DAC0832芯片\n\n- 性能\n\n  - 8位`D/A`转换器\n  - **电流输出**方式\n  - **稳定时间为`1μs`**\n  - **采用`20`脚双立直插式封装**\n  - 同系列芯片还有 `DAC0830`、`DAC0831`\n\n- 工作原理\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129172219134.png\" alt=\"image-20231129172219134\" style=\"zoom:67%;\" />\n\n- 引脚功能\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129172242040.png\" alt=\"image-20231129172242040\" style=\"zoom:67%;\" />\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129172252469.png\" alt=\"image-20231129172252469\" style=\"zoom:67%;\" />\n\n  - 当`WR2`和`XFER`同时有效时，8位`DAC`寄存器端为高电平`“1”`，此时`DAC`寄存器的输出端`Q`跟随输入端D也就是输入寄存器`Q`端的电平变化；反之，当端为低电平`“0”`时，第一级`8`位输入寄存器`Q`端的状态则锁存到第二级`8`位`DAC`寄存器中，以便第三级`8`位`DAC`转换器进行`D/A`转换\n  - 一般情况下为了简化接口电路，可以把和直接接地，使第二级`8`位`DAC`寄存器的输入端到输出端直通，只有第一级8位输入寄存器置成可选通、可锁存的单缓冲输入方式。 特殊情况下可采用双缓冲输入方式，即把两个寄存器都分别接成受控方式\n\n### 12位DAC1210芯片\n\n- 性能\n\n  - 是一个`12`位`D/A`转换器，**电流输出**方式，其结构原理与控制信号功能基本类似于`DAC0832`。由于它比`DAC0832`多了`4`条数据输入线，故有**`24`条引脚**\n\n- 工作原理\n\n  - **内部有`3`个寄存器**\n    - 一个`8`位输入寄存器，用于存放`12`位数字量中的高`8`位`DI11~DI4`；一个`4`位输入寄存器，用于存放`12`位数字量中的低`4`位`DI3 ~DI0`\n    - 一个`12`位`DAC`寄存器，存放上述两个输入寄存器送来的`12`位数字量\n    - `12`位`D/A`转换器用于完成`12`位数字量的转换\n\n- 原理图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129172717416.png\" alt=\"image-20231129172717416\" style=\"zoom:67%;\" />\n\n## 接口电路\n\n- 接口电路的功能：**进行地址译码，产生片选信号或写信号**\n\n### DAC0832接口电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129172920330.png\" alt=\"image-20231129172920330\" style=\"zoom:67%;\" />\n\n- `D/A`转换接口程序\n\n  ~~~asm\n  MOV  DX，220H   ;口地址如220H送入DX     \n  MOV  AL，[DATA] ;被转换的数据如DATA送入累加器AL   \n  OUT  DX，AL     ;送入D/A转换器进行转换\n  ~~~\n\n### DAC1210接口电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129173049042.png\" alt=\"image-20231129173049042\" style=\"zoom:67%;\" />\n\n- `D/A`转换接口程序\n\n  ~~~asm\n  DAC： MOV  DX，0381H  \n        MOV  AL，[DATA]  \n        OUT  DX，AL       ;送高8位数据\n        DEC  DX\n        MOV  AL，[DATA+1]\n        OUT  DX，AL       ;送低4位数据\n        MOV  DX，0384H\n        OUT  DX，AL       ;完成12位数据转换\n  ~~~\n\n## 输出方式\n\n- 分类：**电压输出，电流输出，自动/手动切换输出**等\n\n### 电压输出\n\n- 分类：**单极性输出，双极性输出**\n\n- `DAC`单极性输出\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129173450562.png\" alt=\"image-20231129173450562\" style=\"zoom:67%;\" />\n\n- `DAC`双极性输出\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129173511218.png\" alt=\"image-20231129173511218\" style=\"zoom:67%;\" />\n\n  运算过程：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129173523668.png\" alt=\"image-20231129173523668\" style=\"zoom:67%;\" />\n\n### 电流输出\n\n- **电流信号易于远距离传送，且不易受干扰，特别是在过程控制系统中，自动化仪表只接收电流信号，所以在微机控制输出通道中常以电流信号来传送信息**，这就需要将电压信号再转换成电流信号，完成电流输出方式的电路称为`V/I`变换电路\n\n- 两种形式：**普通运放`V/I`变换电路，集成转换器`V/I`变换电路**\n\n- 普通运放`V/I`交换电路\n\n  - `0~10mA`的输出\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192125339.png\" alt=\"image-20231129192125339\" style=\"zoom:67%;\" />\n\n    分析\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192149832.png\" alt=\"image-20231129192149832\" style=\"zoom:67%;\" />\n\n  - `4~20mA`的输出\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192208487.png\" alt=\"image-20231129192208487\" style=\"zoom:67%;\" />\n\n    分析\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192223213.png\" alt=\"image-20231129192223213\" style=\"zoom:67%;\" />\n\n- 集成转换器`V/I`变换电路\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192342352.png\" alt=\"image-20231129192342352\" style=\"zoom:67%;\" />\n\n### 自动/手动输出方式\n\n- 变换电路图：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192524739.png\" alt=\"image-20231129192524739\" style=\"zoom:67%;\" />\n\n- 自动/手动状态下的`V/I`变换\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192603502.png\" alt=\"image-20231129192603502\" style=\"zoom:67%;\" />\n\n- 自动/手动双向无扰动切换\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192630342.png\" alt=\"image-20231129192630342\" style=\"zoom:67%;\" />\n\n## D/A转换模板\n\n### 通用性\n\n- 体现在三个方面：**符合总线标准，接口地址可选，输出方式可选**\n\n- 符合总线标准\n\n  - 这里的**总线是指计算机内部的总线结构**，`D/A`转换模板及其它所有电路模板都应符合统一的总线标准，以便设计者在组合计算机控制系统硬件时, **只需往总线插槽上插上选用的功能模板而无需连线**，十分方便灵活。\n\n- 接口地址可选\n\n  - **一套控制系统往往需配置多块功能模板，或者同一种功能模板可能被组合在不同的系统中**\n\n  - 因此，**每块模板应具有接口地址的可选性**\n\n  - **一般接口地址可由基址(或称板址)和片址(或称口址)组成**\n\n  - 接口地址可选的译码电路\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129192944988.png\" alt=\"image-20231129192944988\" style=\"zoom:67%;\" />\n\n- 输出方式可选\n\n  - 为了适应不同控制系统对执行器的不同需求，D/A转换模板往往把各种电压输出和电流输出方式组合在一起，然后**通过短接柱来选定某一种输出方式**\n  - 一个实际的`D/A`转换模板，供用户选择的输出范围常常是：`0~5V`、`0~10V`、`±5V`、`0~10mA`、`4~20mA`等\n\n### 设计举例\n\n#### 设计原则\n\n- **安全可靠**：尽量选用性能好的元器件，并采用光电隔离技术\n- **性价比高**：既要在性能上达到预定的技术指标，又要在技术路线、芯片元件上降低成本\n- **通用性**：`D/A`转换模板应符合总线标准，其接口地 址及输出方式应具备可选性\n\n#### 设计步骤\n\n- 确定性能指标\n- 设计电路原理图\n- 设计和制造印制线路板\n- 最后焊接和调试电路板\n\n#### 8路8位D/A转换模板实例\n\n- 设计老师说过不要求，这部分简单看一下就好了\n- 电路原理图\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129194113042.png\" alt=\"image-20231129194113042\" style=\"zoom:67%;\" />\n\n- 分析\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129194149478.png\" alt=\"image-20231129194149478\" style=\"zoom:67%;\" />\n\n- 接口子程序设计\n\n  设`8`路`D/A`转换的`8`个输出数据存放在内存数据段`BUF0~BUF7`单元中，主过程已装填`DS`，`8`片`DAC0832`的通道口地址为`38H~3FH`，分别存放在从`CH0`开始的`8`个连续单元中，该`D/A`转换模板的接口子程序为：\n\n  ~~~asm\n  DOUT   PROC  NEAR\n  MOV  CX，8\n  MOV  BX，OFFSET  BUF0\n  NEXT： MOV  AL，[BX]\n  OUT  CH0，AL\n  INC  CH0\n  INC  BX\n  LOOP  NEXT\n  RET\n  DOUT  ENDP\n  ~~~\n\n# 第三章 模拟量输入通道\n\n## 引言\n\n- 任务：**把被控对象的过程参数如温度，压力，流量，液位，数量等模拟量信号转换为计算机可以接收的数字量信号(模拟量到数字量的转换)**\n\n- 组成核心：`A/D`转换器\n\n- **结构组成，各部分作用**：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129200912376.png\" alt=\"image-20231129200912376\" style=\"zoom:67%;\" />\n\n## 传感变送器\n\n- 作用：**将现场物理量转化为电信号**\n\n## 信号调理电路\n\n- 作用：**抑制干扰，保证`A/D`转换精度**\n- 一般**采用电阻分压法把现场传送来的电流信号转换为电压信号**\n- 分类：**无源`I/V`变换，有源`I/V`变换**\n\n### 无源I/V变换\n\n- 构成：无源器件电阻，RC滤波，二极管限幅等实现\n\n- 取值：\n\n  - 输入`0-10mA`，输出为`0-5V`，`R1=100Ω`，`R2=500Ω`\n  - 输入`4-20mA`，输出为`1-5V`，`R1=100Ω`，`R2=250Ω`\n\n- 电路图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129201237919.png\" alt=\"image-20231129201237919\" style=\"zoom:67%;\" />\n\n### 有源I/V变换\n\n- 构成：运算放大器，电阻电容\n\n- 电路放大倍数\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129201326029.png\" alt=\"image-20231129201326029\" style=\"zoom:67%;\" />\n\n- 取值\n\n  - `R1=200Ω`，`R3=100kΩ`，`R4=150kΩ`，输入`0~10mA`输出`0~5V` \n  - `R1=200Ω`，`R3=100kΩ`，`R4=25kΩ`，输入`4~20mA`输出`1~5V`\n\n- 电路图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129201429941.png\" alt=\"image-20231129201429941\" style=\"zoom:67%;\" />\n\n## 多路模拟开关\n\n- 作用：**实现多选一**\n\n- 结构原理\n\n  - 组成：**电平转换、译码驱动，开关电路**\n\n  - 原理图\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129201520507.png\" alt=\"image-20231129201520507\" style=\"zoom:67%;\" />\n\n- 扩展电路\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129201555935.png\" alt=\"image-20231129201555935\" style=\"zoom:67%;\" />\n\n## 前置放大器\n\n- 作用：**将输入模拟小信号放大到`A/D`转换的量程范围** ，如`0V(DC)~5V(DC)`\n\n- 分类：**测量放大器，可变增益放大器**\n\n- 测量放大器\n\n  - 特点：**对称结构，可抑制共模干扰**\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129201853465.png\" alt=\"image-20231129201853465\" style=\"zoom:67%;\" />\n\n- 可变增益放大器\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129201914425.png\" alt=\"image-20231129201914425\" style=\"zoom:67%;\" />\n\n## 采样保持器\n\n- 作用：**保证，保持`A/D`精度**\n\n### 数据采样定理\n\n- 采样过程：**以一定的时间间隔对连续信号进行采样，使连续信号转化为时间上离散，幅值上连续的脉冲序列的过程**\n\n- 周期采样：以**相同**的时间间隔进行采样\n\n- **香农定理：为了能让采样信号能够完全复现原信号，采样信号的频率至少要为原信号最大频率的2倍**\n\n- 周期采样过程\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129202043371.png\" alt=\"image-20231129202043371\" style=\"zoom:67%;\" />\n\n### 采样保持器\n\n- **零阶采样保持器**\n\n  - 构成：输入输出缓冲放大器`A1`、`A2`和采样开关`S`、保持电容`CH`\n\n  - 工作过程\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129202152271.png\" alt=\"image-20231129202152271\" style=\"zoom:67%;\" />\n\n  - 结构图\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129202207870.png\" alt=\"image-20231129202207870\" style=\"zoom:67%;\" />\n\n- **零阶集成采样保持器**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129202249975.png\" alt=\"image-20231129202249975\" style=\"zoom:67%;\" />\n\n## A/D转换器\n\n### 工作原理与性能指标\n\n#### 工作原理\n\n- 分类：**逐位逼近式，双积分式，电压/频率式**等\n\n- 逐位逼近式`A/D`转换原理\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130093227911.png\" alt=\"image-20231130093227911\" style=\"zoom:67%;\" />\n\n  例题\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130093246804.png\" alt=\"image-20231130093246804\" style=\"zoom:67%;\" />\n\n- 双积分式`A/D`转换原理\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130093312475.png\" alt=\"image-20231130093312475\" style=\"zoom:67%;\" />\n\n- 电压/频率式`A/D`转换原理\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130093347992.png\" alt=\"image-20231130093347992\" style=\"zoom:67%;\" />\n\n#### 性能指标\n\n`A/D`转换器的性能指标\n\n- 分辨率：**分辨率是指`A/D`转换器对微小输入信号变化的敏感程度。分辨率越高，转换时对输入量微小变化的反应越灵敏**(和`D/A`的那个同理)\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130093531573.png\" alt=\"image-20231130093531573\" style=\"zoom:67%;\" />\n\n- 转换精度：用**绝对误差和相对误差**表示\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130093821855.png\" alt=\"image-20231130093821855\" style=\"zoom:67%;\" />\n\n- 转换时间：**`A/D`转换器完成一次转换所需的时间称为转换时间**\n\n  - 逐位逼近式`A/D`转换器的转换时间为**微秒级**，双积分式`A/D`转换器的转换时间为**毫秒级**\n\n- 非线性误差：**`A/D`转换器实际转换特性曲线与理想特性曲线之间的最大偏差**\n\n  - 一般要求非线性误差不大于`1/2LSB`。通常用非线性误差来表示`A/D`转换器的线性度\n\n### 8位ADC0809芯片\n\n#### 芯片介绍                                                                                                     \n\n- `8`位逐位逼近式`A/D`转换器\n\n- 分辨率为`1/ 2^8 ≈ 0.39 %`\n\n- 模拟电压转换范围：`0 ~ +5 V`\n\n- 标准转换时间：`100μs`\n\n- 采用`28`脚双立直插式封装\n\n- 内部结构\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130094442688.png\" alt=\"image-20231130094442688\" style=\"zoom:67%;\" />\n\n- 内部转换时序\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130094457632.png\" alt=\"image-20231130094457632\" style=\"zoom:67%;\" />\n\n#### 接口电路\n\n- 解决：主机如何分时采集多路模拟量输入信号的，即主机如何启动`A/D`转换（体现为对`START`和`ALE`引脚的控制），如何判断`A/D`完成一次模数转换（体现为是否读取`EOC`标志，如何读取），如何读入并存放转换结果的\n- 分类：**查询方式，定时方式**\n\n##### 查询方式读A/D转换数\n\n- 查询：非与门`02（3`）、`/IOW`控制`A/D`转换启动；通过三态缓冲器读入`EOC`状态以判断是否转换结束\n\n- 结构图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130094728435.png\" alt=\"image-20231130094728435\" style=\"zoom:67%;\" />\n\n- 接口程序\n\n  ~~~asm\n          MOV   BX , BUFF  ;置采样数据区首址\n          MOV   CX , 08H   ;８路输入\n  START： OUT   PA , AL       ;启动A/D转换\n  REOC：  IN     AL , PB        ;读EOC\n          RCR   AL , 01       ;判断EOC\n          JNC   REOC          ;若EOC=0，继续查询\n          IN     AL , PA        ;若EOC=1，读A/D转换数\n          MOV  [BX] , AL   ;存A/D转换数\n          INC    BX             ;存A/D转换数地址加1\n          INC    PA             ;接口地址加1\n          LOOP  START      ;循环\n  ~~~\n\n##### 定时方式读A/D转换数\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130094905071.png\" alt=\"image-20231130094905071\" style=\"zoom:67%;\" />\n\n##### 共同点\n\n- 硬软件接口简单，但在转换期间独占了`CPU`时间，好在这种逐位逼近式`A/D`转换的时间只在微秒数量级\n- 当选用双积分式`A/D`转换器时，因其转换时间在毫秒级，因此采用中断法读`A/D`转换数的方式更为适宜\n- 在设计数据采集系统时，究竟采用何种接口方式要根据`A/D`转换器芯片而定\n\n### 12位AD574A芯片\n\n#### 芯片介绍\n\n- 一种高性能的`12`位逐位逼近式`A/D`转换器\n\n- 分辨率：`1 / 2^12 = 0.024%` \n\n- 转换时间：`25μs`,适合于在**高精度快速采样系统**中使用\n\n- 内部结构大体与`ADC0809`类似，由`12`位`A/D`转换器、控制逻辑、三态输出锁存缓冲器与`10V`基准电压源构成，可以直接与主机数据总线连接，但只能输入一路模拟量\n\n- `AD574A`也采用`28`脚双立直插式封装\n\n- 结构图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130095635004.png\" alt=\"image-20231130095635004\" style=\"zoom:67%;\" />\n\n- 模拟输入信号的几种接法\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231130095659594.png\" alt=\"image-20231130095659594\" style=\"zoom:67%;\" />\n\n#### 接口电路\n\n- `12`位`A/D`转换器`AD574A`与`PC`总线的接口有多种方式。既可以与`PC`总线的`16`位数据总线直接相连，构成简单的`12`位数据采集系统；也可以只占用`PC`总线的低`8`位数据总线，将转换后的`12`位数字量分两次读入主机，以节省硬件投入\n- 在`A/D`转换器与`PC`总线之间的数据传送上也可以使用程序查询、软件定时或中断控制等多种方法。由于`AD574A`的转换速度很高，一般多采用查询或定时方式\n\n## A/D转换模板\n\n- 遵循`I/O`模板的通用性原则：**符合总线标准，接口地址可选，输入方式可选**\n- 输入方式可选主要是指模板既可以接受**单端输入信号**也可以接受**双端差动输入信号**\n- 结构组成\n  - **`I/O`电气接口**：完成电平转换、滤波、隔离等信号调理作用\n  - **`I/O`功能部分**：实现采样、放大、模/数转换等功能\n  - **总线接口逻辑**：完成数据缓冲、地址译码等功能\n\n# 第四章 数字量输入/输出通道\n\n在微机控制系统中，除了需要处理模拟信号，还要处理数字信号，包括开关信号，脉冲信号等等。\n\n## 光电耦合隔离技术\n\n### 光电耦合隔离器\n\n- 三种类型：**三极管型，单向可控硅型，双向可控硅型**\n\n- 原理：通过电，光，电这种信号转换，利用**光信号的传送不受电磁场的干扰完成隔离功能**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123102119091.png\" alt=\"image-20231123102119091\" style=\"zoom:67%;\" />\n\n### 光电耦合隔离电路\n\n- **同相传递：输入输出同相，输入为低，输出为低**\n- **反相传递：输入输出反相，输入为高，输出为低**\n- 记忆：同相的两个电阻都在`+5V`的正极这一侧\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123102639789.png\" alt=\"image-20231123102639789\" style=\"zoom:67%;\" />\n\n## 数字量输入通道(DI)\n\n- 生产过程中除了能产生模拟信号，当然也能直接产生数字信号，我们要关心的问题就是这个数字信号能不能被我们的计算机正确接收处理\n- 任务：**把生产过程中的数字信号转换成计算机易于接受的形式**\n\n- 信号调理电路：**虽然都是数字信号，不需进行`A/D`转换，但对通道中可能引入的各种干扰必须采取相应的技术措施，即在外部信号与单片机之间要设置输入信号调理电路**\n\n### 开关输入电路\n\n- 考虑：\n\n  - 电平转换：用电阻分压法把电流信号转换为电压信号\n\n  - `RC`滤波：用`RC`滤波器滤出高频干扰\n\n  - 过电压保护：用稳压管和限流电阻作过电压保护；用稳压管或压敏电阻把瞬态尖峰电压箝位在安全电平上\n\n  - 反电压保护：串联一个二极管防止反极性电压输入\n\n  - 光电隔离：用光耦隔离器实现计算机与外部的完全电隔离\n\n- 开关量输入信号调理电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123103850760.png\" alt=\"image-20231123103850760\" style=\"zoom:67%;\" />\n\n### 脉冲计数电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123104019996.png\" alt=\"image-20231123104019996\" style=\"zoom:67%;\" />\n\n## 数字量输出通道(DO)\n\n- 任务：**把计算机输出的微弱数字信号转换成能对生产过程进行控制的数字驱动信号**\n- 常用电路：**三极管，继电器，晶闸管，固态继电器驱动电路**等\n- 选择：根据现场负荷的不同，如指示灯、继电器、接触器、电机、阀门等，可以选用不同的功率放大器件构成不同的开关量驱动输出通道\n\n### 三极管驱动电路\n\n- 分类：普通三极管驱动电路，达林顿驱动电路\n\n#### 普通三极管驱动电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123104947847.png\" alt=\"image-20231123104947847\" style=\"zoom:67%;\" />\n\n#### 达林顿驱动电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123105124602.png\" alt=\"image-20231123105124602\" style=\"zoom:67%;\" />\n\nMC1416一路驱动电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123105224373.png\" alt=\"image-20231123105224373\" style=\"zoom: 67%;\" />\n\n### 继电器驱动电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123105300226.png\" alt=\"image-20231123105300226\" style=\"zoom:67%;\" />\n\n### 晶闸管驱动电路\n\n- 分类：**单向晶闸管，双向晶闸管**\n- 结构：**阳极A、阴极K、控制极（门极）G**(三个极)\n\n### 固态继电器驱动电路\n\n- **固态继电器SSR**（Solid State Relay）：是一种新型的无触点开关的电子继电器，它利用电子技术实现了控制回路与负载回路之间的电隔离和信号耦合，而且没有\t任何可动部件或触点，却能实现电磁继电器的功能\n- 优点：**体积小、开关速度快、无机械噪声、无抖动和回跳、寿命长**\n\n固态继电器输出驱动电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123105658610.png\" alt=\"image-20231123105658610\" style=\"zoom:67%;\" />\n\n## DI/DO模板\n\n**把数字量输入输出通道设计在一块模板上**，就称为`DI/DO`模板\n\n- 结构组成(遇到了都这么写)：**`I/O`电气接口，`I/O`功能逻辑，总线接口逻辑**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123105738964.png\" alt=\"image-20231123105738964\" style=\"zoom:67%;\" />\n\n# 第五章 键盘及其接口技术\n\n## 引言\n\n- 键盘\n  - 常用的输入设备，是一组按键的集合\n  - 通过功能分类：**数字键和功能键**\n  - 作用：输入数据与命令，查询和控制系统的工作状态，实现简单的人机对话\n- 键盘接口电路\n  - 分类：**编码键盘和非编码键盘**\n  - 编码键盘\n    - 采用硬件编码电路来实现键的编码，每按下一个键，键盘便能自动产生**按键代码**。编码键盘主要有`BCD码`键盘、`ASCII`码键盘等类型\n    - 特点：**使用方便，键盘码产生速度快，占用CPU时间少，但对按键的检测与消除抖动干扰是靠硬件电路来完成的，因而硬件电路复杂、成本高**\n  - 非编码键盘\n    - 仅提供按键的通或断状态，**按键代码**的产生与识别由软件完成\n    - 特点：**硬件电路简单，成本低，但占用CPU的时间较长**\n\n## 键盘输入电路\n\n### 抖动干扰\n\n- 定义：**由于机械触点的弹性振动，按键在按下时不会马上稳定的接通，在弹起时也不能一下完全的断开，从而会出现一连串的抖动，这种抖动就称为按键的抖动干扰**\n\n### 抖动干扰的消除\n\n- 硬件方法：**设计一个滤波延时电路或单稳态电路**\n- 软件方法：**编制一段时间大于100ms的延时程序**\n\n## 非编码独立式键盘\n\n### 查询法接口电路\n\n电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123111857176.png\" alt=\"image-20231123111857176\" style=\"zoom:67%;\" />\n\n流程图\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123111909659.png\" alt=\"image-20231123111909659\" style=\"zoom:67%;\" />\n\n过程\n\n**开关`Si`闭合的时候，对应的`Di`=0；CPU查询检测是否有键按下，之后先消除抖动，然后判断键号，然后再转为对应的键功能程序**\n\n### 中断法接口电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123112139191.png\" alt=\"image-20231123112139191\" style=\"zoom:67%;\" />\n\n## 非编码矩阵式键盘\n\n### 结构组成\n\n矩阵式键盘又叫行列式键盘，是用`I/O`口线组成的行、列矩阵结构，在每根行线与列线的交叉处，**二线不直接相通而通过一个 按键跨接 接通**。采用这种矩阵结构只需`M`根行输出线和`N`根列输入线，就可连接`M×N`个按键。通过键盘扫描程序的行输出与列输入就可确认按键的状态，再通过键盘处理程序便可识别键值。 \n\n结构图\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123113312194.png\" alt=\"image-20231123113312194\" style=\"zoom:67%;\" />\n\n### 程序设计\n\n关于设计的都不是很重要，所以也是了解即可。\n\n- 必须考虑：**实时性，消除抖动干扰**\n- 方式：**编程扫描，定时扫描和中断扫描**\n\n## 编码键盘\n\n### 二进制编码器\n\n- 真值表\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123113616999.png\" alt=\"image-20231123113616999\" style=\"zoom:67%;\" />\n\n### 编码键盘接口电路\n\n- 接口电路图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123113659234.png\" alt=\"image-20231123113659234\" style=\"zoom:67%;\" />\n\n- 消抖电路波形图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123113729301.png\" alt=\"image-20231123113729301\" style=\"zoom:67%;\" />\n\n# 第六章 显示器及其接口技术\n\n## 引言\n\n- 显示装置：用来显示生产过程的工艺状况与运行结果；也叫操作台(第一章)\n\n常用的显示器件\n\n- **显示记录仪**：以**模拟方式**连续显示和记录过程参数的动态变化，但其价格都很贵，在目前的计算机控制系统中已很少采用\n- `LED`**数码管显示器**：具有**结构简单、体积小、功耗低、配置灵活、显示清晰、可靠性高**等优点，已被微型计算机控制系统及智能化仪表广泛采用\n- `LCD`**液晶显示器**：以其**功耗极低**的特点，占据了从电子表到计算器，从袖珍仪表到便携式微型计算机等应用场合\n- `CRT`**终端**：以其**图文并茂的直观生动画面**，可以显示生产过程中的各种画面及报表，如生产流程图、显示报警图、趋势曲线图、\t       路查询图等,在很多微型计算机控制系统中，特别在`DDC`，`SCC`以及`DCS`控制系统中，大都采用`CRT`操作台进行监视和控制\n\n## LED数码管显示器\n\n### 工作原理\n\n- `LED`：**利用`PN`结把电能转换成光能的固体发光器件**，根据制造材料的不同可以发出红、黄、绿、白等不同色彩的可见光来\n- 伏安特性：类似普通二极管，正向压降约为`2`伏左右，工作电流一般在`10-20mA`\n- 结构特性：单段的圆形或方形`LED`常用来显示设备的运行状态，`8`段`LED`可以显示各种数字和字符\n\n### 8段LED显示器\n\n#### 结构与工作原理\n\n- **共阴极：阴极并接成为公共端`COM`，加高电平灯亮**(共阴极加的是高电平，这个记住了，共阳相反)\n\n- **共阳极：阳极并接成为公共端`COM`，加低电平灯亮**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123143020757.png\" alt=\"image-20231123143020757\" style=\"zoom:67%;\" />\n\n#### 选码原理\n\n- 点亮`8`段`LED`不同段的组合，就可以显示十六进制数\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123143230868.png\" alt=\"image-20231123143230868\" style=\"zoom:67%;\" />\n\n### LED显示器显示方式\n\n- `n`个`LED`显示器构成`n`位显示\n- 位选和片选：**把点亮`LED`某一段的控制称为段选，而把点亮`LED`数字某一位的控制称为位选或片选**\n\n#### 静态显示\n\n- 结构特点\n  - **无位选，4个`COM`端连接在一起并接有效电平**\n  - **段选独立，每个`LED`的段选各自与一个8位的并行`I/O`相连**\n- 工作特点\n  - **优点：占用`CPU`机时少，显示稳定可靠**\n  - **缺点：电路中占用`I/O`口资源多**\n- 适用：**规模较大的实时控制系统**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123143606574.png\" alt=\"image-20231123143606574\" style=\"zoom:67%;\" />\n\n#### 动态显示\n\n- 结构特点\n  - **4个LED显示器各自的段选线连在一起，与一个8位的I/O口相连**\n  - **各自的COM端则由另一个I/O口进行位选**\n- 工作特点\n  - **优点：占用I/O资源少**\n  - **缺点：需用软件程序不断地循环扫描定时刷新，因而占用了CPU的大多数机时**\n- 适用：**小型测控系统**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123144933894.png\" alt=\"image-20231123144933894\" style=\"zoom:67%;\" />\n\n### LED显示器接口电路\n\n- 正常工作必须有：**显示部分、锁存器、译码、驱动电路**\n\n#### 静态显示接口电路\n\n- **锁存，驱动，译码均由硬件实现**(`CD4511B)`\n\n- 实现过程：`74LS138`输出作为`LED`片选，每两个共用一个片选；每两个段选码共用一个字节\n\n- 接口电路\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123145649205.png\" alt=\"image-20231123145649205\" style=\"zoom:67%;\" />\n\n#### 动态显示接口电路\n\n- **锁存，驱动由硬件实现**\n\n- **译码由软件实现**\n\n- 实现过程\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123145933065.png\" alt=\"image-20231123145933065\" style=\"zoom:67%;\" />\n\n- 接口电路\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123150002173.png\" alt=\"image-20231123150002173\" style=\"zoom:67%;\" />\n\n## LCD液晶显示器\n\n### 引言\n\n-  一种利用液晶的扭曲/向列效应制成的新型显示器\n-  特点：**功耗极低、体积小、抗干扰能力强、价格廉价**等\n-  分类：**字符式、段位式和点阵式**\n\n### LCD显示器驱动方式\n\n- **直接驱动(静态驱动)**：显示器件只有一个背极（即下玻璃电极基板），但每个字符段都有独立的引脚\n\n- **多极驱动(时分割驱动)**：显示器具有多个背极，各字符段按点阵结构排列，这是显示字段较多时常采用的驱动方式\n\n- 工作过程\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123150810238.png\" alt=\"image-20231123150810238\" style=\"zoom:67%;\" />\n\n- 段位式7段`LCD`的电极配置及译码驱动电路\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123150825707.png\" alt=\"image-20231123150825707\" style=\"zoom:67%;\" />\n\n### 段位式LCD接口电路\n\n- 硬件电路\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123150746085.png\" alt=\"image-20231123150746085\" style=\"zoom:67%;\" />\n\n### 点阵式LCD接口电路\n\n- 引言\n\n  - **点阵式`LCD`不但可以显示字符，而且可以显示各种图形及汉字**\n\n  - **液晶显示模块**`12864`\n\n\n- 液晶模块接线原理\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123151215905.png\" alt=\"image-20231123151215905\" style=\"zoom:67%;\" />\n\n- 液晶模块指令说明\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123151237866.png\" alt=\"image-20231123151237866\" style=\"zoom:67%;\" />\n\n- 软件初始化\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123151300918.png\" alt=\"image-20231123151300918\" style=\"zoom:67%;\" />\n\n- 应用举例\n\n  液晶字符显示使用的时候注意：\n\n  - 要在某一个位置显示中文字符时，应先设定显示字符位置，即先设定显示地址，再写入中文字符编码\n  - 显示`ASCII`字符过程与显示中文字符过程相同。不过在显示连续字符时，只须设定一次显示地址，由模块自动对地址加`1`指向下一个字符位置，否则，显示的字符中将会有一个空`ASCII`字符位置\n  - 当字符编码为`2`字节时，应先写入高位字节，再写入低位字节\n\n\n## 图形显示器\n\n### 概述\n\n- 分类：**`CRT`显示器和`TFT`平面显示器**\n- `CRT`显示器\n  - 由一个图形监示器和相应的控制电路组成。在工业计算机中，插入一块`VGA/TVGA`图形控制板即可实现功能很强的图象显示功能\n  - 优点：丰富的画图命令，如点、线、矩形、多边形、圆、弧以及区域填充、拷贝、剪裁等操作还有窗口功能等\n  - 缺点：体积与功耗大，易受振动和冲击，容易受射线辐射、磁场干扰，因此在恶劣工况下须采用特殊加固和屏蔽措施\n- `TFT`平面显示器\n  - 体积小，耗电省，如最薄的壁挂式机型厚度仅为`5cm`(`2in`)\n  - 可靠性高，寿命长，不易受振动、冲击和射线的干扰影响\n  - 显示颜色`256`种基色，可扩展至`25600`种组合\n\n### 图形显示界面\n\n- 作用：直观形象地监视和操作工业生产过程\n\n- 显示画面功能：反映出整个生产的工艺流程，便于单元操作控制；要有实时动态数据，又要有历史记忆功能\n\n- 显示画面功能内容：调节器、指示仪、记录仪、报警仪、模拟屏以及开关按钮、指示灯等\n\n- 设计语言：早期用汇编语言来编写，后来多采用高级语言，现在采用组态软件\n\n- 常用的显示画面：**总貌画面、分组画面、点画面、流程图画面、趋势曲线画面、报警显示画面、操作指导画面**等\n\n  - 总貌画面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204154704178.png\" alt=\"image-20231204154704178\" style=\"zoom:67%;\" />\n\n  - 分组画面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204154717595.png\" alt=\"image-20231204154717595\" style=\"zoom:67%;\" />\n\n  - 点画面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204154732226.png\" alt=\"image-20231204154732226\" style=\"zoom:67%;\" />\n\n  - 流程图画面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204154745173.png\" alt=\"image-20231204154745173\" style=\"zoom:67%;\" />\n\n  - 趋势曲线画面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204154801510.png\" alt=\"image-20231204154801510\" style=\"zoom:67%;\" />\n\n  - 报警显示画面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204154816038.png\" alt=\"image-20231204154816038\" style=\"zoom:67%;\" />\n\n  - 操作指导画面\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204154832060.png\" alt=\"image-20231204154832060\" style=\"zoom:67%;\" />\n\n\n# 第七章 数据处理技术\n\n## 引言\n\n- 数据采集：**在计算机控制系统中，数据采集是最基本的一种模式**。一般是通过传感器、变送器把生产过程的各种物理参数转换成电信号，然后经`A/D`通道或`DI`通道，把数字量送入计算机中\n- 数据处理：计算机在对这些数字量进行显示和控制之前，还必须根据需要进行相应的数值计算即数据处理。为了满足不同系统的需要，设计出了许多有效的数据处理技术方法，如**预处理，数字滤波，标度变换，查表，越限报警**等\n\n## 预处理技术\n\n- 技术：**数字调零，系统校准，输入和输出数据的极性，字长的预处理技术**\n\n### 系统误差的自动校准\n\n- 系统误差：在控制系统的测量输入通道中，一般均存在**放大器等器件的零点偏移和漂移**，会造成**放大电路的增益误差及器件参数的不稳定**等现象\n- 特点：在一定的测量条件下，其变化规律是可以掌握的，产生误差的原因一般也是知道的\n- 处理方法：通过适当的技术方法如**数字调零、系统校准**来确定并加以校正的，一般采用**软件程序**进行处理\n\n#### 数字调零\n\n- **处理由零点偏移造成的系统误差，通过软件进行实现**\n- 原理：`CPU`分时巡回采集`1`路至`n`路电压信号\n- 特点：**可去掉放大电路、`A/D`转换电路本身的偏移及随时间与温度而发生的各种漂移的影响，从而大大降低对这些电路器件的偏移值的要求，降低硬件成本**\n- 缺点：**不能校正由传感器本身引入的误差**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231123153657445.png\" alt=\"image-20231123153657445\" style=\"zoom:67%;\" />\n\n#### 系统校准\n\n- 原因：**克服传感器本身引入的误差**\n\n- 系统校准计算\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231124111008876.png\" alt=\"image-20231124111008876\" style=\"zoom:67%;\" />\n\n- 适用场合：**传感器特性随时间会发生变化的场合**\n\n### 数据字长的预处理\n\n- 输入位数大于输出位数：**忽略高位数的最低几位**\n- 输入位数小于输出位数：**将`8`位数左移两位构成`10`位数，最低两位用`0`填充**\n\n## 数字滤波方法\n\n- 定义：**计算机系统对输入信号采样多次，然后用某种计算方法进行数字处理，以削弱或滤除干扰噪声造成的随机误差，从而获得一个真实信号的过程**\n\n- 分类：**平均值滤波，中值滤波，限幅滤波，惯性滤波**\n\n### 平均值滤波\n\n- 分类：**算术平均，去极值平均，加权平均，滑动平均**\n\n- 适用场合：工业场合经常遇到的**尖脉冲干扰**的信号滤波\n\n- 缺点：**灵敏度和平滑度较差**\n\n- **算术平均值滤波**\n\n  - 在采样周期`T`内，对测量信号`y`进行`m`次采样， 把`m`个采样值相加后的算术平均值作为本次的有效采样值\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231124114239824.png\" alt=\"image-20231124114239824\" style=\"zoom:67%;\" />\n\n- **去极值平均滤波**\n\n  - 对连续采样的`m`个数据去掉其中的最大值与最小值，然后计算余下的`m-2`个数据的算术平均值\n\n- **加权平均滤波**\n\n  - 对每次采样值不以相同的权系数而以增加新鲜采样值的权重相加\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127143151675.png\" alt=\"image-20231127143151675\" style=\"zoom: 80%;\" />\n\n  - 关于加权系数`Ci`\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127143255796.png\" alt=\"image-20231127143255796\" style=\"zoom:67%;\" />\n\n  - 例子\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127143429294.png\" alt=\"image-20231127143429294\" style=\"zoom:80%;\" />\n\n- **滑动平均滤波**\n\n  - 适用场合：前三种的平均滤波算法有一个共同点，每取得一个有效采样值必须连续进行若干次采样。系统的采样速度较慢或采样信号变化较快时，系统的实时性就无法得到保证\n  - 滑动平均滤波：**在每个采样周期只采样一次，将这一次采样值和过去的若干次采样值一起求平均**，所得结果即为有效采样值\n  - 滑动平均滤波算法优势：**实时性好，提高了系统的响应速度**\n\n\n### 中值滤波\n\n- 定义：**将信号`y`的连续`m`次采样值按大小进行排序，取其中间值作为本次的有效采样值**。本算法为取中值，故采样次数`m`应为奇数，一般`3~5`次即可\n- 编制算法程序：将数据进行排序(随便选一个排序算法，例如冒泡，快排，归并等)，然后取中点\n- 适用场合：**对 缓变过程中的偶然因素引起的波动 或 采样器不稳定造成的误差所引起的脉动干扰 比较有效，而对快速变化过程(如流量)的信号采样则不适用**\n\n### 限幅滤波\n\n- 定义：如下\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127144102345.png\" alt=\"image-20231127144102345\" style=\"zoom:67%;\" />\n\n- 适用场合：**对随机干扰或采样器不稳定引起的失真有良好的滤波效果**\n\n### 惯性滤波\n\n- 定义：**模拟硬件`RC`低通滤波器的数字实现**\n\n- 传递函数：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127144501882.png\" alt=\"image-20231127144501882\" style=\"zoom:80%;\" />\n\n- 实现方法：由于高精度的`RC`电路不易制作，所以硬件`RC`滤波器不可能对极低频率的信号进行滤波。为此，用软件做成低通数字滤波器，从而实现一阶惯性的数字滤波\n\n## 标度变换算法\n\n### 概述\n\n- 标度：衡量某种物理量或参数的量纲\n- 变换：从一种物理量转换为另一种物理量\n- 标度变换：**把计算机系统检测的对象参数的二进制数值还原变换为原物理量的工程实际值**\n- 标度变换方法：**线性式变换，非线性式变换，多项式变换，查表法**\n- 方法选择依据：被测参数的工程量与转换后数字量间的函数关系；通常传感器的输入输出特性决定了此函数关系，从而决定标度变换方法\n\n### 线性式变换\n\n- 线性标度变换：**最常用的标度变换方式**\n\n- 前提条件：传感器输出信号和被测参数之间呈线性关系\n\n- 线式标度变换子程序举例\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127145319214.png\" alt=\"image-20231127145319214\" style=\"zoom:67%;\" />\n\n### 非线性式变换\n\n- 条件：传感器的输出信号与被测参数之间呈非线性关系，**但函数关系可用解析式来表示**\n\n- 非线式标度变换子程序举例\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127150344997.png\" alt=\"image-20231127150344997\" style=\"zoom:67%;\" />\n\n### 多项式变换\n\n- 适用场合：传感器输出信号与被测参数间呈非线性关系\n\n- 应用条件：非线性函数关系不可用解析式来表示\n\n- 采用方法：**插值多项式**来进行标度变换\n\n  - 插值多项式：用一个`n`次多项式来代替某种非线性关系\n\n  - 插值原理：见下图(**我们不知道解析式，因此用多项式来代替，然后用数据带入进行拟合**)\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127151336148.png\" alt=\"image-20231127151336148\" style=\"zoom:80%;\" />\n\n    过程就是这样\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127151516823.png\" alt=\"image-20231127151516823\" style=\"zoom:67%;\" />\n\n  - 插值法缺点\n\n    - 逼近精度影响：很大影响\n\n      处理方法：通常在函数`y= f( x )`的曲线上曲率大的地方应适当加密插值点\n\n    - `CPU`影响：增加插值点和多项式的次数能提高逼近精度但同时会增加计算时间\n\n    - 较好的方法：使用**分段插值法**\n\n      - 分段插值法\n\n        **用多段折线代替曲线进行计算**\n\n        <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127152318278.png\" alt=\"image-20231127152318278\" style=\"zoom:67%;\" />\n\n## 查表法\n\n- 定义：**就是把事先计算或测得的数据按照一定顺序编制成表格**\n\n- 任务：根据被测参数的值或者中间结果，查出最终所需要的结果\n\n- 具体的查表方法：**顺序查表法，计算查表法，对分搜索法**等\n\n  - 顺序查表法\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127152615113.png\" alt=\"image-20231127152615113\" style=\"zoom:67%;\" />\n\n  - 计算查表法\n\n    要求：一定要能够通过一定的计算得出存储单元的地址，然后通过地址访问到数据\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127152633545.png\" alt=\"image-20231127152633545\" style=\"zoom:67%;\" />\n\n  - 对分查表法\n\n    这不就是二分吗，秒了。。。\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127152649719.png\" alt=\"image-20231127152649719\" style=\"zoom:67%;\" />\n\n## 越限报警处理\n\n### 越限报警程序\n\n- 分类：上限报警，下限报警，上下限报警\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127153110730.png\" alt=\"image-20231127153110730\" style=\"zoom:80%;\" />\n\n- 具体设计报警程序时，**为了避免测量值在极限值一点处来回摆动造成频繁报警，一般应在极限值附近设置一个 回差带**\n\n  例如，在下图中上下限其实是一个范围，就是回差带，为了避免频繁报警\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231127153152933.png\" alt=\"image-20231127153152933\" style=\"zoom:67%;\" />\n\n### 越限报警方式\n\n- 分类：**普通声光报警，模拟声光报警，语音报警**\n\n# 第八章 抗干扰技术\n\n## 引言\n\n- **干扰**：有用信号以外的噪声，这些干扰会影响系统的测控精度，降低系统的可靠性，甚至导致系统的运行混乱，造成生产事故\n- 但是干扰是客观存在的，所以必须要研究干扰，以采取相应的抗干扰措施\n\n## 干扰的来源和传播途径\n\n### 来源\n\n- **外部干扰**：例如天电干扰，天体干扰，电器设备的干扰，来自**电源的工频干扰**等等\n- **内部干扰**：由**系统的结构布局、制造工艺**所引入的\n\n### 干扰的传播途径\n\n- 途径：**静电耦合，磁场耦合，公共阻抗耦合**\n  - 静电耦合：电场通过电容耦合途径窜入其他线路\n  - 磁场耦合：通过导体间的互感耦合进来的\n  - 公共阻抗耦合：发生在两个电路的电流流经一个公共阻抗的时候，一个电路在该阻抗上的电压会影响到另一个电路，从而产生干扰噪声的影响\n\n\n## 硬件抗干扰措施\n\n- 除了按照干扰的三种主要作用方式——**串模，共模，长线传输**来分别考虑外，还要从布线、电源、接地等方面考虑\n\n### 串模干扰的抑制\n\n- 抑制措施：**双绞线做信号引线，引入滤波电路**\n\n- 表现形式和产生原因\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129144328532.png\" alt=\"image-20231129144328532\" style=\"zoom:67%;\" />\n\n#### 双绞线做信号引线\n\n- 双绞线抗干扰原因：**外界电磁场会在双绞线相邻的小环路上形成相反方向的感应电动势，从而互相抵消减弱干扰作用**\n\n- 应用场合：**可用来传输模拟信号和数字信号，用于点对点连接和多点连接应用场合，传输距离为几公里，数据传输速率可达2Mbps**\n\n- 抑制效果：**节距越小，干扰的衰减比越大，抑制干扰的屏蔽效果越好**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129144720960.png\" alt=\"image-20231129144720960\" style=\"zoom: 80%;\" />\n\n#### 引入滤波电路\n\n- 硬件滤波器分类：**低通、高通、带通**等滤波器\n\n- 低通滤波器：**干扰频率比被测信号频率高**(干扰频率高了，我们只放低的，高的进不来)\n\n- 高通滤波器：干扰频率比被测信号频率低\n\n- **带通**滤波器：干扰频率落在被测信号频率的**两侧**\n\n- 实现电路：采用电阻`R`、电容`C`、电感`L`等构成滤波器(具体的上高中的时候学物竞的时候我会，但是现在不会了。。。)\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145815942.png\" alt=\"image-20231129145815942\" style=\"zoom:67%;\" />\n\n### 共模干扰的抑制\n\n- 抑制方法：**变压器隔离，光电隔离，浮地屏蔽**等\n\n#### 变压器隔离\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145452377.png\" alt=\"image-20231129145452377\" style=\"zoom:67%;\" />\n\n#### 光电隔离\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145524666.png\" alt=\"image-20231129145524666\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145543082.png\" alt=\"image-20231129145543082\" style=\"zoom:80%;\" />\n\n#### 浮地屏蔽\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145609624.png\" alt=\"image-20231129145609624\" style=\"zoom:67%;\" />\n\n### 长线传输干扰的抑制\n\n#### 波阻抗的测量\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145701639.png\" alt=\"image-20231129145701639\" style=\"zoom:67%;\" />\n\n#### 终端阻抗匹配\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145716676.png\" alt=\"image-20231129145716676\" style=\"zoom:67%;\" />\n\n#### 始端阻抗匹配\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129145734525.png\" alt=\"image-20231129145734525\" style=\"zoom: 80%;\" />\n\n### 信号线的选择和铺设\n\n#### 信号线的选择\n\n| 屏蔽结构            | **干扰衰减比** | 屏蔽效果/dB | **备注**                           |\n| ------------------- | -------------- | ----------- | ---------------------------------- |\n| 铜网（密度85%）     | 103：1         | 40.3        | **电缆的可挠性好，适合近距离使用** |\n| 铜带迭卷（密度90%） | 376：1         | 51.5        | **带有焊药，易接地，通用性好**     |\n| 铝聚酯树脂带迭卷    | 6610：1        | 76.4        | **应使用电缆沟，抗干扰效果最好**   |\n\n#### 信号线的铺设\n\n注意一下事项：\n\n- **模拟信号线与数字信号线不能合用同一根电缆，要绝对避免信号线与电源线合用同一根电缆**\n- **屏蔽信号线的屏蔽层要一端接地，避免多点接地**\n- **信号线的敷设要尽量远离干扰源**，如避免敷设在大容量变压器、电动机等电器设备的附近\n- **信号电缆与电源电缆必须分开，尽量避免平行敷设**\n\n### 电源系统的抗干扰\n\n- 计算机控制系统一般是由**交流电网**供电，电网电压与频率的波动将直接影响到控制系统的可靠性与稳定性\n- **电源的干扰(外部干扰)**是计算机控制系统的一个主要干扰\n\n#### 交流电源系统\n\n- 选用**供电比较稳定**的进线**电源**\n\n- 利用**干扰抑制器**消除尖峰干扰\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129150519032.png\" alt=\"image-20231129150519032\" style=\"zoom:80%;\" />\n\n- 采用**交流稳压器**稳定电网电压\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129150538346.png\" alt=\"image-20231129150538346\" style=\"zoom:80%;\" />\n\n- 利用**不间断电源**(`UPS`)保证不间断供电\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129150547176.png\" alt=\"image-20231129150547176\" style=\"zoom: 67%;\" />\n\n- **掉电保护电路**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129150601888.png\" alt=\"image-20231129150601888\" style=\"zoom:67%;\" />\n\n#### 直流电源系统\n\n- **交流电源变压器**的屏蔽\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129150635014.png\" alt=\"image-20231129150635014\" style=\"zoom:67%;\" />\n\n- 采用**直流电源开关**\n\n- 采用`DC-DC`变换器\n\n- 为每块电路板设置**独立的直流电源**\n\n- 集成电路块的`Vcc`加**旁路电容**\n\n### 接地系统的抗干扰\n\n- 地线：**模拟地，数字地，信号地，系统地，交流地，保护地**\n\n#### 接地处理\n\n- 单点接地与多点接地\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129150938513.png\" alt=\"image-20231129150938513\" style=\"zoom:67%;\" />\n\n- 分别回流法单点接地\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129150956223.png\" alt=\"image-20231129150956223\" style=\"zoom:67%;\" />\n\n- 输入系统的接地\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129151009602.png\" alt=\"image-20231129151009602\" style=\"zoom:67%;\" />\n\n  放大器公共端接屏蔽罩\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129151043936.png\" alt=\"image-20231129151043936\" style=\"zoom:67%;\" />\n\n- 印制线路板的地线分布\n\n  设计印制线路板应遵守下列原则，以免系统内部地线产生干扰。\n\n  - `TTL`，`CMOS`器件的地线要呈辐射状，不能形成环形\n  - 印制线路板上的地线要根据通过的电流大小决定其宽度，不要小于`3mm`，在可能的情况下，地线越宽越好\n  - 旁路电容的地线不能长，应尽量缩短\n  - 大电流的零电位地线应尽量宽，而且必须和小信号的地分开\n\n- 主机系统的接地\n\n  - 全机一点接地\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129151215969.png\" alt=\"image-20231129151215969\" style=\"zoom:67%;\" />\n\n  - 外壳接地机芯浮空\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129151231604.png\" alt=\"image-20231129151231604\" style=\"zoom:67%;\" />\n\n  - 多机系统的接地\n\n## 软件抗干扰措施\n\n- **采用数字滤波方法，即采用某种计算方法对通道的信号进行数字处理，以削弱或滤除干扰噪声**\n- **对于那些可能穿过通道而进入CPU的干扰，可采取指令冗余、软件陷阱，程序运行监视(watchdog timer)等措施来使CPU恢复正常工作**\n\n### 指令冗余\n\n- 解决的问题：**程序跑飞**\n- 解决方法：指令冗余技术\n- 原则：在对程序流向起决定作用的指令之前以及影响系统工作状态的重要指令之前都应插入两、三条**空操作**`NOP`指令，还可以每隔一定数目的指令插入`NOP`指令，以保证跑飞的程序迅速纳入正确轨道\n- 优点：**指令冗余技术可以减少程序出现错误跳转的次数**\n\n### 软件陷阱技术\n\n- 原则：在非程序区设置拦截措施，使程序进入陷阱，即通过一条引导指令，强行将跑飞的程序引向一个指定的地址\n\n- 举例：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129151700051.png\" alt=\"image-20231129151700051\" style=\"zoom:67%;\" />\n\n### 程序运行监视系统\n\n- `Watchdog Timer`工作原理\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129151846909.png\" alt=\"image-20231129151846909\" style=\"zoom:67%;\" />\n\n- `Watchdog Timer`实现方法\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231129151906274.png\" alt=\"image-20231129151906274\" style=\"zoom:67%;\" />\n\n  \n\n# 第九章 数字控制器的设计\n\n- `9.1`是各种数学变换，不会也不考，不在这里罗列了\n- 后面的内容也是了解即可，感觉不会是重点，因为没怎么讲，考了都做不起\n\n## 数字控制器的离散化设计\n\n### 数字控制器的连续设计步骤\n\n- 设计思想：**将整个系统看作模拟系统，设计模拟控制器后再进行控制器的离散化**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194108279.png\" alt=\"image-20231204194108279\" style=\"zoom:67%;\" />\n\n- 设计步骤\n\n  - 设计假象的连续控制器`D(s)`\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194149589.png\" alt=\"image-20231204194149589\" style=\"zoom:67%;\" />\n\n  - 将`D(s)`离散化为`D(z)`\n\n    - **离散化方法：双线性变换法，差分变化法**\n\n      <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194241333.png\" alt=\"image-20231204194241333\" style=\"zoom:67%;\" />\n\n  - 设计由计算机实现的控制算法\n\n    <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194258642.png\" alt=\"image-20231204194258642\" style=\"zoom:67%;\" />\n\n  - 校验\n\n    需按闭环系统性能进行校验,可采用数字仿真方法验证\n\n### PID控制规律\n\n- `PID`控制：**对偏差信号按比例、积分、微分的函数关系进行运算，其运算结果用以输出控制**\n\n- 原理图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194410015.png\" alt=\"image-20231204194410015\" style=\"zoom:67%;\" />\n\n- 控制方法：**比例控制，积分控制，微分控制，比例积分微分控制**\n\n#### 比例控制\n\n- 效果：立即减少偏差\n\n- 优点：调节及时\n\n- 缺点：系统存在余差\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194509564.png\" alt=\"image-20231204194509564\" style=\"zoom:67%;\" />\n\n#### 积分控制\n\n- 效果：消除余差\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194521786.png\" alt=\"image-20231204194521786\" style=\"zoom:67%;\" />\n\n#### 微分控制\n\n- 效果：具有超前控制作用\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194641330.png\" alt=\"image-20231204194641330\" style=\"zoom:67%;\" />\n\n#### 比例积分微分控制\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194707878.png\" alt=\"image-20231204194707878\" style=\"zoom:67%;\" />\n\n#### 优点总结\n\n- 文字懒得打了，就放图吧\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194743204.png\" alt=\"image-20231204194743204\" style=\"zoom:67%;\" />\n\n### 基本数字PID控制算法\n\n- **当采样周期足够短时，用求和代替积分、后向差分代替微分**，就可以使模拟PID离散为数字PID控制算法\n\n- 公式图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194856028.png\" alt=\"image-20231204194856028\" style=\"zoom:67%;\" />\n\n#### 数字PID位置型控制算法\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204194941313.png\" alt=\"image-20231204194941313\" style=\"zoom:67%;\" />\n\n#### 数字PID增量型控制算法\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195004090.png\" alt=\"image-20231204195004090\" style=\"zoom:67%;\" />\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195039305.png\" alt=\"image-20231204195039305\" style=\"zoom:67%;\" />\n\n#### 数字PID控制算法实现比较\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195110215.png\" alt=\"image-20231204195110215\" style=\"zoom:67%;\" />\n\n- 增量型和控制型比较，具有如下图的优点：\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195145142.png\" alt=\"image-20231204195145142\" style=\"zoom:67%;\" />\n\n#### 数字PID控制算法流程\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195207234.png\" alt=\"image-20231204195207234\" style=\"zoom:67%;\" />\n\n### 数字PID算法的改进\n\n- 几种改进算法：**积分分离算法，抗积分饱和算法，不完全微分PID控制算法，微分先行PID控制算法，带死区的算法**\n\n#### 积分分离算法\n\n- 现象：一般的`PID`,当有较大的扰动或大幅度改变设定值时，由于短时间内大的偏差，加上系统本身具有的惯性和滞后，在积分的作用下，将引出现起系统过量的超调和长时间的波动\n\n- 作用：在控制的后期消除稳态偏差\n\n- 分离措施\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195341795.png\" alt=\"image-20231204195341795\" style=\"zoom:67%;\" />\n\n- 普通分离算法：大偏差时不积分——积分“开关”控制\n\n- 积分分离值的确定原则\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195408961.png\" alt=\"image-20231204195408961\" style=\"zoom:67%;\" />\n\n- 变速积分\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195424161.png\" alt=\"image-20231204195424161\" style=\"zoom:67%;\" />\n\n#### 抗积分饱和措施\n\n- 抗积分饱和算法：当控制输出达到系统的上下限幅值的时候，停止积分\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195518787.png\" alt=\"image-20231204195518787\" style=\"zoom:67%;\" />\n\n- 串级控制系统抗积分饱和:主调节器抗积分饱和根据副调节器输出是否越限\n\n#### 抗积分饱和与积分分离的对比\n\n- 相同：某种状态下，切除积分作用\n- 不同\n  - 积分分离根据偏差是否超出预设的分离值(大偏差时不积分)\n  - 抗积分饱和根据最后的控制输出是否越限(输出超限时不积分）\n\n#### 不完全微分PID控制算法\n\n- 问题引出\n\n  - 对有高频扰动的生产过程，微分作用响应过于敏感，易引起振荡，降低调节品质\n  - 执行需要时间，而微分输出短暂，结果是执行器短时间内达不到应有开度，使输出失真\n\n- 解决：在输出端串联一阶惯性环节，组成不完全微分`PID`控制器\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195715550.png\" alt=\"image-20231204195715550\" style=\"zoom:67%;\" />\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195728960.png\" alt=\"image-20231204195728960\" style=\"zoom:67%;\" />\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195741784.png\" alt=\"image-20231204195741784\" style=\"zoom:67%;\" />\n\n#### 微分先行PID控制算法\n\n- 问题引出：给定值的升降会给控制系统带来冲击，如超调量过大，调节阀动作剧烈\n\n- 解决：采用微分先行的`PID`控制算法\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204195841886.png\" alt=\"image-20231204195841886\" style=\"zoom:67%;\" />\n\n- 微分先行PID控制算法和基本PID控制的不同之处：只对被控量（测量值）`y(t)`微分，不对偏差`e(t)`微分，也就是说对给定值`r(t)`无微分作用\n\n- 适用于：给定值频繁升降的控制系统\n\n#### 带死区的算法\n\n- 图\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204200042493.png\" alt=\"image-20231204200042493\" style=\"zoom:67%;\" />\n\n- 注意：死区是一个非线性环节，不能象线性环节一样随便移到`PID`控制器的后面\n\n### 数字PID参数的整定\n\n- 一些方法\n  - 理论整定方法：以被控对象的数学模型为基础，通过理论计算如根轨迹、频率特性等方法直接求得控制器参数\n  - 工程整定方法：近似的经验方法，不依赖模型\n  - 扩充临界比例带法，扩充响应曲线法，试凑法\n- 数字控制器与模拟控制器相比，除了需要整定PID参数，即比例系数、积分时间和微分时间外，还有一个重要参数——采样周期\n\n#### 采样周期的确定\n\n- 影响采样周期选择的因素主要有： 对象的动态特性、扰动的特性、控制算法、执行机构的速度跟踪性能的要求\n\n- 经验数据\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204200256667.png\" alt=\"image-20231204200256667\" style=\"zoom:67%;\" />\n\n#### 扩充临界比例法\n\n- 模拟调节器中使用的临界比例带法（也称稳定边界法）的扩充，是一种闭环整定的实验经验方法\n- 步骤\n  - 选择一个足够短的采样周期`Tmin`\n  - 找临界状态的参数\n  - 选定控制度\n  - 查表，求得`T，Kp，Ti，Td`的值\n  - 按参数投入运行，做调整\n\n#### 扩充响应曲线法\n\n- 采用扩充响应曲线法进行数字PID的整定\n\n- 步骤\n\n  - 断开数字控制器，使系统在手动状态下工作。将被控量调节到给定值附近，当达到平衡时，突然改变手操值，相当给对象施加一个阶跃输入信号\n  - 记录被控量在此阶跃作用下的变化过程曲线（即广义对象的飞升特性曲线\n  - 根据飞升特性曲线，求得被控对象纯滞后时间    和等效惯性时间常数    。据此求得数字PID的整定参数的             值，按参数投入在投运观察控制效果\n\n- 飞升特性曲线\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204200502410.png\" alt=\"image-20231204200502410\" style=\"zoom: 80%;\" />\n\n#### 试凑法\n\n- 通过模拟或实际的系统璧还运行情况，观察系统的响应曲线，根据各参数对系统响应的大致影响，反复试凑，直至达到满意的目标\n\n- 步骤\n\n  - 整定比例部分（`纯P`作用）\n  - 加入积分环节（`PI`作用）\n  - 加入微分环节（`PID`作用）\n\n- `PID`参数对系统性能影响\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204200605439.png\" alt=\"image-20231204200605439\" style=\"zoom:67%;\" />\n\n#### 仿真寻优法\n\n- 运用仿真工具，或离散化后编程仿真\n\n- 寻优方法：单纯形法、梯度法等\n\n- 常见积分型性能指标\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20231204200644373.png\" alt=\"image-20231204200644373\" style=\"zoom:67%;\" />\n\n","categories":["校内课程","智能控制"]},{"title":"牛客 Linux","url":"/posts/ff333d31.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 学习路线\n\n![image-20230712153227763](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712153227763.png)\n\n<!-- more -->\n\n# 第一章 Linux系统编程入门\n\n## GCC\n\n### 什么是GCC\n\n![image-20230712154631108](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712154631108.png)\n\n### GCC工作流程\n\n![image-20230712162031153](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712162031153.png)\n\n预处理命令 **-E**\n\n![image-20230712162645602](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712162645602.png)\n\n得到的结果：\n\n![image-20230712162728058](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712162728058.png)\n\n得到汇编代码命令 **-S**\n\n![image-20230712163010950](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712163010950.png)\n\n得到的结果：\n\n![image-20230712163038321](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712163038321.png)\n\n### 常用参数选项\n\n![image-20230712163407827](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712163407827.png)\n\n![image-20230712163412996](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712163412996.png)\n\n关于-D：**用于在编译的时候指定一个宏**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int a = 10;\n\n    // 用 -D 来表示在编译的时候指定一个宏，从而可以输出这句话!!! -DDEBUG\n    // 一个用途是：可以在用于调试的时候输出一些信息来检测程序，对程序整体的运行没有太大作用\n#ifdef DEBUG\n    cout << \"FUCK\" << endl;\n#endif\n\n    cout << \"you\" << endl;\n\n    return 0;\n}\n\n```\n\n关于-On：进行优化\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int b, c, d, e;\n    b = 10;\n    c = b;\n    d = c;\n    e = d;\n\n    // 使用 -On 进行优化,比如可以优化成如下\n    // int b, c, d, e;\n    // b = 10;\n    // c = 10;\n    // d = 10;\n    // e = 10;\n\n    return 0;\n}\n```\n\n### gcc和g++区别\n\n![image-20230712170016696](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712170016696.png)\n\n![image-20230712170241165](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712170241165.png)\n\n## 静态库\n\n关于库：\n\n![image-20230712192929996](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712192929996.png)\n\n### 命名规则\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230712193256400.png\" alt=\"image-20230712193256400\" style=\"zoom:80%;\" />\n\n### 制作\n\n![image-20230712193344515](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712193344515.png)\n\n制作示例：\n\n现在我想把四则运算的代码打成一个静态库供别人使用\n\n![image-20230712194227453](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712194227453.png)\n\n**按照上面的操作，先通过gcc生成 .o 文件，也就是 -c 到编译汇编，但是不链接的状态，这就得到了各个文件的.o**\n\n![image-20230712194715642](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712194715642.png)\n\n### 使用\n\n在实际的开发环境中，代码的结构往往是这样的\n\n![image-20230712200023339](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712200023339.png)\n\n**include文件夹包含相应库当中实现的头文件，lib就存放对应的库，src存放源码，这个对程序的运行没有影响，可以理解为就是工作目录**\n\n**在实际编译运行程序的过程中，不仅需要提供include下的头文件，也需要提供lib下相对应实现的库**\n\n这就需要在g++或者gcc编译的过程中加入参数了\n\n![image-20230712200254526](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712200254526.png)\n\n直接编译会导致找不到头文件，因为这个时候head.h和main.c不在同一目录，所以需要用 -I 来包含头文件搜索的目录\n\n![image-20230712200359114](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712200359114.png)\n\n在包含了头文件之后，发现里面的函数进行了声明但是没有实现，这个时候就需要引用库文件了\n\n![image-20230712200507667](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712200507667.png)\n\n**calc是库的名称，libcalc.a是我们认为要求的库文件的名称**\n\n![image-20230712200537940](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712200537940.png)\n\n## 动态库\n\n### 命名规则\n\n![image-20230712202308744](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712202308744.png)\n\n### 制作\n\n**得到与位置无关的代码 -fpic/-fPIC (这个 / 是或者的意思，就是两个任选一个写都可以)**\n\n![image-20230712202505969](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712202505969.png)\n\n![image-20230712204636658](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712204636658.png)\n\n### 使用\n\n和静态库的使用方法一致，但是这里会出现动态库加载失败的问题\n\n![image-20230712204703427](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712204703427.png)\n\n![image-20230712204335700](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712204335700.png)\n\n### 加载失败及其解决\n\n![image-20230712205553942](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712205553942.png)\n\n**ldd命令(找到动态库的依赖关系)**\n\n可以看出libcalc.so，我们自己写的动态库找不到依赖，显然无法执行\n\n![image-20230712210027653](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712210027653.png)\n\n**/lib64/ld-linux-x86-64.so.2 这个是系统提供的动态载入器，用来获取依赖库的绝对路径并且装入到内存当中，这样程序就不会报错了**\n\n#### **如何解决**\n\n##### DT_RPATH段无法修改\n\n##### 通过在环境变量 LD_LIBRARY_PATH 中进行添加\n\n```bash\nexport LD_LIBRARY_PATH = $LD_LIBRARY_PATH:/mnt/d/Code/Code-C++/深入学习/Linux方向/牛客网课程/第一章-Linux开发环境搭建/04/library/lib\n```\n\nexport就是修改环境变量的意思，$获取原先的环境变量，:表示在后面添加新的绝对路径，这里把我们的路径添加进去就好了\n\n添加完之后就可以正常运行了\n\n![image-20230712212247869](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712212247869.png)\n\n**但是注意：这个环境变量的配置只是暂时的，当终端关闭环境变量也就消失了，每次需要重新配置**\n\n所以需要永久级别的配置\n\n- 用户级别\n\n**通过 .bashrc 来进行配置**\n\n![image-20230712212541900](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712212541900.png)\n\nvim .bashrc 进入并修改\n\n![image-20230712212710023](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712212710023.png)\n\n在里面添加一行表示配置好了\n\n**完事之后进行更新，以使其应用生效**\n\n![image-20230712212817883](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712212817883.png)\n\n之后也能正常运行\n\n- 系统级别\n\n 在这个文件( /etc/profile )当中进行添加，需要sudo权限\n\n![image-20230712213659601](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712213659601.png)\n\n同样加上这句话\n\n![image-20230712213823973](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712213823973.png)\n\n然后保存更新\n\n![image-20230712213917346](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712213917346.png)\n\n然后同样能正常执行\n\n##### 修改 /etc/ld.so.cathe 文件列表\n\n通过这个文件进行配置 /etc/ld.so.conf\n\n![image-20230712214441428](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712214441428.png)\n\n然后把路径放到这个文件里面就好了\n\n![image-20230712214549726](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712214549726.png)\n\n然后进行更新\n\n![image-20230712215334405](https://cdn.davidingplus.cn/images/2025/01/31/image-20230712215334405.png)\n\n也能正常运行\n\n##### 将动态库文件放到 /lib 或者 /usr/lib 目录下\n\n不建议使用，因为这两个目录中已经放了很多文件，再放入我们自己的文件不利于管理，并且由于可能我们自己的文件和系统文件重名，有可能造成替换然后造成出错\n\n## 静态库和动态库的对比\n\n### 程序编译成可执行程序的过程\n\n**静态库和动态库都是在链接阶段起作用**\n\n![image-20230713095340490](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713095340490.png)\n\n### 静态库制作过程\n\n![image-20230713095639181](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713095639181.png)\n\n### 动态库制作过程\n\n![image-20230713100533853](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713100533853.png)\n\n### 静态库的优缺点\n\n![image-20230713100855560](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713100855560.png)\n\n### 动态库的优缺点\n\n![image-20230713101528981](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713101528981.png)\n\n## makefile\n\n### 什么是makefile\n\n**主要是为了方便进行自动化编译，因为实际的开发过程中代码的存放位置是有规定的，不一定都在同一个目录，这样就导致可能文件依赖出问题，找不到这种，还有就是某个文件依赖于另一个文件，这就需要要求哪些文件需要先编译，哪些文件后编译，这样就需要一个makefile文件来全自动化编译**\n\n![image-20230713102059928](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713102059928.png)\n\n### 命名规则\n\n提供一个或者多个规则\n\n![image-20230713103610886](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713103610886.png)\n\n### 简单案例\n\n创建Makefile文件\n\n![image-20230713103811609](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713103811609.png)\n\n编写\n\n![image-20230713104023510](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713104023510.png)\n\n**第一行app：生成的目标，: 后面是生成目标所需要的依赖文件**\n\n**第二行(需要Tab缩进)：通过执行该命令生成目标**\n\n![image-20230713104408213](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713104408213.png)\n\n### 工作原理\n\n![image-20230713105602304](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713105602304.png)\n\n**makefile可以检测更新，就是我执行命令的时候，会看上次目标的生成时间和现在的依赖文件的时候是否匹配，不匹配则更新了，于是重新执行相对应的代码然后更新目标文件**\n\n举个例子来说明：\n\n![image-20230713105556164](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713105556164.png)\n\n**现在我的目标是app文件，然后我写的依赖是这些 .o 文件，也就是编译了但未链接的可执行文件**\n\n**然后这些文件按理来说是找不到的，所以需要在下面作为目标文件被已有的依赖来进行命令生成**\n\n**最下面的clean是makefile文件最好都有的，清理编译过程中生成的 *.o 和 app 文件**\n\n**这样做的好处是：当某个源文件进行修改之后，在执行make命令的时候，其他的文件不用重新编译，提高了效率**\n\n### 变量\n\n**自动变量只能在规则的命令当中使用!!!**\n\n![image-20230713113345866](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713113345866.png)\n\n### 模式匹配\n\n**把一些格式差不多的规则用通式写出来**!\n\n![image-20230713113808672](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713113808672.png)\n\n### 函数\n\n**wildcard这个函数只能用来获取 .c 文件**\n\n![image-20230713132533052](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713132533052.png)\n\n**用patsubst 来将 .c 文件替换为 .o文件**\n\n![image-20230713132756923](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713132756923.png)\n\n举例：这样就可以把上面的例子优化成这样\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230713133926048.png\" alt=\"image-20230713133926048\" style=\"zoom:80%;\" />\n\n遇到c++可以这么写：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230713140259470.png\" alt=\"image-20230713140259470\" style=\"zoom:80%;\" />\n\n**注意：patsubst里面几个逗号之间不能用空格!!!!(否则出错)**\n\n## GDB调试\n\n### 什么是GDB\n\n![image-20230713140857081](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713140857081.png)\n\n### 准备工作\n\n**gdb是调试可执行程序的，所以我们需要先编译文件成为一个可执行程序**\n\n![image-20230713141622040](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713141622040.png)\n\n示例\n\n**-g 保证了gdb能找到源文件**\n\n![image-20230713143121240](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713143121240.png)\n\n### GDB命令\n\n**gdb 启动的是可执行程序!!!**\n\n![image-20230713142329930](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713142329930.png)\n\n示例：\n\n![image-20230713143240623](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713143240623.png)\n\n#### 查看 list\n\n**list命令**\n\n![image-20230713143813271](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713143813271.png)\n\n**查看别的文件**\n\n先把这三个cpp文件编译连接成为一个可执行文件，加上-g -Wall\n\n![image-20230713144716128](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713144716128.png)\n\n进入gdb，默认查看的是main.cpp，现在我看bubble.cpp\n\n![image-20230713144828842](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713144828842.png)\n\n#### 断点操作 break\n\n![image-20230713150206430](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713150206430.png)\n\n**示例：**\n\n![image-20230713150556682](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713150556682.png)\n\n**在其他文件打断点**\n\n![image-20230713150932690](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713150932690.png)\n\n**设置断点无效或者有效**\n\n![image-20230713151406288](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713151406288.png)\n\n**设置条件断点(一般用在循环的位置)**\n\n![image-20230713151623439](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713151623439.png)\n\n#### 调试命令\n\n![image-20230713152020106](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713152020106.png)\n\n示例：\n\nstart\n\n![image-20230713152439462](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713152439462.png)\n\nrun，next，step\n\n![image-20230713153024581](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713153024581.png)\n\n![image-20230713153323313](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713153323313.png)\n\n**next不会进入函数体，step会进入函数体**\n\n![image-20230713153540431](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713153540431.png)\n\n**自动变量操作**\n\n**这样每次执行代码都可以打印变量的值**\n\n![image-20230713154539740](https://cdn.davidingplus.cn/images/2025/01/31/image-20230713154539740.png)\n\n## 文件IO\n\n### 标准C库IO函数\n\n**使用标准C库的IO函数开发的程序在任意平台上都可以运行**\n\n**标准C库的IO函数的效率更高，因为当中带有缓冲区(设置在内存当中)**\n\n![image-20230714100055222](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714100055222.png)\n\n标准C库的IO和Linux系统IO的关系\n\n**调用这两个标准C库IO函数的时候，会让数据进入设置在内存当中的缓冲区IO buffer，然后通过系统提供的API例如write和read来进行内存到磁盘的读写操作；如果直接使用Linux系统IO函数，则不会经过内存中的缓冲区**\n\n![image-20230714101445015](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714101445015.png)\n\n### 虚拟地址空间\n\n**堆空间是从下往上存，也就是低地址到高地址；**\n\n**栈空间是从上往下村，也就是高地址到低地址**\n\n![image-20230714102646385](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714102646385.png)\n\n### 文件描述符\n\n![image-20230714105536343](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714105536343.png)\n\n### Linux系统IO函数\n\n![image-20230714110840838](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714110840838.png)\n\n### open函数\n\n两种形式\n\n```c++\n// 打开一个已经存在的文件\nint open(const char *pathname, int flags);\n\n// 创建一个新的文件\nint open(const char *pathname, int flags, mode_t mode);\n```\n\n#### open函数打开文件\n\n```c++\nint open(const char* pathname, int flags);\n```\n\n参数解释\n\n- pathname：文件路径\n- flags：对文件的操作权限设置，还有其他的设置，例如：O_RDONLY，O_WRONLY，O_RDWR 这三个设置是互斥的\n- 返回值：返回一个新的文件描述符(int类型，类似于编号)，如果失败，返回-1\n\n关于错误errno\n\n**当打开文件错误的时候，系统会自动将错误号赋值给errno**\n\nerrno属于linux系统函数库，库里面一个全局变量，记录错误号，记录的是最近的错误号\n\n比如这里open函数失败了，系统会自动把错误号赋值给errno\n\n如何打印错误信息？perror()\n\n```c++\n void perror(const char *s);\n```\n\n打印error对应的错误描述\n\ns参数：用户描述，比如hello，最终输出的内容是 hello:xxx(实际的错误描述)\n\n![image-20230714113744182](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714113744182.png)\n\n代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n\n// 使用linux系统IO open()函数的头文件\n#include <fcntl.h>  //函数的声明文件\n#include <sys/stat.h>\n#include <sys/types.h>\n\n// 使用 close()函数头文件\n#include <unistd.h>\n\nint main() {\n    // 打开\n    int fd = open(\"a.txt\", O_RDONLY);\n\n    if (fd == -1)  // 调用错误\n        perror(\"open\");\n\n    // 关闭\n    close(fd);\n\n    return 0;\n}\n```\n\n关闭函数\n\n```c++\nint close(int fd);//  fd：文件描述符 fd\n```\n\n#### open函数创建新文件\n\n```c++\nint open(const char *pathname, int flags, mode_t mode);\n```\n\n参数解释：\n\n- pathname：创建的文件路径\n\n- flags：对文件的操作权限和其他的设置 \n  **必选项：O_RDONLY, O_WRONLY, or O_RDWR 这三个之间是互斥的**\n  **可选项：O_CREAT 文件不存在创建新文件；O_APPEND 可以进行文件的追加**\n  **flags参数是一个int类型的数据，占4个字节，32位，每一位就是一个标志位，1表示有，0表示没有，所以用按位或**\n\n- mode：八进制的数，表示用户对创建出的新的文件的操作权限，比如：0777\n  **3个7分别表示对不同的用户(所有者，组成员，其他用户的权限)的权限，每一个都是3位 ，第一位表示读R，第二位表示写W，第三位 表示可执行X，7对应就是111全有!!!**\n\n  **最终的权限是：mode & ~umask**\n  umask可以通过shell命令 umask 查看\n  umask的作用是为了抹去某些权限，让我们创建的权限更加合理一些\n  例子：0777 & ~0022\n\n```c++\n#include <iostream>\nusing namespace std;\n\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    // 创建一个新的文件\n    int fd = open(\"1.txt\", O_RDWR | O_CREAT, 0777);  // 标签之间要用按位或\n\n    if (fd == -1)\n        perror(\"create\");\n\n    close(fd);\n\n    return 0;\n}\n```\n\n**用shell命令 ll 来查看文件的权限**\n\n![image-20230714134141808](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714134141808.png)\n\n![image-20230714134158964](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714134158964.png)\n\n### read,write函数\n\n头文件：\n\n```c++\n#include <unistd.h>\n```\n\n两个函数：\n\n```c++\nssize_t read(int fd, void *buf, size_t count);\n```\n\n- 参数：\n\n  - fd：文件描述符，通过open得到的，通过文件描述符操作某个文件\n  - buf：缓冲区，需要读取数据存放的地方，数组的地方(传出参数)\n  - count：指定的数组的大小\n\n- 返回值：\n\n  - 成功 >0 返回实际读取到的字节数\n\n    \t\t**==0 文件已经读取完了(注意是在调用read函数之前文件指针就在末尾了才会返回0，一次性从头读完是会返回读取的字节数的)**\n\n  - 失败 -1 并且修改errno\n\n```c++\nssize_t write(int fd, const void *buf, size_t count);\n```\n\n- 参数：\n  - fd：文件描述符，通过open得到，通过文件描述符操作某个文件\n  - buf：要往磁盘写入的数据\n  - count：要写入的实际的大小\n\n- 返回值：\n  - 成功 >0 返回实际写入的字节数\n    ==0 文件已经写入完了\n  - 失败 -1 并且修改errno\n\n代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define SIZE 1024\n\nint main() {\n    // 通过open打开english.txt文件\n    int fd_src = open(\"english.txt\", O_RDONLY);\n    if (fd_src == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 创建新的文件\n    int fd_dest = open(\"cpy.txt\", O_WRONLY | O_CREAT | O_APPEND, 0777);\n    if (fd_dest == -1) {\n        perror(\"create\");\n        return -1;\n    }\n\n    // 频繁的读写操作\n    char buf[SIZE] = {0};\n    int len = 0;\n    while ((len = read(fd_src, buf, sizeof(buf))) > 0)\n        // 在循环的条件中进行读操作，在循环体中进行写入\n        write(fd_dest, buf, len);\n\n    // 关闭文件\n    close(fd_src);\n    close(fd_dest);\n\n    return 0;\n}\n```\n\n### lseek函数\n\n在标准C库里面也有一个非常相似的函数fseek()，我甚至怀疑在linux平台下他的底层是不是调用的是fseek()\n\n```c++\n//标准C库的函数\n#include <stdio.h>\n\nint fseek(FILE *stream, long offset, int whence);\n\n//Linux系统函数\n#include <sys/types.h>\n#include <unistd.h>\n\noff_t lseek(int fd, off_t offset, int whence);\n```\n\n- 参数：\n\n  - fd：文件描述符，通过open得到，通过这个fd操作某个文件\n  - offset：off_t(long别名) 偏移量\n  - whence：\n\n  \t\t \\- SEEK_SET 设置文件指针的偏移量，从头开始\n\n      \t- SEEK_CUR 设置偏移量：当前位置 + 第二参数offset的值\n\t    \t\n\t\t \t- SEEK_END 设置偏移量：文件大小 + 第二参数offset的值\n\n- 返回值：返回文件指针设置之后的位置\n\n- 作用：\n\n  \t1.移动文件指针到头部 lseek(fd,0,SEEK_SET);\n  \t\n  \t2.获取当前文件指针的位置 lseek(fd,0,SEEK_CUR);\n  \t\n  \t3.获取文件长度 lseek(fd,0,SEEK_END);\n  \t\n  \t4.拓展文件的长度，当前文件10B，增加100B，增加了100个字节 lseek(fd,100,SEEK_END);\n  \t\n  \t**为什么能扩展？**\n  \t\n  \t**因为我们把文件指针移动到了本来不属于文件的位置上去，系统就进行了扩展，**\n  \t\n  \t**不过一定要一次写的操作。迅雷等下载工具在下载文件时候先扩展一个空间，然后再下载的。**\n\n代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"hello.txt\", O_RDWR);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    int ret = lseek(fd, 100, SEEK_END);\n    if (ret == -1) {\n        perror(\"lseek\");\n        return -1;\n    }\n\n    // 写入一个空数据\n    write(fd, \" \", 1);\n\n    close(fd);\n\n    return 0;\n}\n```\n\n### stat,lstat函数\n\n```c++\n    #include <sys/stat.h>\n    #include <sys/types.h>\n    #include <unistd.h>\n\n    int stat(const char *pathname, struct stat *statbuf);\n//作用：获取一个文件的相关的信息\n//参数：\n    //pathname：操作的文件路径\n    //statbuf：结构体变量，传出参数，用于保存获取到的文件信息\n//返回值：\n    //成功 0\n    //失败 -1，并且修改errno\n\n    int lstat(const char *pathname, struct stat *statbuf);\n//参数，返回值同上\n```\n\n里面有一个stat结构体变量，他的结构如下：\n\n#### stat结构体(!!!)\n\n![image-20230714152755154](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714152755154.png)\n\n比较重要的是mode_t类型的 st_mode变量：**就是下面的16位数(01)**\n\n**之前创建文件open函数的第三个参数也是这个类型，只不过里面只用了User,Group,Others这三个**\n\n![image-20230714153204023](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714153204023.png)\n\n**判断后面某一位是否为1，也就是比如User是否具有r权限，就用st_mode变量(他就是这16位数)与其相与**\n\n**判断文件类型：由于文件类型在前四位当中可能不止一位为1，那么联系计网，与掩码相与看是不是和这个标识相同就知道了!!!**\n\n#### 区别\n\n软链接文件\n\n![image-20230714154550861](https://cdn.davidingplus.cn/images/2025/01/31/image-20230714154550861.png)\n\n**就是说 2.txt 是指向 1.txt 文件的!!!但是它本身的大小是5个字节**\n\n**lstat()就是用来获取该软链接文件本身的信息的，而不是获取他指向的文件的信息，如果用stat()函数就会获得指向的文件，这里就是1.txt的信息**\n\n代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    struct stat statbuf;\n\n    int ret = stat(\"1.txt\", &statbuf);\n    if (ret == -1) {\n        perror(\"stat\");\n        return -1;\n    }\n\n    cout << \"size: \" << statbuf.st_size << endl;\n\n    ret = stat(\"2.txt\", &statbuf);\n    if (ret == -1) {\n        perror(\"stat\");\n        return -1;\n    }\n\n    cout << \"size: \" << statbuf.st_size << endl;\n\n    ret = lstat(\"2.txt\", &statbuf);\n    if (ret == -1) {\n        perror(\"stat\");\n        return -1;\n    }\n\n    cout << \"size: \" << statbuf.st_size << endl;\n\n    return 0;\n}\n```\n\n**在shell终端中可以用 stat 命令来获取文件的信息，这里的文件信息就是本文件了，就不是软链接文件的指向文件**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230714154900243.png\" alt=\"image-20230714154900243\"  />\n\n### 模拟实现ls -l 命令\n\n**里面有很多库函数的调用，这些大概知道就行，开发的时候去查文档就好了**\n\n![image-20230715104004715](https://cdn.davidingplus.cn/images/2025/01/31/image-20230715104004715.png)\n\n第一个字符( ’-‘ )是文件类型，后面一堆rwx是读写权限\n\n后面 1 是硬连接数量\n\n在后面两个是文件所有者和文件所在组\n\n然后是文件大小\n\n然后是上一次的修改时间\n\n最后就跟着文件的名称\n\n代码：\n\n~~~cpp\n#include <ctime>\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <grp.h>\n#include <pwd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define MAXSIZE 1024\n\n// 模拟实现 ls -l 这个指令\n// -rwxrwxrwx 1 lzx0626 lzx0626 107 Jul 15 09:40 ls-l.cpp\n\nint main(int argc, char const *argv[]) {\n    if (argc < 2) {\n        cout << \"usage: \" << argv[0] << \" <filename>\" << endl;\n        return -1;\n    }\n\n    struct stat statbuf;\n\n    // 通过stat()函数获取文件的信息\n    int ret = stat(argv[1], &statbuf);\n    if (ret == -1) {\n        perror(\"stat\");\n        return -1;\n    }\n\n    // 获取文件类型和文件权限 st_mode变量\n    string perms;  // 保存文件类型和权限的字符串\n    mode_t _mode = statbuf.st_mode;\n    // 获得文件类型和掩码 -S_IFMT 相与\n    switch (_mode & S_IFMT) {\n    case S_IFSOCK:\n        perms.append(\"s\");\n        break;\n    case S_IFLNK:\n        perms.append(\"1\");\n        break;\n    case S_IFREG:\n        perms.append(\"-\");\n        break;\n    case S_IFBLK:\n        perms.append(\"b\");\n        break;\n    case S_IFDIR:\n        perms.append(\"d\");\n        break;\n    case S_IFCHR:\n        perms.append(\"c\");\n        break;\n    case S_IFIFO:\n        perms.append(\"p\");\n        break;\n    default:\n        perms.append(\"?\");\n        break;\n    }\n\n    // 判断文件访问权限 Users Group Others\n    // Users\n    perms.append((_mode & S_IRUSR) ? \"r\" : \"-\");\n    perms.append((_mode & S_IWUSR) ? \"w\" : \"-\");\n    perms.append((_mode & S_IXUSR) ? \"x\" : \"-\");\n    // Group\n    perms.append((_mode & S_IRGRP) ? \"r\" : \"-\");\n    perms.append((_mode & S_IWGRP) ? \"w\" : \"-\");\n    perms.append((_mode & S_IXGRP) ? \"x\" : \"-\");\n    // Others\n    perms.append((_mode & S_IROTH) ? \"r\" : \"-\");\n    perms.append((_mode & S_IWOTH) ? \"w\" : \"-\");\n    perms.append((_mode & S_IXOTH) ? \"x\" : \"-\");\n\n    // 获取硬连接数\n    nlink_t link_num = statbuf.st_nlink;\n\n    // 文件所有者\n    // 这个函数可以通过用户uid获得用户名称\n    string _User = getpwuid(statbuf.st_uid)->pw_name;\n\n    // 文件所在组\n    // 这个函数通过组gid获得名称\n    string _Group = getgrgid(statbuf.st_gid)->gr_name;\n\n    // 文件大小\n    off_t _size = statbuf.st_size;\n\n    // 获取修改时间\n    // ctime()函数可以将时间差值转化为本地时间\n    string _mtime = string(ctime(&statbuf.st_mtime));\n    // 这个时间格式化之后回车换行了，将其去掉\n    _mtime.pop_back();\n\n    // 输出\n    char ret_buf[MAXSIZE];\n    // 这个函数可以往字符串中填充\n    sprintf(ret_buf, \"%s %ld %s %s %ld %s %s\", perms.c_str(), link_num, _User.c_str(), _Group.c_str(),\n            _size, _mtime.c_str(), argv[1]);\n\n    cout << ret_buf << endl;\n\n    return 0;\n}\n~~~\n\n里面有一个系统函数对应的功能已经列出了，下面罗列他们的头文件\n\n~~~cpp\n#include <pwd.h>\nstruct passwd *getpwuid(uid_t uid);\n~~~\n\n~~~cpp\n#include <grp.h>\nstruct group *getgrgid(gid_t gid);\n~~~\n\n~~~cpp\n#include <time.h>\nchar *ctime(const time_t *timep);\n~~~\n\n### 文件属性操作函数\n\n四个函数\n\n![image-20230715110918357](https://cdn.davidingplus.cn/images/2025/01/31/image-20230715110918357.png)\n\n#### access函数\n\n```cpp\n#include <unistd.h>\nint access(const char *pathname, int mode);\n// 作用：用来判断某个文件是否有某个权限，或者判断文件是否存在\n// 参数：\n// pathname：文件路径\n// mode：\n    // R_OK 是否有读权限\n    // W_OK 是否有写权限\n    // X_OK 是否有执行权限\n    // F_OK 文件是否存在\n// 返回值：\n// 成功 返回0\n// 失败(没有这个权限) 返回-1，并且修改errno\n```\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    int ret = access(\"1.txt\", F_OK);\n    if (ret == -1) {\n        perror(\"access\");\n        return -1;\n    }\n\n    cout << \"file exists.\" << endl;\n\n    return 0;\n}\n~~~\n\n#### chmod函数\n\n~~~cpp\n#include <sys/stat.h>\nint chmod(const char *pathname, mode_t mode);\n// 作用：修改文件权限\n// 参数：\n//     pathname：文件路径\n//     mode：需要修改的权限值，八进制的数\n// 返回值：\n//     成功返回0\n//     失败返回-1\n~~~\n\n```cpp\n#include <iostream>\nusing namespace std;\n#include <sys/stat.h>\n\nint main() {\n    int ret = chmod(\"1.txt\", 0777);\n    if (ret == -1) {\n        perror(\"chmod\");\n        return -1;\n    }\n\n    return 0;\n}\n```\n\n#### chown函数(了解)\n\n```cpp\n#include <unistd.h>\n\nint chown(const char *pathname, uid_t owner, gid_t group);\nint fchown(int fd, uid_t owner, gid_t group);\nint lchown(const char *pathname, uid_t owner, gid_t group);\n```\n\n#### truncate函数\n\n~~~cpp\n#include <sys/types.h>\n#include <unistd.h>\n\nint truncate(const char *path, off_t length);\n// 作用：缩减或者扩展文件尺寸到达指定的大小\n// 参数:\n    // path：文件路径\n    // length：需要最终文件变成的大小\n// 返回值：\n    // 成功 0\n    // 失败 -1\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    int ret = truncate(\"b.txt\", 5);\n    if (ret == -1) {\n        perror(\"truncate\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n### 文件目录操作函数\n\n![image-20230715113517243](https://cdn.davidingplus.cn/images/2025/01/31/image-20230715113517243.png)\n\n#### mkdir函数\n\n~~~cpp\n    #include <sys/stat.h>\n    #include <sys/types.h>\n\n    int mkdir(const char *pathname, mode_t mode);\n// 作用：去创建一个目录\n// 参数：\n//     pathname：目录名称\n//     mode：权限，八进制数\n// 返回值：\n//     成功 0\n//     失败 -1\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <sys/stat.h>\n#include <sys/types.h>\n\nint main() {\n    int ret = mkdir(\"fuck\", 0777);\n    if (ret == -1) {\n        perror(\"mkdir\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n#### rmdir函数\n\n~~~cpp\n#include <unistd.h>\nint rmdir(const char *pathname);\n~~~\n\n删除目录，略\n\n**这个函数只能删除空目录，如果里面有文件需要先把文件清空，才能进行删除!!!**\n\n#### rename函数\n\n~~~cpp\n#include <stdio.h>\nint rename(const char *oldpath, const char *newpath);\n//一看就懂了\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    int ret = rename(\"fuck\", \"fuckyou\");\n    if (ret == -1) {\n        perror(\"rename\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n#### chdir函数和getcwd函数\n\n~~~cpp\n#include <unistd.h>\nint chdir(const char *path);\n//作用：修改进程的工作目录\n    //比如在 /home/newcoder 启动了一个可执行程序 a.out，进程的工作目录 /home/newcoder\n//参数：\n    //path：需要修改到的工作目录\n\n\n#include <unistd.h>\nchar *getcwd(char *buf, size_t size);\n//作用：获取当前工作目录\n//参数：\n    //buf：往数组里存，传出参数\n    //size：数组的大小\n//返回值：返回的是指向的一块内存，这个数据就是第一个参数buf\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#include <cstring>\n\nint main() {\n    // 获取当前工作目录\n    char buf[1024] = {0};\n\n    getcwd(buf, sizeof(buf));\n    cout << buf << endl;\n\n    // 修改工作目录\n    int ret = chdir(\"./fuckyou\");\n    if (ret == -1) {\n        perror(\"chdir\");\n        return -1;\n    }\n\n    // 代码执行到这里把工作目录修改之后在该目录之下进行下一步操作\n    // 只在程序运行的时候生效，程序结束后终端当中的工作目录不会改变!\n    \n    // 创建新的文件\n    int fd = open(\"1.txt\", O_RDWR | O_CREAT, 0664);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    close(fd);\n\n    char Null_buf[1024] = {0};\n    strncpy(buf, Null_buf, sizeof(buf));\n\n    getcwd(buf, sizeof(buf));\n    cout << buf << endl;\n\n    return 0;\n}\n~~~\n\n### 文件目录遍历函数\n\n![image-20230715125019218](https://cdn.davidingplus.cn/images/2025/01/31/image-20230715125019218.png)\n\n#### opendir函数\n\n~~~cpp\n#include <dirent.h>\n#include <sys/types.h>\nDIR *opendir(const char *name);\n//参数：\n    //name：需要打开的目录的名称\n//返回值：\n    //DIR * 类型，理解为目录流\n    //错误 返回nullptr\n~~~\n\n#### readdir函数\n\n#### dirent结构体和d_type(!!!)\n\n![image-20230715130311932](https://cdn.davidingplus.cn/images/2025/01/31/image-20230715130311932.png)\n\n**这个dirent存储的也是文件的信息，前面也有个stat结构体也有存储，但是这两个存储的东西不太一样**\n\n~~~cpp\n//打开目录\n#include <dirent.h>\n#include <sys/types.h>\nDIR *opendir(const char *name);\n//参数：\n    //name：需要打开的目录的名称\n//返回值：\n    //DIR * 类型，理解为目录流\n    //错误 返回nullptr\n\n//读取目录中的数据\n#include <dirent.h>\nstruct dirent *readdir(DIR *dirp);\n//参数：\n    //dirp是通过opendir返回的结果\n//返回值：\n    //struct dirent 代表读取到的文件的信息\n    //读取到了文件末尾或者失败了，返回Null，区别是读到文件末尾不会修改errno，失败会修改\n\n//关闭目录\n#include <dirent.h>\nint closedir(DIR *dirp);\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <dirent.h>\n#include <sys/types.h>\n\n// 递归函数，用于获取目录下所有普通文件的个数\nvoid getFileNum(string path, int& num) {\n    // 打开目录\n    DIR* _dir = opendir(path.c_str());\n    if (_dir == nullptr) {\n        perror(\"opendir\");\n        exit(0);\n    }\n\n    // 读取目录数据\n    // 循环读取，因为// 注意这个16的由来dir是一个一个读取的，读到末尾返回Null\n    struct dirent* _ptr;\n\n    while ((_ptr = readdir(_dir)) != nullptr) {\n        // 获取名称\n        // Shell终端中有当前目录 ./ 和 上级目录 ../，这两个不能拿来递归，需要忽略\n        string _dname = _ptr->d_name;\n        if (_dname == \".\" || _dname == \"..\")\n            continue;\n\n        // 判断是普通文件还是目录\n        if (_ptr->d_type == DT_DIR)\n            // 目录需要拼接一下\n            getFileNum(path + \"/\" + _dname, num);\n        else if (_ptr->d_type == DT_REG)\n            ++num;\n    }\n\n    // 关闭目录\n    closedir(_dir);\n}\n\nint main(int argc, char* const argv[]) {\n    // 读取某个目录下所有普通文件的个数\n    if (argc < 2) {\n        cout << \"usage: \" << argv[0] << \" <path>\" << endl;\n        return -1;\n    }\n\n    int num = 0;\n    getFileNum(argv[1], num);\n    cout << num << endl;\n\n    return 0;\n}\n~~~\n\n### dup,dup2函数(与文件描述符相关)\n\n![image-20230715141246853](https://cdn.davidingplus.cn/images/2025/01/31/image-20230715141246853.png)\n\n#### dup()\n\n~~~cpp\n#include <unistd.h>\nint dup(int oldfd);\n// 作用：复制一个新的文件描述符，他们是指向同一个文件的，只是用了两个文件描述符\n// 新的文件描述符会使用空闲的文件描述符表中最小的那个!!!\n~~~\n\n~~~cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"1.txt\", O_RDWR | O_CREAT, 0664);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    int fd1 = dup(fd);\n    if (fd1 == -1) {\n        perror(\"dup\");\n        return -1;\n    }\n\n    printf(\"fd : %d , fd1 : %d\\n\", fd, fd1);\n\n    // 关闭fd，现在只有fd1指向文件\n    close(fd);\n\n    // 通过fd1来写该文件\n    string fuck = \"hello world\";\n    int ret = write(fd1, fuck.c_str(), fuck.size());\n    if (ret == -1) {\n        perror(\"write\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n#### dup2()\n\n~~~cpp\n#include <unistd.h>\n\nint dup2(int fd1, int fd2);\n// 作用：重定向文件描述符\n    // fd1指向a.txt，fd2指向b.txt\n    // 调用函数成功后，fd2和b.txt的连接做close(fd1仍指向a.txt)，fd2指向a.txt\n    // fd1必须是一个有效的文件描述符\n    // 如果相同则相当于什么都没做\n// 返回值：\n    // fd2，他们都指向的是fd1之前指向的文件\n~~~\n\n~~~cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    int fd = open(\"2.txt\", O_RDWR | O_CREAT, 0664);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    int fd1 = open(\"3.txt\", O_RDWR | O_CREAT, 0664);\n    if (fd1 == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    printf(\"fd : %d , fd1 : %d\\n\", fd, fd1);\n\n    int fd2 = dup2(fd, fd1);\n    // 现在fd本来指向 2.txt ，现在fd仍指向2.txt\n    // fd1本来 3.txt，现在指向到了 2.txt\n    if (fd2 == -1) {\n        perror(\"dup2\");\n        return -1;\n    }\n\n    // 通过fd1去写数据，实际操作的是2.txt\n    // 通过fd一样指向2.txt\n    string fuck = \"hello world\";\n    int ret = write(fd1, fuck.c_str(), fuck.size());\n    if (ret == -1) {\n        perror(\"write\");\n        return -1;\n    }\n\n    printf(\"fd : %d , fd1 : %d , fd2: %d\\n\", fd, fd1, fd2);\n\n    return 0;\n}\n~~~\n\n### fcntl()\n\n两个作用：\n\n**复制文件描述符**\n\n**设置或者获取文件的状态标志**\n\n![image-20230715145100478](https://cdn.davidingplus.cn/images/2025/01/31/image-20230715145100478.png)\n\n~~~cpp\n#include <fcntl.h>\n#include <unistd.h>\n\nint fcntl(int fd, int cmd, ...); ...当中是可变参数\n// 参数：\n//     fd：需要操作的文件描述符\n//     cmd：表示对文件描述符进行如何操作\n//         F_DUPFD 复制文件描述符，复制的是第一个参数，得到一个新的文件描述符(返回值)\n//             int ret = fcntl(fd,F_DUPFD);\n//         F_GETFL 获取指定文件描述符的文件状态flag\n//             获取的flag和我们通过open函数传递的flag是一个东西\n//         F_SETFL 设置文件描述符的文件状态flag\n//             必选项：O_RDONLY O_WRONLY O_RDWR 不可以被修改\n//             可选项：O_APPEND O_NONBLOCK\n//                 O_APPEND 表示追加数据\n//                 O_NONBLOCK 设置成非阻塞\n//                     阻塞和非阻塞：描述的是函数调用的行为\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    // 1.复制文件描述符，得到两个文件描述符(int值不同)指向同一个文件，可以进行的操作相同\n    // int fd = open(\"1.txt\", O_RDONLY);\n    // if (fd == -1) {\n    //     perror(\"open\");\n    //     return -1;\n    // }\n\n    // int ret = fcntl(fd, F_DUPFD);\n    // if (ret == -1) {\n    //     perror(\"fcntl\");\n    //     return -1;\n    // }\n\n    // 2.修改或者获取文件描述符的文件状态flag\n    // 这里必须读写权限都要有才行\n    int fd = open(\"1.txt\", O_RDWR, 0664);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 修改文件描述符的flag，加入O_APPEND这个标记\n    // 首先获得\n    int _flag = fcntl(fd, F_GETFL);\n    if (_flag == -1) {\n        perror(\"fcntl\");\n        return -1;\n    }\n\n    // 然后修改\n    int ret = fcntl(fd, F_SETFL, _flag | O_APPEND);\n    if (ret == -1) {\n        perror(\"fcntl\");\n        return -1;\n    }\n\n    // 然后进行追加\n    string fuck = \"你好\";\n    ret = write(fd, fuck.c_str(), fuck.size());\n    if (ret == -1) {\n        perror(\"write\");\n        return -1;\n    }\n\n    close(fd);\n\n    return 0;\n}\n~~~\n\n### 文件删除函数\n\n#### unlink()和remove()\n\n~~~cpp\n#include <unistd.h>\nint unlink(const char *pathname); // linux系统的函数\n~~~\n\n~~~cpp\n#include <stdio.h>\nint remove(const char *pathname); // 标准C库的函数\n~~~\n\n# 第二章 Linux多进程开发\n\n## 一些概念\n\n### 程序和进程\n\n![image-20230716113520531](https://cdn.davidingplus.cn/images/2025/01/31/image-20230716113520531.png)\n\n![image-20230716113908652](https://cdn.davidingplus.cn/images/2025/01/31/image-20230716113908652.png)\n\n### 单道，多道程序设计\n\n![image-20230716114055627](https://cdn.davidingplus.cn/images/2025/01/31/image-20230716114055627.png)\n\n### 时间片\n\n![image-20230716114135444](https://cdn.davidingplus.cn/images/2025/01/31/image-20230716114135444.png)\n\n\n\n### 并行和并发\n\n![image-20230716114205304](https://cdn.davidingplus.cn/images/2025/01/31/image-20230716114205304.png)\n\n### 进程控制块PCB\n\n**在Linux内核的进程控制块是 task_struct 结构体**\n\n![image-20230716120419774](https://cdn.davidingplus.cn/images/2025/01/31/image-20230716120419774.png)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230716121448756.png\" alt=\"image-20230716121448756\" style=\"zoom:80%;\" />\n\n## 进程状态\n\n### 状态转化图\n\n![image-20230718093121456](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718093121456.png)\n\n**加入新建和终止的状态**\n\n![image-20230718093806701](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718093806701.png)\n\n### 进程相关命令\n\n~~~shell\nps aux / ajx\n#注意aux和ajx的区别\n~~~\n\n![image-20230718094028703](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718094028703.png)\n\n#### ps aux\n\n![image-20230718094423758](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718094423758.png)\n\nstat参数的意义：\n\n![image-20230718095104233](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718095104233.png)\n\n#### ps ajx\n\n![image-20230718095230919](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718095230919.png)\n\n#### top\n\n**实时显示进程动态**\n\n![image-20230718095445176](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718095445176.png)\n\n#### kill\n\n**杀死进程**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230718095843259.png\" alt=\"image-20230718095843259\" style=\"zoom: 80%;\" />\n\n里面有一个 9 号信号(SIGKILL)，比如：\n\n~~~bash\nkill -9 <pid>\n~~~\n\n**这个命令可以强制杀掉某个进程**\n\n![image-20230718100643298](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718100643298.png)\n\n#### ./a.out & 后台运行程序\n\n**这个时候，这个进程会被挂在后台进行运行，然后他的打印信息仍然会打印在屏幕上，这里使用ps aux查看命令可以看出是可以正常执行命令的，不冲突，然后可以用 kill 998 将其杀掉**\n\n![image-20230718101259447](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718101259447.png)\n\n## 创建进程\n\n### 进程号和相关函数\n\n**进程组是一个或者多个进程的集合，他们相关联，并且可以接受同一终端的各种信号，具有一个进程组号(pgid)**\n\n![image-20230718101452289](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718101452289.png)\n\n### 进程创建\n\n![image-20230718101951634](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718101951634.png)\n\n#### fork()\n\n~~~cpp\n#include <unistd.h>\n\npid_t fork(void);\n//作用：用于创建子进程\n//返回值：\n    //fork()的返回值会返回两次，一次是在父进程中，一次是在子进程中\n    //为什么会走两次呢？因为这个cpp文件编译出来是一个可执行文件 a.out，这个文件执行后是进程 ./a.out，自然创建出来的也是 ./a.out进程，也就是走的是这个cpp程序\n    //但是注意一点：子进程是不会执行fork()函数的，因为fork()函数是父进程执行的，但是他会持有返回值，在子进程当中就是0\n    //成功 父进程中返回子进程的pid，子进程中返回0\n    //失败 父进程中返回-1，没有子进程被创建，然后修改errno\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    int pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    // 判断是父进程还是子进程\n    if (pid > 0) {  // 父进程走，返回的是创建的子进程编号\n        cout << pid << endl;\n        printf(\"I am parent process, pid : %d , ppid : %d\\n\", getpid(), getppid());\n    } else if (pid == 0)  // 子进程走\n        printf(\"I am child process, pid : %d , ppid : %d\\n\", getpid(), getppid());\n\n    // for\n    for (int i = 0; i < 3; ++i) {\n        sleep(1);\n        cout << i << endl;\n    }\n\n    return 0;\n}\n~~~\n\n**父进程和子进程是并发执行的，在如上的程序当中先打印那个是不确定的，取决于谁先拿到处理机!!!**\n\n**当然如果程序的运行时间太短了，导致在一个时间片当中可以完成，那么看起来就像是两个东西是按照顺序进行的，但是实际上是并发的!!!**\n\n例如这是两次的执行结果：\n\n![image-20230718104207327](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718104207327.png)\n\n当给多点的时候，到后面并发执行的时候就可能是交替执行\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230718105046657.png\" alt=\"image-20230718105046657\" style=\"zoom:67%;\" />\n\n### 父子进程虚拟地址空间\n\n**执行到fork()函数的时候，克隆一份空间(不完全正确，后面会讲)，子进程这边不执行fork()函数，fork()函数只给父进程执行，但是子进程会得到返回值为0用来和父进程进行区别，然后两个进程根据逻辑并发执行!!**\n\n**但其实这两个空间大部分的东西都是一样的!!!**\n\n![image-20230718142613257](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718142613257.png)\n\n#### 读时拷贝，写时共享\n\n**子进程在被创建出来的时候，如果没有对变量进行修改，进行写的操作，那么父子进程共享一块空间；当父子进程需要进行写，就是修改变量的值的时候就拷贝一块空间，这样就节省了物理内粗拿到空间!!!**\n\n![image-20230718143403658](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718143403658.png)\n\n### 总结：父子进程关系\n\n区别：\n\n- fork()函数返回值不同：父进程 > 0 ，返回子进程的pid；子进程 = 0\n- pcb中的一些数据：当前进程的id pid，当前进程的父进程的id ppid，**信号集**\n\n共同点：\n\n- 在某些状态下，子进程刚被创建出来，还没执行任何写的操作\n\n  用户区的数据，文件描述符表是共享的!!!\n\n- 父子进程对变量是不是共享的？\n\n  刚开始的时候是一样的，共享的；但是修改了数据就不共享了\n\n  读时共享(两个进程没有做任何写的操作)，写时拷贝\n\n## GDB多进程调试\n\n**默认情况下gdb调试的都是父进程，加了断点的话默认只对父进程生效，可以设置**\n\n![image-20230718145227613](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718145227613.png)\n\n### 设置调试子进程\n\n![image-20230718145632605](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718145632605.png)\n\n### 设置调试模式\n\n**这里我把 detac-on-fork 模式关闭了，父进程在被调试的时候，子进程会被挂起，所以屏幕上没显示j的信息**\n\n![image-20230718151209448](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718151209448.png)\n\n![image-20230718151224879](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718151224879.png)\n\n## exec函数族\n\n### 函数族介绍\n\n**exec函数族的作用是根据指定的文件名找到可执行文件，然后用它替换当前我们调用的进程的内容然后去执行**\n\n**为了保护当前的进程的内容，一般创建一个子进程然后让exec函数族去替换子进程的内容去执行，这样就好了**\n\n**执行成功了不会返回，因为新的已经取代了旧的，旧的再接受返回值并做操作没有任何意义；只有调用失败了才会返回-1，这个时候新的不会进来，还是旧的**\n\n![image-20230718152959795](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718152959795.png)\n\n图解\n\n![image-20230718154755731](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718154755731.png)\n\n### 函数族(附图)\n\n**前面6个函数是C标准库当中的函数，最后一个(execve)是Linux下的系统函数**\n\n![image-20230718154816547](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718154816547.png)\n\n#### execl()\n\n~~~cpp\n#include <unistd.h>\nint execl(const char *pathname, const char *arg, ... , (char *) NULL );\n//参数：\n    //path：指定的执行的可执行文件的路径，例如：a.out 推荐写绝对路径\n    //arg：字符串，是可执行文件所需要的参数列表\n        //第一个参数(arg当中的第一个参数!!)一般没有作用，为了方便，一般写的是可执行的程序的名称\n        //从第二参数开始往后，就是程序执行所需要的参数列表\n        //参数最后需要以NULL结束(哨兵)\n\n//返回值：\n    //只有调用错误，才会有返回值，为-1，且设置errno\n    //调用成功不会有返回值，\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    // 创建一个子进程，在子进程中执行exec函数族当中的函数\n    pid_t child_pid = fork();\n    if (child_pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (child_pid > 0) {\n        // 父进程\n        printf(\"I am parent process , pid : %d\\n\", getpid());\n        sleep(1);\n    } else if (child_pid == 0) {\n        // 子进程\n        execl(\"hello\", \"hello\", nullptr);\n        printf(\"I am child process , pid : %d\\n\", getpid());\n    }\n\n    for (int i = 0; i < 3; ++i)\n        printf(\"i = %d , pid = %d\\n\", i, getpid());\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n可以看出 child process 这句话没有打印出来，他被可执行文件hello替换掉了，最后的打印i是父进程打印出来的\n\n![image-20230718170703719](https://cdn.davidingplus.cn/images/2025/02/01/image-20230718170703719.png)\n\n**还可以让其执行linux的shell命令**\n\n比如 ps aux 命令，ps就是一个命令，对应可执行文件 /usr/bin/ps\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    // 创建一个子进程，在子进程中执行exec函数族当中的函数\n    pid_t child_pid = fork();\n    if (child_pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (child_pid > 0) {\n        // 父进程\n        printf(\"I am parent process , pid : %d\\n\", getpid());\n        sleep(1);\n    } else if (child_pid == 0) {\n        // 子进程\n        // execl(\"hello\", \"hello\", nullptr);\n\n        // 可以执行linux系统自己的可执行程序，比如ps命令(/usr/bin/ps)\n        execl(\"/usr/bin/ps\", \"ps\", \"aux\", nullptr);\n\n        printf(\"I am child process , pid : %d\\n\", getpid());\n    }\n\n    for (int i = 0; i < 3; ++i)\n        printf(\"i = %d , pid = %d\\n\", i, getpid());\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230718171319019](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718171319019.png)\n\n#### execlp()\n\n**与execl()函数的区别是execlp()函数里面传入的是可执行文件名，不是路径；会自动到环境变量中去查找这些可执行文件名，适合用作系统的命令，而execl()传路径，适合自己的可执行文件(不用配置环境变量)**\n\n~~~cpp\n#include <unistd.h>\nint execlp(const char *file, const char *arg, ... , (char *) NULL );\n//参数：\n    //会到环境变量中查找可执行文件，找到了就执行，找不到就不成功!!!\n    //file：需要执行的可执行文件的文件名，不包含路径!!!\n\n\n    //arg：字符串，是可执行文件所需要的参数列表\n        //第一个参数(arg当中的第一个参数!!)一般没有作用，为了方便，一般写的是可执行的程序的名称\n        //从第二参数开始往后，就是程序执行所需要的参数列表\n        //参数最后需要以NULL结束(哨兵)\n\n//返回值：\n    //只有调用错误，才会有返回值，为-1，且设置errno\n    //调用成功不会有返回值\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    // 创建一个子进程，在子进程中执行exec函数族当中的函数\n    pid_t child_pid = fork();\n    if (child_pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (child_pid > 0) {\n        // 父进程\n        printf(\"I am parent process , pid : %d\\n\", getpid());\n        sleep(1);\n    } else if (child_pid == 0) {\n        // 子进程\n        // execl(\"hello\", \"hello\", nullptr);\n\n        // 可以执行linux系统自己的可执行程序，比如ps命令(/usr/bin/ps)\n        execlp(\"ps\", \"ps\", \"aux\", nullptr);\n\n        printf(\"I am child process , pid : %d\\n\", getpid());\n    }\n\n    for (int i = 0; i < 3; ++i)\n        printf(\"i = %d , pid = %d\\n\", i, getpid());\n\n    return 0;\n}\n~~~\n\n依然能执行ps aux 命令\n\n## 进程控制\n\n### 进程退出\n\n**exit()是标准C库的函数，在linux系统下底层会调用linux系统的函数_exit()**\n\n![image-20230718194621050](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718194621050.png)\n\n两个的区别：**exit()在调用之后需要比_exit()做更多的事情，其中有一个就是刷新I/O缓冲关闭文件描述符**\n\n对于下面的程序\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    cout << \"hello\" << endl;\n    cout << \"world\";\n\n    // exit(0);\n    _exit(0);\n\n    return 0;\n}\n~~~\n\n使用exit(0)和_exit(0)会有如下两个不同结果\n\nexit:\n\n![image-20230718195742100](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718195742100.png)\n\n_exit:\n\n![image-20230718195756973](https://cdn.davidingplus.cn/images/2025/02/01/image-20230718195756973.png)\n\n那么为什么会这样呢？\n\n#### 刷新缓冲区问题(重要)\n\n**c++和c语言中的cout或者printf()也好，本质都是printf()，printf()作为C语言标准库的函数，并不是直接输出到终端屏幕上，而是先写在缓冲区当中，然后当缓冲区刷新的时候在清空缓冲区输出到屏幕当中!!!**\n\n![image-20230718200326121](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718200326121.png)\n\n于是乎刚才的代码：\n\n~~~cpp\ncout << \"hello\" << endl;\ncout << \"world\";\n\n// exit(0);\n_exit(0);\n~~~\n\nhello遇到endl，相当于 '\\n'，刷新缓冲区，显示；第二个world在缓冲区中，本来正常程序结束就显示在屏幕上了，现在遇到了_exit()不刷新缓冲区，那么就丢掉了，不显示\n\n##### 变式\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    cout << \"hello\";\n\n    sleep(2);\n\n    return 0;\n}\n~~~\n\n这个程序在输出的时候不会立刻输出hello，因为这个时候缓冲区没有刷新，会谁2秒，然后return 0主程序结束的时候再刷新缓冲区进行显示!!!\n\n### 孤儿进程\n\n**父进程有义务回收子进程的资源，但是当父进程结束而子进程未结束的时候这一点无法做到，所以这个时候内核会把这个子进程的父进程设置为init进程(linux上的第一层进程，linux下的进程都是不断的创建子进程而创建出来的)，init进程会循环的wait()等待这个子进程，当这个子进程结束了之后，init进程会将其回收，处理善后工作!!!**\n\n![image-20230718202030384](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718202030384.png)\n\n演示代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    int pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    // 判断是父进程还是子进程\n    if (pid > 0) {  // 父进程走，返回的是创建的子进程编号\n        printf(\"I am parent process, pid : %d , ppid : %d\\n\", getpid(), getppid());\n    } else if (pid == 0) {  // 子进程走\n        sleep(1);           // 强制让子进程睡1秒，让父进程跑完，子进程称为孤儿进程\n        printf(\"I am child process, pid : %d , ppid : %d\\n\", getpid(), getppid());\n    }\n\n    // for\n    for (int i = 0; i < 3; ++i) {\n        printf(\"i : %d , pid : %d\\n\", i, getpid());\n    }\n\n    return 0;\n}\n~~~\n\n输出效果：\n\n![image-20230718203522772](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718203522772.png)\n\n**父进程创建出来子进程之后，子进程休眠1秒，父进程早已跑完，结束，子进程交给_init进程作为他的父进程进行管理，所以会显示终端是因为父进程结束了，但是这个时候子进程尚未结束，父进程和子进程在内核区域有一些数据是一样的，比如文件描述符012的标准输入，输出和错误，所以仍然可以在当前终端输出信息。并且这里 _init还让他结束之后阻塞了**\n\n### 僵尸进程\n\n**每个进程结束之后，内核区的PCB没有办法自己释放，需要父进程释放；用户区的数据可以自己释放**\n\n**进程终止的时候，父进程尚未回收，子进程的残留资源(PCB)存放在内核中，变成了僵尸进程**\n\n**僵尸进程不能被 kill -9 杀死**\n\n**僵尸进程多了会占据进程号，进程号范围 0 ~ 32767，占据完了就会有危险**\n\n![image-20230718203825193](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718203825193.png)\n\n演示代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    int pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    // 判断是父进程还是子进程\n    if (pid > 0) {   // 父进程走，返回的是创建的子进程编号\n        while (1) {  // 强制让父进程一直循环，不退出，让子进程结束，父进程没办法回收他的资源\n            printf(\"I am parent process, pid : %d , ppid : %d\\n\", getpid(), getppid());\n            sleep(1);\n        }\n    } else if (pid == 0) {  // 子进程走\n        printf(\"I am child process, pid : %d , ppid : %d\\n\", getpid(), getppid());\n    }\n\n    return 0;\n}\n~~~\n\n输出结果：\n\n![image-20230718205238264](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718205238264.png)\n\n可以看出，子进程结束了但是父进程没结束，没有办法释放子进程内核区域的数据，导致了僵尸进程\n\n![image-20230718205324350](https://cdn.davidingplus.cn/images/2025/02/01/image-20230718205324350.png)\n\n现在的状态，子进程Z+代表是僵尸进程，< defunct >代表不存在的；父进程S+代表睡眠\n\nkill -9 杀不掉僵尸进程\n\n![image-20230718205637544](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718205637544.png)\n\n![image-20230718205647171](https://cdn.davidingplus.cn/images/2025/02/01/image-20230718205647171.png)\n\n**这个时候想要解决这个问题只能杀掉父进程，把子进程托管给 /init ，这样才能将其释放，但是实际开发当中杀掉父进程往往不现实，所以需要父进程调用wait()和waitpid()来保证父进程会把子进程的内核PCB的数据给释放掉，这样才能避免僵尸进程**\n\n![image-20230718210109506](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718210109506.png)\n\n### 进程回收\n\n![image-20230718211154805](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718211154805.png)\n\n#### wait()\n\n**为了避免僵尸进程，父进程需要回收子进程的资源**\n\n**wait()函数会阻塞，父进程调用之后会阻塞在那里等待子进程结束然后释放子进程的资源**\n\n~~~cpp\n#include <sys/wait.h>\n\npid_t wait(int *wstatus);\n//功能：等待任意一个子进程结束，如果任意一个子进程结束了，此函数会回收这个子进程的资源\n//参数：int *wstatus\n    //进程退出时候的状态信息，传入的是一个int类型的地址，传出参数\n//返回值：\n    //成功 返回被回收的子进程的id\n    //失败 -1(所有的子进程都结束，调用函数失败) 并且修改errno\n\n//调用wait()函数，进程会阻塞，知道他的一个子进程退出或者收到一个不能被忽略的信号，这个时候才被唤醒\n//如果没有子进程，这个函数立刻返回-1；如果子进程都已经结束了，也会返回-1\n~~~\n\n示例代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main() {\n    // 有一个父进程，创建5个子进程\n    pid_t pid;\n\n    for (int i = 0; i < 5; ++i) {\n        pid = fork();\n\n        if (pid == -1) {\n            perror(\"fork\");\n            return -1;\n        }\n\n        if (pid == 0)  // 说明是子进程，如果不加这行代码，子进程也会走for循环，他也会fork()产生更多的孙子进程，重孙进程等等\n            break;\n    }\n\n    if (pid > 0) {\n        // 父进程\n        while (1) {\n            printf(\"parent , pid = %d\\n\", getpid());\n\n            // int ret = wait(NULL);\n\n            int status;\n            int ret = wait(&status);\n\n            printf(\"child die,pid = %d\\n\", ret);\n\n            sleep(1);\n        }\n    } else if (pid == 0) {\n        // 子进程\n        printf(\"child , pid = %d\\n\", getpid());\n        sleep(1);\n\n        exit(0);\n    }\n\n    return 0;\n}\n~~~\n\n这个代码用父进程创建了5个子进程(注意看怎么创建的)，父进程中用wait()函数阻塞等待子进程结束，子进程结束一个，父进程输出关于ret的一段信息表示子进程已经被回收，然后重复，直到所有子进程全部结束被回收完毕；这个时候父进程依然在循环，只不过wait()返回-1\n\n执行结果：\n\n![image-20230719094953685](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719094953685.png)\n\n稍加修改，现在我需要查看进程退出的状态：\n\n我让进程正常退出\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main() {\n    // 有一个父进程，创建5个子进程\n    pid_t pid;\n\n    for (int i = 0; i < 5; ++i) {\n        pid = fork();\n\n        if (pid == -1) {\n            perror(\"fork\");\n            return -1;\n        }\n\n        if (pid == 0)  // 说明是子进程，如果不加这行代码，子进程也会走for循环，他也会fork()产生更多的孙子进程，重孙进程等等\n            break;\n    }\n\n    if (pid > 0) {\n        // 父进程\n        while (1) {\n            printf(\"parent , pid = %d\\n\", getpid());\n\n            // int ret = wait(NULL);\n\n            int status;\n            int ret = wait(&status);\n\n            if (ret == -1)  // 没有子进程\n                break;\n\n            // 有子进程，回收了子进程的资源\n            if (WIFEXITED(status)) {  // 是不是正常退出\n                printf(\"退出的状态码: %d\\n\", WEXITSTATUS(status));\n            } else if (WIFSIGNALED(status)) {  // 是不是异常退出\n                printf(\"被哪个信号干掉了: %d\\n\", WTERMSIG(status));\n            }\n\n            printf(\"child die,pid = %d\\n\", ret);\n\n            sleep(1);\n        }\n    } else if (pid == 0) {\n        // 子进程\n        // while(1) {\n        printf(\"child , pid = %d\\n\", getpid());\n        sleep(1);\n\t    // }\n        \n        exit(0);\n    }\n\n    return 0;\n}\n~~~\n\n这个时候子进程退出时候调用C标准库函数exit(0)，状态码就是0，因此正常退出的状态码用图中形式接受并打印\n\n执行结果：\n\n![image-20230719095319683](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719095319683.png)\n\n现在我把子进程改成while(1)循环，然后用 kill -9 杀掉他，看看他是被哪个信号干掉的\n\n##### 退出信息宏函数(status相关)\n\n![image-20230718220547310](https://cdn.davidingplus.cn/images/2025/01/31/image-20230718220547310.png)\n\n执行结果：\n\n![image-20230719095606504](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719095606504.png)\n\n![image-20230719095625400](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719095625400.png)\n\n#### waitpid()\n\n~~~cpp\n#include <sys/wait.h>\n\npid_t waitpid(pid_t pid, int *_Nullable wstatus, int options);\n// 作用：回收指定进程号的子进程，可以设置是否阻塞\n// 参数：\n//     pid：> 0 表示某个子进程的id\n//         == 0 回收当前进程组的所有子进程(我自己的子进程不一定和我属于一个组，有可能被我给出去了)\n//         == -1 回收所有的子进程，相当于wait()，最常用\n//         < -1 回收某个进程组当中的所有子进程，组号是这个参数的绝对值\n//     options：设置阻塞或者非阻塞\n//         0 阻塞\n//         WNOHANG：非阻塞\n// 返回值：\n//     > 0 返回子进程的id\n//     == 0 options = WNOHANG，表示还有子进程活着\n//     ==-1 错误，并且设置错误号，在非阻塞的情况下返回-1可以代表没有子进程了\n\n// 这么来看,waitpid(-1,&status,0) 相当于是 wait(&status)\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <sys/wait.h>\n#include <unistd.h>\n\nint main() {\n    // 有一个父进程，创建5个子进程\n    pid_t pid;\n\n    for (int i = 0; i < 5; ++i) {\n        pid = fork();\n\n        if (pid == -1) {\n            perror(\"fork\");\n            return -1;\n        }\n\n        if (pid == 0)  // 说明是子进程，如果不加这行代码，子进程也会走for循环，他也会fork()产生更多的孙子进程，重孙进程等等\n            break;\n    }\n\n    if (pid > 0) {\n        // 父进程\n        while (1) {\n            printf(\"parent , pid = %d\\n\", getpid());\n            sleep(1);\n\n            // int ret = wait(NULL);\n\n            int status;\n            // int ret = waitpid(-1, &status, 0);        // 阻塞\n            int ret = waitpid(-1, &status, WNOHANG);  // 非阻塞\n\n            if (ret == -1)  // 没有子进程\n                break;\n            else if (ret == 0)\n                // 非阻塞就是执行到这个位置判断一下，然后遇到了就回收了，没有就走了\n                // ret==0表明还有子进程活着，重开循环判断\n                // 非阻塞的好处：父进程不用一直阻塞这等待子进程结束，可以做自己的逻辑，然后每隔一段时间就回来看子进程是否运行完毕然后回收。提高效率\n                continue;\n            else if (ret > 0) {\n                // 有子进程，回收了子进程的资源\n                if (WIFEXITED(status)) {  // 是不是正常退出\n                    printf(\"退出的状态码: %d\\n\", WEXITSTATUS(status));\n                } else if (WIFSIGNALED(status)) {  // 是不是异常退出\n                    printf(\"被哪个信号干掉了: %d\\n\", WTERMSIG(status));\n                }\n                printf(\"child die,pid = %d\\n\", ret);\n            }\n        }\n    } else if (pid == 0) {\n        // 子进程\n        while (1) {\n            printf(\"child , pid = %d\\n\", getpid());\n            sleep(1);\n        }\n\n        exit(0);\n    }\n\n    return 0;\n}\n~~~\n\n非阻塞的含义：非阻塞就是执行到这个位置判断一下，然后遇到了就回收了，没有就走了\n\n非阻塞的好处：父进程不用一直阻塞这等待子进程结束，可以做自己的逻辑，然后每隔一段时间就回来看子进程是否运行完毕然后回收。提高效率\n\n图中的代码含义就是：子进程一直循环输出，父进程每次非阻塞的waitpid()，有子进程则重新循环再次判断，如果子进程结束(正常或异常)，则进入下方循环输出相关信息然后再回去循环\n\n执行结果：\n\n我不管他是这样，可以父进程是非阻塞的一直在工作的\n\n![image-20230719103805234](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719103805234.png)\n\n现在我把子进程kill掉\n\n![image-20230719103852259](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719103852259.png)\n\nkill一次输出一个信息，然后kill完毕之后结束进程\n\n![image-20230719103900180](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719103900180.png)\n\n## 进程间通信 IPC\n\n### 概念\n\n![image-20230719104207710](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719104207710.png)\n\n进程间通信方式(记忆!!!)\n\n![image-20230719110333954](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719110333954.png)\n\n### 管道\n\n管道的数据结构是环形队列。为什么是环形？大概率是为了处理边界问题吧\n\n**管道拥有文件的特质，读操作和写操作；**\n\n**匿名管道没有文件实体；有名管道有文件实体，但是不存储数据**\n\n**可以按照操作文件的方式对管道进行操作，也具有文件描述符，有两个，分别指向读端和写端**\n\n**一个管道就是一个字节流，管道没有消息或者消息边界的概念，从管道读数据可以任意读，不用考虑写入的数据是多少；并且管道传递的数据是有顺序的**\n\n![image-20230719112527654](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719112527654.png)\n\n**管道单向，一边写，一边读；半双工**\n\n**匿名管道只能在拥有共同祖先的进程当中使用，例如父进程和子进程；两个兄弟进程**\n\n![image-20230719143725384](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719143725384.png)\n\n**为什么可以用管道通信**\n\n父进程 fork() 之后，子进程和父进程共享了一份这个文件描述符表。管道也具有文件的性质，他的两端分别对应读和写的文件描述符，因此需要两个进程指向这同一个位置，所以必须是具有一定关系的进程才能使用，就像如图所示，父子进程的5号都对应写数据，6号都对应读数据，然后这样就可以联系起来了\n\n#### 那么在fork之前还是fork之后建立管道呢？\n\n**答案是fork()之前。**\n\n**因为fork()之前建立管道，比如如图，管道占据两个文件描述符5和6，现在fork()之后，由于管道具有文件描述符，子进程内核区域文件描述符指向的东西是和父进程一块东西，所以他们两个指向的是同一块管道，这样才能进行通信!!!**\n\n![image-20230719144556698](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719144556698.png)\n\n管道的数据结构：环形队列\n\n![image-20230719145008340](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719145008340.png)\n\n#### 匿名管道(pipe)\n\n![image-20230719111308071](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719111308071.png)\n\n看如图的命令：\n\n~~~bash\nls | wc -l\n~~~\n\n**这是两个命令 ls 和 wc -l，整个的作用就是用ls查看目录下的文件然后传递给 wc -l 命令实现统计并且在屏幕上进行输出**\n\n**那么怎么进行传递呢？或者说怎么把ls获取到的数据交给wc进程呢？**\n\n**这就需要管道了，命令当中的 | 就是指在两个进程之间建立一个匿名管道，然后前面的进程向后面的进程进行通信，提供数据信息**\n\n匿名管道的使用\n\n![image-20230719145051553](https://cdn.davidingplus.cn/images/2025/02/01/image-20230719145051553.png)\n\n##### pipe()\n\n~~~cpp\n#include <unistd.h>\n\nint pipe(int pipefd[2]);\n// 功能：创建一个匿名管道，用于进程间通信\n// 参数：int pipefd[2] 这个数组是一个传出参数\n//     pipefd[0] 对应的是管道的读端\n//     pipefd[1] 对应的是管道的写端\n// 返回值：\n//     成功 0\n//     失败 -1，并且设置errno\n\n// 注意：匿名管道只能用于具有关系的进程通信之间，比如：父子进程，兄弟进程等等\n\n//     管道默认是阻塞的，如果管道中没有数据，read阻塞；管道满了，write阻塞\n~~~\n\n~~~cpp\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <unistd.h>\n#define _size 1024\n\nint main() {\n    // 子进程发送数据给父进程，父进程读取到数据输出\n\n    // 在fork之前创建管道，因为要指向一个管道\n    int pipefd[2];\n\n    int ret = pipe(pipefd);\n    if (ret == -1) {\n        perror(\"pipe\");\n        return -1;\n    }\n\n    // 管道创建成功了，现在创建子进程\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {  // 父进程\n        printf(\"i am parent process , pid : %d\\n\", getpid());\n\n        char buf[_size] = {0};\n        const char *str = \"hello,i am parent\";\n        while (1) {\n            // 读数据\n            // read默认是阻塞的\n            read(pipefd[0], buf, sizeof(buf));\n            printf(\"parent recv : \\\"%s\\\" , pid : %d\\n\", buf, getpid());\n            // 读完清空buf\n            bzero(buf, _size);\n\n            // 写数据\n            write(pipefd[1], str, strlen(str));\n            // read会在缓冲区空的时候阻塞，父进程写一次子进程读一次，然后再次阻塞，所以sleep是在父进程这边\n            // 如果在子进程这边sleep，父进程在这段时间疯狂写\n            sleep(1);\n        }\n\n    } else if (pid == 0) {  // 子进程\n        printf(\"i am child process , pid : %d\\n\", getpid());\n\n        char buf[_size] = {0};\n        const char *str = \"hello,i am child\";\n        while (1) {\n            // 写数据\n            write(pipefd[1], str, strlen(str));\n            sleep(1);\n\n            // 读数据\n            // read默认是阻塞的\n            read(pipefd[0], buf, sizeof(buf));\n            printf(\"child recv : \\\"%s\\\" , pid : %d\\n\", buf, getpid());\n            // 读完清空buf\n            bzero(buf, _size);\n        }\n    }\n\n    return 0;\n}\n~~~\n\n这个程序的本意是让父子进程之间建立管道，然后子进程向管道写数据，父进程接受数据并输出\n\n代码当中用了两个循环，子进程循环写数据给管道，父进程调用read()函数接受，read()函数默认是阻塞的，调用while(1)一直读，因此最后的结果是这样\n\n![image-20230719153654422](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719153654422.png)\n\n变式：\n\n父进程和子进程相互通信，一个道理\n\n~~~cpp\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    // 子进程发送数据给父进程，父进程读取到数据输出\n\n    // 在fork之前创建管道，因为要指向一个管道\n    int pipefd[2];\n\n    int ret = pipe(pipefd);\n    if (ret == -1) {\n        perror(\"pipe\");\n        return -1;\n    }\n\n    // 管道创建成功了，现在创建子进程\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {  // 父进程\n        printf(\"i am parent process , pid : %d\\n\", getpid());\n        while (1) {\n            // 读数据\n            char buf[1024] = {0};\n            // read默认是阻塞的\n            read(pipefd[0], buf, sizeof(buf));\n            printf(\"parent recv : \\\"%s\\\" , pid : %d\\n\", buf, getpid());\n\n            // 写数据\n            const char *str = \"hello,i am parent\";\n            write(pipefd[1], str, strlen(str));\n            sleep(1);\n        }\n\n    } else if (pid == 0) {  // 子进程\n        printf(\"i am child process , pid : %d\\n\", getpid());\n\n        while (1) {\n            // 写数据\n            const char *str = \"hello,i am child\";\n            write(pipefd[1], str, strlen(str));\n            sleep(1);\n\n            // 读数据\n            char buf[1024] = {0};\n            // read默认是阻塞的\n            read(pipefd[0], buf, sizeof(buf));\n            printf(\"child recv : \\\"%s\\\" , pid : %d\\n\", buf, getpid());\n        }\n    }\n\n    return 0;\n}\n~~~\n\n父子进程都设置读操作和写操作，只是要注意一点，这里顺序要相反，因为父进程和子进程如果都先读都阻塞程序没办法推进了\n\n执行结果：\n\n![image-20230719153922897](https://cdn.davidingplus.cn/images/2025/01/31/image-20230719153922897.png)\n\n##### fpathconf()\n\n用来获取管道缓冲区的大小(4096 bytes)\n\n~~~cpp\n#include <unistd.h>\n\nlong fpathconf(int fd, int name);\n// 作用：获取管道的大小\n// 参数：fd 管道的文件描述符(两个填一个即可)\n//     name：宏值\n//         获取大小使用 _PC_PIPE_BUF\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    int pipefd[2];\n\n    int ret = pipe(pipefd);\n    if (ret == -1) {\n        perror(\"pipe\");\n        return -1;\n    }\n\n    // 获取管道大小\n    long size = fpathconf(pipefd[0], _PC_PIPE_BUF);\n    printf(\"pipe size : %ld\\n\", size);  // 4096\n\n    return 0;\n}\n~~~\n\n#### 匿名管道通信案例\n\n##### 注意\n\n刚才的案例有一个问题就是说匿名管道在实现相互通信的时候，可能会出现进程自己写的数据被自己读取\n\n一般的交互情况如下所示：\n\n![image-20230721103551177](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721103551177.png)\n\n![image-20230721103558631](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721103558631.png)\n\n**但是有可能在cpu分配时间片的时候处理不得当，或者说我写了数据之后忘了加sleep让自己的进程和对面抢夺read，就可能导致自己写的数据被自己读取，并且在实际开发的过程中我们肯定不可能让写的一方sleep来让出cpu让对方来读取，所以就很可能出现这种情况，这个是没有办法避免的**\n\n**所以我们匿名管道在实际运用的时候一般规定数据流只从一端流向另一端，不会去实现双向的数据流动，因为这样就可能发生自己数据被自己接受的情况**\n\n![image-20230721103607149](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721103607149.png)\n\n所以在实际的开发过程中我们往往直接关闭一方的写端和另一方的读端，如下所示：\n\n我们想要的就是第三种情况\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230721104349892.png\" alt=\"image-20230721104349892\" style=\"zoom:80%;\" />\n\n~~~cpp\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <unistd.h>\n#define _size 1024\n\nint main() {\n    // 子进程发送数据给父进程，父进程读取到数据输出\n\n    // 在fork之前创建管道，因为要指向一个管道\n    int pipefd[2];\n\n    int ret = pipe(pipefd);\n    if (ret == -1) {\n        perror(\"pipe\");\n        return -1;\n    }\n\n    // 管道创建成功了，现在创建子进程\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {  // 父进程\n        printf(\"i am parent process , pid : %d\\n\", getpid());\n\n        char buf[_size] = {0};\n        // const char *str = \"hello,i am parent\";\n        while (1) {\n            // 读数据\n            // read默认是阻塞的\n            read(pipefd[0], buf, sizeof(buf));\n            printf(\"parent recv : \\\"%s\\\" , pid : %d\\n\", buf, getpid());\n            // 读完清空buf\n            bzero(buf, _size);\n\n            // 关闭写端\n            close(pipefd[1]);\n        }\n\n    } else if (pid == 0) {  // 子进程\n        printf(\"i am child process , pid : %d\\n\", getpid());\n\n        char buf[_size] = {0};\n        const char *str = \"hello,i am child\";\n        while (1) {\n            // 写数据\n            write(pipefd[1], str, strlen(str));\n            sleep(1);\n\n            // 关闭读端\n            close(pipefd[0]);\n        }\n    }\n\n    return 0;\n}\n~~~\n\n##### 案例(!!!)\n\n实现 ps aux | grep root，父子进程之间通信\n\n![image-20230721115524021](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721115524021.png)\n\n代码：(看代码理解!!!)\n\n注意：\n\n父进程需要调用wait()函数来释放子进程，防止出现僵尸进程;\n\ndup2()函数的作用：\n\n~~~cpp\n#include <unistd.h>\nint dup2(int oldfd , int newfd);\n\n//作用：重定向文件描述符\n    //oldfd指向a.txt，newfd指向b.txt\n    //调用函数成功后，newfd和b.txt的连接做close(oldfd仍指向a.txt)，newfd指向a.txt\n    //oldfd必须是一个有效的文件描述符\n    //如果相同则相当于什么都没做\n//返回值：\n    //newfd，他们都指向的是oldfd之前指向的文件\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#define _size 1024\n\n/*\n    实现 ps aux 父子进程之间通信\n\n    子进程：ps aux，子进程结束之后将数据发送给父进程\n    父进程：获取到数据，打印\n\n    思路：\n    子进程需要执行 ps aux 命令，调用exec族函数，但是这些函数的默认输出端是在stdout_fileno\n    所以需要使用dup2()函数将其重定向到管道的写端\n    将读取的内容存到文本中，然后去执行grep命令即可\n*/\n\nint main() {\n    // 创建管道\n    int pipefd[2];\n\n    int ret = pipe(pipefd);\n    if (ret == -1) {\n        perror(\"pipe\");\n        return -1;\n    }\n\n    // 创建子进程\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {\n        // 父进程\n\n        // 关闭写端\n        close(pipefd[1]);\n\n        // 读\n        char buf[_size] = {0};\n        int len = -1;\n\n        // 先打开，如果不存在则创建，存在则删除再创建\n        // 建议不要重复打开，这里就打开一次然后写，最后关闭即可\n        int fd = open(\"file.txt\", O_RDONLY);\n        if (fd != -1)            // 存在，将其删除\n            remove(\"file.txt\");  // 不能用exec()函数族，因为这就把这个主进程替换了，不会回来\n        close(fd);\n\n        // 然后创建一个\n        fd = open(\"file.txt\", O_RDWR | O_CREAT, 0664);\n        if (fd == -1) {\n            perror(\"open\");\n            return -1;\n        }\n\n        // -1 留一个结束符\n        // 循环读\n        while ((len = read(pipefd[0], buf, sizeof(buf) - 1)) != 0) {\n            if (len == -1) {\n                perror(\"read\");\n                return -1;\n            }\n\n            // printf(\"%s\", buf);\n            write(fd, buf, strlen(buf));\n\n            bzero(buf, _size);\n        }\n\n        close(fd);\n\n        // grep筛选root\n        execlp(\"grep\", \"grep\", \"root\", \"file.txt\", nullptr);\n\n        // 父进程回收子进程资源防止出现僵尸进程\n        wait(nullptr);\n    } else if (pid == 0) {\n        // 子进程\n\n        // 关闭读端\n        close(pipefd[0]);\n\n        // 将标准输入stdout_fileno重定向到管道的写端\n        // dup2() newfd指向oldfd指向的位置，oldfd被释放\n        int ret = dup2(pipefd[1], STDOUT_FILENO);\n        if (ret == -1) {\n            perror(\"dup2\");\n            return -1;\n        }\n\n        // 使用exec函数族执行shell命令，他输出靠的是的是stdout_fileno\n        // 为防止管道大小不够，循环的去执行保证指令被写完\n        while (ret = execlp(\"ps\", \"ps\", \"aux\", nullptr))\n            if (ret == -1) {\n                perror(\"execlp\");\n                return -1;\n            }\n    }\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230721115546729](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721115546729.png)\n\n#### 管道的读写特点\n\n使用管道的时候，需要注意一下几种特殊的情况(假设都是阻塞I/O操作)：\n\n- **所有指向管道写端的文件描述符都关闭了(管道写端引用计数为0)，有进程从管道的读端读数据，那么管道中剩余的数据被读取以后，再次去read()会返回0，就像读到文件末尾一样**\n\n  如图所示，这里的读端计数为2，写端计数为0\n\n  ![image-20230721134808630](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721134808630.png)\n\n- **如果有指向管道写端的文件描述符没有关闭(管道写端的引用计数大于0)，而持有管道写端的进程也没有往管道中写数据，这个时候有进程往管道中读取数据，那么管道中剩余的数据被读取完毕之后，再次read阻塞，直到管道中有数据可以读取了才会读取数据并且返回**\n  ![image-20230721135603117](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721135603117.png)\n\n- **如果所有指向管道读端的文件描述符没有关闭(管道读端的引用计数为0)，这个时候有进程向管道中写数据，那么该进程会收到一个信号SIGPIPE，通常会导致进程异常终止**\n\n  ![image-20230721135452517](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721135452517.png)\n\n- **如果有指向管道读端的文件描述符没有关闭(管道读端的引用计数大于0)，而持有管道读端的进程也没有从管道中读取数据，这时候有进程向管道中写数据，那么在管道被写满的时候再次调用write()会阻塞，直到管道中有空位置才能再次写入数据并返回**\n  ![image-20230721140511484](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721140511484.png)\n\n总结：\n\n- **读管道：**\n  - **管道中有数据，读取会返回实际读到的字节数**\n  - **管道中无数据：**\n    - **写端全部关闭，read返回0(相当于读到文件的末尾)**\n    - **写端没有完全关闭，read阻塞等待**\n- **写管道：**\n  - **管道读端全部关闭，产生信号SIGPIPE，进程异常终止**\n  - **管道读端没有全部关闭：**\n    - **管道已满，write阻塞**\n    - **管道没有满，write将数据写入，并返回实际写入的字节数**\n\n#### 设置管道非阻塞(fcntl)\n\n~~~cpp\n#include <fcntl.h>\n#include <unistd.h>\n\nint fcntl(int fd, int cmd, ...); ...当中是可变参数\n// 参数：\n//     fd：需要操作的文件描述符\n//     cmd：表示对文件描述符进行如何操作\n//         F_DUPFD 复制文件描述符，复制的是第一个参数，得到一个新的文件描述符(返回值)\n//             int ret = fcntl(fd,F_DUPFD);\n//         F_GETFL 获取指定文件描述符的文件状态flag\n//             获取的flag和我们通过open函数传递的flag是一个东西\n//         F_SETFL 设置文件描述符的文件状态flag\n//             必选项：O_RDONLY O_WRONLY O_RDWR 不可以被修改\n//             可选项：O_APPEND O_NONBLOCK\n//                 O_APPEND 表示追加数据\n//                 O_NONBLOCK 设置成非阻塞\n//                     阻塞和非阻塞：描述的是函数调用的行为\n~~~\n\n如何设置？\n\n~~~cpp\nint flags = fcntl(pipefd[0], F_GETFL);\nflags |= O_NONBLOCK;\nfcntl(pipefd[0], F_SETFL, flags);\n~~~\n\n代码：\n\n~~~cpp\n#include <cstring>\n#include <iostream>\n#include <string>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n#define _size 1024\n\n/*\n    设置管道非阻塞\n    int flags =  fcntl(fd[0],F_GETFL); //获取原来的flag\n    flags | = O_NONBLOCK; //修改flag的值\n    fcntl(fd[0],F_SETFL,flags); //设置新的flag\n*/\n\nint main() {\n    // 子进程发送数据给父进程，父进程读取到数据输出\n\n    // 在fork之前创建管道，因为要指向一个管道\n    int pipefd[2];\n\n    int ret = pipe(pipefd);\n    if (ret == -1) {\n        perror(\"pipe\");\n        return -1;\n    }\n\n    // 管道创建成功了，现在创建子进程\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {  // 父进程\n        printf(\"i am parent process , pid : %d\\n\", getpid());\n\n        char buf[_size] = {0};\n\n        int flags = fcntl(pipefd[0], F_GETFL);\n        flags |= O_NONBLOCK;\n        fcntl(pipefd[0], F_SETFL, flags);\n\n        // 关闭写端\n        close(pipefd[1]);\n\n        while (1) {\n            // 读数据\n            // read默认是阻塞的\n            // 设置成为非阻塞\n            int len = read(pipefd[0], buf, sizeof(buf));\n            printf(\"len = %d\\n\", len);\n            printf(\"parent recv : \\\"%s\\\" , pid : %d\\n\", buf, getpid());\n            // 读完清空buf\n            bzero(buf, _size);\n\n            sleep(1);  // 子进程和父进程睡眠的时间不同，这样可以方便的观察是否阻塞\n        }\n\n    } else if (pid == 0) {  // 子进程\n        printf(\"i am child process , pid : %d\\n\", getpid());\n        const char *str = \"hello,i am child\";\n\n        // 关闭读端\n        close(pipefd[0]);\n\n        while (1) {\n            // 写数据\n            write(pipefd[1], str, strlen(str));\n            sleep(5);\n        }\n    }\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n可见子进程在睡眠的时候父进程执行到read()并没有阻塞，而是执行走了!!!\n\n![image-20230721145953793](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721145953793.png)\n\n#### 有名管道(FIFO)\n\n**有名管道和匿名管道的区别在于：匿名管道本身没有一个文件描述符或者说路径可以让两个进程找到他，这就导致我们只能通过某种方式让两个进程指向同一块管道，比如主进程先建立管道，然后创建子进程，这样保证了两个进程的读端和写端的文件描述符指向的是同样的匿名管道的两端，这样就只能用于亲缘关系的进程之间通信，而有名管道则恰好克服了这个问题；设置了一个路径名方便两个进程关联，并且这个路径名可以像文件一样被访问(FIFO)，这样就可以被任意关系的两个进程找到并且建立通信**\n\n![image-20230721150130194](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721150130194.png)\n\n区别：\n\n![image-20230721151257066](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721151257066.png)\n\n##### mkinfo()\n\n![image-20230721151329604](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721151329604.png)\n\n**通过命令 mkfifo < name >**\n\n![image-20230721152717230](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721152717230.png)\n\n这里创建失败，为什么呢？因为windows系统的文件系统不支持管道文件(匿名管道没有管道文件)\n\n![image-20230721151935217](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721151935217.png)\n\n在linux系统自己的本地文件夹当中创建\n\n![image-20230721152127780](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721152127780.png)\n\n**观察发现fifo文件的大小为0，这是因为fifo管道文件的信息是存储在内核的缓冲区里面的，当程序结束之后便会清空，留给下一次使用**\n\n**通过函数 mkfifo()**\n\n注意这里的路径也是linux本地文件夹的路径，否则就会被拒绝\n\n~~~cpp\n// - 通过函数\n \t#include <sys/stat.h>\n\t#include <sys/types.h>\n\n    int mkfifo(const char *pathname, mode_t mode);\n// 参数：\n//     pathname：管道名称的路径\n//     mode：文件的权限 和 open 的 mode 一样，八进制数\n// 返回值：\n//     成功 返回0\n//     失败 返回-1，并设施errno\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nint main() {\n    // 判断文件是否存在\n    // access()函数可以获取文件的权限和查看是否存在\n    int ret = access(\"/home/lzx0626/fuck/fifo\", F_OK);\n    if (ret == -1) {\n        printf(\"管道不存在，创建管道\\n\");\n\n        ret = mkfifo(\"/home/lzx0626/fuck/fifo\", 0664);\n        if (ret == -1) {\n            perror(\"mkfifo\");\n            return -1;\n        }\n    }\n\n    return 0;\n}\n~~~\n\n现在我需要写两个进程并且通过有名管道来实现通信，实现write.cpp和read.cpp\n\n~~~cpp\n// write.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#define _size 1024\n\n// 向管道中写数据\nint main() {\n    // 判断管道是否存在，不存在则创建\n    int ret = access(\"/home/lzx0626/fuck/fifo\", F_OK);\n    if (ret == -1) {\n        printf(\"管道不存在，创建管道\\n\");\n\n        ret = mkfifo(\"/home/lzx0626/fuck/fifo\", 0664);\n        if (ret == -1) {\n            perror(\"mkfifo\");\n            return -1;\n        }\n    }\n\n    // 打开管道，以只写的方式\n    int fd = open(\"/home/lzx0626/fuck/fifo\", O_WRONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 写数据\n    for (int i = 0; i < 100; ++i) {\n        char buf[_size];\n        sprintf(buf, \"hello, %d\", i);\n        printf(\"write data : %s\\n\", buf);\n        write(fd, buf, strlen(buf));\n        sleep(1);\n    }\n\n    close(fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// read.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <unistd.h>\n#define _size 1024\n\n// 向管道中读数据\nint main() {\n    // 打开管道文件，以只读的方式\n    int fd = open(\"/home/lzx0626/fuck/fifo\", O_RDONLY);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 读取数据\n    char buf[_size] = {0};\n    while (1) {\n        int len = read(fd, buf, sizeof(buf));\n        if (len == 0) {\n            printf(\"写端断开连接了...\\n\");\n            break;\n        }\n        printf(\"recv buf : %s\\n\", buf);\n        bzero(buf, sizeof(buf));\n    }\n\n    close(fd);\n\n    return 0;\n}\n~~~\n\n执行结果：(本来想写注意事项的，都在下面了)\n\n![image-20230721164727872](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721164727872.png)\n\n![image-20230721164735118](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721164735118.png)\n\n**有名管道的注意事项：**\n\n- **一个为读而打开一个管道的进程会阻塞，直到另一个进程为写打开管道**\n\n- **一个为写而打开一个管道的进程会阻塞，直到另一个进程为读打开管道**\n  **(可见有名管道的实现还是非常严谨的，双方没有就位不开放)**\n\n  (所以测试程序当中先后打开两个进程先打开的进程会等待后打开的进程，这里阻塞就是因为这个，并且是阻塞在open()函数的位置)\n\n**读管道：**\n\n- **管道中有数据，read会返回实际读取到的数据**\n- **管道中无数据：**\n  - **管道写端被全部关闭，read返回0(相当于读到文件末尾)**\n  - **管道写端没有被完全关闭，read阻塞等待**\n\n**写管道：**\n\n- **管道读端被全部关闭，进程异常终止(收到 SIGPIPE信号)**\n- **管道读端没有全部关闭：**\n  - **管道已经满了，write会阻塞**\n  - **管道没有满，write会将数据写入，并且返回实际写入的字节数**\n\n#### 有名管道通信案例\n\n实现一个简易聊天的功能，循环读写，我写你读，你写我读\n\n##### 思路\n\n![image-20230721170443404](https://cdn.davidingplus.cn/images/2025/01/31/image-20230721170443404.png)\n\n需要注意一点的就是两个进程是你来我往的，所以需要一方先写，另一方先读，否则就会导致阻塞\n\n~~~cpp\n//一方的代码，另一方稍加修改即可\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n#define _size 1024\n\nint main() {\n    // 判断有名管道文件1 2是否存在\n    int ret = access(\"/home/lzx0626/FIFO/fifo1\", F_OK);\n    if (ret == -1) {\n        printf(\"管道1不存在,创建相关的管道文件\\n\");\n        ret = mkfifo(\"/home/lzx0626/FIFO/fifo1\", 0664);\n        if (ret == -1) {\n            perror(\"mkfifo\");\n            return -1;\n        }\n    }\n\n    ret = access(\"/home/lzx0626/FIFO/fifo2\", F_OK);\n    if (ret == -1) {\n        printf(\"管道2不存在,创建相关的管道文件\\n\");\n        ret = mkfifo(\"/home/lzx0626/FIFO/fifo2\", 0664);\n        if (ret == -1) {\n            perror(\"mkfifo\");\n            return -1;\n        }\n    }\n\n    // 以只写的方式打开管道1\n    int fdw = open(\"/home/lzx0626/FIFO/fifo1\", O_WRONLY);\n    if (fdw == -1) {\n        perror(\"open\");\n        return -1;\n    }\n    printf(\"打开管道fifo1成功,等待写入...\\n\");\n\n    // 以只读的方式打开管道2\n    int fdr = open(\"/home/lzx0626/FIFO/fifo2\", O_RDONLY);\n    if (fdr == -1) {\n        perror(\"open\");\n        return -1;\n    }\n    printf(\"打开管道fifo2成功,等待读取...\\n\");\n\n    char buf[_size] = {0};\n    // 循环的写读数据\n    while (1) {\n        // 写数据\n        bzero(buf, sizeof(buf));\n        // 获取标准输入的数据\n        fgets(buf, sizeof(buf) - 1, stdin);  // 包含了回车符号\n        // 写数据\n        int ret = write(fdw, buf, sizeof(buf) - 1);\n        if (ret == -1) {\n            perror(\"write\");\n            return -1;\n        }\n\n        // 读数据\n        bzero(buf, sizeof(buf));\n        int len = read(fdr, buf, sizeof(buf));\n        if (len == -1) {\n            perror(\"read\");\n            return -1;\n        }\n        if (len == 0)\n            break;\n        printf(\"buf : %s\", buf);\n    }\n\n    // 关闭\n    close(fdw);\n    close(fdr);\n\n    return 0;\n}\n~~~\n\n问题来了，这个程序只能我写了你读，然后你写了我读，不能实现随意的交流，因为程序的逻辑就是写了之后读，读了之后写，如果写了之后再写，由于读是阻塞在那里的，所以写的东西会存在终端stdin的缓冲区当中，直到read()之后再刷新\n\n现在我想让随时通信，随意的读写，这样不妨可以联想到可以让读和写的操作独立起来，可以用子进程的方式，父进程绑定读，子进程绑定写，这样就可以实现了\n\n~~~cpp\n//一方的代码，另一方稍微修改一些就好了\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#define _size 1024\n\nint main() {\n    // 父进程写，子进程读\n    int pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {\n        // 负责写，绑定管道fifo1\n        int ret = access(\"/home/lzx0626/FIFO/fifo1\", F_OK);\n        if (ret == -1) {\n            printf(\"管道文件fifo1不存在,正在创建...\\n\");\n            // 不存在则创建\n            ret = mkfifo(\"/home/lzx0626/FIFO/fifo1\", 0664);\n            if (ret == -1) {\n                perror(\"mkfifo\");\n                return -1;\n            }\n        }\n\n        // 打开管道\n        int fdw = open(\"/home/lzx0626/FIFO/fifo1\", O_WRONLY);\n        if (fdw == -1) {\n            perror(\"open\");\n            return -1;\n        }\n        printf(\"父进程管道已打开,等待写入...\\n\");\n\n        // 写数据\n        char buf[_size] = {0};\n        while (1) {\n            bzero(buf, sizeof(buf));\n            fgets(buf, sizeof(buf) - 1, stdin);\n            printf(\"send : %s\", buf);\n            int len = write(fdw, buf, sizeof(buf) - 1);\n            if (len == -1) {\n                perror(\"write\");\n                return -1;\n            }\n        }\n        // 关闭\n        close(fdw);\n        // 父进程回收子进程\n        wait(NULL);\n    } else if (pid == 0) {\n        // 负责读，绑定管道fifo2\n        int ret = access(\"/home/lzx0626/FIFO/fifo2\", F_OK);\n        if (ret == -1) {\n            // 不存在则创建\n            printf(\"管道文件fifo2不存在,正在创建...\\n\");\n            ret = mkfifo(\"/home/lzx0626/FIFO/fifo2\", 0664);\n            if (ret == -1) {\n                perror(\"mkfifo\");\n                return -1;\n            }\n        }\n\n        // 打开管道\n        int fdr = open(\"/home/lzx0626/FIFO/fifo2\", O_RDONLY);\n        if (fdr == -1) {\n            perror(\"open\");\n            return -1;\n        }\n        printf(\"子进程管道已打开,等待读取...\\n\");\n\n        // 读数据\n        char buf[_size] = {0};\n        while (1) {\n            bzero(buf, sizeof(buf));\n            int len = read(fdr, buf, sizeof(buf));\n            if (len == -1) {\n                perror(\"read\");\n                return -1;\n            }\n            if (len == 0)  // 读端全部关闭，相当于读到文件末尾\n                break;\n            printf(\"recv : %s\", buf);\n        }\n        // 关闭\n        close(fdr);\n    }\n\n    return 0;\n}\n~~~\n\n### 内存映射\n\n将磁盘文件的数据映射到内存，用户修改内存就能修改磁盘文件\n\n![image-20230722143701427](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722143701427.png)\n\n#### 相关函数(!!!)\n\nmmap()用来建立映射，munmap()用来取消映射\n\n![image-20230722143806582](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722143806582.png)\n\n~~~cpp\n    #include <sys/mman.h>\n\n    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);\n// 作用：将一个文件或者设备的数据映射到内存中\n// 参数：\n//     void *addr：绝大多数情况传nullptr，表示由内核决定映射的内存地址在哪里\n//     length：要映射的数据的长度，这个值不能为0，建议使用文件的长度\n//         获取文件的长度：stat lseek\n//         这个虚拟地址的应映射是以分页为管理的，如果映射的长度不满页的大小，会自动调整为一个分页的大小\n//     prot：对我们申请的内存映射区的操作权限\n//         - PROT_EXEC  可执行的权限\n//         - PROT_READ  读的权限\n//         - PROT_WRITE 写的权限\n//         - PROT_NONE  没有权限\n//         要操作映射区，必须要有读权限，一般给 读权限 或者 读权限和写权限都有 (按位或)\n//     flags：\n//         - MAP_SHARED 映射区的数据会自动和磁盘文件进行同步，进程间通信必须设置这个选项\n//         - MAP_PROVATE 不同步，内存映射区的数据改变了，对原来的文件不会修改，会重新创建一个新的文件(copy on write)\n//     fd：需要映射的文件的文件描述符\n//         通过open()得到，open的是一个磁盘文件\n//         注意，文件的大小不能为0；open指定的权限不能和prot参数的权限有冲突\n//         比如，   prot：PROT_READ                    open：只读/读写\n//                 prot：PROT_READ | PROT_WRITE       open：读写\n//     offset：映射时候的偏移量，必须指定的是4K的整数倍，0表示不偏移\n// 返回值：\n//     成功 返回创建好的映射区的内存首地址\n//     失败 返回 MAP_FAILED (void *)-1，并且设置errno\n\n\tint munmap(void *addr, size_t length);\n// 功能：释放内存映射\n// 参数：\n//     addr：要释放的内存映射的首地址\n//     length：要释放的内存大小，要和mmap()的length参数值一样\n// \n\n// \n// 使用内存映射实现进程之间通信\n// 1.有关系的进程，父子进程\n//     在没有子进程的时候，通过唯一的父进程先通过一个大小不是0的磁盘文件创建内存映射区，有了之后再创建子进程，然后父子共享这个内存映射区\n// 2.没有关系的进程间通信\n//     准备一个大小不是0的磁盘文件\n//     进程1通过磁盘文件得到一个内存映射区，得到一个操作这个内存的指针\n//     进程2同理，得到一个指针\n//     使用内存映射区进行通信\n\n// 注意：内存映射区通信，不会阻塞\n~~~\n\n父子进程通过内存映射区通信的例子：\n\n**思路：通信？内存映射的本质是将文件映射到内存当中形成一块区域，和父子进程联系起来，不妨联想到了匿名管道，父进程在创建子进程之前就创建好内存映射区，然后fork()出子进程，这样父子进程就指向了同一块内存映射区了，就可以互相通信了**\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#define _size 1024\n\nint main() {\n    // 打开1个文件\n    int fd = open(\"test.txt\", O_RDWR);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n    // 获取大小\n    off_t size = lseek(fd, 0, SEEK_END);\n\n    // 创建内存映射区\n    void* ptr = mmap(nullptr, size, PROT_WRITE | PROT_READ, MAP_SHARED, fd, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    // 创建子进程\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {   // 父进程\n        wait(NULL);  // 等待子进程写入数据然后回收完毕再读取\n\n        // 读数据\n        char buf[_size] = {0};\n        strcpy(buf, (char*)ptr);\n        printf(\"read data : %s\\n\", buf);\n    } else if (pid == 0) {  // 子进程\n        // 写数据，注意是直接操作这个指针，和管道不一样，管道是通过文件描述符操作\n        // 我写的字符串后面带有 '\\0' 结束符，不用担心会和原来文件的数据冲突，因为我是从头开始覆盖，然后走到尾部自动补上 '\\0'，读操作也是一样的\n        strcpy((char*)ptr, \"nihao\");\n    }\n\n    // 关闭内存映射区\n    int ret = munmap(ptr, size);\n    if (ret == -1) {\n        perror(\"munmap\");\n        return -1;\n    }\n\n    // 关闭文件\n    close(fd);\n\n    return 0;\n}\n~~~\n\n**注意：'\\0'就是 char(0)，所以我才用 char buf[_size] = {0} 对字符串初始化!!!**\n\n不相关的进程之间通过内存映射通信\n\n思路：写进程先打开文件，创建映射区，然后修改数据，然后读进程打开文件，创建映射区然后读取修改后的数据；我这里的设计两个进程不能并发执行，因为读进程不是阻塞的，这样读取的是文件中原本的数据，需要等待写进程写完数据之后再执行\n\n~~~cpp\n// write.cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#define _size 1024\n\nint main() {\n    // 打开文件\n    int fd = open(\"test.txt\", O_RDWR);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 获取文件大小\n    struct stat statbuf;\n    int ret = stat(\"test.txt\", &statbuf);\n    if (ret == -1) {\n        perror(\"stat\");\n        return -1;\n    }\n    off_t size = statbuf.st_size;\n\n    // 创建内存映射区\n    void* ptr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    // 操作这块内存\n    char buf[_size] = {0};\n    fgets(buf, sizeof(buf) - 1, stdin);  // 保证后面留有一个'\\0'符号\n    // 写数据\n    strcpy((char*)ptr, buf);\n\n    // 关闭内存映射区\n    munmap(ptr, size);\n    // 关闭文件\n    close(fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// read.cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#define _size 1024\n\nint main() {\n    // 打开文件\n    int fd = open(\"test.txt\", O_RDWR);\n    if (fd == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 获取文件大小\n    struct stat statbuf;\n    int ret = stat(\"test.txt\", &statbuf);\n    if (ret == -1) {\n        perror(\"stat\");\n        return -1;\n    }\n    off_t size = statbuf.st_size;\n\n    // 创建内存映射区\n    void* ptr = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    // 操作这块内存\n    char buf[_size] = {0};\n    // 读数据\n    strcpy(buf, (char*)ptr);\n    printf(\"read data : %s\", buf);\n\n    // 关闭内存映射区\n    munmap(ptr, size);\n    // 关闭文件\n    close(fd);\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230722155039444](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722155039444.png)\n\n**但是要注意一点，写的数据不能比文件本身的大小大，不然就会超出内存的大小范围了，就会写不进去!!!**\n\n#### 思考问题\n\n1.如果对mmap的返回值(ptr)做++操作(ptr++), munmap是否能够成功?\nvoid * ptr = mmap(...);\nptr++;  可以对其进行++操作\nmunmap(ptr, len);   // 错误,要保存地址\n\n2.如果open时O_RDONLY, mmap时prot参数指定PROT_READ | PROT_WRITE会怎样?\n错误，返回MAP_FAILED\nopen()函数中的权限建议和prot参数的权限保持一致。\n\n3.如果文件偏移量为1000会怎样?\n**偏移量必须是4K的整数倍，返回MAP_FAILED**\n\n4.mmap什么情况下会调用失败?\n    - 第二个参数：length = 0\n    - 第三个参数：prot\n        - 只指定了写权限\n        - prot PROT_READ | PROT_WRITE\n          第5个参数fd 通过open函数时指定的 O_RDONLY / O_WRONLY\n\n5.可以open的时候O_CREAT一个新文件来创建映射区吗?\n    - 可以的，但是创建的文件的大小如果为0的话，肯定不行\n        - 可以对新的文件进行扩展\n        - lseek()\n        - truncate()\n\n6.mmap后关闭文件描述符，对mmap映射有没有影响？\n    int fd = open(\"XXX\");\n    mmap(,,,,fd,0);\n    close(fd); \n    映射区还存在，创建映射区的fd被关闭，没有任何影响。\n\n7.对ptr越界操作会怎样？\nvoid * ptr = mmap(NULL, 100,,,,,);\n映射出来会调整为**4K**\n越界操作操作的是非法的内存 -> 段错误\n\n#### 示例\n\n**将english.txt文件拷贝一份为cpy.txt，保存在当前目录**\n\n思路：两个文件分别映射到内存当中，然后操纵内存进行复制即可\n\n**注意：新文件需要预分配大小，不能出现空文件**\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n// 将english.txt文件拷贝一份为cpy.txt，保存在当前目录\nint main() {\n    // 打开english.txt\n    int fd_src = open(\"english.txt\", O_RDONLY);\n    if (fd_src == -1) {\n        perror(\"open\");\n        return -1;\n    }\n\n    // 获取english.txt的大小\n    off_t size = lseek(fd_src, 0, SEEK_END);\n\n    // 创建内存映射区\n    void* ptr_src = mmap(nullptr, size, PROT_READ, MAP_SHARED, fd_src, 0);\n    if (ptr_src == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    // 创建cpy.txt\n    int ret = access(\"copy.txt\", F_OK);\n    if (ret == 0)  // 存在把他删除\n        unlink(\"cpy.txt\");\n    // 创建\n    int fd_dest = open(\"cpy.txt\", O_RDWR | O_CREAT, 0664);\n    if (fd_dest == -1) {\n        perror(\"open\");\n        return -1;\n    }\n    // 将空文件的大小修改为源文件的大小，防止出现空文件\n    ret = truncate(\"cpy.txt\", size);\n    // ret = lseek(fd_dest, size, SEEK_END);\n    // write(fd_dest, \" \", 1);  // lseek扩展文件需要进行一次写的操作，truncate不需要!!!\n    if (ret == -1) {\n        perror(\"truncate\");\n        return -1;\n    }\n\n    // 创建内存映射区\n    void* ptr_dest = mmap(nullptr, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd_dest, 0);\n    if (ptr_dest == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    // 拷贝\n    strncpy((char*)ptr_dest, (char*)ptr_src, size);\n\n    // 关闭内存映射区\n    munmap(ptr_src, size);\n    munmap(ptr_dest, size);\n    // 关闭文件\n    close(fd_src);\n    close(fd_dest);\n\n    return 0;\n}\n~~~\n\n这里我们得到了两种扩展文件内存的方式，分别使用truncate()和lseek()\n\n- **truncate()中，size是想要扩展到的文件大小**\n- **lseek()中，length是在SEEK_END基础上的文件指针偏移量，最后文件指针会走到length+SEEK_END的位置，这是原来文件走不到的位置，因此文件就相应扩展了，length就是扩展了的文件大小**\n- **lseek扩展文件需要进行一次写的操作，truncate不需要!!!**\n\n~~~cpp\ntruncate(\"cpy.txt\", size);\n\nlseek(fd_dest, length, SEEK_END);\nwrite(fd_dest, \" \", 1);  // lseek扩展文件需要进行一次写的操作，truncate不需要!!!\n~~~\n\n#### 匿名映射\n\n**顾名思义，匿名映射，都匿名了，说明没有文件实体做支撑了吧，因此两个不相关的进程不适用于这个，因为找不到连接的接口，而父子进程恰好可以用这个来通信**\n\n**flags参数当中，MAP_SHARED和MAP_PRIVATE参数是必选一个，然后其他的是可选项，MAP_ANONYMOUS就是一个可选项**\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/wait.h>\n#include <unistd.h>\n#define _size 1024\n\n/*\n匿名映射：不需要文件实体进行一个内存映射，只能在父子和有关系的进程之间通信，因为没有办法通过文件进行关联\n- 修改flags参数，做匿名映射需要传入 MAP_ANONYMOUS，这样会忽略掉fd参数，一般我们传入-1\n- flags参数当中，MAP_SHARED和MAP_PRIVATE参数是必选一个，然后其他的是可选项，MAP_ANONYMOUS就是一个可选项\n*/\n\nint main() {\n    // 创建匿名内存映射区\n    int length = 4096;\n    void* ptr = mmap(nullptr, length, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);\n    if (ptr == MAP_FAILED) {\n        perror(\"mmap\");\n        return -1;\n    }\n\n    // 父子进程间通信\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {  // 父进程\n        strcpy((char*)ptr, \"helloworld\");\n        wait(nullptr);\n    } else if (pid == 0) {  // 子进程\n        sleep(1);           // 非阻塞，先睡一秒让父进程执行完写入操作\n        printf(\"%s\\n\", (char*)ptr);\n    }\n\n    // 关闭内存映射区\n    int ret = munmap(ptr, length);\n    if (ret == -1) {\n        perror(\"munmap\");\n        return -1;\n    }\n\n    return 0;\n}\n~~~\n\n### 信号\n\n#### 概念\n\n![image-20230722171544342](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722171544342.png)\n\n软件中断\n\n处理紧急事务，完毕后回到保存的位置继续执行\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722171944530.png\" alt=\"image-20230722171944530\" style=\"zoom:67%;\" />\n\n#### 目的\n\n**让进程知道了已经发生了某一个特定的事情；强迫进程执行他自己代码当中的信号处理程序**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722172651186.png\" alt=\"image-20230722172651186\" style=\"zoom: 67%;\" />\n\n#### Linux信号列表\n\n**一共62个(32 33没有)，1-31是常规信号，32-64是预定义好的信号，目前还没有使用，将来可能会使用，并且是实时信号**\n\n![image-20230722172945238](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722172945238.png)\n\n红色信号比较重要：\n\n![image-20230722173136070](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722173136070.png)\n\n![image-20230722173332099](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722173332099.png)\n\n![image-20230722173427247](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722173427247.png)\n\n![image-20230722173511150](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722173511150.png)\n\n#### 信号的5种默认处理动作\n\n其中，Core是指终止进程并且生成一个Core文件，这个文件当中记载了程序异常终止时候保存的一些错误信息等等\n\n![image-20230722173544492](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722173544492.png)\n\n##### 查看并且使用Core文件\n\nCore文件里面记录了程序异常退出的状态信息，可以让程序在异常退出的时候生成Core文件，方便我们查看和调试错误的信息\n\n系统默认在进程异常退出的时候是不会产生Core文件的，通过 ulimit -a 命令查看：\n\n可以看出 core file size 这一项默认是0\n\n![image-20230722190246653](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722190246653.png)\n\n我们将其设置一下，可以设置为一个具体的大小或者不限制\n\n![image-20230722190333227](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722190333227.png)\n\n现在就应该有了\n\n还要注意一点：这个Core文件要想被记录下来，必须在Linux的本地目录当中操作，不能在和windows的共享文件夹或者windows文件夹当中操作，这样出来的Core文件是会生成，但是大小为0，没有用\n\n源代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <cstring>\n\nint main() {\n    char* buf;\n\n    strcpy(buf, \"hello\");\n    //这里显然会报错，因为buf指针没有被初始化，根本不知道操作的是哪一块内存，指向的字符串区域有多大，是个野指针\n\n    return 0;\n}\n~~~\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722190630746.png\" alt=\"image-20230722190630746\" style=\"zoom:67%;\" />\n\n执行 a.out 之后，报了段错误，我们来查看下core文件的大小，不为0，可见记录了相关错误信息\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722190751504.png\" alt=\"image-20230722190751504\" style=\"zoom:80%;\" />\n\n怎么查看呢？可以通过gdb调试来查看，这也是为什么我们编译的时候加上 -g 调试参数的原因\n\n通过gdb调试可执行文件a.out，里面有一个命令\n\n~~~shell\ncore-file core #用来查看该可执行文件对应的core文件信息\n~~~\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722190919579.png\" alt=\"image-20230722190919579\" style=\"zoom:80%;\" />\n\n可以看出程序的异常终止是因为这一行的问题，与我们的预期一致；\n\n而发出的终止信号SIGSEGV的含义就是程序进行了无效的内存访问，也就是段错误\n\n#### 相关函数\n\n##### kill(),raise(),abort()\n\n![image-20230722174710585](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722174710585.png)\n\n~~~cpp\n    #include <signal.h>\n\n    int kill(pid_t pid, int sig);\n// 作用：给任何的进程或者进程组pid，发送任何的信号sig\n// 参数：\n//     pid：\n//         >  0  将信号发送给指定的进程\n//         == 0  将信号发送给当前的进程组中所有的进程\n//         == -1 将信号发送给每一个有权限接受这个信号的进程\n//         <  -1 这个pid = 某个进程组的ID的相反数，给这个进程组中所有的进程发送信号\n\n//     sig：需要发送的信号编号或者宏值，如果是0则表示不发送任何信号\n// 返回值：成功 0 ; 失败 -1，并设置errno\n\n\n    int raise(int sig);\n// 作用：给当前进程发送信号\n// 参数：sig：需要发送的信号编号或者宏值，如果是0则表示不发送任何信号\n// 返回值： 成功 0 ; 失败 非 0\n//     kill(getpid(),sig);\n\n\n    void abort(void);\n// 功能：发送一个SIGABRT信号给当前的进程，默认是杀死当前的进程\n//     kill(getpid(),SIGABRT);\n~~~\n\n测试程序：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <signal.h>\n\nint main() {\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0) {\n        printf(\"parent process\\n\");\n        sleep(2);\n        printf(\"kill child process now\\n\");\n        kill(pid, SIGINT);\n    } else if (pid == 0) {\n        for (int i = 0; i < 5; ++i) {\n            printf(\"child process\\n\");\n            sleep(1);\n        }\n    }\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722193118885.png\" alt=\"image-20230722193118885\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722193131543.png\" alt=\"image-20230722193131543\" style=\"zoom:67%;\" />\n\n**有可能为2次也有可能为3次，因为父子进程是并发执行的，谁先运行要看抢占cpu，这里如果是父进程先执行就是2次，子进程先执行就会先偷偷打印一次，就是3次，这也体现了多进程程序执行结果的不确定性，这完全取决于操作系统对于进程的调度**\n\n##### alarm()\n\n**这里面请注意alarm()函数的返回值和设置参数为0时候的情况**\n\n定时器到时间之后程序会接受 SIGALARM 信号，然后终止\n\n~~~cpp\n    #include <unistd.h>\n\n    unsigned int alarm(unsigned int seconds);\n// 作用：去设置定时器；函数调用，开始倒计时；\n//     当倒计时为0的时候，函数会给当前的进程发送一个信号 SIGALARM\n// 参数：\n//     seconds：倒计时时长，单位秒，当参数为0的时候，计时器无效(不进行倒计时，也不发送信号)\n//         取消一个定时器 alarm(0)\n// 返回值：\n//     - 之前没有定时器，返回0\n//     - 之前有定时器，返回之前定时器剩余的时间\n\n// - SIGALARM 信号：默认终止当前的进程，每一个进程都有且只有唯一的一个定时器\n//     alarm(10); ->返回0\n//     //过了一秒\n//     alarm(5);  ->返回9\n\n// 该函数不阻塞，设置之后会继续往下执行\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\nint main() {\n    int seconds = alarm(5);             // 不阻塞\n    printf(\"seconds : %d\\n\", seconds);  // 0\n\n    sleep(2);\n    seconds = alarm(2);\n    printf(\"seconds : %d\\n\", seconds);  // 3\n\n    while (1)\n        ;\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230722200410797](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722200410797.png)\n\n案例：查看计算机一秒能输出多少个数\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <unistd.h>\n\n// 1秒钟电脑能数多少个数\nint main() {\n    alarm(1);\n\n    int i = 0;\n    while (1)\n        printf(\"%d\\n\", i++);\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230722200801779](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722200801779.png)\n\n但是我们观察到输出完毕花的时间好像不止1秒，这是为什么呢？\n\n**注意到这里输出的数好多好多，而终端的输出是依靠内核当中的012文件描述符，0标准输入STDIN_FILENO，1标准输出STDOUT_FILENO，2标准错误STDERR_FILENO，然后要想输出到终端必须要经历特定的事件，比如程序终止或者遇到回车'\\n'等等，这是因为终端有缓冲区的存在；之所以花了超过1秒是因为从缓冲区输出到屏幕上，还是输出了这么多的数据，花费了大量时间**\n\n**但是这里只数了20万不到，感觉少太多了，这是因为往终端上输出的时候需要调用文件描述符，输出一次调用一次磁盘I/O，这样浪费时间，CPU没有百分百去执行数的这个操作，我们可以将其输出重定向到一个文本当中，这样只用调用一次文件I/O就可以把文件写在里面**\n\n![image-20230722201704262](https://cdn.davidingplus.cn/images/2025/01/31/image-20230722201704262.png)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230722201732964.png\" alt=\"image-20230722201732964\" style=\"zoom:67%;\" />\n\n可见这样就多了很多\n\n**实际的时间 = 内核时间 + 用户时间 + 消耗的时间(比如I/O操作)**\n\n**进行文件I/O操作的时候比较浪费时间**\n\n**定时器，和进程的状态无关(自然定时法)；无论进程处于什么状态，这个alarm()都会计时**\n\n##### settimer()\n\n注意注释的介绍\n\n~~~cpp\n    #include <sys/time.h>\n\n    int setitimer(int which, const struct itimerval *restrict new_value,\n                struct itimerval *_Nullable restrict old_value);\n// 作用：设置定时器；可以替代alarm函数。精度可以达到微秒，并且还可以实现周期性的定时\n// 参数：\n//     which：指定的是定时器以什么时间计时\n//         - ITIMER_REAL：真实时间(包含内核+用户+消耗的时间(例如I/O))，时间到达发送 SIGALRM 常用\n//         - ITIMER_VIRTUAL：用户时间，时间到达发送 SIGVTALRM\n//         - ITIMER_PROF：以该进程在用户态和内核态所消耗的时间来计算，时间到达发送 SIGPROF\n\n//     new_value：设置定时器属性\n\n//         struct itimerval { //定时器的结构体\n//             struct timeval it_interval;  // 每个阶段的时间，间隔时间\n//             struct timeval it_value;     // 延迟多长时间执行定时器\n//         };\n\n//         struct timeval { //时间的结构体\n//             time_t tv_sec;        // 秒数\n//             suseconds_t tv_usec;  // 微秒\n//         };\n\n//         eg：过10秒(it_value)后，每隔2秒(it_interval)定时一次\n\n//     old_value：记录上一次定时的时间参数，是一个传出参数，函数将上一次的状态心如进去，一般不使用，就指定nullptr就可以了\n// 返回值：\n//     成功 0\n//     失败 -1，设置errno\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <sys/time.h>\n\n// 过3秒以后，每隔2秒定时一次\nint main() {\n    // 过三秒，会发送信号\n    struct timeval _value;\n    _value.tv_sec = 3;\n    _value.tv_usec = 0;\n\n    // 每隔两秒，会发送信号\n    struct timeval _interavl;\n    _interavl.tv_sec = 2;\n    _interavl.tv_usec = 0;\n\n    // itimerval结构体\n    struct itimerval new_value;\n    new_value.it_value = _value;\n    new_value.it_interval = _interavl;\n\n    // 设置定时器\n    int ret = setitimer(ITIMER_REAL, &new_value, nullptr);  // 非阻塞\n    printf(\"定时器开始了\\n\");                               // 立刻执行，表明是非阻塞的\n    if (ret == -1) {\n        perror(\"setitimer\");\n        return -1;\n    }\n\n    while (1)\n        ;\n\n    return 0;\n}\n~~~\n\n**3秒的延迟开始和2秒的定时间隔到了后都会发送信号，因此程序执行下来是在3秒之后就退出了，这是3秒的延迟开始的信号**\n\n**而且\"定时器开始了\"这句话是立刻开始的，这就表明这个函数是非阻塞的，这个函数执行后，虽然定时器还没有开始，但是程序继续在执行**\n\n**但是这样看起来没有办法实现每2秒一次的效果，这就需要捕捉信号，这样才能做我们自己的事情**\n\n#### 信号捕捉函数\n\n![image-20230723150743944](https://cdn.davidingplus.cn/images/2025/01/31/image-20230723150743944.png)\n\n##### signal()\n\n注意回调函数的函数格式定义是有要求的，就是 typedef 那一行，那是个函数指针的写法，**要求我们传入的回调函数返回值必须为void，然后参数是int，这个记录的是捕捉到的信号的编号**\n\n~~~cpp\n    #include <signal.h>\n\n    typedef void (*sighandler_t)(int);\n    sighandler_t signal(int signum, sighandler_t handler);\n// 作用：设置某个信号的捕捉行为，\n// 参数：\n//     signum：要捕捉的信号\n//         注意：SIGKILL 和 SIGSTOP 不能被捕捉，不能被忽略；\n//             因为这两个信号都是带有强制性的杀死或者暂停进程，这个是需要保证权威的，否则强制性都解决不了就可以被不法分子利用了，比如制作病毒让进程一直运行消耗资源，这两个信号没有办法解决\n//     hander：捕捉到信号要如何处理\n//         SIG_IGN：忽略信号\n//         SIG_DFL：用信号默认的行为\n//         回调函数：这个函数是内核调用，程序员只负责写，捕捉到信号后如何去处理信号\n//             回调函数需要程序员实现，提前准备好，函数的类型根据实际需求，看函数指针的定义\n//             不是程序员调用的，而是当信号产生由内核调用\n//             函数指针是实现回调的手段，函数实现后，将函数名放到函数指针的位置就可以了\n\n// 返回值：\n//     成功，返回上一次注册的信号处理函数的地址；第一次返回nullptr\n//     失败，返回SIG_ERR，设置errno\n~~~\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <signal.h>\n#include <sys/time.h>\n\nvoid myalarm(int num) {\n    printf(\"捕捉到了信号的编号是: %d\\n\", num);\n}\n\nint main() {\n    // 注册信号捕捉，需要提前注册，避免定时器开始执行后可能信号捕捉还没生效导致错过信号捕捉的情况\n    // signal(SIGALRM, SIG_IGN);  // 信号产生后忽略信号，程序会一直执行\n    // signal(SIGALRM, SIG_DFL);  // 按照默认的方式处理信号，程序延迟3秒的时候开始计时，发送信号然后终止\n\n    // typedef void (*sighandler_t)(int); 函数指针的类型，int类型的参数表示捕捉到的信号的值\n    sighandler_t ret = signal(SIGALRM, myalarm);\n    if (ret == SIG_ERR) {\n        perror(\"signal\");\n        return -1;\n    }\n\n    // 过三秒，会发送信号\n    struct timeval _value;\n    _value.tv_sec = 3;\n    _value.tv_usec = 0;\n\n    // 每隔两秒，会发送信号\n    struct timeval _interavl;\n    _interavl.tv_sec = 2;\n    _interavl.tv_usec = 0;\n\n    // itimerval结构体\n    struct itimerval new_value;\n    new_value.it_value = _value;\n    new_value.it_interval = _interavl;\n\n    // 设置定时器\n    int rets = setitimer(ITIMER_REAL, &new_value, nullptr);  // 非阻塞\n    printf(\"定时器开始了\\n\");                                // 立刻执行，表明是非阻塞的\n    if (rets == -1) {\n        perror(\"setitimer\");\n        return -1;\n    }\n\n    while (1)\n        ;\n\n    return 0;\n}\n~~~\n\n#### 信号集\n\n**位图机制：信号集是一堆信号的集合，那么怎么去表示这个信号集呢？我们知道信号是用一个整数的序号表示的(1-31 34-64)，所以我们用类似于文件st_mode那个的形式，用每一位来表示一个信号，0 1 表示信号有无，这样信号集就相当于是一个整数，而想要添加一个信号进去就用这个信号(用信号集的格式表示)按位或就好了**\n\n**信号三种状态：**\n\n**产生：信号产生**\n\n**未决：信号产生到信号被处理之前的这段时间**\n\n**抵达：信号抵达**\n\n**然后阻塞信号是指阻止信号被处理，而不是阻止信号产生；阻塞就是让系统保持信号，留着以后发送**\n\n**我们可以设置阻塞信号集，表示要阻塞哪些信号；而不能修改或者设置未决信号集，我们不能阻止信号的产生；**\n\n**系统PCB当中自带阻塞信号集和未决信号集，我们也不能直接操作，需要借助系统提供的API才能操作**\n\n![image-20230723154213795](https://cdn.davidingplus.cn/images/2025/01/31/image-20230723154213795.png)\n\n阻塞信号集和未决信号集(在PCB当中)\n\n- **用户通过键盘 Ctrl + C，产生SIGINT信号，信号被创建**\n- **信号产生，但是没有被处理，未决状态，以下是工作过程(也解释了为什么信号产生了不会被立即处理)**\n  - **在内核当中，将所有的没有被处理的信号存储在一个集合当中(未决信号集)**\n  - **SIGINT信号，状态存储在第二个标志位，这个标志位的值为0说明信号不是未决状态，为1说明信号是未决状态**\n- **这个未决状态的信号，需要被处理，处理之前需要和另一个信号集(阻塞信号集)对应的标志位进行比较**\n  - **阻塞信号集默认不阻塞所有信号**\n  - **如果想要阻塞某些信号，需要用户调用系统的API**\n- **在处理的时候和阻塞信号集中的标志位查询，看是不是对该信号设置了阻塞**\n  - **没有阻塞，这个信号就会被处理**\n  - **如果阻塞了，这个信号就继续处于未决状态，直到阻塞解除，这个信号被处理**\n\n![image-20230723165142990](https://cdn.davidingplus.cn/images/2025/01/31/image-20230723165142990.png)\n\n##### 相关函数\n\n![image-20230723170027725](https://cdn.davidingplus.cn/images/2025/01/31/image-20230723170027725.png)\n\n**前面五个，都是对自己定义的信号集进行操作，信号集的类型是 sigset_t，本质就是一个数组，下标对应信号signum，值代表是否信号状态**\n\n~~~cpp\n\t#include <signal.h>\n\n// 以下的信号集相关的函数都是对自定义的信号集进行操作，我们不能直接修改系统当中的未决信号集和阻塞信号集!!!\n\n\tint sigemptyset(sigset_t *set);\n// 功能：清空信号集中的数据，将信号集中的所有标志位置为0\n// 参数：set，传出参数，需要操作的信号集\n// 返回值：成功 0；失败 -1，修改errno\n\n\tint sigfillset(sigset_t *set);\n// 功能：将信号集中的所有标志位置为1\n// 参数：set，传出参数，需要操作的信号集\n// 返回值：成功 0；失败 -1，修改errno\n\n\tint sigaddset(sigset_t *set, int signum);\n// 功能：设置信号集中的某一个信号对应的标志位为1，表示阻塞这个信号\n// 参数：set，传出参数，需要操作的信号集；signum：需要设置为阻塞的信号\n// 返回值：成功 0；失败 -1，修改errno\n\n\tint sigdelset(sigset_t *set, int signum);\n// 功能：设置信号集中的某一个信号对应的标志位为0，表示不阻塞这个信号\n// 参数：set，传出参数，需要操作的信号集；signum：需要设置不为阻塞的信号\n// 返回值：成功 0；失败 -1，修改errno\n\n\tint sigismember(const sigset_t *set, int signum);\n// 功能：判断某个信号是否阻塞\n// 参数：set，需要操作的信号集；signum：需要查看是否阻塞的信号\n// 返回值：(与前面不一样!!!)\n//     1 是成员，signum被阻塞；0 不是成员，不阻塞\n//     -1 表示失败，修改errno\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <signal.h>\n\nvoid Judge(const sigset_t& set, const int& signum) {\n    int ret = sigismember(&set, signum);\n    if (ret == -1) {\n        perror(\"sigismember\");\n        exit(-1);\n    }\n\n    if (ret == 1)\n        printf(\"信号%d在set当中\\n\", signum);\n    else if (ret == 0)\n        printf(\"信号%d不在set当中\\n\", signum);\n}\n\nint main() {\n    // 创建一个信号集\n    sigset_t set;\n\n    // 这么创建的数据一般是随机的，我们一般用系统的api清空\n    int ret = sigemptyset(&set);\n    if (ret == -1) {\n        perror(\"sigemptyset\");\n        return -1;\n    }\n\n    // 判断SIGINT是否在信号集set中\n    Judge(set, SIGINT);  // 2号信号不在\n\n    // 添加几个信号\n    ret = sigaddset(&set, SIGINT);\n    if (ret == -1) {\n        perror(\"sigaddset\");\n        return -1;\n    }\n\n    ret = sigaddset(&set, SIGQUIT);\n    if (ret == -1) {\n        perror(\"sigaddset\");\n        return -1;\n    }\n\n    // 判断是否在信号集set中\n    Judge(set, SIGINT);   // 2号信号在\n    Judge(set, SIGQUIT);  // 3号信号在\n\n    // 删除一个信号\n    ret = sigdelset(&set, SIGQUIT);\n    if (ret == -1) {\n        perror(\"sigdelset\");\n        return -1;\n    }\n\n    // 判断SIGQUIT是否在信号集set中\n    Judge(set, SIGQUIT);  // 3号信号不在\n\n    return 0;\n}\n~~~\n\n**sigprocmask()和sigpending()**\n\n**调用之后就可以把我们自己设置的信号集设置到系统提供的阻塞信号集当中，这也是我们唯一能设置系统内核PCB中的信号集，未决信号集不能被设置或者处理，只能被读取**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230724150434261.png\" alt=\"image-20230724150434261\" style=\"zoom:50%;\" />\n\n~~~cpp\n    #include <signal.h>\n\n\tint sigprocmask(int how, const sigset_t *_Nullable restrict set,\n                                   sigset_t *_Nullable restrict oldset);\n// 功能：将自定义信号集中的数据设置到内核当中(设置阻塞，接触阻塞，替换)\n// 参数：\n//     how：如何对内核阻塞信号集进行处理\n//         SIG_BLOCK：将用户设置的阻塞信号集添加到内核中，原来的数据不变\n//             假设中内核中默认的阻塞信号集是mask，则 mask | set (添加的公式)\n//         SIG_UNBLOCK：根据用户设置的数据，对内核中的数据进行接触阻塞\n//             mask & = ~ set (去除的公式)\n//             比如 mask 1 0 1 1 1 ，set 0 0 1 0 1，解除这两位的阻塞\n//             那么就是 ~set 1 1 0 1 0 ，然后想与就得到 1 0 0 1 0\n//         SIG_SETMASK：覆盖内核中原来的值\n\n//     set：已经初始化好的用户自定义的信号集\n//     oldset：保存的之前内核中的阻塞信号集的状态，传出参数，一般不使用，设置为nullptr即可\n// 返回值：\n//     成功 0\n//     失败 -1，并且设置errno，有两个值：EFAULT，EINVAL\n\n\tint sigpending(sigset_t *set);\n// 功能：获取内核中的未决信号集\n// 参数：set，传出参数，保存的是内核中的未决信号集\n// 返回值：\n//     成功 0，失败 -1，设置errno\n~~~\n\n注意一点，就是在二进制数当中，添加位数为1和解除位数为1(变为0)的操作\n\n~~~cpp\nmask | set //添加\nmask & = ~set //解除\n~~~\n\n现在我们需要写一个程序，用来查看内核当中的未决信号集，并且设置某些信号阻塞，然后再次查看\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <signal.h>\n#include <unistd.h>\n\n// 编写一个程序，把所有的常规信号(1-31)的未决状态打印到屏幕\n// 设置某些信号是阻塞的，通过键盘产生这些信号\nint main() {\n    // 设置 2号信号 SIGINT(ctrl+C) 和 3号信号SIGQUIT(ctrl+\\) 阻塞\n    sigset_t set;\n    // 清空\n    int ret = sigemptyset(&set);\n    if (-1 == ret) {\n        perror(\"sigemptyset\");\n        return -1;\n    }\n\n    // 将2号和3号信号添加进去\n    ret = sigaddset(&set, SIGINT);\n    if (-1 == ret) {\n        perror(\"sigaddset\");\n        return -1;\n    }\n    ret = sigaddset(&set, SIGQUIT);\n    if (-1 == ret) {\n        perror(\"sigaddset\");\n        return -1;\n    }\n\n    // 修改内核中的信号集\n    ret = sigprocmask(SIG_BLOCK, &set, nullptr);\n    if (-1 == ret) {\n        perror(\"sigprocmask\");\n        return -1;\n    }\n\n    int count = 0;\n\n    // 在循环当中获取未决信号集的数据\n    while (1) {\n        sigset_t pendingset;\n        ret = sigemptyset(&pendingset);\n        if (-1 == ret) {\n            perror(\"sigemptyset\");\n            return -1;\n        }\n\n        sigpending(&pendingset);\n\n        // 遍历前32位 即1-31号(0号没用)\n        for (int i = 1; i < 32; ++i) {\n            ret = sigismember(&pendingset, i);\n            if (-1 == ret) {\n                perror(\"sigismember\");\n                return -1;\n            }\n\n            if (1 == ret)\n                printf(\"1\");\n            else if (0 == ret)\n                printf(\"0\");\n        }\n        puts(\"\");\n\n        // 为了防止只能通过kill -9 命令杀死该进程，现在我们计数，到10就接触阻塞\n        if (count++ == 10) {\n            printf(\"2号信号SIGINT和3号信号SIGQUIT已经解除阻塞\\n\");\n            ret = sigprocmask(SIG_UNBLOCK, &set, nullptr);\n            if (-1 == ret) {\n                perror(\"sigprocmask\");\n                return -1;\n            }\n        }\n        sleep(1);\n    }\n\n    return 0;\n}\n~~~\n\n这里我们设置了10秒后就会解除阻塞，因为我们需要防止这个进程只能通过kill -9命令强制杀死，给自己留一条后路\n\n执行结果：\n\n**可见，当我们输出 ctrl+c 和ctrl+\\ 的时候，未决信号集里面添加了这两个信号，但是由于我们设置了阻塞，不会去立即处理，这种情况会持续到我解除他的阻塞才行，所以他很急，但是他没得选择。当我解除了这两个信号的阻塞后，马上就处理了，程序异常终止**\n\n这里输出一个空行是因为第一，字符串我输出了换行，第二，SIGINT信号和SIGQUIT信号执行后都会输出空行，这里是执行了SIGINT信号\n\n![image-20230724155507574](https://cdn.davidingplus.cn/images/2025/01/31/image-20230724155507574.png)\n\n补充：将程序挂到后台执行，加上 & 符号\n\n~~~shell\n./a.out &\n~~~\n\n程序到后台运行，所以我 ctrl+c 没有用，并且我可以执行我自己的命令，图中就执行了ls和kill -9\n\n并且由于这个进程的输出是默认定向到终端的，所以终端会输出\n\n![image-20230724160250340](https://cdn.davidingplus.cn/images/2025/01/31/image-20230724160250340.png)\n\n切换到前台\n\n~~~shell\nfg\n~~~\n\n![image-20230724160542261](https://cdn.davidingplus.cn/images/2025/01/31/image-20230724160542261.png)\n\n#### (续信号捕捉函数)sigaction()\n\n~~~cpp\n    #include <signal.h>\n\n    int sigaction(int signum,\n                        const struct sigaction *_Nullable restrict act,\n                        struct sigaction *_Nullable restrict oldact);\n// 作用：用来检查或者改变信号的处理，信号捕捉\n// 参数：\n//     signum：需要捕捉的信号的编号或者宏值\n//     act：捕捉到信号之后相应的处理动作\n//     oldact：上一次对信号捕捉的相关的设置，一般不使用，传递nullptr\n// 返回值：\n//     成功 0\n//     失败 -1，设置errno\n\n    struct sigaction {\n            //函数指针，指向的函数就是信号捕捉到之后的处理函数\n            void     (*sa_handler)(int);\n            //函数指针，一般不使用\n            void     (*sa_sigaction)(int, siginfo_t *, void *);\n            //临时阻塞信号集，在信号捕捉函数执行过程中会临时阻塞某些信号，执行完之后恢复\n            sigset_t   sa_mask;\n            //指定是用第一个回调处理sa_handler还是第二个sa_sigaction，0表示第一个，SA_SIGINFO表示第二个，还有其他的值，但是用的少\n            int        sa_flags;\n            //被废弃掉了，不需要用，传入nullptr\n            void     (*sa_restorer)(void);\n\t};\n~~~\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <signal.h>\n#include <sys/time.h>\n\nvoid myalarm(int num) {\n    printf(\"捕捉到了信号的编号是: %d\\n\", num);\n}\n\nint main() {\n    struct sigaction act;\n    act.sa_flags = 0;\n    act.sa_handler = myalarm;\n    sigemptyset(&act.sa_mask);  // 清空吧，表示不要临时阻塞任何信号\n\n    int ret = sigaction(SIGALRM, &act, nullptr);\n    if (-1 == ret) {\n        perror(\"signal\");\n        return -1;\n    }\n\n    // 过三秒，会发送信号\n    struct timeval _value;\n    _value.tv_sec = 3;\n    _value.tv_usec = 0;\n\n    // 每隔两秒，会发送信号\n    struct timeval _interavl;\n    _interavl.tv_sec = 2;\n    _interavl.tv_usec = 0;\n\n    // itimerval结构体\n    struct itimerval new_value;\n    new_value.it_value = _value;\n    new_value.it_interval = _interavl;\n\n    // 设置定时器\n    int rets = setitimer(ITIMER_REAL, &new_value, nullptr);  // 非阻塞\n    printf(\"定时器开始了\\n\");                                // 立刻执行，表明是非阻塞的\n    if (rets == -1) {\n        perror(\"setitimer\");\n        return -1;\n    }\n\n    while (1)\n        ;\n\n    return 0;\n}\n~~~\n\n执行结果和signal.cpp是一样的，延迟三秒后开始定时器发送信号，然后每隔两秒发送信号\n\n##### 比较二者\n\n**建议使用 sigaction()**\n\n- **signal()是ANSI C signal handling，是美国那边的标准，对其他的标准例如POSIX可能不匹配，所以有一定局限性**\n- **sigaction()是标准的，也可以说是改进过的函数，基本都能适配标准，并且功能更多**\n\n##### 更好理解信号捕捉\n\n![image-20230724170811186](https://cdn.davidingplus.cn/images/2025/01/31/image-20230724170811186.png)\n\n要注意几点：\n\n- **在sigaction()中，处理信号的时候使用的是我们传递进去的临时阻塞信号集，当处理结束之后会回到PCB当中的阻塞信号集**\n- **信号发出之后不会立即处理，先进入未决信号集，变为1，然后去找对应的阻塞信号集，不阻塞则处理，并且修改未决信号集相应为0，当信号在处理过程当中如果未处理完毕这时候收到一个对应的新的信号，不会处理，而是先填入未决信号集，然后等待处理结束然后处理**\n- **如果查找阻塞信号集发现阻塞，则阻塞等待，这个时候如果收到新的信号，由于未决信号集相应位置都还是1，那么表示信号尚未被处理，新来的信号会被忽略，当然也不可能记录来了几个，到时候一起处理这种，因为只能存0 1，这也是忽略的原因**\n\n![image-20230724172117665](https://cdn.davidingplus.cn/images/2025/01/31/image-20230724172117665.png)\n\n#### SIGCHLD信号\n\n**顾名思义，这是子进程给父进程发送的信号**\n\n**产生的三种条件：**\n\n- **子进程终止**\n- **子进程收到SIGSTOP信号停止**\n- **子进程处在停止态，收到SIGCONT唤醒**\n\n**父进程接收到这个信号之后，默认处理是忽略这个信号**\n\n**如果我们能接受这个信号，然后去回收子进程的资源，因为wait()函数是阻塞的，父进程不可能一直等待子进程等待结束然后回收，那么可以捕捉子进程结束时候(当然还有其他两种情况)发出的SIGCHLD信号，然后父进程中断去处理这个事情，回收子进程，这样就很好的避免了僵尸进程的问题**\n\n![image-20230724173035421](https://cdn.davidingplus.cn/images/2025/01/31/image-20230724173035421.png)\n\n代码：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <signal.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n/*\n    SIGCHLD信号产生的三个条件\n    - 子进程结束\n    - 子进程暂停\n    - 子进程从暂停状态继续运行\n    都会给父进程发送该信号，父进程默认忽略该信号\n\n    可以使用SIGCHLD信号解决僵尸进程的问题\n\n*/\n\nvoid myFunc(int num) {\n    printf(\"捕捉到的信号 : %d\\n\", num);\n    // 回收子进程PCB的资源\n    // wait(nullptr);\n\n    while (1) {\n        int ret = waitpid(-1, nullptr, WNOHANG);\n        if (ret > 0) {\n            printf(\"chile die , pid = %d\\n\", getpid());\n        } else if (0 == ret)\n            // 说明还有子进程，这一次的循环捕捉回收没回收完毕\n            break;\n        else if (-1 == ret)\n            // 说明没有子进程了\n            break;\n    }\n}\n\nint main() {\n    // 创建子进程\n    pid_t pid;\n    for (int i = 0; i < 20; ++i) {\n        pid = fork();\n        if (0 == pid)\n            break;\n    }\n\n    if (pid > 0) {\n        // 父进程\n\n        // 提前设置好阻塞信号集，阻塞SIGCHLD，因为子进程可能很快结束，父进程还没注册好\n        sigset_t set;\n        sigemptyset(&set);\n        sigaddset(&set, SIGCHLD);\n        sigprocmask(SIG_BLOCK, &set, nullptr);\n\n        // 捕捉子进程死亡时发送的SIGCHLD信号\n        struct sigaction act;\n        act.sa_flags = 0;\n        act.sa_handler = myFunc;\n        sigemptyset(&act.sa_mask);\n\n        sigaction(SIGCHLD, &act, nullptr);\n\n        // 注册完信号捕捉之后解除阻塞\n        sigprocmask(SIG_UNBLOCK, &set, nullptr);\n\n        while (1) {\n            printf(\"parent process pid : %d\\n\", getpid());\n            sleep(2);\n        }\n    } else if (pid == 0) {\n        // 子进程\n        printf(\"child process pid : %d\\n\", getpid());\n        // sleep(1);\n    }\n\n    return 0;\n}\n~~~\n\n**由于我们对子进程的设置，在运行中20个子进程结束的时间非常接近，waitpid(-1,...)是能识别所有的子进程，但是一次只能清理一个，这些子进程的SIGCHLD信号发送到未决信号集这里，当然未决信号集只能接受一个并且填入，然后交给阻塞信号集，其他的丢弃，所以我们需要while()循环来释放这些几乎同时结束的子进程；之所以设置非阻塞是因为可能个别子进程因为自己的原因，没有和上面的匹配，所以我们设置非阻塞，那个时候这个进程完了发送信号然后父进程去处理，这个时候的未决信号集肯定是写入(0)的，因为如果不可以写入，那必然这个进程就是和前面是一样的了**\n\n### 共享内存(效率最高)\n\n#### 概念\n\n并不是完全没有内核介入，而是相比于其他通信的操作要少得多，因为没有经过内核和用户之间的切换操作或者说非常少，省去了这一大部分的时间，就是将数据从用户空间当中拷贝到内核当中的这一段时间，所以他的效率是最高的\n\n![image-20230724204226816](https://cdn.davidingplus.cn/images/2025/01/31/image-20230724204226816.png)\n\n#### 使用步骤\n\n创建共享内存，连接共享内存；分离，删除\n\n![image-20230725090718804](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725090718804.png)\n\n#### 相关函数\n\n![image-20230725091618011](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725091618011.png)\n\n记得查man文档，太多太杂了!!!\n\n~~~cpp\n\t#include <sys/shm.h>\n\n\tint shmget(key_t key, size_t size, int shmflg);\n// 作用：创建一个新的共享内存段或者获取一个既有的共享内存段的标识\n//     新创建的内存段中的数据都会被初始化为0\n// 参数：\n//     key：key_t类型，是一个整形，通过这个找到或者创建一个共享内存\n//         一般用16进制表示，并且是非0值，创建的时候可以随便给，给一个16进制的数或者10进制(会转化)，找到的时候按照创建时候匹配就行\n//     size：size_t类型，共享内存的大小，会自动调整为分页边界的整数倍(和内存映射是一样的)\n//     shmflg：\n//         共享内存的属性：用按位或连接\n//             - 访问权限\n//             - 附加属性(创建共享内存，判断共享内存是否存在，获取共享内存)\n\n//                 创建：IPC_CREAT 加上 访问权限(比如0664)\n//                 获取：IPC_CREAT(不加访问权限)\n//                 判断：IPC_EXCL，需要和IPC_CREAT一起使用，用按位或连接\n// 返回值：\n//     成功 >0 返回共享内存引用的ID，后面操作共享内存使用这个标识\n//     失败 -1.修改errno\n\n\tvoid *shmat(int shmid, const void *_Nullable shmaddr, int shmflg);\n// 作用：和当前的进程进行关联\n// 参数：\n//     shmid：共享内存的标识，ID，由shmget()返回值获取\n//     shmaddr：申请的共享内存的起始地址，指定为nullptr，让系统帮我们去分配\n//     shmflg：\n//         对共享内存的操作\n//             - 读：SHM_RDONLY，而且必须要有读权限\n//             - 读写：0，我们指定什么都不给，但是由于必须有读权限，系统会给我们加上读写的权限\n// 返回值：\n//     成功 返回共享内存的起始地址\n//     失败 (void*)-1\n\n\n\tint shmdt(const void *shmaddr);\n// 作用：解除当前进程和共享内存的关联\n// 参数：\n//     shmaddr：共享内存的首地址\n// 返回值：\n//     成功 0\n//     失败 -1，修改errno\n\n\tint shmctl(int shmid, int cmd, struct shmid_ds *buf);\n// 作用：对共享内存进行操作，比如可以删除，共享内存要删除才会消失；创建共享内存的进程被销毁了对这块共享内存没有任何影响，必须要手动删除才行\n// 参数：\n//     shmid：共享内存的id\n//     cmd：要做的操作\n//         IPC_STAT：获取共享内存当前的状态\n//         IPC_SET：设置共享内存的状态\n//         IPC_RMID：标记共享内存被销毁，之所以是标记是因为有很多个进程都连接了这个共享内存，我这一个进程并不能想删除就删除，而只是标记下来，当检测到连接数为0时，系统自会将这块共享内存删除\n//     buf：需要设置或者获取的共享内存的属性信息\n//         IPC_STAT：buf存储数据\n//         IPC_SET：buf中需要初始化数据，设置到内核中\n//         IPC_RMID：没有用，传递nullptr即可\n\n    #include <sys/ipc.h>\n\n    key_t ftok(const char *pathname, int proj_id);\n//作用：根据指定的路径名和int值，生成一个共享内存的key，我们可以不用自己指定\n//参数：\n    //pathname：指定一个存在的路径\n    //proj_id：int类型的值，但是这系统调用只会使用其中的一个字节(8位)\n        //返回：0-255，一般指定一个字符 'a'\n~~~\n\n#### 示例\n\n写两个程序进行通信\n\n~~~cpp\n//write.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#define _size 1024\n\nint main() {\n    // 创建共享内存\n    int shmid = shmget(100, 4096, 0664 | IPC_CREAT);\n    if (-1 == shmid) {\n        perror(\"shmget\");\n        return -1;\n    }\n    printf(\"shmid : %d\\n\", shmid);\n\n    // 和当前进程进行关联\n    void *ptr = shmat(shmid, nullptr, 0);\n    if ((void *)-1 == ptr) {\n        perror(\"shmat\");\n        return -1;\n    }\n\n    char str[_size] = {0};\n\n    printf(\"请输入写入的字符串: \");\n    fgets(str, sizeof(str), stdin);\n\n    // 写数据\n    memcpy(ptr, str, strlen(str) + 1);  // 为了保险，拷上字符串结束符\n\n    printf(\"按任意键继续\\n\");\n    getchar();\n\n    // 解除关联\n    int ret = shmdt(ptr);\n    if (-1 == ret) {\n        perror(\"shmdt\");\n        return -1;\n    }\n\n    // 删除共享内存\n    shmctl(shmid, IPC_RMID, nullptr);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n//read.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <sys/ipc.h>\n#include <sys/shm.h>\n\nint main() {\n    // 获得共享内存的标识，我们是用key标识的\n    int shmid = shmget(100, 4096, IPC_CREAT);\n    if (-1 == shmid) {\n        perror(\"shmget\");\n        return -1;\n    }\n    printf(\"shmid : %d\\n\", shmid);\n\n    // 绑定连接\n    void* ptr = shmat(shmid, nullptr, 0);\n    if ((void*)-1 == ptr) {\n        perror(\"shmat\");\n        return -1;\n    }\n\n    // 读数据\n    printf(\"data : %s\", (char*)ptr);\n\n    printf(\"按任意键继续\\n\");\n    getchar();\n\n    // 关闭关联\n    int ret = shmdt(ptr);\n    if (-1 == ret) {\n        perror(\"shmdt\");\n        return -1;\n    }\n\n    // 标记删除\n    shmctl(shmid, IPC_RMID, nullptr);\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230725102001298](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725102001298.png)\n\n![image-20230725102008328](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725102008328.png)\n\n#### 共享内存操作命令\n\n**注意，shmctl()执行的删除只是标记删除操作，执行到这一步后，这个共享内存的key修改为0，然后不再接受连接，其他程序再次执行shmctl()标记删除相当于什么也没做，但是可以执行不会报错，系统就监听其他进程对这个共享内存的解除连接操作，然后维护shm_nattach，记录关联数，当程序执行shmdt()手动解除或者程序结束的时候系统自动解除连接，当连接数为0之后系统就删除这块共享内存。之所以标记删除，是为了防止删除后还有其他进程在使用这块内存造成不必要的危险**\n\n![image-20230725104726840](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725104726840.png)\n\n#### 注意\n\n**问题1：操作系统如何知道一块共享内存被多少个进程关联？**\n\n- 共享内存维护了一个结构体 struct shmid_ds 这个结构体中有一个成员 shm_nattach\n- shm_nattach记录了关联的进程个数\n\n**问题2：可以不可以对共享内存多次删除 stmctl()**\n\n- 可以，因为shmctl()只是标记删除共享内存，不是直接删除\n- 什么时候真正删除，当和共享内存关联的进程数为0的时候，就真正被删除\n- 当共享内存的key为0的时候，表示共享内存被标记删除，如果进程取消关联就不能继续操作这个共享内存，这种情况下也不能再次关联\n\n**问题3：共享内存和内存映射的区别**\n\n- 共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外)\n- 共享内存效率更高\n- 内存：\n  - 共享内存：所有的进程操作的是同一块共享内存\n    - 内存映射：(父子进程除外)每个进程在自己的虚拟地址空间中有一个独立的内存\n- 数据安全\n  - 进程突然退出，共享内存还存在，内存映射消失了\n  - 运行进程的电脑死机了，数据存储在共享内存中就没有了，内存映射区的数据也没有了，但是他的数据已经同步给磁盘了\n- 生命周期\n  - 内存映射区：进程退出，内存映射区销毁\n  - 共享内存：进程退出，共享内存还在，标记删除(所有关联的进程数为0)，或者关机\n    如果进程退出，系统会自动和共享内存取消关联\n\n## 守护进程\n\n### 终端\n\n![image-20230725111929961](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725111929961.png)\n\n### 进程组\n\n![image-20230725112626809](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725112626809.png)\n\n### 会话\n\n![image-20230725113205286](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725113205286.png)\n\n### 理解关系举例\n\n![image-20230725113517970](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725113517970.png)\n\n### 操作函数\n\ngid：进程组id；sid：会话的id\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230725113838738.png\" alt=\"image-20230725113838738\" style=\"zoom: 67%;\" />\n\n### 守护进程(Daemon进程，精灵进程)\n\n**后台服务进程，是一个生存期较长的进程，一般采用以d结尾的名字**\n\n![image-20230725114051864](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725114051864.png)\n\n#### 创建步骤(!!!)\n\n**必须有的是的是前两步和最后一步**\n\n**首先为什么要用子进程来创建会话，因为如果是父进程创建会话的话，一旦父进程是这个进程组的首进程，进程组号就是父进程的id，然后创建会话之后新会话中创建出来的进程组号也用的是这个，两个不同会话中存在同一个进程组号，这个显然是不可以的，所以我们用子进程创建，就避免了这个问题；然后父进程退出一是为了保证不出现僵尸进程(这是孤儿进程没有什么危险)，而是避免子进程运行着时候父进程完了然后输出终端提示符，就是如下(突然冒出来很诡异)**\n\n![image-20230725150200682](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725150200682.png)\n\n**第二，为什么要创建一个新会话？因为如果不是新创建而是挪入其他的会话或者就用自身的会话，那么可能这个会话绑定了控制终端，能够接受信号处理信号这些，这显然与守护进程的初衷不符，所以我们要创建一个新会话，新会话默认是不绑定控制终端的，但是不代表没有终端，至少文件描述符012，标准输入输出错误是有的，言下之意就是可以向屏幕上输出数据，所以这就有了下面关闭文件描述符，然后重定向到 dev/null 的操作，当然这一步也不是必须的**\n\n![image-20230725114544913](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725114544913.png)\n\n##### 示例\n\n写一个守护进程，用来每两秒记录一次当前的时间并写到文本当中\n\n**就严格按照这几步来，创建子进程，子进程创建会话，设置umask(不必要)，设置工作目录(不必要)，关闭从父进程继承而来的文件描述符(不必要，这里没有)，重定向文件描述符(不必要，这里有)，核心业务逻辑(设置定时器，捕捉信号)**\n\n~~~cpp\n#include <cstring>\n#include <ctime>\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <signal.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n// 写一个守护进程，每隔两秒获取系统时间，将这个时间写到磁盘文件中\n\nvoid _deal(int num) {\n    // 获取系统时间写入磁盘文件\n    time_t _time = time(nullptr);\n    // 将time()获得的距离计算机元年(1970-1-1 00:00:00)的秒数转化为当前的时间\n    struct tm* _localtime = localtime(&_time);\n\n    const char* str = asctime(_localtime);\n    // 如果不存在则创建，存在则追加\n    int ret = access(\"time.txt\", F_OK);\n    int fd = -1;\n    if (-1 == ret)\n        // 不存在\n        fd = open(\"time.txt\", O_RDWR | O_CREAT, 0664);\n    else if (0 == ret)\n        // 存在\n        fd = open(\"time.txt\", O_RDWR | O_APPEND);\n    if (-1 == fd) {\n        perror(\"open\");\n        exit(-1);\n    }\n\n    ret = write(fd, str, strlen(str));\n    if (-1 == ret) {\n        perror(\"write\");\n        exit(-1);\n    }\n}\n\nint main() {\n    // 创建子进程，退出父进程\n    pid_t pid = fork();\n    if (-1 == pid) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid > 0)\n        // 父进程\n        return 0;\n    else if (0 == pid) {\n        // 子进程\n\n        // 如果存在time.txt，将其删除，准备工作\n        int ret = access(\"time.txt\", F_OK);\n        if (0 == ret)\n            unlink(\"time.txt\");\n\n        // 在子进程中重新创建一个会话，脱离原来的控制终端\n        pid_t sid = setsid();\n        if (-1 == pid) {\n            perror(\"setsid\");\n            return -1;\n        }\n\n        // 设置umask\n        umask(022);\n\n        // 更改工作目录\n        chdir(\"/mnt/d/Code/Cpp/深入学习/Linux方向/牛客网Linux网络课程/第2章-多进程开发/13\");\n\n        // 关闭，以及重定向文件描述符\n        int fd = open(\"/dev/null\", O_RDWR);\n        dup2(fd, STDIN_FILENO);\n        dup2(fd, STDOUT_FILENO);\n        dup2(fd, STDERR_FILENO);\n\n        // 业务逻辑\n\n        // 注册信号捕捉器\n        struct sigaction _act;\n        _act.sa_flags = 0;\n        _act.sa_handler = _deal;\n        sigemptyset(&_act.sa_mask);\n        sigaction(SIGALRM, &_act, nullptr);\n\n        // 创建定时器\n        itimerval _new;\n        // 延迟时间\n        _new.it_interval.tv_sec = 2;\n        _new.it_interval.tv_usec = 0;\n        // 周期时间\n        _new.it_value.tv_sec = 2;\n        _new.it_value.tv_usec = 0;\n\n        ret = setitimer(ITIMER_REAL, &_new, nullptr);\n        if (-1 == ret) {\n            perror(\"setitimer\");\n            return -1;\n        }\n\n        // 不让进程结束，不然无法记录\n        while (1)\n            sleep(10);\n    }\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230725162229689.png\" alt=\"image-20230725162229689\" style=\"zoom:67%;\" />\n\n并且从文件大小不断变化可以看出是实时更新的\n\n![image-20230725162327872](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725162327872.png)\n\n守护进程没有控制终端，所以没有办法接受控制终端发出的信号(例如SIGINT( ctrl+c )和SIGQUIT( ctrl+\\ ) )，我们只能通过kill -9 强制杀死\n\n![image-20230725162413359](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725162413359.png)\n\n# 第三章 Linux多线程开发\n\n## 概述\n\n### 概念\n\n**同一个程序的所有线程均会执行相同程序，并且会共享同一份全局内存区域**\n\n**进程是资源持有的最小单位，线程是操作系统分配和调度的最小单位**\n\n**线程是轻量级的进程(LWP)，在Linux下线程的本质仍是进程**\n\n![image-20230725162732120](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725162732120.png)\n\n查看指定进程的LWP号\n\n例如这里打开firefox进程，它的内部是多线程实现的\n\n![image-20230725163508676](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725163508676.png)\n\n我们用命令查看，图中进程号是105266\n\n~~~shell\nps -LF 105266\n~~~\n\n结果：\n\n可以看出，firefox进程的这么多线程，虽然进程号都是一样的，但是线程号是不一样的\n\n![image-20230725163632242](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725163632242.png)\n\n### 进程和线程区别\n\n**进程之间的信息难以共享，想要共享需要采取进程间通信的方式；并且fork()代价比较高**\n\n**线程之间能够方便，快速的共享信息，只需要将数据复制到共享(全局或堆)变量中即可**\n\n**创建线程的速率比进程通常快很多，10倍甚至更多；线程之间共享虚拟地址空间，无序采取写时复制的方式复制内存，也无须复制页表**\n\n![image-20230725164029090](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725164029090.png)\n\n我们画个图来理解一下\n\n**虽然线程是共享虚拟地址空间的，但不代表空间中所有的区域都是共享的，比如下面的栈空间和.text代码段就不共享**\n\n**.text是代码段，这个线程是不共享的，而是划分出自己的一块区域**\n\n**栈空间也是不共享的，各个线程将这一块栈空间划分出自己的一块区域**\n\n![image-20230725203244279](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725203244279.png)\n\n### 线程的共享和非共享资源\n\n- **用户区中，虚拟地址空间除了栈和代码段不共享，其他共享；剩余的都是内核区的数据，这些是共享的，没有复制操作**\n- **非共享资源：线程ID，信号掩码(阻塞信号集)，线程特有的数据，errno变量，实时调度策略和优先级；栈，本地变量和函数调用链接信息**\n\n![image-20230725201723897](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725201723897.png)\n\n## 线程操作\n\n![image-20230726174153972](https://cdn.davidingplus.cn/images/2025/01/31/image-20230726174153972.png)\n\n### 创建线程 pthead_create()\n\n注意返回值与进程那一套有区别，还有错误号也有区别了\n\n~~~cpp\n//\t   一般情况下，main函数所在的线程称为主线程(main线程)，其余创建的线程称为子线程\n//     程序中默认只有一个进程，fork()函数调用，变为2个进程\n//     程序中默认只有一个线程，pthread_create()调用，变为2个线程\n\n    #include <pthread.h>\n\n    int pthread_create(pthread_t *restrict thread,\n                     const pthread_attr_t *restrict attr,\n                     void *(*start_routine)(void *),\n                     void *restrict arg);\n// 作用：创建一个子线程\n// 参数：\n//     thread：类型是pthread_t指针，传出参数，线程创建成功后，子线程的线程ID被写到在变量中\n//     attr：设置线程的属性，一般使用默认值，传递nullptr\n//     start_routine：函数指针，这个函数是子线程需要处理的逻辑代码\n//     arg：给第三个参数使用，传参\n// 返回值：\n//     成功 0\n//     失败 返回一个错误号，这个错误号和之前的errno不太一样(实现方式一样，但是含义不同)\n//         不能通过perror()去获取错误号信息\n//         如何获取？ char* strerror(int errnum);\n~~~\n\n代码\n\n**这个代码只需要注意一点，就是主线程和子线程执行的区域是不一样的，主线程执行main函数里面的内容，然后创建出了子线程，子线程的代码段当中执行call_back()回调函数里面的逻辑，他的范围就局限于这个回调函数，参数可以通过主线程传递给他，这就是也是为什么线程之间代码段和栈空间的内容不是共享的，因为这样设计下来就没法共享了**\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\n// 主线程和子线程执行的代码段是不一样的，这个回调函数里面是子线程执行的代码逻辑\nvoid* call_back(void* args) {\n    printf(\"child thread...\\n\");\n    printf(\"arg value : %d\\n\", *(int*)args);\n\n    return nullptr;\n}\n\n// main函数里面是主线程执行的逻辑\nint main() {\n    // 创建一个子线程\n    pthread_t tid;\n\n    int num = 10;\n\n    int ret = pthread_create(&tid, nullptr, call_back, (void*)&num);\n    if (0 != ret) {\n        const char* _error = strerror(ret);\n        printf(\"error : %s\\n\", _error);\n        return -1;\n    }\n\n    for (int i = 0; i < 5; ++i)\n        printf(\"%d\\n\", i);\n\n    sleep(1);  // 保证子线程万一没有创建好主线程就执行完了\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n**注意编译要链接上pthread动态库，文件名是libpthread.so，库名字是pthread，用 -l 参数链接**\n\n![image-20230725212001708](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725212001708.png)\n\n当然，由于主线程和子线程是并发的关系，很有可能执行结果不一样\n\n![image-20230725212124179](https://cdn.davidingplus.cn/images/2025/01/31/image-20230725212124179.png)\n\n### 终止线程 pthread_exit()\n\n~~~cpp\n\t#include <pthread.h>\n\n\tvoid pthread_exit(void *retval);\n// 作用：终止一个线程，在哪个线程中调用，就表示终止哪个线程\n// 参数：\n//     retval：需要传递一个指针，作为一个返回值，可以在pthread_join()中获取到\n\n\tpthread_t pthread_self(void);\n// 作用：获取当前线程的线程id(unsigned long int 无符号长整形)\n\n\tint pthread_equal(pthread_t t1.pthread_t t1);\n// 作用：比较两个线程id是否相等\n//     不同的操作系统对于 pthread_t 的实现不一样，有的是无符号的长整型，有的是用结构体去实现的，不能简单的用 == 号判断\n~~~\n\n代码：\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\nvoid* call_back(void* arg) {\n    // 为了测试pthread_exit()会不会影响其他线程的正常运行，这里睡三秒，让主线程跑完\n    sleep(3);\n    printf(\"child thread id : %ld\\n\", pthread_self());\n\n    // 这里两个对等是因为子线程结束并不决定整个进程的结束，主线程 return 0 就代表进程结束退出，子线程则不一样\n    return nullptr;  // pthread_exit(nullptr)\n}\n\nint main() {\n    // 创建一个子线程\n    pthread_t tid;\n\n    int ret = pthread_create(&tid, nullptr, call_back, nullptr);\n    if (0 != ret) {\n        const char* str = strerror(ret);\n        printf(\"error : %s\\n\", str);\n        return -1;\n    }\n\n    // 主线程\n    for (int i = 0; i < 5; ++i)\n        printf(\"%d\\n\", i);\n\n    printf(\"tid : %ld , parent thread id : %ld\\n\", tid, pthread_self());\n\n    // 让主线程退出，当主线程退出的时候不会影响其他正常运行的线程\n    pthread_exit(nullptr);\n\n    // 这一行代码没有执行，说明主线程退出后执行return 0结束掉整个进程；而是当所有线程跑完进程才结束，因此不会对其他的线程产生影响\n    printf(\"main thread exit.\\n\");\n\n    return 0;\n}\n~~~\n\n**注意对pthread_exit()的理解：**\n\n- **线程退出和线程结束的含义是不同的，线程退出不会影响其他的线程，特别是主线程，线程结束对于主线程而言就会导致整个进程结束了，程序结束，而主线程退出则不会**\n- **主线程调用这个函数，意思是主线程退出，但是不走后面的代码，比如图中后面一句的打印就不走，也不会 return 0，因为在主线程中 return 0 就会导致整个进程的结束，所以这时进程不会结束，子线程可以尽情的运行，知道均运行完毕，然后整个进程结束**\n- **子线程的执行函数逻辑当中，最后返回，例如 return nullptr，也相当于pthread_exit()，因为子线程退出不会对整个进程造成退出的影响，所以没有什么区别；所以子线程退出和子线程结束基本没有区别**\n\n### 连接已终止的线程 pthread_join()\n\n~~~cpp\n\t#include <pthread.h>\n\n\tint pthread_join(pthread_t thread, void **retval);\n// 作用：和一个已经终止的线程进行连接\n//     说白了就是回收子线程的资源，防止产生僵尸线程\n//     这个函数是阻塞函数，调用一次只能回收一个子线程\n//     一般在主线程中去使用(父线程回收子线程的资源)\n// 参数：\n//     thread：需要回收的子线程id\n//     retval：接受子线程退出时的返回值，是个二级指针；如果不需要则传递nullptr\n// 返回值：\n//     成功 0\n//     失败 返回错误号(用strerror())\n~~~\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\nint value = 10;\n\nvoid* call_back(void* arg) {\n    // 为了测试pthread_exit()会不会影响其他线程的正常运行，这里睡三秒，让主线程跑完\n    printf(\"child thread id : %ld\\n\", pthread_self());\n    sleep(3);\n\n    // 这里两个对等是因为子线程结束并不决定整个进程的结束，主线程 return 0 就代表进程结束退出，子线程则不一样\n    // 这里给一个返回值\n    // int value = 10;               // 局部变量，这是存在于自己的栈空间当中，子线程结束之后就被释放，所以主线程无法接收到；一般用全局变量或者堆空间的数据\n    pthread_exit((void*)&value);  // return (void*)&value;\n}\n\nint main() {\n    // 创建一个子线程\n    pthread_t tid;\n\n    int ret = pthread_create(&tid, nullptr, call_back, nullptr);\n    if (0 != ret) {\n        const char* str = strerror(ret);\n        printf(\"error : %s\\n\", str);\n        return -1;\n    }\n\n    // 主线程\n    for (int i = 0; i < 5; ++i)\n        printf(\"%d\\n\", i);\n\n    printf(\"tid : %ld , parent thread id : %ld\\n\", tid, pthread_self());\n\n    // 主线程调用pthread_join()去回收子线程资源\n    // 这里可以选择接受子线程执行的返回值也可以选择不要，不要就传递nullptr\n    // 为什么是二级指针？返回值是一级指针，我要传递他的指针做传出参数才能接受到!!!\n    int* thread_retval;\n    // ret = pthread_join(tid, nullptr);\n    ret = pthread_join(tid, (void**)&thread_retval);\n    if (0 != ret) {\n        const char* str = strerror(ret);\n        printf(\"error : %s\\n\", str);\n        return -1;\n    }\n\n    printf(\"exit data : %d\\n\", *thread_retval);\n\n    printf(\"回收子线程资源成功\\n\");  // 这一行代码会在回收子线程之后结束\n\n    // 由于子线程已经结束，主线程已经回收完了所有的资源，所以不用担心主线程结束会导致进程结束子线程没跑完的问题了\n    // 所以这一行有无没有区别，有下面一行执行不了，没有下面一行会执行\n    pthread_exit(nullptr);\n\n    printf(\"main thread exit.\\n\");\n\n    return 0;\n}\n~~~\n\n注意几点：\n\n- pthread_join(pthread_t thread, void **retval)，第一个参数是需要回收的线程id，第二个参数可以选择接受该子线程的执行的回调函数的返回值，注意类型是二级指针，不需要接受则传递nullptr\n\n  那为什么要传递二级指针呢？就是传出参数的含义了，因为回调函数返回的是void*一级指针类型，我们要想通过传入的参数让系统帮我们修改不能return by value，只能return by pointer或者return by reference，这样才能正确修改，所以需要传入的是二级指针\n\n- ![image-20230727111343535](https://cdn.davidingplus.cn/images/2025/01/31/image-20230727111343535.png)\n\ncall_back()函数里面的返回的变量不能是局部变量，也就是放在栈上面的，因为线程之间非常重要的两个不共享的东西就是栈空间和.text代码段，栈空间里面的变量在子线程结束后就会释放掉，所以如果要传递的话最好选择全局变量。堆空间虽然也是共享的，但是可能有问题(不管是全局堆还是局部堆)，虽然空间是公用的，但是好像其他线程一是没有办法free()这个数据，二是我测试过好像不行，我也不知道为什么。所以建议就用全局变量\n\n### 线程的分离 pthread_detach()\n\n~~~cpp\n\t#include <pthread.h>\n\n\tint pthread_detach(pthread_t thread);\n// 作用：分离一个线程，被分离的线程在终止的时候会自动释放资源返回给系统\n//     - 不能多次分离，会产生不可预期的结果\n//     - 不能去连接(join)一个已经分离的线程，如果操作了会报错(会自动释放资源)\n// 参数：需要分离的线程id\n// 返回值：\n//     成功 0\n//     失败 错误号\n~~~\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n\nvoid* call_back(void* arg) {\n    printf(\"child thread id : %ld\\n\", pthread_self());\n\n    return nullptr;\n}\n\nint main() {\n    // 创建一个线程\n    pthread_t tid;\n    int ret = pthread_create(&tid, nullptr, call_back, nullptr);\n    if (0 != ret) {\n        const char* errstr = strerror(ret);\n        printf(\"error pthread_create : %s\\n\", errstr);\n        return -1;\n    }\n\n    // 输出主线程和子线程的id\n    printf(\"tid : %ld , main thread id : %ld\\n\", tid, pthread_self());\n\n    // 设置子线程分离，子线程分离后，结束时候对应的资源就不需要主线程手动回收了\n    ret = pthread_detach(tid);\n    if (0 != ret) {\n        const char* errstr = strerror(ret);\n        printf(\"error pthread_detach : %s\\n\", errstr);\n        return -1;\n    }\n\n    // 设置分离后，对分离的子线程进行连接，我偏要手动释放，程序执行结果就会报错\n    // ret = pthread_join(tid, nullptr);\n    // if (0 != ret) {\n    //     const char* errstr = strerror(ret);\n    //     printf(\"error pthread_join : %s\\n\", errstr);\n    //     return -1;\n    // }\n\n    // 退出主线程防止主线程结束导致进程结束导致程序结束\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n设置子线程分离后就不能再去连接子线程手动释放他的资源了，因为系统会自动将他的资源给释放掉，不用我们操心\n\n如果强行加上的话pthread_join()的返回值就会是个错误号了，但是Linux本身并未对他进行处理，没有发出信号说错误什么什么的，这就需要我们自己进行严谨的判断了，加上的话ret是个错误号，然后就会获取到错误信息，如下：\n\n![image-20230727114257371](https://cdn.davidingplus.cn/images/2025/01/31/image-20230727114257371.png)\n\n因此不能手动释放(连接 join)已经分离的线程\n\n### 线程取消 pthread_cancel()\n\n**执行线程取消后，子进程不是立马退出的，而是执行到了某个取消点，线程才会终止**\n\n**取消点就是系统设置好的一些系统调用(比如printf()就是之一)，可以粗略的理解为从用户区到内核区的切换**\n\n~~~cpp\n\t#include <pthread.h>\n\n    int pthread_cancel(pthread_t thread);\n// 作用：取消线程，让线程终止；底层的执行是发送一个取消的请求给线程(有可能是信号)，取消(终止)线程是要执行到某个条件点才能终止\n// 取消某个线程可以终止某个线程的运行，但是并不是立马终止，而是执行到了一个取消点，线程才会终止\n// 取消点：系统规定好的一些系统调用(比如就有printf())，我们可以粗略的理解为从用户区到内核区的切换，这个位置称之为取消点\n~~~\n\n~~~cpp\n#include <pthread.h>\n#include <unistd.h>\nusing namespace std;\n#include <cstring>\n#include <iostream>\n\nvoid* call_back(void* arg) {\n    printf(\"child thread id : %ld\\n\", pthread_self());\n\n    for (int i = 0; i < 5; ++i)\n        printf(\"child : %d\\n\", i);\n\n    return nullptr;\n}\n\nint main() {\n    // 创建一个线程\n    pthread_t tid;\n    int ret = pthread_create(&tid, nullptr, call_back, nullptr);\n    if (0 != ret) {\n        const char* errstr = strerror(ret);\n        printf(\"error pthread_create : %s\\n\", errstr);\n        return -1;\n    }\n\n    // 取消线程\n    pthread_cancel(tid);\n\n    for (int i = 0; i < 5; ++i)\n        printf(\"%d\\n\", i);\n\n    // 输出主线程和子线程的id\n    printf(\"tid : %ld , main thread id : %ld\\n\", tid, pthread_self());\n\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n输出的结果每次可能都是不一样的，因为主线程和子线程运行的顺序可能不同，所以执行到的取消点位置也可能不同，所以很可能输出的结果是不一样的，比如下面：\n\n![image-20230731101134205](https://cdn.davidingplus.cn/images/2025/01/31/image-20230731101134205.png)\n\n## 线程属性\n\n![image-20230731101232100](https://cdn.davidingplus.cn/images/2025/01/31/image-20230731101232100.png)\n\n注意：线程的属性不只这一个，还有很多其他的，如下，都可以由我们自己去设置：\n\n![image-20230731103140397](https://cdn.davidingplus.cn/images/2025/01/31/image-20230731103140397.png)\n\n~~~cpp\n    #include <pthread.h>\n\n    int pthread_attr_init(pthread_attr_t *attr);\n// 作用：初始化线程属性变量\n\n    int pthread_attr_destroy(pthread_attr_t *attr);\n// 作用：释放线程属性资源\n\n    int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);\n// 作用：获取线程分离的状态属性\n\n    int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);\n// 作用：设置线程分离的状态属性\n~~~\n\n~~~cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\nvoid* call_back(void* arg) {\n    printf(\"child thread id : %ld\\n\", pthread_self());\n\n    return nullptr;\n}\n\nint main() {\n    // 创建一个线程属性变量\n    pthread_attr_t attr;\n    // 初始化属性变量\n    pthread_attr_init(&attr);\n    // 设置属性\n    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);  // 表示设置了线程分离\n\n    // 获取线程栈的大小\n    size_t _size;\n\n    pthread_attr_getstacksize(&attr, &_size);\n    printf(\"thread stack size : %ld\\n\", _size);\n\n    // 创建一个线程\n    pthread_t tid;\n    int ret = pthread_create(&tid, &attr, call_back, nullptr);  // 这里第二个参数，表示线程属性就需要传递进来了\n    if (0 != ret) {\n        const char* errstr = strerror(ret);\n        printf(\"error pthread_create : %s\\n\", errstr);\n        return -1;\n    }\n\n    // 输出主线程和子线程的id\n    printf(\"tid : %ld , main thread id : %ld\\n\", tid, pthread_self());\n\n    // 释放线程属性资源，初始化了必要释放!!!\n    pthread_attr_destroy(&attr);\n\n    // 退出主线程防止主线程结束导致进程结束导致程序结束\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n在代码中注意两点：\n\n- **线程属性结构体初始化(init)之后就必须要释放(destroy)**\n- **一般来说主线程和子线程的释放可以有两种方法来写：一是主线程调用pthread_join()手动阻塞回收子线程资源，这个时候就不用考虑子线程结束了主线程还没结束没办法回收资源的问题，当然我们不能让pthread_join()前面的逻辑执行太久，这样僵尸线程的存在时间可能会太长，和没有处理几乎是一样的；二是主线程将子线程分离pthread_detach()，这样主线程就不用去管子线程的释放问题了，但是这样最好在末尾加上pthread_exit()让主线程退出，否则很可能主线程执行完了导致进程结束然后子线程跑不完，主线程退出恰好就解决了这个问题**\n\n## 线程同步\n\n### 示例引入\n\n写一个主线程，创建三个子线程，三个子线程的任务是共同售卖100张门票\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\n// 使用多线程去实现卖票的案例\n// 有3个窗口，一共100张票\n\n// 全局变量，但是还是有问题\nint tickets = 100;\n\nvoid* CALLBACK_sell(void* arg) {\n    while (tickets > 0) {\n        usleep(8000);\n        printf(\"pthread tid %ld is selling ticket %d\\n\", pthread_self(), tickets);\n        --tickets;\n    }\n\n    return nullptr;\n}\n\nint main() {\n    // 创建子线程\n    pthread_t tid1, tid2, tid3;\n\n    pthread_create(&tid1, nullptr, CALLBACK_sell, nullptr);\n    pthread_create(&tid2, nullptr, CALLBACK_sell, nullptr);\n    pthread_create(&tid3, nullptr, CALLBACK_sell, nullptr);\n\n    // 分离线程\n    pthread_detach(tid1);\n    pthread_detach(tid2);\n    pthread_detach(tid3);\n\n    // 主线程退出\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n在代码当中我使用了全局变量tickets，来让三个线程进行共享对他进行处理，但是想法是很美好的，现实却不美好\n\n![image-20230731143537103](https://cdn.davidingplus.cn/images/2025/01/31/image-20230731143537103.png)\n\n图中有两个问题，一是7号票三个线程卖了三次；二是线程卖了0号和-1号票，这如果对于实际的问题将会是毁灭性的打击\n\n- **我们先来看为什么会卖三次？**\n\n**谁想如下情形：三个线程ABC，线程A这时候抢占到了CPU，然后睡眠；在睡眠的时候线程B和C进来抢占了CPU，然后睡眠，如果这个时候B先拿到CPU打印这一句，但是还没来得及 --ticket ，就被C抢占了，C也打印同样的ticket，然后来不及--又被A抢占了，所以这个时候就会出现三个线程卖同一张票的情况**\n\n- **那么用类似的思路我们去看为什么会卖出0和-1**\n\n**图样的事情，三个线程同时在 ticket == 1 的时候进来然后睡眠，然后A线程进来执行打印和 --ticket 两句，这个时候ticket变成0，B线程同样执行这两句，但是这个时候打印的ticket是0，C线程同理，只不过这个时候打印的是-1**\n\n**总结一下，这就是没有加访问互斥锁的原因，对共享数据的处理没有加锁导致几个线程同时对数据进行处理，这样数据的更新时机和读取时间一旦不恰当，就很有可能出现数据不同步的问题，这对于要求精确的项目是毁灭性的打击**\n\n### 概述\n\n**临界区是访问一个共享资源的代码片段，并且对该代码进行原子操作，原子操作在执行的过程中不能被中断，必须要执行完毕才能被其他线程占用访问临界区资源**\n\n线程同步就是让一个线程在内存进行操作的时候，其他线程都不允许对这个内存资源进行访问，只有该线程完成操作，其他线程才能对该内存地址进行操作，在执行的过程中其他线程位于阻塞等待状态\n\n![image-20230731154000837](https://cdn.davidingplus.cn/images/2025/01/31/image-20230731154000837.png)\n\n### 互斥锁\n\n所以访问共享资源的时候，为了避免线程更新共享变量的时候出现问题，需要使用互斥锁mutex来对访问进行限制，访问的时候线程给这个共享资源加上互斥锁，其他线程不能试图在加锁的时候对该资源进行访问或者尝试解锁，只有所有者才能给互斥量解锁\n\n![image-20230731161340736](https://cdn.davidingplus.cn/images/2025/01/31/image-20230731161340736.png)\n\n加了互斥锁之后，现在的访问过程就是这样了：\n\n![image-20230801145448245](https://cdn.davidingplus.cn/images/2025/01/31/image-20230801145448245.png)\n\n#### 相关函数\n\n![image-20230801145628830](https://cdn.davidingplus.cn/images/2025/01/31/image-20230801145628830.png)\n\n#### 示例修改(!!!)\n\n回到之前哪个卖票的例子，现在我加上互斥锁，如下：\n\n互斥量必须是全局的，如果是局部的，线程之间没有办法共享这个互斥量，则会导致有问题\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\n// 全局变量，但是还是有问题\nint tickets = 100;\n// 全局互斥量\npthread_mutex_t mutex;\n\nvoid* CALLBACK_sell(void* arg) {\n    // 加锁\n    pthread_mutex_lock(&mutex);\n\n    // 临界区\n    while (tickets > 0) {\n        usleep(8000);\n        printf(\"pthread tid %ld is selling ticket %d\\n\", pthread_self(), tickets);\n        --tickets;\n    }\n\n    // 解锁\n    pthread_mutex_unlock(&mutex);\n\n    return nullptr;\n}\n\nint main() {\n    // 初始化互斥量，必须是全局的\n    pthread_mutex_init(&mutex, nullptr);\n\n    // 创建子线程\n    pthread_t tid1, tid2, tid3;\n\n    pthread_create(&tid1, nullptr, CALLBACK_sell, nullptr);\n    pthread_create(&tid2, nullptr, CALLBACK_sell, nullptr);\n    pthread_create(&tid3, nullptr, CALLBACK_sell, nullptr);\n\n    // 阻塞等待回收线程\n    pthread_join(tid1, nullptr);\n    pthread_join(tid2, nullptr);\n    pthread_join(tid3, nullptr);\n\n    // 释放互斥量资源\n    pthread_mutex_destroy(&mutex);\n\n    return 0;\n}\n~~~\n\n这段代码实际上还是有问题的，我们来看输出结果：\n\n我们发现所有的票都是由一个线程卖出的，我们从代码中查看是为什么\n\n![image-20230802144136067](https://cdn.davidingplus.cn/images/2025/01/31/image-20230802144136067.png)\n\n来看我们进行加锁的这段逻辑：\n\n我们发现如果A线程上了锁，那么他就进入了while()循环，在这个while()循环结束之前是没有办法被其他线程加锁访问的，所以就导致了所有的票都是由一个线程去卖的，这显然不符合我们的预期\n\n~~~cpp\nvoid* CALLBACK_sell(void* arg) {\n    // 加锁\n    pthread_mutex_lock(&mutex);\n\n    // 临界区\n    while (tickets > 0) {\n        usleep(8000);\n        printf(\"pthread tid %ld is selling ticket %d\\n\", pthread_self(), tickets);\n        --tickets;\n    }\n\n    // 解锁\n    pthread_mutex_unlock(&mutex);\n\n    return nullptr;\n}\n~~~\n\n所以我们这里得到一个启发，就是加锁要加在while()循环里面\n\n所以我们的代码这么修改：\n\n在while(1)循环里面要开始访问临界区的时候，然后跳出循环的条件是卖完了，其他线程可以在上一张票卖完准备跳到下一张票中间没有互斥锁保护的循环过渡期进行抢占 或者 时间片用完进行抢占\n\n~~~cpp\nvoid* CALLBACK_sell(void* arg) {\n    // 临界区\n    while (1) {\n        // 加锁\n        pthread_mutex_lock(&mutex);\n\n        if (tickets > 0) {\n            usleep(5000);\n            printf(\"pthread tid %ld is selling ticket %d\\n\", pthread_self(), tickets);\n            --tickets;\n        } else {\n            // 卖完了\n            pthread_mutex_unlock(&mutex);\n            break;\n        }\n        // 解锁\n        pthread_mutex_unlock(&mutex);\n    }\n\n    return nullptr;\n}\n~~~\n\n但是我们的输出结果是：\n\n还是只有一个人在卖，为什么呢？\n\n我们观察发现，我们卖完票睡眠了一段时间，这段时间肯定是比CPU的时间片要大的，并且线程A在休眠的过程中还是被加锁保护了的，除非这段时间小于时间片，系统才会把CPU给他，但是没有，所以往返而来就是一个线程在卖\n\n![image-20230802145837448](https://cdn.davidingplus.cn/images/2025/01/31/image-20230802145837448.png)\n\n所以我们可以把睡眠去掉再来看\n\n~~~cpp\nvoid* CALLBACK_sell(void* arg) {\n    // 临界区\n    while (1) {\n        // 加锁\n        pthread_mutex_lock(&mutex);\n\n        if (tickets > 0) {\n            // usleep(5000);\n            printf(\"pthread tid %ld is selling ticket %d\\n\", pthread_self(), tickets);\n            --tickets;\n        } else {\n            // 卖完了\n            pthread_mutex_unlock(&mutex);\n            break;\n        }\n        // 解锁\n        pthread_mutex_unlock(&mutex);\n    }\n\n    return nullptr;\n}\n~~~\n\n执行结果为：\n\n可以看出的确线程是交替来卖票的，只不过时间片完了被其他线程进行抢占，然后交替卖票\n\n并且由于我们的设计是while(1)死循环，跳出的点是票卖完了，所以我们的线程可以进行第二轮的卖票，而不是卖了一轮就结束\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230802150151733.png\" alt=\"image-20230802150151733\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230802150219200.png\" alt=\"image-20230802150219200\" style=\"zoom:67%;\" />\n\n### 死锁\n\n死锁可能产生的几种场景：\n\n- **忘记释放锁**\n- **重复加锁**\n- **多线程多锁，抢占锁资源**\n\n死锁产生的四个必要条件(缺一不可):\n\n- **互斥**\n- **非剥夺**\n- **请求和保持**\n- **环路等待**\n\n![image-20230803135330646](https://cdn.davidingplus.cn/images/2025/01/31/image-20230803135330646.png)\n\n我们来看死锁产生的几种情景：\n\n- 忘记释放锁：很显然，一个线程访问临界区的时候加上锁，访问完毕走的时候忘了解锁，这样其他的线程没办法加锁，更没办法访问了，自己第二次过来想继续加锁访问也是不可以的，因为上一把锁还没解开\n\n  ~~~cpp\n  void* CALLBACK_sell(void* arg) {\n      // 临界区\n      while (1) {\n          // 加锁\n          pthread_mutex_lock(&mutex);\n  \n          if (tickets > 0) {\n              // usleep(5000);\n              printf(\"pthread tid %ld is selling ticket %d\\n\", pthread_self(), tickets);\n              --tickets;\n          } else {\n              // 卖完了\n              pthread_mutex_unlock(&mutex);\n              break;\n          }\n          // 解锁\n          // pthread_mutex_unlock(&mutex);\n      }\n  \n      return nullptr;\n  }\n  ~~~\n\n  ![image-20230803143045431](https://cdn.davidingplus.cn/images/2025/01/31/image-20230803143045431.png)\n\n- 重复加相同的锁：设想一个我们写代码的时候应该不会犯的错误，就是在我要加锁的时候，我加了两次，第一把锁能够加上，但是第二把是加不上的，因为第一把锁还没加开，所以自己没办法访问，显然其他的线程更没办法访问了；但是我们一般不会犯这么傻的错误，我们可能加了锁之后去调用其他的函数，然后其他的函数当中存在加锁，这样显然就出现了上面的情况，然而这样的话我们不易察觉\n\n  ~~~cpp\n  void* CALLBACK_sell(void* arg) {\n      // 临界区\n      while (1) {\n          // 加锁\n          // 这里对同一把锁加了两次\n          pthread_mutex_lock(&mutex);\n          pthread_mutex_lock(&mutex);\n  \n          if (tickets > 0) {\n              // usleep(5000);\n              printf(\"pthread tid %ld is selling ticket %d\\n\", pthread_self(), tickets);\n              --tickets;\n          } else {\n              // 卖完了\n              pthread_mutex_unlock(&mutex);\n              break;\n          }\n          // 解锁\n          pthread_mutex_unlock(&mutex);\n          pthread_mutex_unlock(&mutex);\n      }\n  \n      return nullptr;\n  }\n  ~~~\n\n  ![image-20230803143334595](https://cdn.davidingplus.cn/images/2025/01/31/image-20230803143334595.png)\n\n- 多线程多锁，抢占锁资源：看图中，线程A和线程B分别给资源1和资源2加锁，但是线程的执行依赖于这两个资源的共同访问，所以谁都没办法进行，这就导致了环路等待，产生了死锁\n\n  下面是一个示例：\n\n  假设我们这里的代码不睡1秒，那么线程会先后执行，因为线程执行的时间太短了，导致在时间片内就完成了，这样其他线程没有抢占然后去加锁的过程，因此这种情况是不会产生死锁的\n\n  但是如果我们死循环的去执行，就有可能产生死锁，死循环执行，时间片完了我们也不知道线程执行到哪一步，然后被抢占了万一刚好给第一个加锁，另外一个也给第一个加锁，这不就死锁了嘛\n\n  这里我在加锁了之后睡1秒，我让第二个线程去抢占加锁，让他成为死锁，从执行结果来看必然是死锁\n\n  ~~~cpp\n  #include <iostream>\n  using namespace std;\n  #include <pthread.h>\n  #include <unistd.h>\n  \n  pthread_mutex_t mutex1, mutex2;\n  \n  void* CALLBACK_A(void* arg) {\n      pthread_mutex_lock(&mutex1);\n      sleep(1);  // 这里睡一秒，让线程B得到抢占权\n      pthread_mutex_lock(&mutex2);\n  \n      printf(\"thread A , tid : %ld is working.\\n\", pthread_self());\n  \n      // 释放锁的时候最好反着来，因为加锁是有顺序的\n      pthread_mutex_unlock(&mutex2);\n      pthread_mutex_unlock(&mutex1);\n  \n      return nullptr;\n  }\n  \n  void* CALLBACK_B(void* arg) {\n      pthread_mutex_lock(&mutex2);\n      sleep(1);  // 这里睡一秒，让线程A得到抢占权\n      pthread_mutex_lock(&mutex1);\n  \n      printf(\"thread B , tid : %ld is working.\\n\", pthread_self());\n  \n      pthread_mutex_unlock(&mutex1);\n      pthread_mutex_unlock(&mutex2);\n  \n      return nullptr;\n  }\n  \n  int main() {\n      // 初始化互斥信号量\n      pthread_mutex_init(&mutex1, nullptr);\n      pthread_mutex_init(&mutex2, nullptr);\n  \n      pthread_t tid1, tid2;\n  \n      // 创建子线程\n      pthread_create(&tid1, nullptr, &CALLBACK_A, nullptr);\n      pthread_create(&tid2, nullptr, &CALLBACK_B, nullptr);\n  \n      // 回收子线程\n      pthread_join(tid1, nullptr);\n      pthread_join(tid2, nullptr);\n  \n      // 释放信号量\n      pthread_mutex_destroy(&mutex1);\n      pthread_mutex_destroy(&mutex2);\n  \n      return 0;\n  }\n  ~~~\n\n  ![image-20230803151736722](https://cdn.davidingplus.cn/images/2025/01/31/image-20230803151736722.png)\n\n### 读写锁\n\n在实际的开发过程中，存在读和写的两种情况，我们发现如果读写都是独占加锁的话，读是可以多个线程同时进行的呀，因为没有修改数据的大小，所以加锁就造成了资源和效率上的浪费；所以我们可以让多个线程可以同时读数据，然后写数据需要加互斥锁，只能一个线程写数据，并且在写的时候其他线程不能读数据\n\n特点：\n\n- **如果有线程在读数据，其他线程只允许读数据而不允许写数据**\n- **如果有线程在写数据，其他线程都不允许进行读写操作**\n- **写数据是独占的，他的优先级更高**\n\n![image-20230804134719753](https://cdn.davidingplus.cn/images/2025/01/31/image-20230804134719753.png)\n\n#### 相关函数\n\n![image-20230816104436489](https://cdn.davidingplus.cn/images/2025/01/31/image-20230816104436489.png)\n\n示例代码：(8个线程，3个写线程，5个读线程)\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\n/*\n    读写锁的类型 pthread_rwlock_t\n\n    int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);\n\n    int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);\n\n    int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n\n    int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n\n    int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n\n    int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n\n    int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n*/\n\n// 定义全局变量\nint num = 1;\n\n// 定义读写互斥量\npthread_rwlock_t _rwlock;\n\nvoid* WRITE_CALLBACK(void* arg) {\n    while (1) {\n        pthread_rwlock_wrlock(&_rwlock);\n\n        printf(\"++write, tid : %ld , num : %d\\n\", pthread_self(), ++num);\n\n        pthread_rwlock_unlock(&_rwlock); //这行代码要在usleep上面，因为需要睡眠让其他线程进行抢占，如果在下面就不好说了\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nvoid* READ_CALLBACK(void* arg) {\n    while (1) {\n        pthread_rwlock_rdlock(&_rwlock);\n\n        printf(\"===read, tid : %ld , num : %d\\n\", pthread_self(), num);\n\n        pthread_rwlock_unlock(&_rwlock);\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\n// 案例：创建8个线程，操作同一个全局变量\n// 3个线程不定时的写一个全局变量，5个线程不定时的读这个全局变量\nint main() {\n    // 初始化读写互斥量\n    pthread_rwlock_init(&_rwlock, nullptr);\n\n    // 创建3个写线程，5个读线程\n    pthread_t wr_tids[3], rd_tids[5];\n\n    for (int i = 0; i < 3; ++i)\n        pthread_create(&wr_tids[i], nullptr, WRITE_CALLBACK, nullptr);\n\n    for (int i = 0; i < 5; ++i)\n        pthread_create(&rd_tids[i], nullptr, READ_CALLBACK, nullptr);\n\n    // 分离线程\n    for (int i = 0; i < 3; ++i)\n        pthread_detach(wr_tids[i]);\n\n    for (int i = 0; i < 5; ++i)\n        pthread_detach(rd_tids[i]);\n\n    // 退出主线程\n    pthread_exit(nullptr);\n\n    // 释放读写互斥量\n    pthread_rwlock_destroy(&_rwlock);\n\n    return 0;\n}\n~~~\n\n执行结果：\n\n![image-20230816112647486](https://cdn.davidingplus.cn/images/2025/01/31/image-20230816112647486.png)\n\n### 生产者消费者模型\n\n![image-20230816150325060](https://cdn.davidingplus.cn/images/2025/01/31/image-20230816150325060.png)\n\n我们现在用一个简陋的实现来模拟这个过程\n\n~~~cpp\n#include <ctime>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\n/*\n    生产者消费者模型(粗略的版本)\n*/\n\n// 定义一个链表\nstruct Node {\n    int val;\n    struct Node* next;\n};\n\n// 定义头结点\nstruct Node* head = nullptr;\n\nvoid* PRO_CALLBACK(void*) {\n    // 不断生成新节点，插入到链表当中(头插)\n    while (1) {\n        struct Node* newNode = new struct Node;\n        newNode->next = head;\n        head = newNode;\n\n        newNode->val = rand() % 1000;\n\n        printf(\"add node , val : %d , tid : %ld\\n\", newNode->val, pthread_self());\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nvoid* CUS_CALLBACK(void*) {\n    // 不断从头部释放头结点\n    while (1) {\n        struct Node* tmp = head;\n        head = head->next;\n        printf(\"delete node , val : %d , tid : %ld\\n\", tmp->val, pthread_self());\n\n        delete tmp;\n        tmp = nullptr;\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nint main() {\n    // 创建5个生产者线程，和5个消费者线程\n    pthread_t ptids[5], ctids[5];\n\n    for (int i = 0; i < 5; ++i) {\n        pthread_create(&ptids[i], nullptr, PRO_CALLBACK, nullptr);\n        pthread_create(&ctids[i], nullptr, CUS_CALLBACK, nullptr);\n    }\n\n    // 线程分离\n    for (int i = 0; i < 5; ++i) {\n        pthread_detach(ptids[i]);\n        pthread_detach(ctids[i]);\n    }\n\n    while (1) {\n        sleep(10);\n    }\n\n    // 线程退出\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n这个程序没有对多线程进行数据处理的同步操作，会导致一系列问题，比如链表没有数据就进行释放，这样就会导致内存的访问错误，也就是会报段错误，多次执行，每次执行的结果可能都是不一样的\n\n![image-20230817102529078](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817102529078.png)\n\n#### 自己的思路\n\n我们自己先尝试着解决这两个问题，一个是数据不同步的问题，一个是非法访问内存导致段错误的问题，我们的代码如下：\n\n- **数据同步：由于我们在生产和消费的时候都是处理的是头结点，这一块区域就是临界区，我们可以给这个区域加上互斥锁，也就是定义pthread_mutex_t类型互斥锁来处理**\n- **段错误，这个问题的出现在于我们在链表为空的时候进行了消费者行为，移出数据，这个时候会导致内存的非法访问，因此我们可以加上一个条件判断，当没有数据的时候就循环直到有数据**\n  **但是这么做的坏处就是如果消费者线程一直拿到CPU执行一直没有数据，那就一直空转等待，会消耗性能和降低效率，我们希望消费者在没有数据的时候能够题型生产者去生产数据，而生产者相反的可以在满了的时候提醒消费者消费数据，当然我们这个设计链表可以无限延申，这里不需要考虑，这才是我们想要的，所以下面就有条件变量和信号量两种操作**\n\n~~~cpp\n#include <ctime>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\n/*\n    生产者消费者模型(粗略的版本)\n*/\n\n// 创建互斥量来解决数据同步的问题\npthread_mutex_t mutex;\n\n// 定义一个链表\nstruct Node {\n    int val;\n    struct Node* next;\n};\n\n// 定义头结点\nstruct Node* head = nullptr;\n\nvoid* PRO_CALLBACK(void*) {\n    // 不断生成新节点，插入到链表当中(头插)\n    while (1) {\n        pthread_mutex_lock(&mutex);\n\n        struct Node* newNode = new struct Node;\n        newNode->next = head;\n        head = newNode;\n\n        newNode->val = rand() % 1000;\n\n        printf(\"add node , val : %d , tid : %ld\\n\", newNode->val, pthread_self());\n\n        pthread_mutex_unlock(&mutex);\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nvoid* CUS_CALLBACK(void*) {\n    // 不断从头部释放头结点\n    while (1) {\n        pthread_mutex_lock(&mutex);\n\n        struct Node* tmp = head;\n\n        // 这里如果没有数据head就为nullptr就会报错这一行，非法访问内存\n        // 需要进行判断\n        if (head == nullptr) {\n            delete tmp;\n            tmp = nullptr;\n\n            pthread_mutex_unlock(&mutex);\n\n            usleep(1000);\n            continue;\n        }\n\n        head = head->next;\n        printf(\"delete node , val : %d , tid : %ld\\n\", tmp->val, pthread_self());\n\n        delete tmp;\n        tmp = nullptr;\n\n        pthread_mutex_unlock(&mutex);\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nint main() {\n    // 初始化互斥锁\n    pthread_mutex_init(&mutex, nullptr);\n\n    // 创建5个生产者线程，和5个消费者线程\n    pthread_t ptids[5], ctids[5];\n\n    for (int i = 0; i < 5; ++i) {\n        pthread_create(&ptids[i], nullptr, PRO_CALLBACK, nullptr);\n        pthread_create(&ctids[i], nullptr, CUS_CALLBACK, nullptr);\n    }\n\n    // 回收线程\n    for (int i = 0; i < 5; ++i) {\n        pthread_detach(ptids[i]);\n        pthread_detach(ctids[i]);\n    }\n\n    // 用死循环来保证主线程不会结束，如果用 pthread_exit() 会导致互斥锁释放的位置问题\n    while (1)\n        ;\n\n    // 释放互斥锁\n    pthread_mutex_destroy(&mutex);\n\n    // 主线程退出(这里其实没什么用了)\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n#### 条件变量\n\n**条件变量可以有两个行为，满足某个条件线程阻塞，或者满足条件线程解除阻塞**\n\n**他不能保证数据混乱的问题，数据混乱需要加互斥锁，需要使用 pthread_mutex_t 类型的互斥锁解决**\n\n**我们发现阻塞和解除阻塞，还要满足某个条件，这不就是我想要的嘛？所以head为空就阻塞，head不为空就解除阻塞，这就是基本的思路**\n\n![image-20230817104711611](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817104711611.png)\n\n将我们的代码进行改进：\n\n**其实就改了两个地方，就是生产者生产了之后的动作和消费者没有数据时候的处理**\n\n- **生产者：生产者在生产了数据之后会调用条件变量的信号函数 pthread_cond_signal() 函数来提醒消费者有数据了，至于是怎么提醒的呢？这就依赖于消费者里面的函数 pthread_cond_wait()**\n- **消费者：调用阻塞函数 pthread_cond_wait() 进行阻塞等待(没有数据的时候)，然后当有数据的时候就解除阻塞**\n  **这里会出现一个问题，为什么 pthread_cond_wait() 函数中会需要传入mutex互斥锁的信息呢？**\n  **肯定是操作了互斥锁，我们来看，假设不操作，那么我阻塞，然后我还拿着临界区的访问互斥锁，那么就出问题了，其他的线程不管是消费者还是生产者都没有办法拿到这把锁，那么就肯定会导致死锁，所以肯定对这个锁进行了处理**\n  **其实，当调用阻塞的时候，会释放掉这把锁，让其他线程进行争抢，当生产者拿到锁，生产了数据，调用pthread_cond_signal()函数告诉消费者可以解除阻塞了，那么这个时候就会解除阻塞并且重新给这个线程上锁，因此解除阻塞的时候锁还在我身上，刚才阻塞的过程中不在了，所以后面需要跟上一句释放这个锁，因为根据我们的逻辑会重新循环拿锁，我们需要避免死锁**\n\n~~~cpp\n#include <ctime>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <unistd.h>\n\n/*\n    生产者消费者模型(粗略的版本)\n*/\n\n// 创建互斥量来解决数据同步的问题\npthread_mutex_t mutex;\n// 定义条件变量\npthread_cond_t cond;\n\n// 定义一个链表\nstruct Node {\n    int val;\n    struct Node* next;\n}* head = nullptr;  // 定义头结点\n\nvoid* PRO_CALLBACK(void* args) {\n    // 不断生成新节点，插入到链表当中(头插)\n    while (1) {\n        pthread_mutex_lock(&mutex);\n\n        struct Node* newNode = new struct Node;\n        newNode->next = head;\n        head = newNode;\n\n        newNode->val = rand() % 1000;\n\n        printf(\"add node , val : %d , tid : %ld\\n\", newNode->val, pthread_self());\n\n        pthread_mutex_unlock(&mutex);\n        \n        pthread_cond_signal(&cond);\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nvoid* CUS_CALLBACK(void* args) {\n    // 不断从头部释放头结点\n    while (1) {\n        pthread_mutex_lock(&mutex);\n\n        struct Node* tmp = head;\n\n        // 这里如果没有数据head就为nullptr就会报错这一行，非法访问内存\n        // 需要进行判断\n        if (head != nullptr) {\n            head = head->next;\n            printf(\"delete node , val : %d , tid : %ld\\n\", tmp->val, pthread_self());\n\n            delete tmp;\n            tmp = nullptr;\n\n            pthread_mutex_unlock(&mutex);\n\n            usleep(1000);\n        } else {\n            // 没有数据，需要阻塞等待\n            // 当这个函数调用阻塞的时候，会解锁，当不阻塞的时候继续向下执行，会重新加锁\n            pthread_cond_wait(&cond, &mutex);\n            // 当有数据唤醒之后，我们的代码逻辑是重新进入循环加锁，因此必须提前释放锁\n            pthread_mutex_unlock(&mutex);\n        }\n    }\n\n    return nullptr;\n}\n\nint main() {\n    // 初始化互斥锁\n    pthread_mutex_init(&mutex, nullptr);\n    // 初始化条件变量\n    pthread_cond_init(&cond, nullptr);\n\n    // 创建5个生产者线程，和5个消费者线程\n    pthread_t ptids[5], ctids[5];\n\n    for (int i = 0; i < 5; ++i) {\n        pthread_create(&ptids[i], nullptr, PRO_CALLBACK, nullptr);\n        pthread_create(&ctids[i], nullptr, CUS_CALLBACK, nullptr);\n    }\n\n    // 回收线程\n    for (int i = 0; i < 5; ++i) {\n        pthread_detach(ptids[i]);\n        pthread_detach(ctids[i]);\n    }\n\n    // 用死循环来保证主线程不会结束，如果用 pthread_exit() 会导致互斥锁释放的位置问题\n    while (1)\n        ;\n\n    // 释放条件变量\n    pthread_cond_destroy(&cond);\n    // 释放互斥锁\n    pthread_mutex_destroy(&mutex);\n\n    // 主线程退出(这里其实没什么用了)\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n#### 信号量\n\n看到 sem_wait() 和 sem_post() 函数就想到操作系统中学到的PV问题了\n\n![image-20230817114724983](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817114724983.png)\n\n~~~cpp\n    #include <semaphore.h>\n\n    int sem_init(sem_t *sem, int pshared, unsigned int value);\n//作用：初始化信号量\n//参数：\n    //sem：信号量变量的地址\n    //pshared：0 用在线程； 非0 用在进程\n    //value：信号量的值\n\n    int sem_destroy(sem_t *sem);\n//作用：释放资源\n\n    int sem_wait(sem_t *sem);\n//作用：对信号量加锁，调用一次，对信号量的值减1，如果值为0，就阻塞\n\n    int sem_trywait(sem_t *sem);\n//作用：尝试wait\n\n    int sem_timedwait(sem_t *restrict sem, const struct timespec *restrict abs_timeout);\n//作用：等待一段时间\n\n    int sem_post(sem_t *sem);\n//作用：解锁一个信号量，调用一次，对信号量的值加1\n\n    int sem_getvalue(sem_t *restrict sem, int *restrict sval);\n//作用：获取信号量的值\n~~~\n\n实际代码：\n\n~~~cpp\n#include <ctime>\n#include <iostream>\nusing namespace std;\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h>\n\n// 创建互斥量来解决数据同步的问题\npthread_mutex_t mutex;\n// 创建两个信号量\nsem_t psem, csem;\n\n// 定义一个链表\nstruct Node {\n    int val;\n    struct Node* next;\n}* head = nullptr;  // 定义头结点\n\nvoid* PRO_CALLBACK(void* args) {\n    // 不断生成新节点，插入到链表当中(头插)\n    while (1) {\n        sem_wait(&psem);\n\n        pthread_mutex_lock(&mutex);\n\n        struct Node* newNode = new struct Node;\n        newNode->next = head;\n        head = newNode;\n\n        newNode->val = rand() % 1000;\n\n        printf(\"add node , val : %d , tid : %ld\\n\", newNode->val, pthread_self());\n\n        pthread_mutex_unlock(&mutex);\n\n        sem_post(&csem);  // 将消费者的信号量加1表示可以进行消费\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nvoid* CUS_CALLBACK(void* args) {\n    // 不断从头部释放头结点\n    // 这就是操作系统当中学的经典的PV问题了，巩固一下\n    while (1) {\n        sem_wait(&csem);\n\n        pthread_mutex_lock(&mutex);\n\n        struct Node* tmp = head;\n\n        head = head->next;\n        printf(\"delete node , val : %d , tid : %ld\\n\", tmp->val, pthread_self());\n\n        delete tmp;\n        tmp = nullptr;\n\n        pthread_mutex_unlock(&mutex);\n\n        sem_post(&psem);  // 将生产者的信号量加1表示可以生产\n\n        usleep(1000);\n    }\n\n    return nullptr;\n}\n\nint main() {\n    // 初始化互斥锁\n    pthread_mutex_init(&mutex, nullptr);\n    // 初始化信号量\n    sem_init(&psem, 0, 8);\n    sem_init(&csem, 0, 0);\n\n    // 创建5个生产者线程，和5个消费者线程\n    pthread_t ptids[5],\n        ctids[5];\n\n    for (int i = 0; i < 5; ++i) {\n        pthread_create(&ptids[i], nullptr, PRO_CALLBACK, nullptr);\n        pthread_create(&ctids[i], nullptr, CUS_CALLBACK, nullptr);\n    }\n\n    // 回收线程\n    for (int i = 0; i < 5; ++i) {\n        pthread_detach(ptids[i]);\n        pthread_detach(ctids[i]);\n    }\n\n    // 用死循环来保证主线程不会结束，如果用 pthread_exit() 会导致互斥锁释放的位置问题\n    while (1)\n        ;\n\n    // 释放互斥锁\n    pthread_mutex_destroy(&mutex);\n\n    // 主线程退出(这里其实没什么用了)\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n# 第四章 Linux网络编程\n\n## 网络结构模式\n\n### C/S结构\n\n#### 简介\n\n- 服务器 - 客户机，即 Client - Server（C/S）结构。C/S 结构通常采取两层结构。服务器负责数据的 管理，客户机负责完成与用户的交互任务。客户机是因特网上访问别人信息的机器，服务器则是提 供信息供人访问的计算机。\n- 客户机通过局域网与服务器相连，接受用户的请求，并通过网络向服务器提出请求，对数据库进行 操作。服务器接受客户机的请求，将数据提交给客户机，客户机将数据进行计算并将结果呈现给用 户。服务器还要提供完善安全保护及对数据完整性的处理等操作，并允许多个客户机同时访问服务 器，这就对服务器的硬件处理数据能力提出了很高的要求。 \n- 在C/S结构中，应用程序分为两部分：服务器部分和客户机部分。服务器部分是多个用户共享的信 息与功能，执行后台服务，如控制共享数据库的操作等；客户机部分为用户所专有，负责执行前台 功能，在出错提示、在线帮助等方面都有强大的功能，并且可以在子程序间自由切换。\n\n#### 优点\n\n1. 能充分发挥客户端 PC 的处理能力，很多工作可以在客户端处理后再提交给服务器，所以 C/S 结构客户端响应速度快；\n2. 操作界面漂亮、形式多样，可以充分满足客户自身的个性化要求； \n3. C/S 结构的管理信息系统具有较强的事务处理能力，能实现复杂的业务流程； \n4. 安全性较高，C/S 一般面向相对固定的用户群，程序更加注重流程，它可以对权限进行多层次校验，提供了更安全的存取模式，对信息安全的控制能力很强，一般高度机密的信息系统采用 C/S 结构适宜。\n\n#### 缺点\n\n1. 客户端需要安装专用的客户端软件。首先涉及到安装的工作量，其次任何一台电脑出问题，如病 毒、硬件损坏，都需要进行安装或维护。系统软件升级时，每一台客户机需要重新安装，其维护和 升级成本非常高； \n2. 对客户端的操作系统一般也会有限制，不能够跨平台。\n\n### B/S结构\n\n#### 简介\n\nB/S 结构（Browser/Server，浏览器/服务器模式），是 WEB 兴起后的一种网络结构模式，WEB 浏览器是客户端最主要的应用软件。这种模式统一了客户端，将系统功能实现的核心部分集中到服 务器上，简化了系统的开发、维护和使用。客户机上只要安装一个浏览器，如 Firefox 或 Internet Explorer，服务器安装 SQL Server、Oracle、MySQL 等数据库。浏览器通过 Web Server 同数据 库进行数据交互。\n\n#### 优点\n\nB/S 架构最大的优点是总体拥有成本低、维护方便、 分布性强、开发简单，可以不用安装任何专门的软 件就能实现在任何地方进行操作，客户端零维护，系统的扩展非常容易，只要有一台能上网的电脑就能 使用。\n\n#### 缺点\n\n1. 通信开销大、系统和数据的安全性较难保障; \n2. 个性特点明显降低，无法实现具有个性化的功能要求；\n3. 协议一般是固定的：http/https\n4. 客户端服务器端的交互是请求-响应模式，通常动态刷新页面，响应速度明显降低。\n\n## MAC地址\n\n网卡是一块被设计用来允许计算机在计算机网络上进行通讯的计算机硬件，又称为网络适配器或网络接口卡NIC。其拥有 MAC 地址，属于 OSI 模型的第 2 层，它使得用户可以通过电缆或无线相互 连接。每一个网卡都有一个被称为 MAC 地址的独一无二的 48 位串行号。网卡的主要功能：1.数据的封装与解封装、2.链路管理、3.数据编码与译码。\n\n![image-20230817154336052](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817154336052.png)\n\nMAC 地址（Media Access Control Address），直译为媒体存取控制位址，也称为局域网地址、 以太网地址、物理地址或硬件地址，它是一个用来确认网络设备位置的位址，由网络设备制造商生产时烧录在网卡中。在 OSI 模型中，第三层网络层负责 IP 地址，第二层数据链路层则负责 MAC 位址 。MAC 地址用于在网络中唯一标识一个网卡，一台设备若有一或多个网卡，则每个网卡都需 要并会有一个唯一的 MAC 地址。\n\nMAC 地址的长度为 48 位（6个字节），通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就 是一个MAC 地址，**其中前 3 个字节，16 进制数 00-16-EA 代表网络硬件制造商的编号，它由 IEEE（电气与电子工程师协会）分配，而后 3 个字节，16进制数 AE-3C-40 代表该制造商所制造的 某个网络产品（如网卡）的系列号。**只要不更改自己的 MAC 地址，MAC 地址在世界是唯一的。 形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性。\n\n## IP地址\n\n### 简介\n\nIP 协议是为计算机网络相互连接进行通信而设计的协议。在因特网中，它是能使连接到网上的所有计算机网络实现相互通信的一套规则，规定了计算机在因特网上进行通信时应当遵守的规则。任 何厂家生产的计算机系统，只要遵守 IP 协议就可以与因特网互连互通。各个厂家生产的网络系统 和设备，如以太网、分组交换网等，它们相互之间不能互通，不能互通的主要原因是因为它们所传 送数据的基本单元（技术上称之为“帧”）的格式不同。\n\nIP 协议实际上是一套由软件程序组成的协议 软件，它把各种不同“帧”统一转换成“IP 数据报”格式，这种转换是因特网的一个最重要的特点，使 所有各种计算机都能在因特网上实现互通，即具有“开放性”的特点。正是因为有了 IP 协议，因特 网才得以迅速发展成为世界上最大的、开放的计算机通信网络。因此，IP 协议也可以叫做“因特网 协议”。\n\nIP 地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以 此来屏蔽物理地址的差异。 IP 地址是一个 32 位的二进制数，通常被分割为 4 个“ 8 位二进制数”（也就是 4 个字节）。IP 地址 通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是 0~255 之间的十进制整数。 例：点分十进IP地址（100.4.5.6），实际上是 32 位二进制数 （01100100.00000100.00000101.00000110）。\n\n### IP地址编址方式(ABCDE和CIDR)\n\n最初设计互联网络时，为了便于寻址以及层次化构造网络，每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工 作站，服务器和路由器等）有一个主机 ID 与其对应。Internet 委员会定义了 5 种 IP 地址类型以适合不 同容量的网络，即 A 类~ E 类。\n\n其中 A、B、C 3类（如下表格）由 InternetNIC 在全球范围内统一分配，D、E 类为特殊地址。\n\n![image-20230817162026337](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817162026337.png)\n\n#### A类IP地址\n\n一个 A 类 IP 地址是指， 在 IP 地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算 机的号码。如果用二进制表示 IP 地址的话，A 类 IP 地址就由 1 字节的网络地址和 3 字节主机地址组 成，网络地址的最高位必须是“0”。A 类 IP 地址中网络的标识长度为 8 位，主机标识的长度为 24 位，A 类网络地址数量较少，有 126 个网络，每个网络可以容纳主机数达 1600 多万台。 \n\nA 类 IP 地址 地址范围 1.0.0.1 - 126.255.255.254（二进制表示为：00000001 00000000 00000000 00000001 - 01111111 11111111 11111111 11111110）。最后一个是广播地址。 \n\nA 类 IP 地址的子网掩码为 255.0.0.0，每个网络支持的最大主机数为 256 的 3 次方 - 2 = 16777214 台\n\n#### B类IP地址\n\n一个 B 类 IP 地址是指，在 IP 地址的四段号码中，前两段号码为网络号码。如果用二进制表示 IP 地址的 话，B 类 IP 地址就由 2 字节的网络地址和 2 字节主机地址组成，网络地址的最高位必须是“10”。B 类 IP 地址中网络的标识长度为 16 位，主机标识的长度为 16 位，B 类网络地址适用于中等规模的网络，有 16384 个网络，每个网络所能容纳的计算机数为 6 万多台。 \n\nB 类 IP 地址地址范围 128.0.0.1 - 191.255.255.254 （二进制表示为：10000000 00000000 00000000 00000001 - 10111111 11111111 11111111 11111110）。 最后一个是广播地址。 \n\nB 类 IP 地址的子网掩码为 255.255.0.0，每个网络支持的最大主机数为 256 的 2 次方 - 2 = 65534 台。\n\n#### C类IP地址\n\n一个 C 类 IP 地址是指，在 IP 地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算 机的号码。如果用二进制表示 IP 地址的话，C 类 IP 地址就由 3 字节的网络地址和 1 字节主机地址组 成，网络地址的最高位必须是“110”。C 类 IP 地址中网络的标识长度为 24 位，主机标识的长度为 8 位， C 类网络地址数量较多，有 209 万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台 计算机。 \n\nC 类 IP 地址范围 192.0.0.1-223.255.255.254 （二进制表示为: 11000000 00000000 00000000 00000001 - 11011111 11111111 11111111 11111110）。 \n\nC类IP地址的子网掩码为 255.255.255.0，每个网络支持的最大主机数为 256 - 2 = 254 台。\n\n#### D类IP地址\n\nD 类 IP 地址在历史上被叫做多播地址（multicast address），即组播地址。在以太网中，多播地址命 名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是 “1110”，范围从 224.0.0.0 - 239.255.255.255。\n\n#### 特殊IP地址\n\n每一个字节都为 0 的地址（ “0.0.0.0” ）对应于当前主机； \n\nIP 地址中的每一个字节都为 1 的 IP 地址（ “255.255.255.255” ）是当前子网的广播地址； \n\nIP 地址中凡是以 “11110” 开头的 E 类 IP 地址都保留用于将来和实验使用。 \n\nIP地址中不能以十进制 “127” 作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测 试，如：127.0.0.1可以代表本机IP地址。\n\n#### 子网掩码\n\n子网掩码（subnet mask）又叫网络掩码、地址掩码、子网络遮罩，它是一种用来指明一个 IP 地 址的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。子网掩码不能单独存 在，它必须结合 IP 地址一起使用。子网掩码只有一个作用，就是将某个 IP 地址划分成网络地址和 主机地址两部分。 \n\n子网掩码是一个 32 位地址，用于屏蔽 IP 地址的一部分以区别网络标识和主机标识，并说明该 IP 地址是在局域网上，还是在广域网上。\n\n子网掩码是在 IPv4 地址资源紧缺的背景下为了解决 lP 地址分配而产生的虚拟 lP 技术，通过子网掩码将 A、B、C 三类地址划分为若干子网，从而显著提高了 IP 地址的分配效率，有效解决了 IP 地址资源紧张 的局面。另一方面，在企业内网中为了更好地管理网络，网管人员也利用子网掩码的作用，人为地将一 个较大的企业内部网络划分为更多个小规模的子网，再利用三层交换机的路由功能实现子网互联，从而 有效解决了网络广播风暴和网络病毒等诸多网络管理方面的问题。 \n\n在大多数的网络教科书中，一般都将子网掩码的作用描述为通过逻辑运算，将 IP 地址划分为网络标识 (Net.ID) 和主机标识(Host.ID)，只有网络标识相同的两台主机在无路由的情况下才能相互通信。 \n\n根据 RFC950 定义，子网掩码是一个 32 位的 2 进制数， 其对应网络地址的所有位都置为 1，对应于主 机地址的所有位置都为 0。子网掩码告知路由器，地址的哪一部分是网络地址，哪一部分是主机地址， 使路由器正确判断任意 IP 地址是否是本网段的，从而正确地进行路由。网络上，数据从一个地方传到另 外一个地方，是依靠 IP 寻址。从逻辑上来讲，是两步的。第一步，从 IP 中找到所属的网络，好比是去 找这个人是哪个小区的；第二步，再从 IP 中找到主机在这个网络中的位置，好比是在小区里面找到这个 人。 \n\n子网掩码的设定必须遵循一定的规则。与二进制 IP 地址相同，子网掩码由 1 和 0 组成，且 1 和 0 分别 连续。子网掩码的长度也是 32 位，左边是网络位，用二进制数字 “1” 表示，1 的数目等于网络位的长 度；右边是主机位，用二进制数字 “0” 表示，0 的数目等于主机位的长度。这样做的目的是为了让掩码 与 IP 地址做按位与运算时用 0 遮住原主机数，而不改变原网络段数字，而且很容易通过 0 的位数确定子 网的主机数（ 2 的主机位数次方 - 2，因为主机号全为 1 时表示该网络广播地址，全为 0 时表示该网络 的网络号，这是两个特殊地址）。通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使 网络正常工作。\n\n## 端口\n\n### 简介\n\n“端口” 是英文 port 的意译，可以认为是设备与外界通讯交流的出口。端口可分为虚拟端口和物理 端口，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见，是特指TCP/IP协议中的端 口，是逻辑意义上的端口。例如计算机中的 80 端口、21 端口、23 端口等。物理端口又称为接 口，是可见端口，计算机背板的 RJ45 网口，交换机路由器集线器等 RJ45 端口。电话使用 RJ11 插 口也属于物理端口的范畴。 \n\n如果把 IP 地址比作一间房子，端口就是出入这间房子的门。真正的房子只有几个门，但是一个 IP 地址的端口可以有 65536（即：2^16）个之多！端口是通过端口号来标记的，端口号只有整数， 范围是从 0 到65535（2^16-1）。\n\n### 端口类型\n\n1. 周知端口（Well Known Ports） 周知端口是众所周知的端口号，也叫知名端口、公认端口或者常用端口，范围从 0 到 1023，它们紧密 绑定于一些特定的服务。例如 80 端口分配给 WWW 服务，21 端口分配给 FTP 服务，23 端口分配给 Telnet服务等等。我们在 IE 的地址栏里输入一个网址的时候是不必指定端口号的，因为在默认情况下 WWW 服务的端口是 “80”。网络服务是可以使用其他端口号的，如果不是默认的端口号则应该在地址栏 上指定端口号，方法是在地址后面加上冒号“:”（半角），再加上端口号。比如使用 “8080” 作为 WWW 服务的端口，则需要在地址栏里输入“网址:8080”。但是有些系统协议使用固定的端口号，它是不能被改 变的，比如 139 端口专门用于 NetBIOS 与 TCP/IP 之间的通信，不能手动改变。 \n2. 注册端口（Registered Ports） 端口号从 1024 到 49151，它们松散地绑定于一些服务，分配给用户进程或应用程序，这些进程主要是 用户选择安装的一些应用程序，而不是已经分配好了公认端口的常用程序。这些端口在没有被服务器资 源占用的时候，可以用用户端动态选用为源端口。 \n3. 动态端口 / 私有端口（Dynamic Ports / Private Ports） 动态端口的范围是从 49152 到 65535。之所以称为动态端口，是因为它一般不固定分配某种服务，而是动态分配\n\n## 网络模型\n\n### OSI 七层参考模型\n\n七层模型，亦称 OSI（Open System Interconnection）参考模型，即开放式系统互联。参考模型 是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为 OSI 参 考模型或七层模型。 \n\n它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。\n\n![image-20230817164927457](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817164927457.png)\n\n1. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率 等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为 1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 \n2. 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。定义了如何让格式化数据以帧 为单位进行传输，以及如何让控制对物理介质的访问。将比特组合成字节进而组合成帧，用MAC地 址访问介质。 \n3. 网络层：进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选 择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的 层。 \n4. 传输层：定义了一些传输数据的协议和端口号（ WWW 端口 80 等），如：TCP（传输控制协议， 传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方 式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这 一层数据叫做段。 \n5. 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求。 \n6. 表示层：数据的表示、安全、压缩。主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等）。 \n7. 应用层：网络服务与最终用户的一个接口。这一层为用户的应用程序（例如电子邮件、文件传输和 终端仿真）提供网络服务。\n\n### TCP/IP 四层模型\n\n#### 简介\n\n现在 Internet（因特网）使用的主流协议族是 TCP/IP 协议族，它是一个分层、多协议的通信体 系。TCP/IP协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用 层。每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。\n\n![image-20230817165030403](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817165030403.png)\n\nTCP/IP 协议在一定程度上参考了 OSI 的体系结构。OSI 模型共有七层，从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在 TCP/IP 协议中， 它们被简化为了四个层次。\n\n（1）应用层、表示层、会话层三个层次提供的服务相差不是很大，所以在 TCP/IP 协议中，它们被合并为应用层一个层次。 \n\n（2）由于传输层和网络层在网络协议中的地位十分重要，所以在 TCP/IP 协议中它们被作为独立的两个层次。 \n\n（3）因为数据链路层和物理层的内容相差不多，所以在 TCP/IP 协议中它们被归并在网络接口层一个层 次里。只有四层体系结构的 TCP/IP 协议，与有七层体系结构的 OSI 相比要简单了不少，也正是这样， TCP/IP 协议在实际的应用中效率更高，成本更低。\n\n![image-20230817165057099](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817165057099.png)\n\n#### 四层介绍\n\n1. 应用层：应用层是 TCP/IP 协议的第一层，是直接为应用进程提供服务的。 \n   （1）对不同种类的应用程序它们会根据自己的需要来使用应用层的不同协议，邮件传输应用使用 了 SMTP 协议、万维网应用使用了 HTTP 协议、远程登录服务应用使用了有 TELNET 协议。 \n   （2）应用层还能加密、解密、格式化数据。 \n   （3）应用层可以建立或解除与其他节点的联系，这样可以充分节省网络资源。 \n2. 传输层：作为 TCP/IP 协议的第二层，运输层在整个 TCP/IP 协议中起到了中流砥柱的作用。且在运输层中， TCP 和 UDP 也同样起到了中流砥柱的作用。 也可以叫运输层(我一般叫运输层)\n3. 网络层：网络层在 TCP/IP 协议中的位于第三层。在 TCP/IP 协议中网络层可以进行网络连接的建立 和终止以及 IP 地址的寻找等功能。 \n4. 网络接口层：在 TCP/IP 协议中，网络接口层位于第四层。由于网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。\n\n## 协议\n\n### 简介\n\n协议，网络协议的简称，网络协议是通信计算机双方必须共同遵从的一组约定。如怎么样建立连 接、怎么样互相识别等。只有遵守这个约定，计算机之间才能相互通信交流。它的三要素是：**语法、语义、时序**。 \n\n为了使数据在网络上从源到达目的，网络通信的参与方必须遵循相同的规则，这套规则称为协议 （protocol），它最终体现为在网络上传输的数据包的格式。 协议往往分成几个层次进行定义，分层定义是为了使某一层协议的改变不影响其他层次的协议。\n\n### 常见协议\n\n应用层常见的协议有：FTP协议（File Transfer Protocol 文件传输协议）、HTTP协议（Hyper Text Transfer Protocol 超文本传输协议）、NFS（Network File System 网络文件系统）。 \n\n传输层常见协议有：TCP协议（Transmission Control Protocol 传输控制协议）、UDP协议（User Datagram Protocol 用户数据报协议）。 \n\n网络层常见协议有：IP 协议（Internet Protocol 因特网互联协议）、ICMP 协议（Internet Control Message Protocol 因特网控制报文协议）、IGMP 协议（Internet Group Management Protocol 因特 网组管理协议）。 \n\n网络接口层常见协议有：ARP协议（Address Resolution Protocol 地址解析协议）、RARP协议 （Reverse Address Resolution Protocol 反向地址解析协议）。\n\n### UDP协议\n\n![image-20230817171145866](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171145866.png)\n\n### TCP协议\n\n![image-20230817171159785](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171159785.png)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230817171216720.png\" alt=\"image-20230817171216720\" style=\"zoom:125%;\" />\n\n### IP协议\n\n![image-20230817171259144](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171259144.png)\n\n![image-20230817171313342](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171313342.png)\n\n### 以太网帧协议\n\n![image-20230817171325127](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171325127.png)\n\n### ARP协议\n\n![image-20230817171331187](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171331187.png)\n\n例如，这里就是一个arp请求包\n\n![image-20230817203353404](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817203353404.png)\n\n当然，需要发送出去还要加上帧头帧尾能封装成为一个完整的帧\n\n### 封装\n\n上层协议是如何使用下层协议提供的服务的呢？其实这是通过封装（encapsulation）实现的。应用程序 数据在发送到物理网络上之前，将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，这个过程就称为封装。\n\n![image-20230817171342456](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171342456.png)\n\n### 分用\n\n当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协议依次处理帧中本层负责的头部数据， 以获取所需的信息，并最终将处理后的帧交给目标应用程序。这个过程称为分用（demultiplexing）。 分用是依靠头部信息中的类型字段实现的。\n\n![image-20230817171356559](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171356559.png)\n\n![image-20230817171401748](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817171401748.png)\n\n## 网络通信的过程\n\n示意图\n\n![image-20230817201604241](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817201604241.png)\n\n## socket介绍\n\n所谓 socket（套接字），就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。 一个套接字就是网络上进程通信的一端，提供了应用层进程利用网络协议交换数据的机制。从所处的地位来讲，套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进行通信的接口， 是应用程序与网络协议根进行交互的接口。 \n\nsocket 可以看成是两个网络应用程序进行通信时，各自通信连接中的端点，这是一个逻辑上的概 念。它是网络环境中进程间通信的 API，也是可以被命名和寻址的通信端点，使用中的每一个套接 字都有其类型和一个与之相连进程。通信时其中一个网络应用程序将要传输的一段信息写入它所在主机的 socket 中，该 socket 通过与网络接口卡（NIC）相连的传输介质将这段信息送到另外一台主机的 socket 中，使对方能够接收到这段信息。socket 是由 IP 地址和端口结合的，提供向应用 层进程传送数据包的机制。 \n\n**socket 本身有“插座”的意思，在 Linux 环境下，用于表示进程间网络通信的特殊文件类型。本质为内核借助缓冲区形成的伪文件。既然是文件，那么理所当然的，我们可以使用文件描述符引用套接字。与管道类似的，也存在读写缓冲区，写方向写的缓冲区写入数据，读方接收到数据在读缓冲区中，这就形成了数据的传递，Linux 系统将其封装成文件的目的是为了统一接口，使得读写套接字和读写文件的操作一致。区别是管道主要应用于本地进程间通信，而套接字多应用于网络进程间数据的传递。**\n\n![image-20230817210404237](https://cdn.davidingplus.cn/images/2025/01/31/image-20230817210404237.png)\n\n~~~cpp\n// 套接字通信分两部分：\n- 服务器端：被动接受连接，一般不会主动发起连接\n- 客户端：主动向服务器发起连接\nsocket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别\n~~~\n\n##  字节序\n\n### 简介\n\n现代 CPU 的累加器一次都能装载（至少）4 字节（这里考虑 32 位机），即一个整数。那么这 4 字节在内存中排列的顺序将影响它被累加器装载成的整数的值，这就是字节序问题。在各种计算机 体系结构中，对于字节、字等的存储机制有所不同，因而引发了计算机通信领域中一个很重要的问 题，即通信双方交流的信息单元（比特、字节、字、双字等等）应该以什么样的顺序进行传送。如 // 套接字通信分两部分： - 服务器端：被动接受连接，一般不会主动发起连接 - 客户端：主动向服务器发起连接 socket是一套通信的接口，Linux 和 Windows 都有，但是有一些细微的差别。 果不达成一致的规则，通信双方将无法进行正确的编码/译码从而导致通信失败。 \n\n**字节序，顾名思义字节的顺序，就是大于一个字节类型的数据在内存中的存放顺序(一个字节的数据当然就无需谈顺序的问题了)。** \n\n**字节序分为大端字节序（Big-Endian） 和小端字节序（Little-Endian）。大端字节序是指一个整数的高位字节存储在内存的低地址处，低位字节存储在内存的高地址处；小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。**\n\n### 字节序举例\n\n**小端字节序是低位字节存储在内存的低地址处，高位字节存储在内存的高地址处；大端字节序则相反!!!**\n\n**图中的0x11就是一个字节，因为他是用16进制表示的，也就是0x11对应的11是8个bit，然后就是一个字节，这个数就是这么存储下来的，因此就有了高位字节和低位字节在内存中的顺序问题**\n\n![image-20230818092738767](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818092738767.png)\n\n![image-20230818092744993](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818092744993.png)\n\n好，我们了解了这些就可以写一个测试样例来查看我们的主机是小端字节序还是大端字节序(记忆：小端字节序就是内存高位对应数里面的高位)\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n\n/*\n字节序：字节在内存中存储的顺序\n小端字节序：数据的高位字节存储在内存的高位地址，低位字节存储在内存的低位地址\n大端字节序：数据的高位字节存储在内存的低位地址，低位字节存储在内存的高位地址(与前面的相反)\n*/\n\n// 通过代码检测当前主机的字节序\n\n// 联合里面的数据地址的起始位置都是从头开始的，因此指向的内存很大概率是有重复的\nunion Fuck {\n    short value;                // 两个字节\n    char bytes[sizeof(short)];  // 两个字节的数组，可以查看两个字节分成一半是怎么存储的\n} test;\n\nint main() {\n    test.value = 0x0102;\n\n    if (test.bytes[0] == 1 && test.bytes[1] == 2)  // 数据的高位对应字节存储的低位，则为大端字节序\n        printf(\"大端字节序\\n\");\n    else\n        printf(\"小端字节序\\n\");\n\n    return 0;\n}a\n~~~\n\n当然，这个代码简化一下一行就可以搞定\n\n~~~cpp\ncout << (char(0x0102) == 0x02 ? \"小端字节序\" : \"大端字节序\") << endl;  // 这么写更加简单\n~~~\n\n### 字节序转换函数\n\n**当格式化的数据在两台使用不同字节序的主机之间直接传递时，接收端必然错误的解释之。解决问题的方法是：发送端总是把要发送的数据转换成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。** \n\n因此，**在网络中，我们规定都用大端字节序传递数据，称为网络字节序**\n\n**网络字节顺序**是 TCP/IP 中规定好的一种数据表示格式，它与具体的 CPU 类型、操作系统等无关，从而 可以保证数据在不同主机之间传输时能够被正确解释，网络字节顺序采用大端排序方式。 \n\nBSD Socket提供了封装好的转换接口，方便程序员使用。包括从主机字节序到网络字节序的转换函数： htons、htonl；从网络字节序到主机字节序的转换函数：ntohs、ntohl。\n\n~~~cpp\nh - host 主机，主机字节序\nto - 转换成什么\nn - network 网络字节序\ns - short unsigned short\nl - long unsigned int\n~~~\n\n~~~cpp\n#include <arpa/inet.h>\n// 转换端口 端口号 0-65535，就是16位，因此是 uint16_t\nuint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序\nuint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序\n// 转IP IP地址，IPV4是32位，因此是uint32_t\nuint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序\nuint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序\n~~~\n\n我们写一个测试案例来演示一下这几个函数\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n\n/*\n    网络通信时，需要将主机字节序转化为网络字节序(大端)\n    另外一端获取到数据以后，根据情况将网络字节序转换为主机字节序\n\n    #include <arpa/inet.h>\n    // 转换端口 端口号 0-65535，就是16位，因此是 uint16_t\n    uint16_t htons(uint16_t hostshort); // 主机字节序 - 网络字节序\n    uint16_t ntohs(uint16_t netshort); // 主机字节序 - 网络字节序\n    // 转IP IP地址，IPV4是32位，因此是uint32_t\n    uint32_t htonl(uint32_t hostlong); // 主机字节序 - 网络字节序\n    uint32_t ntohl(uint32_t netlong); // 主机字节序 - 网络字节序\n*/\n\nint main() {\n    // htons() 转换端口\n    unsigned short a = 0x0102;\n    printf(\"a : %x\\n\", a);\n    unsigned short b = htons(a);\n    printf(\"b : %x\\n\", b);\n\n    printf(\"----------------------------------------------\\n\");\n\n    // htonl() 转换IP\n    // 这里用char会报 narrowing conversion 缩窄转换\n    // 这是c++11在使用初始化序列时候编译器会自动判断，如果发生缩窄转换就会报错\n    unsigned char buf[4] = {192, 168, 1, 100};\n\n    int num = *(int*)buf;\n    int ans = htonl(num);\n\n    unsigned char* p = (unsigned char*)&ans;\n    printf(\"%u %u %u %u\\n\", *p, *(p + 1), *(p + 2), *(p + 3));\n\n    printf(\"----------------------------------------------\\n\");\n\n    // ntohl()\n    unsigned char buf1[4] = {1, 1, 168, 192};\n    int num1 = *(int*)buf1;\n    int ans1 = ntohl(num1);\n    unsigned char* p1 = (unsigned char*)&ans1;\n    printf(\"%u %u %u %u\\n\", *p1, *(p1 + 1), *(p1 + 2), *(p1 + 3));\n\n    return 0;\n}\n~~~\n\n**我们来解释一下里面的一些东西，值得我们深思**\n\n**在c++11当中新增了一个 narrowing convertions，就是缩窄转换；他的规定是c++11之后引入了一个新特性就是列表初始化initializer_list，在用初始化列表初始化值的时候不允许发生类型的缩窄转换**\n\n**比如：**\n\n~~~cpp\nvector<int> tmp {1,2.2}; \n//这里不允许将double类型的2.2转化为int类型，在初始化列表中，因为double类型的范围比int类型更宽(这是新规定的)\n~~~\n\n**但是**\n\n~~~cpp\nint num = double(2.2);\n//这行代码显然是合法的，没有用initializer_list，num的值显然为2\n~~~\n\n**我们再举一个例子：**\n\n~~~cpp\nint a(double(2.2));\nint a{double(2.2)};\n~~~\n\n**类似的两行代码，第一个使用的是构造函数，第二个调用的是initializer_list，在c++11标准下，第一个是可以通过编译的，第二会报错，原因是narrowing convertions，缩窄变换**\n\n**对应到我们这里，我们看这一行代码：**\n\n~~~cpp\nunsigned char buf[4] = {192, 168, 1, 100};\n~~~\n\n**为什么我们会选择unsigned char 而不是 char？**\n\n**我们知道，c语言内置的类型都是signed，即有符号的，所以以char为例，是1个字节，表示的范围为-128到127，8位数，第一位拿来表示符号，1为负，0为正，然后-128是用来表示-0，和+0用于区分；然后我们图中传入的是192，168，这两个如果要想转化为char类型的话那就是负数，但是在initializer_list当中就不允许这样的缩窄转换，就是把int类型转化为char类型，因为这里我们可以看出192已经超过了-128到127的范围**\n\n~~~cpp\nchar(192);\n~~~\n\n**虽然我们这么写是没有问题的，存入的数字应该是-64，但是initializer_list中会被认为是缩窄转换，所以不允许这么做**\n\n**但是我们再来看unsigned char，由于网络字节当中的不管是IP还是port端口都是无符号，也就是非负的，所以我们可以选择unsigned，其次，这里的IP地址，一个字节的范围是0-255，而unsigned char的表示范围恰好就是0-255，他们把负数表示为对应的补码，所以范围恰好完美对应，当然如果数在大一点可能会出问题，但是我们对应的是实际的IP情况，所以就能应对了，因此这里的类型我们选择unsigned char**\n\n**而C语言如果我们用char或者低版本的c++，例如c++98这种，就不会报错，因为这是语法定义的对数组初始化，只不过c++11之后引入了一个更加厉害的initializer_list而已**\n\n## socket地址\n\n**主要是用来封装IP和端口号port的信息**\n\n~~~cpp\n// socket地址其实是一个结构体，封装端口号和IP等信息。后面的socket相关的api中需要使用到这个socket地址。\n// 客户端 -> 服务器（IP, Port）\n~~~\n\n### 通用socket地址\n\nsocket 网络编程接口中表示 socket 地址的是结构体 sockaddr，这个在一般是通用的，其定义如下：\n\n~~~cpp\n#include <bits/socket.h>\nstruct sockaddr {\n    sa_family_t sa_family;\n    char sa_data[14]; //存储数据，包括IP和端口号的信息\n};\ntypedef unsigned short int sa_family_t;\n~~~\n\n**这个结构体data部分的长度最大是14个字节，然后下面会看出其他两种都可能会超出14个字节，而IPv4就6个字节，可以存放下，因此绝大多数情况下是给IPv4使用的**\n\n**sa_family 成员是地址族类型（sa_family_t）的变量。**地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称 domain）和对应的地址族入下所示：\n\n![image-20230818115634758](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818115634758.png)\n\n宏 PF_ * 和 AF_ * 都定义在 bits/socket.h 头文件中，且后者与前者有完全相同的值，所以二者通常混用。\n\nsa_data 成员用于存放 socket 地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下所示：\n\n![image-20230818115654321](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818115654321.png)\n\n由上表可知，14 字节的 sa_data 根本无法容纳多数协议族的地址值。因此，Linux 定义了下面这个新的 通用的 socket 地址结构体，这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的。\n\n~~~cpp\n#include <bits/socket.h>\nstruct sockaddr_storage\n{\n    sa_family_t sa_family;\n    unsigned long int __ss_align;\n    char __ss_padding[ 128 - sizeof(__ss_align) ]; //存储数据\n};\ntypedef unsigned short int sa_family_t;\n~~~\n\n### 专用socket地址\n\n**很多网络编程函数诞生早于 IPv4 协议，那时候都使用的是 struct sockaddr 结构体，为了向前兼容，现 在sockaddr 退化成了（void *）的作用，传递一个地址给函数，至于这个函数是 sockaddr_in 还是 sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230818115728450.png\" alt=\"image-20230818115728450\" style=\"zoom:80%;\" />\n\nUNIX 本地域协议族使用如下专用的 socket 地址结构体：\n\n~~~cpp\n#include <sys/un.h>\nstruct sockaddr_un\n{\n\tsa_family_t sin_family;\n\tchar sun_path[108];\n};\n~~~\n\nTCP/IP 协议族有 sockaddr_in 和 sockaddr_in6 两个专用的 socket 地址结构体，它们分别用于 IPv4 和 IPv6：\n\n~~~cpp\n#include <netinet/in.h>\nstruct sockaddr_in\n{\n    sa_family_t sin_family; /* __SOCKADDR_COMMON(sin_) */\n    in_port_t sin_port; /* Port number. */\n    struct in_addr sin_addr; /* Internet address. */\n    /* Pad to size of `struct sockaddr'. */\n    unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -\n    sizeof (in_port_t) - sizeof (struct in_addr)];\n};\n\nstruct in_addr\n{\n\tin_addr_t s_addr;\n};\n\nstruct sockaddr_in6\n{\n    sa_family_t sin6_family;\n    in_port_t sin6_port; /* Transport layer port # */\n    uint32_t sin6_flowinfo; /* IPv6 flow information */\n    struct in6_addr sin6_addr; /* IPv6 address */\n    uint32_t sin6_scope_id; /* IPv6 scope-id */\n};\n\ntypedef unsigned short uint16_t;\ntypedef unsigned int uint32_t;\ntypedef uint16_t in_port_t;\ntypedef uint32_t in_addr_t;\n#define __SOCKADDR_COMMON_SIZE (sizeof (unsigned short int))\n~~~\n\n**所有专用 socket 地址（以及 sockaddr_storage）类型的变量在实际使用时都需要转化为通用 socket 地 址类型 sockaddr（强制转化即可），因为所有 socket 编程接口使用的地址参数类型都是 sockaddr。需要做到兼容**\n\n## IP地址转换（字符串ip-整数 ，主机、网络字节序的转换）\n\n通常，人们习惯用可读性好的字符串来表示 IP 地址，比如用点分十进制字符串表示 IPv4 地址，以及用 十六进制字符串表示 IPv6 地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录 日志时则相反，我们要把整数表示的 IP 地址转化为可读的字符串。下面 3 个函数可用于用点分十进制字 符串表示的 IPv4 地址和用网络字节序整数表示的 IPv4 地址之间的转换：\n\n**这个是旧的函数，只能适用于IPv4地址，可以使用但是不建议**\n\n~~~cpp\n#include <arpa/inet.h>\n// 这个数字转化过来之后是网络字节序，就是大端\nin_addr_t inet_addr(const char *cp); \n// 第二个参数是传出参数，保存转换后的结果，返回值 1 成功，0 失败，字符串非法，不设置错误号\nint inet_aton(const char *cp, struct in_addr *inp); \nchar *inet_ntoa(struct in_addr in);\n~~~\n\n**下面这对更新的函数也能完成前面 3 个函数同样的功能，并且它们同时适用 IPv4 地址和 IPv6 地址：(推荐使用这里的新的api)**\n\n~~~cpp\n#include <arpa/inet.h>\n// p:点分十进制的IP字符串，n:表示network，网络字节序的整数\nint inet_pton(int af, const char *src, void *dst);\n    // af:地址族： AF_INET AF_INET6\n    // src:需要转换的点分十进制的IP字符串\n    // dst:转换后的结果保存在这个里面，是一个传出参数\n    // 将网络字节序的整数，转换成点分十进制的IP地址字符串\n    // 返回值：1 成功 ；失败 0 或者 -1，0表示传入的点分制字符串不合理invalid，不设置errno；-1表示错误(比如地址族内容不合理)，并且设置errno\nconst char *inet_ntop(int af, const void *src, char *dst, socklen_t size);\n    // af:地址族： AF_INET AF_INET6\n    // src: 要转换的ip的整数的地址\n    // dst: 转换成IP地址字符串保存的地方\n    // size：第三个参数的大小（数组的大小）\n    // 返回值：返回转换后的数据的地址（字符串），和 dst 是一样的\n~~~\n\n我们写代码来巩固：\n\n~~~cpp\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n\nint main() {\n    // 创建一个IP字符串\n    const char* buf = \"192.168.1.4\";\n\n    in_addr_t num;\n    // 其实这里给包装他的结构体 in_addr 也是可以的，因为函数要求传入的是指针，还是 void* ，脏活系统API帮我们干完了都\n\n    // 将点分十进制的IP字符串转换为网络字节序的整数\n    inet_pton(AF_INET, buf, &num);\n\n    unsigned char* p = (unsigned char*)&num;\n    // 转化之后的结果应该是数字高位192存放在地址低位，就是大端字节序，所以结果应该是192.168.1.4\n    printf(\"%u %u %u %u\\n\", *p, *(p + 1), *(p + 2), *(p + 3));\n\n    // 将网络字节序的IP整数转换为字符串形式\n    // 字符串形式的IP地址最多多少个字节，一个字符一个字节，然后数字每个最多3位，3个点，加起来就是15，然后\\0符，定义16就行\n    char ip_str[16] = {0};\n    const char* ans = inet_ntop(AF_INET, &num, ip_str, sizeof(ip_str) - 1);\n\n    printf(\"ans : %s\\n\", ans);\n    printf(\"ip_str : %s\\n\", ip_str);\n    printf(\"%d\\n\", ip_str == ans);\n\n    return 0;\n}\n~~~\n\n**注意字符串形式的IP地址和数字形式的IP地址的字节数的区别和计算方法，注意不要弄混了!!!**\n\n## TCP通信流程\n\n~~~cpp\n// TCP 和 UDP -> 传输层的协议\n    UDP:用户数据报协议，面向无连接，可以单播，多播，广播， 面向数据报，不可靠\n    TCP:传输控制协议，面向连接的，可靠的，基于字节流，仅支持单播传输(端对端)\n    \t\t\t\t      UDP \t\t\t\t\t\t\t\tTCP\n    是否创建连接 \t\t\t 无连接 \t\t\t\t\t\t\t面向连接\n    是否可靠 \t\t\t   不可靠 \t\t\t\t  \t\t\t  可靠的\n    连接的对象个数 \t\t 一对一、一对多、多对一、多对多       支持一对一\n    传输的方式 \t\t\t  面向数据报 \t\t\t\t\t   面向字节流\n    首部开销 \t\t       8个字节 \t\t\t\t\t     最少20个字节\n    适用场景 \t\t       实时应用（视频会议，直播） \t  可靠性高的应用（文件传输）\n~~~\n\n![image-20230818143501064](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818143501064.png)\n\n~~~cpp\n// TCP 通信的流程\n// 服务器端 （被动接受连接的角色）\n    1. 创建一个用于监听的套接字\n        - 监听：监听有客户端的连接\n        - 套接字：这个套接字其实就是一个文件描述符\n    2. 将这个监听文件描述符和本地的IP和端口绑定（IP和端口就是服务器的地址信息）\n    \t- 客户端连接服务器的时候使用的就是这个IP和端口\n    3. 设置监听，监听的fd开始工作\n    4. 阻塞等待，当有客户端发起连接，解除阻塞，接受客户端的连接，会得到一个和客户端通信的套接字(fd)\n    5. 通信\n        - 接收数据\n        - 发送数据\n    6. 通信结束，断开连接\n~~~\n\n~~~cpp\n// 客户端\n    1. 创建一个用于通信的套接字（fd）\n    2. 连接服务器，需要指定连接的服务器的 IP 和 端口\n    3. 连接成功了，客户端可以直接和服务器通信\n        - 接收数据\n        - 发送数据\n    4. 通信结束，断开连接\n~~~\n\n## 套接字函数\n\n~~~cpp\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <arpa/inet.h> // 包含了这个头文件，上面两个就可以省略\n\nint socket(int domain, int type, int protocol);\n    - 功能：创建一个套接字\n    - 参数：\n    - domain: 协议族\n        AF_INET : ipv4\n        AF_INET6 : ipv6\n        AF_UNIX, AF_LOCAL : 本地套接字通信（进程间通信）\n\t// 第二个参数type和第三个参数protocol一个是协议类型，一个是具体的某个协议，划分的还比较细和周到\n    - type: 通信过程中使用的协议类型\n        SOCK_STREAM : 流式协议(例如：字节流的TCP，当然不一定只有这一种，可以被第三个参数具体指定)\n        SOCK_DGRAM : 报式协议(例如：用户数据报的UDP，当然不一定只有这一种，可以被第三个参数具体指定)\n    - protocol : 具体的一个协议。一般写0，可以表示默认的或者当协议类型中只有一个具体类型的时候就是用这个具体的类型\n        - SOCK_STREAM : 流式协议默认使用 TCP\n        - SOCK_DGRAM : 报式协议默认使用 UDP\n    - 返回值：\n        - 成功：返回文件描述符，操作的区域是内核缓冲区。\n        - 失败：-1，并且设置errno\nint bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); // socket命名\n    - 功能：绑定，将 fd 和 本地的IP + 端口 port 进行绑定\n    - 参数：\n        - sockfd : 通过socket函数得到的文件描述符\n        - addr : 需要绑定的socket地址，这个地址封装了ip和端口号的信息\n        - addrlen : 第二个参数结构体占的内存大小\nint listen(int sockfd, int backlog); // /proc/sys/net/core/somaxconn\n    - 功能：监听这个socket上的连接\n    - 参数：\n        - sockfd : 通过socket()函数得到的文件描述符\n        - backlog : 连接请求等待队列的长度，表示最多有多少个连接请求排队，并不是服务端最多可以连接通信的个数，因为出队列之后就可以进行通信，这个时候请求队列减一恢复了\nint accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n    - 功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接\n    - 参数：\n        - sockfd : 用于监听的文件描述符\n        - addr : 传出参数，记录了连接成功后客户端的地址信息（ip，port），注意是客户端，这个信息是系统给我的，我获得的\n        - addrlen : 指定第二个参数的对应的内存大小\n    - 返回值：\n        - 成功 ：用于通信的文件描述符\n        - -1 ： 失败，设置errno\n\nint connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);\n    - 功能： 客户端连接服务器\n    - 参数：\n        - sockfd : 用于通信的文件描述符\n        - addr : 客户端要连接的服务器的地址信息，这个信息是我给的，表示我要和谁进行连接\n        - addrlen : 第二个参数的内存大小\n    - 返回值：成功 0， 失败 -1，设置errno\nssize_t write(int fd, const void *buf, size_t count); // 写数据\nssize_t read(int fd, void *buf, size_t count); // 读数据\n~~~\n\n### 示例\n\n我们写一个例子，就是客户端可以从键盘读入字符串，发送给服务端，然后服务端原封不动的返回给客户端\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define IPV4_STRING_MAX 16\n#define MAX_SIZE 1024\n\n// 回射服务器，客户端发送什么服务端就返回什么\nint main(int argc, char const* argv[]) {\n    // 判断命令行参数个数\n    if (argc != 3) {\n        printf(\"usage : %s  <ip_address>  <port>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const short server_port = atoi(argv[2]);  // atoi()函数可以把合理的字符串转化为整数\n\n    // 1.创建socket\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.绑定IP和端口号\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(server_port);  // 注意从主机字节序转换为网络字节序\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    // 3.开始监听\n    ret = listen(listen_fd, 8);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    // 4.接受连接请求\n    struct sockaddr_in client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n    int connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n    if (-1 == connect_fd) {\n        perror(\"accept\");\n        return -1;\n    }\n\n    // 打印连接的客户端的信息\n    char client_ip[IPV4_STRING_MAX] = {0};\n    inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip, sizeof(client_ip));\n    printf(\"client has connected , ip : %s , port : %d\\n\", client_ip, ntohs(client_addr.sin_port));\n\n    // 5.开始通信\n    // 我们的要求是客户端发送什么，服务端都返回相同的值\n    char buf[MAX_SIZE] = {0};\n    while (1) {\n        bzero(buf, sizeof(buf));\n        // 读数据\n        int len = read(connect_fd, buf, sizeof(buf) - 1);\n        if (-1 == len) {\n            perror(\"read\");\n            return -1;\n        }\n        if (len > 0)\n            printf(\"recv data : %s\", buf);\n        else if (0 == len) {  // 客户端断开连接\n            printf(\"client closed...\\n\");\n            break;\n        }\n\n        // 写数据\n        write(connect_fd, buf, strlen(buf));\n    }\n\n    // 6.关闭连接\n    close(connect_fd);\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_SIZE 1024\n\nstatic int count = 0;\n\nint main(int argc, char const* argv[]) {\n    // 判断命令行参数个数\n    if (argc != 3) {\n        printf(\"usage : %s  <ip_address>  <port>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const short server_port = atoi(argv[2]);  // atoi()函数可以把合理的字符串转化为整数\n\n    // 1.创建socket\n    int connect_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == connect_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.建立连接\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // 端口号\n    server_addr.sin_port = htons(server_port);\n    // IP地址\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n\n    int ret = connect(connect_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"connect\");\n        return -1;\n    }\n    // 连接成功，输出信息\n    printf(\"connected successfully , waiting for communication.\\n\");\n\n    // 3.开始通信\n    // 我们要求客户端可以从键盘录入值进行通信\n    char buf[MAX_SIZE] = {0};\n    while (1) {\n        bzero(buf, sizeof(buf));\n        // 写数据\n        fgets(buf, sizeof(buf), stdin);  \n        // 这里有一个问题，服务器在阻塞读的时候服务端如果强制退出比如 ctrl + c，就会出问题，这样客户端不会停止，因为他还在写的部分阻塞，没有在读的部分，但是问题不大，因为实际开发当中我们不会对服务器做这样的操作\n\n        // 增加退出功能\n        if (strcmp(buf, \"quit\\n\") == 0 || strcmp(buf, \"QUIT\\n\") == 0)\n            return 0;\n\n        printf(\"send : %s\", buf);\n        write(connect_fd, buf, strlen(buf));\n\n        // 读数据\n        bzero(buf, sizeof(buf));\n        int len = read(connect_fd, buf, sizeof(buf) - 1);\n        if (-1 == len) {\n            perror(\"len\");\n            return -1;\n        }\n        if (len > 0)\n            printf(\"recv : %s\", buf);\n\n        else if (0 == len) {\n            // 服务端关闭了\n            printf(\"server closed...\\n\");\n            break;\n        }\n    }\n\n    // 4.关闭连接\n    close(connect_fd);\n\n    return 0;\n}\n~~~\n\n**其中为什么read()的结果为0的时候就表示对方关闭了呢？**\n\n**首先对方是写端，我们是读端，如果对方关闭的话，read()会返回0表示读到文件末尾，也就是表示对方关闭了，和管道的操作非常类似**\n\n**总结：**\n\n- **读管道：**\n  - **管道中有数据，读取会返回实际读到的字节数**\n  - **管道中无数据：**\n    - **写端全部关闭，read返回0(相当于读到文件的末尾)**\n    - **写端没有完全关闭，read阻塞等待**\n- **写管道：**\n  - **管道读端全部关闭，产生信号SIGPIPE，进程异常终止**\n  - **管道读端没有全部关闭：**\n    - **管道已满，write阻塞**\n    - **管道没有满，write将数据写入，并返回实际写入的字节数**\n\n当然上面的代码还有点小问题，如图所示，后续修改\n\n## TCP三次握手\n\nTCP 是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如 IP 地址、端口号等。\n\nTCP 可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在 TCP 头部。\n\nTCP 提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用四次挥手来关闭一个连接。\n\n**三次握手的目的是保证了双方互相之间建立了连接。**\n\n**三次握手发生在客户端连接的时候，当调用connect()的时候，底层会通过TCP协议进行三次握手。**\n\n![image-20230818175354581](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818175354581.png)\n\n- 16 位端口号（port number）：告知主机报文段是来自哪里（源端口）以及传给哪个上层协议或 应用程序（目的端口）的。进行 TCP 通信时，客户端通常使用系统自动选择的临时端口号。\n- 32 位序号（sequence number）：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输 方向上的字节流的每个字节的编号。假设主机 A 和主机 B 进行 TCP 通信，A 发送给 B 的第一个 TCP 报文段中，序号值被系统初始化为某个随机值 ISN（Initial Sequence Number，初始序号 值）。那么在该传输方向上（从 A 到 B），后续的 TCP 报文段中序号值将被系统设置成 ISN 加上 该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个 TCP 报文段传送的数据是字 节流中的第 1025 ~ 2048 字节，那么该报文段的序号值就是 ISN + 1025。另外一个传输方向（从 B 到 A）的 TCP 报文段的序号值也具有相同的含义。 \n- 32 位确认号（acknowledgement number）：用作对另一方发送来的 TCP 报文段的响应。其值是 收到的 TCP 报文段的序号值 + 标志位长度（SYN，FIN） + 数据长度 。假设主机 A 和主机 B 进行 TCP 通信，那么 A 发送出的 TCP 报文段不仅携带自己的序号，而且包含对 B 发送来的 TCP 报文段 的确认号。反之，B 发送出的 TCP 报文段也同样携带自己的序号和对 A 发送来的报文段的确认序 号。 \n- 4 位头部长度（head length）：标识该 TCP 头部有多少个 32 bit(4 字节)。因为 4 位最大能表示 15，所以 TCP 头部最长是60 字节。\n- 6 位标志位包含如下几项：\n  - URG 标志，表示紧急指针（urgent pointer）是否有效。 \n  - ACK 标志，表示确认号是否有效。我们称携带 ACK 标志的 TCP 报文段为确认报文段。 PSH 标志，提示接收端应用程序应该立即从 TCP 接收缓冲区中读走数据，为接收后续数据腾 出空间（如果应用程序不将接收到的数据读走，它们就会一直停留在 TCP 接收缓冲区中）。 \n  - RST 标志，表示要求对方重新建立连接。我们称携带 RST 标志的 TCP 报文段为复位报文段。 \n  - SYN 标志，表示请求建立一个连接。我们称携带 SYN 标志的 TCP 报文段为同步报文段。 \n  - FIN 标志，表示通知对方本端要关闭连接了。我们称携带 FIN 标志的 TCP 报文段为结束报文 段。 \n  - 16 位窗口大小（window size）：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收 通告窗口（Receiver Window，RWND）。它告诉对方本端的 TCP 接收缓冲区还能容纳多少 字节的数据，这样对方就可以控制发送数据的速度。 \n  - 16 位校验和（TCP checksum）：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以校验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。 这也是 TCP 可靠传输的一个重要保障。 \n  - 16 位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一 个紧急数据的下一个字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。\n\n![image-20230818175513668](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818175513668.png)\n\n![image-20230819113154633](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819113154633.png)\n\n### 类比\n\n我们用男女朋友的例子来进行举例，画图如下：\n\n![image-20230819103736969](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819103736969.png)\n\n男生向女生说能不能做我女朋友，女生说可以，但是这个时候女生不放心，需要问男生能不能做自己的男朋友，为了进行确认；男生回复可以，双方都表示愿意做男女朋友，也就是双方都要确认对方和自己能够建立连接并且能够发送消息和收到消息，这才能保证整个TCP连接的可靠性，这也是为什么TCP连接需要建立连接\n\n### 为什么需要三次握手而不是两次握手？\n\n**为了能够建立起可靠的连接，客户端和服务端双方都必须各自确认一些信息才能保证整个连接是可靠的，就是确认双方都能接受和发送消息，好，我们一次一次来看**\n\n- **第一次客户端发送SYN=1的请求连接消息，这个时候客户端能够确认自己的发送数据没有问题；服务端收到请求连接消息之后能够确认自己的接收数据没有问题，并且还能够确认客户端的发送数据没有问题**\n- **第二次服务端发送ACK=1 SYN=1的确认信息，服务端能够确认自己的发送数据没有问题，客户端收到服务端的消息之后能够确认服务端的发送数据没有问题，并且由于这条消息是因为客户端发送请求，服务端回复的，因此客户端还能确认服务端的收到数据没有问题，至此，客户端已经能够完全确认自己和服务端收发数据都没有问题了**\n- **但是我们现在观察服务端，他还没有办法确认客户端接收数据有没有问题，因为服务端还没有收到客户端的回复报文，因此我们需要第三次握手，客户端针对上一条确认报文在发送一条确认报文，这个时候服务端才能完全确认所有都没问题，换句话说，这个连接才是可靠的!!!**\n\n## TCP滑动窗口\n\n滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包， 谁也发不了数据，所以就有了滑动窗口机制来解决此问题。滑动窗口协议是用来改善吞吐量的一种 技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包 （称窗口尺寸）。 \n\nTCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于 接收数据。发送**方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报。 \n\n滑动窗口是 TCP 中实现诸如 ACK 确认、流量控制、拥塞控制的承载结构。\n\n窗口理解为缓冲区的大小\n\n滑动窗口的大小会随着发送数据和接收数据而变化\n\n通信的双方都有发送缓冲区和接受缓冲区\n\n- 服务器：\n  - 发送缓冲区  (发送缓冲区的窗口)\n  - 接受缓冲区  (接受缓冲区的窗口)\n- 客户端：\n  - 发送缓冲区  (发送缓冲区的窗口)\n  - 接受缓冲区  (接受缓冲区的窗口)\n\n![image-20230818175617550](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818175617550.png)\n\n~~~cpp\n发送方的缓冲区：\n    白色格子：空闲的空间\n    灰色格子：数据已经被发送出去了，但是还没有被接受\n   \t紫色格子：还没有发送出去的数据\n    \n接受方的缓冲区：\n    白色格子：空闲的空间\n    紫色格子：已经接收到的数据\n~~~\n\n![image-20230818175628648](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818175628648.png)\n\n~~~cpp\n# mss : Maximum Segment Size(一条数据最大的数据量)\n# win : 滑动窗口\n\n1.客户端向服务器发送连接，客户端的滑动窗口是4096，一次发送的最大数据量是1460\n2.服务器接受连接请求，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024\n3.第三次握手\n4.4-9 客户端连续给服务器发送了6k的数据，每次发送1k\n5.第10次，服务器告诉客户端：发送的6k数据已经接收到，存储在缓冲区中，缓冲区数据已经处理了2k，窗口大小是2k\n6.第10次，服务器告诉客户端：发送的6k数据已经接收到，存储在缓冲区中，缓冲区数据已经处理了4k，窗口大小是4k\n7.第12次，客户端给服务器发送了1k的数据\n8.第13次，客户端主动请求和服务端断开连接，并且给服务器发送1k的数据\n9.第14次，服务器回复ACK 8194，同意客户端断开连接的请求，并且告诉客户端已经接收到刚才的2k的数据，并且指出滑动窗口的大小\n10.第15，16次，通知客户端滑动窗口的大小\n11.第17次，第三次挥手，服务端给客户端发送FIN，请求断开连接\n12.第18次，第四次挥手，客户端同意了服务端的断开连接请求\n~~~\n\n## TCP四次挥手\n\n**四次挥手发生在断开连接的时候，在程序中当调用close()会使用TCP协议进行4次挥手。**\n\n**客户端和服务端都可以主动发起断开连接，谁先调用close()谁就先发起**\n\n**因为在TCP连接的时候，采用三次握手建立的连接是双向的，因此在断开的时候也需要双向断开，这就是为什么需要四次挥手**\n\n![image-20230818175657616](https://cdn.davidingplus.cn/images/2025/01/31/image-20230818175657616.png)\n\n### 类比\n\n还是用男女的例子来举例：\n\n**客户端向服务端发出断开连接请求FIN，服务端接受请求，并返回确认，至此，客户端向服务端方向的数据传输就断开了；但是服务端仍可以向客户端发送数据，当发送数据完毕之后(或者不发)服务端向客户端发送断开连接请求FIN，客户端接受请求，然后返回针对该请求报文的确认，至此服务端向客户端方向的数据传输断开，该TCP连接就此关闭**\n\n![image-20230819150618612](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819150618612.png)\n\n那我们想一下，第二步和第三步能不能合起来呢？也就是：\n\n### 为什么要四次挥手而不是三次挥手？\n\n**我个人的理解是，首先前两步和后两步的工作是不同的，前两步是针对客户端向服务端释放连接的(在这里是客户端先释放连接)，后两步是针对服务端向客户端释放连接，功能不同，针对不同；其次，在第三步服务端发出释放连接请求之前，服务端还可以但单方面的向客户端发送数据，这时客户端虽然不能发送数据，但是仍可以接受服务端发送的数据，服务端很可能还有没有发送完毕的数据想要发送，因为这个释放连接的请求是客户端提出的，这样两个步骤就必须分开了**\n\n## TCP通信并发\n\n### 多进程实现并发服务器\n\n**要实现TCP通信服务器并发的任务，使用多线程或者多进程解决**\n\n**思路：**\n\n- **一个父进程，多个子进程**\n- **父进程负责等待并且接受客户端的连接**\n- **子进程负责完成通信，接受一个客户端连接，创建一个子进程用于通信**\n\n以下是代码：\n\n完成的功能是，服务端可以接受多个客户端的连接，然后客户端键入数据，服务端返回相同的数据\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <signal.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#define MAX_IPV4_STRING 16\n#define MAXSIZE 1024\n\nvoid Recycle_Callback(int signum) {\n    while (1) {\n        // 第二个参数可以用来获取子进程退出的状态\n        int ret = waitpid(-1, nullptr, WNOHANG);\n        if (-1 == ret)\n            //-1表示回收错误，也就是没有子进程了，为了达到这个判断，我们使用非阻塞的，因为阻塞的他会阻塞\n            return;\n        else if (0 == ret)  // 0在非阻塞的情况下代表还有子进程活着，重开循环把结束的子进程尽可能都回收\n            continue;\n        else if (ret > 0)\n            // 回收了某个子进程\n            printf(\"child process (pid %d) has be recycled.\\n\", ret);\n    }\n}\n\n// 接受多个客户端的连接，这个程序用多进程来处理\nint main(int argc, char const* argv[]) {\n    // 创建出来子进程父进程需要对其进行回收的操作，但是wait()或者waitpid()无论是阻塞还是非阻塞的情况都没办法实现我们想要的操作\n    // 所以想到捕捉信号SIGCHID\n    struct sigaction sig_child;\n    sig_child.sa_flags = 0;\n    sigemptyset(&sig_child.sa_mask);  // 不阻塞任何临时的信号\n    sig_child.sa_handler = Recycle_Callback;\n\n    sigaction(SIGCHLD, &sig_child, nullptr);\n\n    // 命令行参数\n    if (argc != 3) {\n        printf(\"usage : %s  <ip_address>  <port>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const int server_port = atoi(argv[2]);\n\n    // 1.创建socket套接字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.将套接字绑定IP和端口\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // 端口，注意转换字节序\n    server_addr.sin_port = htons(server_port);\n    // IP\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    // 3.开始监听\n    ret = listen(listen_fd, 5);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    // 不断循环等待客户端连接\n    while (1) {\n        // 4.接受请求\n        struct sockaddr_in client_addr;\n        socklen_t client_addr_len = sizeof(client_addr);\n        int connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n        if (-1 == connect_fd) {\n            if (errno == EINTR)\n                // 说明产生了信号发生了软中断，执行回来accept()就不阻塞了，这是预料之内的状态，我们对其进行细微处理\n                continue;\n            perror(\"accept\");\n            return -1;\n        }\n\n        // 5.开始通信，在子进程中进程通信\n        pid_t pid = fork();\n        if (-1 == pid) {\n            perror(\"fork\");\n            return -1;\n        }\n        if (0 == pid) {  // 子进程\n            //  输出连接的客户端的IP和端口\n            char client_ip[MAX_IPV4_STRING] = {0};\n            inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip, sizeof(client_ip));\n            in_port_t client_port = ntohs(client_addr.sin_port);\n            printf(\"one client has connected , ip : %s , port : %d\\n\", client_ip, client_port);\n\n            // 处理数据，接受客户端的数据并且相同返回\n            char buf[MAXSIZE] = {0};\n            while (1) {\n                // 读\n                bzero(buf, sizeof(buf));\n                int len = read(connect_fd, buf, sizeof(buf) - 1);  // 这里老师提到要注意\\0，我这么做也是可以的，我在读的时候留出\\0的空间，写的时候我全部写入，这样我的buf最后肯定是有\\0的\n                if (-1 == len) {\n                    perror(\"read\");\n                    return -1;\n                }\n                if (len > 0)\n                    printf(\"recv client (ip : %s , port : %d) data : %s\", client_ip, client_port, buf);\n                else if (0 == pid) {\n                    // 写端断开连接，子进程任务结束，退出\n                    printf(\"client (ip : %s , port : %d) has closed...\\n\", client_ip, client_port);\n                    close(connect_fd);\n                    goto FINAL;  // 跳转到程序结束的位置\n                }\n\n                // 写\n                write(connect_fd, buf, strlen(buf));\n            }\n        } else if (pid > 0)  // 父进程\n            continue;\n    }\n\n    // 6.断开连接\nFINAL:\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n执行结果如下：\n\n直截取了服务端的图片\n\n![image-20230819170952283](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819170952283.png)\n\n**服务器的代码涉及到两个问题：**\n\n- **为了防止僵尸进程，服务端的父进程必须对所有的子进程进行回收，那么如何有效的对子进程进行回收？**\n\n  **父进程是在不断的阻塞等待客户端的连接，调用accept()函数，在这里如果回收子进程是非常不好的，所以我们结合子进程结束会发出SIGCHID信号，这个信号默认被父进程忽略，但是我们捕捉这个信号，然后开启软中断，就可以对子进程进行回收了**\n\n  **我们可以调用waitpid()函数对所有的子进程进行回收，但是一次只能回收一个所以需要while(1)，然后由于我们需要判断没有子进程可以回收的状态以此来跳出中断，因此我们使用非阻塞的waitpid()，当服务端结束的时候，对应的子进程也结束，我的非阻塞的waitpid()就尽可能的把已经结束的子进程给全部回收掉了，避免僵尸进程的出现**\n\n- **那么这样的话我们执行就会出现第二个问题，如下：**\n\n  **当我一个子进程结束的时候，父进程中断处理之后，应该回到原来accept()的状态，但是这时accept()报错了**\n\n  **![image-20230819172037175](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819172037175.png)**\n\n  **是什么原因呢？**\n\n  **因为accpt()这里软中断结束之后，会从阻塞中断变成非阻塞的，然后没有客户端连接，就报错了，程序结束，errno被设置为EINTR**\n\n  **![image-20230819172505207](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819172505207.png)**\n\n  **所以这里我们判断一下errno的值特殊处理就好了**\n\n客户端代码基本没变，所以不用深究\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_SIZE 1024\n\nstatic int count = 0;\n\nint main(int argc, char const* argv[]) {\n    // 判断命令行参数个数\n    if (argc != 3) {\n        printf(\"usage : %s  <ip_address>  <port>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const short server_port = atoi(argv[2]);  // atoi()函数可以把合理的字符串转化为整数\n\n    // 1.创建socket\n    int connect_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == connect_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.建立连接\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // 端口号\n    server_addr.sin_port = htons(server_port);\n    // IP地址\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n\n    int ret = connect(connect_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"connect\");\n        return -1;\n    }\n    // 连接成功，输出信息\n    printf(\"connected successfully , waiting for communication.\\n\");\n\n    // 3.开始通信\n    // 我们要求客户端可以从键盘录入值进行通信\n    char buf[MAX_SIZE] = {0};\n    while (1) {\n        bzero(buf, sizeof(buf));\n        // 写数据\n        fgets(buf, sizeof(buf), stdin);  // 这里有一个问题，服务器在阻塞读的时候服务端如果强制退出比如 ctrl + c，就会出问题，这样客户端不会停止，因为他还在写的部分阻塞，没有在读的部分，但是问题不大，因为实际开发当中我们不会对服务器做这样的操作\n\n        // 增加退出功能\n        if (strcmp(buf, \"quit\\n\") == 0 || strcmp(buf, \"QUIT\\n\") == 0)\n            return 0;\n\n        printf(\"send : %s\", buf);\n        write(connect_fd, buf, strlen(buf));\n\n        // 读数据\n        bzero(buf, sizeof(buf));\n        int len = read(connect_fd, buf, sizeof(buf) - 1);\n        if (-1 == len) {\n            perror(\"len\");\n            return -1;\n        }\n        if (len > 0)\n            printf(\"recv : %s\", buf);\n        else if (0 == len) {\n            // 服务端关闭了\n            printf(\"server has closed...\\n\");\n            break;\n        }\n    }\n\n    // 4.关闭连接\n    close(connect_fd);\n\n    return 0;\n}\n~~~\n\n### 多线程实现并发服务器\n\n服务端的代码需要注意一些细节：\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <pthread.h>\n#include <unistd.h>\n\n#define MAXSIZE 1024\n#define MAX_IPV4_STRING 16\n#define MAX_INFO_SIZE 128\n\n// 封装一个结构体来保存需要传给子线程的信息\nstruct Pthread_Info {\n    int _connect_fd;                  // 用于通信的文件描述符\n    struct sockaddr_in _client_addr;  // 客户端的socket地址信息\n} p_infos[MAX_INFO_SIZE];\n\n// 定义一个这个数组的计数器\nint count = 0;\n\n// 线程处理的回调函数\nvoid* Communicate_Callback(void* args) {\n    // 接受参数得到通信用到的信息\n    int connect_fd = ((Pthread_Info*)args)->_connect_fd;\n    struct sockaddr_in client_addr = ((Pthread_Info*)args)->_client_addr;\n\n    in_port_t client_port = ntohs(client_addr.sin_port);\n\n    char client_ip[MAX_IPV4_STRING] = {0};\n    inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip, sizeof(client_ip));\n    printf(\"one client has connected , ip : %s , port : %d\\n\", client_ip, client_port);\n\n    // 开始通信\n    char buf[MAXSIZE] = {0};\n    while (1) {\n        // 读\n        bzero(buf, sizeof(buf));\n        int len = read(connect_fd, buf, sizeof(buf) - 1);\n        if (-1 == len) {\n            perror(\"read\");\n            return (void*)-1;\n        }\n        if (len > 0)\n            printf(\"recv client ( ip : %s , port : %d ) data : %s\", client_ip, client_port, buf);\n        else if (0 == len) {  // 写端关闭，也就是客户端关闭连接，才会返回0\n            printf(\"client ( ip : %s , port : %d ) has closed...\\n\", client_ip, client_port);\n            close(connect_fd);\n            printf(\"child thread has closed , tid : %ld\\n\", pthread_self());\n\n            // // 释放堆上的这块内存\n            // delete args;\n\n            return nullptr;\n        }\n\n        // 写\n        write(connect_fd, buf, strlen(buf));\n    }\n\n    // // 释放堆上的这块内存\n    // delete args;\n\n    return nullptr;\n}\n\n// 用多线程实现服务器并发\nint main(int argc, char const* argv[]) {\n    // 初始化数据\n    int size = sizeof(p_infos) / sizeof(p_infos[0]);\n    for (int i = 0; i < size; ++i) {\n        // 将所有的都初始化为0\n        bzero(&p_infos[i], sizeof(p_infos[i]));\n        // 文件描述符初始化为-1，不能让他占据正在使用的\n        p_infos[i]._connect_fd = -1;\n    }\n\n    // 命令行参数\n    if (argc != 3) {\n        printf(\"usage : %s  <ip_address>  <port>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const unsigned short server_port = atoi(argv[2]);\n\n    // 1.创建socket套接字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.绑定IP和端口\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // 端口\n    server_addr.sin_port = htons(server_port);\n    // IP\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    // 3.监听\n    ret = listen(listen_fd, 5);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    printf(\"server has initialized...\\n\");\n\n    // 4.接受客户端请求\n    while (1) {\n        // 思路：主线程不断接受客户端请求，然后创建子线程和客户端进行通信\n        struct sockaddr_in client_addr;\n        socklen_t client_addr_len = sizeof(client_addr);\n        int connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n        if (-1 == connect_fd) {\n            perror(\"accept\");\n            return -1;\n        }\n\n        // 这里是局部变量，为了保证循环一次不会被释放，我们选择其他的方式\n        // 我们可以选择用堆来存储，但是一是客户端数量多了没有办法进行限制，而是还要处理释放并且消耗资源大，所以我们可以开一个全局数组\n\n        struct Pthread_Info& p_info = p_infos[count++];  // 创建数组成员的引用别名\n        if (count >= MAX_INFO_SIZE) {\n            // 超出最大客户端连接数量\n            printf(\"client oversize , closing...\\n\");\n            return 0;\n        }\n        p_info._connect_fd = connect_fd;\n        p_info._client_addr = client_addr;  // 这个系统类实现了copy assignment，实现了深拷贝\n\n        // 5.开始通信\n        pthread_t tid;\n        pthread_create(&tid, nullptr, Communicate_Callback, &p_info);\n        // 将子线程分离，不用手动回收\n        pthread_detach(tid);\n    }\n\n    // 6.关闭连接\n    close(listen_fd);\n\n    // 退出主线程，这里就这么写吧，主线程不可能比子线程早结束，因为主线程要等待\n    pthread_exit(nullptr);\n\n    return 0;\n}\n~~~\n\n客户端的代码基本没变，可以不用深究\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAXSIZE 1024\n\nint main(int argc, char const* argv[]) {\n    // 命令行\n    if (argc != 3) {\n        printf(\"usage : %s  <ip_address>  <port>\\n\", argv[0]);\n        return -1;\n    }\n\n    const char* server_ip = argv[1];\n    const unsigned short server_port = atoi(argv[2]);\n\n    // 1.创建socket套接字\n    int connect_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == connect_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.建立连接\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // 端口\n    server_addr.sin_port = htons(server_port);\n    // IP\n    inet_pton(AF_INET, server_ip, &server_addr.sin_addr.s_addr);\n\n    int ret = connect(connect_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"connect\");\n        return -1;\n    }\n\n    printf(\"connected successfully , waiting for communicating.\\n\");\n\n    char buf[MAXSIZE] = {0};\n    // 3.开始通信\n    while (1) {\n        // 写\n        bzero(buf, sizeof(buf));\n        fgets(buf, sizeof(buf), stdin);\n\n        // 增加退出功能\n        if (strcmp(buf, \"quit\\n\") == 0 || strcmp(buf, \"QUIT\\n\") == 0)\n            return 0;\n\n        write(connect_fd, buf, strlen(buf));\n        printf(\"send : %s\", buf);\n\n        // 读\n        bzero(buf, sizeof(buf));\n        int len = read(connect_fd, buf, sizeof(buf) - 1);\n        if (-1 == len) {\n            perror(\"read\");\n            return -1;\n        }\n        if (len > 0)\n            printf(\"recv : %s\", buf);\n        else if (0 == len) {  // 说明写端关闭，也就是服务端关闭\n            printf(\"server has closed...\\n\");\n            break;\n        }\n    }\n\n    // 4.关闭连接\n    close(connect_fd);\n\n    return 0;\n}\n~~~\n\n## TCP状态转换\n\n![image-20230819153502987](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819153502987.png)\n\n![image-20230819153510357](https://cdn.davidingplus.cn/images/2025/01/31/image-20230819153510357.png)\n\n### 2MSL（Maximum Segment Lifetime） \n\n**主动断开连接的一方, 最后进出入一个 TIME_WAIT 状态, 这个状态会持续: 2msl** \n\n- msl: 官方建议: 2分钟, 实际是30s\n  当 TCP 连接主动关闭方接收到被动关闭方发送的 FIN 和最终的 ACK 后，连接的主动关闭方 必须处于TIME_WAIT 状态并持续 2MSL 时间。 \n  **这样就能够让 TCP 连接的主动关闭方在它发送的 ACK 丢失的情况下重新发送最终的 ACK。 为了让被动关闭方第三次挥手的FIN应该获得的第四次挥手的ACK能够正确到达，如果最后一次ACK丢失了被动关闭方会及时再次发送第三次的FIN让主动关闭方发送ACK来确认关闭，否则直接关闭就没办法让被动关闭方确认了，也就是关闭的不完整**\n  主动关闭方重新发送的最终 ACK 并不是因为被动关闭方重传了 ACK（它们并不消耗序列号， 被动关闭方也不会重传），而是因为被动关闭方重传了它的 FIN。事实上，被动关闭方总是 重传 FIN 直到它收到一个最终的 ACK。 \n\n### 半关闭\n\n**在四次挥手关闭的过程中主动断开连接方收到了两次被动连接方的报文，第一个是第二次挥手的ACK确认，第二个是第三次挥手的FIN请求，为什么叫FIN_WAIT_1和FIN_WAIT_2？就是因为第一次主动断开连接方发送FIN请求后等待ACK确认，然后第二次就主动等待被动连接方的FIN请求，最后就进入TIME_WAIT状态，这么说了理解得更透彻，参照下图理解**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230821093427390.png\" alt=\"image-20230821093427390\" style=\"zoom: 80%;\" />\n\n**当 TCP 链接中 A 向 B 发送 FIN 请求关闭，另一端 B 回应 ACK 之后（A 端进入 FIN_WAIT_2 状态），并没有立即发送 FIN 给 A，A 方处于半连接状态（半开关），此时 A 可以接收 B 发 送的数据，但是 A 已经不能再向 B 发送数据。**\n\n#### shutdown()\n\n从程序的角度，可以使用 API 来控制实现半连接状态：\n\n~~~cpp\n#include <sys/socket.h>\nint shutdown(int sockfd, int how);\n    sockfd: 需要关闭的socket的描述符\n    how: 允许为shutdown操作选择以下几种方式:\n        SHUT_RD(0): 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。\n                    该套接字不再接收数据，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。\n        SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发\n                    出写操作。\n        SHUT_RDWR(2):关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以\n                    SHUT_WR。\n~~~\n\n**使用 close 中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为 0 时才关闭连接。**\n\n**shutdown 不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。** \n\n注意: \n\n1. **如果有多个进程共享一个套接字，close 每被调用一次，计数减 1 ，直到计数为 0 时，也就是所用进程都调用了 close，套接字将被释放。当然遇到父子进程的时候注意一下他们内核区是共享的还是独立的，下面会谈到** \n\n2. **在多进程中如果一个进程调用了 shutdown(sfd, SHUT_RDWR) 后，其它的进程将无法进行通信，因为直接关闭，不看引用计数。 但如果一个进程 close(sfd) 将不会影响到其它进程。**\n\n3. **引申：为什么多进程中的文件描述符的引用计数不为1呢？我们来看我们代码的逻辑：**\n\n   **我们用父进程接受连接，然后用子进程进行处理；文件描述符是内核区的，因此父进程和子进程就共享了这一份文件描述符数据了，父进程当然可以通过这个通信，但是逻辑没有这么干**\n   ![image-20230822153655659](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822153655659.png)\n\n#### 关于文件描述符的引用计数(file_description)\n\n我们先从父子进程看起，就是父子进程对于文件描述符，下面有两段代码：\n\n~~~cpp\n// code1\n#include <iostream>\nusing namespace std;\n#include <fcntl.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#define MAXSIZE 1024\n\nint main() {\n    int fd = open(\"a.txt\", O_RDONLY);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    char buf[MAXSIZE] = {0};\n\n    pid_t pid = fork();\n    if (-1 == pid) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    if (pid == 0) {\n        read(fd, buf, 1);  // 我给buf中读进去1个字节内容\n        printf(\"buf = %s\\n\", buf);\n    } else if (pid > 0) {\n        sleep(3);          // 保证子进程可以先读文件\n        read(fd, buf, 2);  // 父进程中读取2个字节\n\n        printf(\"buf = %s\\n\", buf);\n        wait(nullptr);\n    }\n\n    close(fd);\n    return 0;\n}\n\n// 执行结果：\n// buf = h\n// buf = el\n~~~\n\n~~~cpp\n// code2\n#include <assert.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/wait.h>\n#include <unistd.h>\n\n#define MAXSIZE 1024\n\nint main() {\n    pid_t pid = fork();\n    if (-1 == pid) {\n        perror(\"fork\");\n        return -1;\n    }\n\n    int fd = open(\"a.txt\", O_RDONLY);\n    if (-1 == fd) {\n        perror(\"open\");\n        return -1;\n    }\n\n    char buf[MAXSIZE] = {0};\n\n    if (pid == 0) {\n        read(fd, buf, 1);  // 我给buf中读进去1个字节内容\n        printf(\"buf = %s\\n\", buf);\n    } else if (pid > 0) {\n        sleep(3);          // 保证子进程可以先读文件\n        read(fd, buf, 2);  // 父进程中读取2个字节\n\n        printf(\"buf = %s\\n\", buf);\n        wait(nullptr);\n    }\n\n    close(fd);\n    return 0;\n}\n\n// 执行结果：\n// buff = h\n// buff = he\n~~~\n\n**我们仔细观察这两个代码，发现第一个代码先open()文件在fork()子进程；第二个代码先fork()子进程在open()文件，第一个代码的执行结果发现父子进程的文件指针好像是公用的，第二个则是独立的，那么这是为什么呢？**\n\n**在Linux系统中父子进程在实际操作的时候具有\"读时共享，写时拷贝\"的性质，这个是针对用户区的，我们通过open()函数打开的文件描述符fd是属于内核区的，并且内核区还专门设有一个文件描述符表用来存放文件描述符，比如  STDIN_FILENO 0 ， STDOUT_FILENO 1 ， STDERR_FILENO 2 ，由于先打开open()再创建子进程fork()，那么他们内核区的数据是共享的，因此文件描述符也是用的同一个，文件描述符的引用计数为1，虽然close()的机制是引用计数为0才真正关闭，但是这里为1，因此关闭任意一个都相当于关闭了这个文件描述符，因此他们读取的文件指针也是共享的，所以开始读的位置不相同；但是第二个先创建子进程fork()再打开open()，显然这两个的文件描述符是不同的，这就跟匿名管道pipe通信父子进程需要先创建匿名管道pipe再创建子进程fork()一个道理**\n\n**总结：**\n\n- **fork前进行open，子进程无条件继承父进程的文件描述信息，子进程和父进程指向一样文件描述信息**\n- **fork后进行open，子进程可以有自己的选择啊，不用继承父进程的所有，比如文件描述信息**\n\n## 端口复用(关于sockopt())\n\n**端口复用最常用的用途是:** \n\n- **防止服务器重启时之前绑定的端口还未释放** \n- **程序突然退出而系统没有释放端口**\n\n**这两个的本质都是因为某些原因主动连接方程序退出了但是TCP的信息还在TIME_WAIT状态，可能这个时候被动连接方没办法收到LAST ACK，这就会导致一直处在TIME_WAIT状态，然后TIME_WAIT的时间2mss一般是60s，很长，很烦，这就导致端口一直被占用而没办法及时进行后续操作**\n\n~~~cpp\n#include <sys/types.h>\n#include <sys/socket.h>\n// 设置套接字的属性(不仅仅能够设置端口复用)\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\n参数：\n    - sockfd：要操作的套接字的文件描述符\n    - level：级别 SOL_SOCKET (端口复用的级别)\n    - optname：选项的名称\n    \t- SO_REUSEADDR\n    \t- SO_REUSEPORT\n    - optval：属性的值，可以是int类型，也可以是其他类型，所以用void*接受，这里是整型\n    \t- 1：可以复用\n    \t- 0：不可以复用\n    - optlen：上一个属性的长度\n返回值：\n    成功 0\n    失败 -1，设置errno\n \n端口复用，设置的时机是服务器绑定端口之前，先设置再 bind() ，否则就失效了\n~~~\n\n关于level参数，有很多，我们这里选择 SOL_SOCKET，代表是端口复用的级别\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230820172341423.png\" alt=\"image-20230820172341423\" style=\"zoom: 80%;\" />\n\n查看网络信息相关的命令\n\n~~~bash\nnetstat\n参数：\n\t-a 显示所有的socket\n\t-p 显示正在使用socket的程序的名称\n\t-n 直接使用IP地址，不通过域名服务器\n~~~\n\n我们可以使用命令 **netstat -anp** 来查看相关的信息\n\n### 示例\n\n我们现在来看一段代码，是关于TCP通信的：\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_IPV4_STRING 16\n#define MAXSIZE 1024\n\nint main() {\n    // 创建socket\n    int listen_fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (listen_fd == -1) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    server_addr.sin_port = htons(9999);\n\n    // 设置端口复用(在绑定之前)\n    int optval = 1;\n    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));\n\n    // 绑定\n    int ret = bind(listen_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n    if (ret == -1) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    // 监听\n    ret = listen(listen_fd, 8);\n    if (ret == -1) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    // 接收客户端连接\n    struct sockaddr_in client_addr;\n    socklen_t client_len = sizeof(client_addr);\n    int connect_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_len);\n    if (connect_fd == -1) {\n        perror(\"accpet\");\n        return -1;\n    }\n\n    // 获取客户端信息\n    char client_ip[MAX_IPV4_STRING] = {0};\n    inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip, sizeof(client_ip));\n    unsigned short client_port = ntohs(client_addr.sin_port);\n\n    // 输出客户端的信息\n    printf(\"client's ip is %s, and port is %d\\n\", client_ip, client_port);\n\n    // 接收客户端发来的数据\n    char buf[MAXSIZE] = {0};\n    while (1) {\n        int len = recv(connect_fd, buf, sizeof(buf), 0);\n        if (len == -1) {\n            perror(\"recv\");\n            return -1;\n        } else if (0 == len) {\n            printf(\"客户端已经断开连接...\\n\");\n            break;\n        } else if (len > 0)\n            printf(\"read buf = %s\", buf);\n\n        // 小写转大写\n        for (int i = 0; i < len; ++i)\n            buf[i] = toupper(buf[i]);\n\n        printf(\"after buf = %s\", buf);\n\n        // 大写字符串发给客户端\n        ret = send(connect_fd, buf, strlen(buf) + 1, 0);\n        if (ret == -1) {\n            perror(\"send\");\n            return -1;\n        }\n    }\n\n    close(connect_fd);\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAXSIZE 1024\n\nint main() {\n    // 创建socket\n    int connect_fd = socket(PF_INET, SOCK_STREAM, 0);\n    if (connect_fd == -1) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    struct sockaddr_in server_addr;\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr.s_addr);\n    server_addr.sin_family = AF_INET;\n    server_addr.sin_port = htons(9999);\n\n    // 连接服务器\n    int ret = connect(connect_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n\n    if (ret == -1) {\n        perror(\"connect\");\n        return -1;\n    }\n\n    while (1) {\n        char buf[MAXSIZE] = {0};\n        fgets(buf, sizeof(buf), stdin);\n\n        write(connect_fd, buf, strlen(buf) + 1);\n\n        // 接收\n        int len = read(connect_fd, buf, sizeof(buf));\n        if (len == -1) {\n            perror(\"read\");\n            return -1;\n        } else if (len > 0)\n            printf(\"read buf = %s\", buf);\n        else {\n            printf(\"服务器已经断开连接...\\n\");\n            break;\n        }\n    }\n\n    close(connect_fd);\n\n    return 0;\n}\n~~~\n\n#### 理解\n\n我们先把TCP通信的图拿过来\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230819153502987.png\" alt=\"image-20230819153502987\" style=\"zoom:67%;\" />\n\n这段代码的作用是服务端发送字符串，服务端接受并且返回大写后的版本，代码逻辑我们不谈，前面早就谈过了，我们来看看释放连接时候会发生些什么事情\n\nserver.cpp代码当中有一个注释的部分，这个部分是用来设置端口复用的，我们现在先不管\n\n~~~cpp\nint optval = 1;\nsetsockopt(listen_fd, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval));\n~~~\n\n在代码中我们指定服务端的端口为9999，IP为任意IP(只要能连接)，然后用网络命令来查看一下状态\n\n通过管道和grep命令通信来过滤剩下9999的信息\n\n~~~bash\nnetstat -anp | grep 9999\n~~~\n\n我们来看下正常状态时候的输出：\n\n服务端有两条信息，一条是用来监听的，因为我们没有关闭监听套接字，理论上它还可以继续accept()客户端，只是我们代码逻辑没有实现这个；另一条和客户端是已经建立连接；客户端就是和服务端建立连接\n\n服务端使用的端口是9999\n\n![image-20230820174841668](https://cdn.davidingplus.cn/images/2025/01/31/image-20230820174841668.png)\n\n现在我们使用 ctrl + c 发送SIGINT信号是服务端异常终止，输出：\n\n此时，服务端到客户端的单向连接就关闭了，但是客户端还在，服务端处于FIN_WAIT2状态，等待客户端发送FIN的关闭连接报文；客户端处于CLOSE_WAIT状态\n\n![image-20230820175148993](https://cdn.davidingplus.cn/images/2025/01/31/image-20230820175148993.png)\n\n好，现在我们也类似强制关闭客户端，输出：\n\n此时服务端进入TIME_WAIT状态，这个状态服务端接收到了FIN报文然后发送针对该报文的ACK报文，为了避免最后一次报文丢失，所以会有这个阶段，这个阶段的持续时间是2MSL，在Linux上大概是60秒\n\n![image-20230820175507945](https://cdn.davidingplus.cn/images/2025/01/31/image-20230820175507945.png)\n\n如果我们在这段时间重开服务器，就会这样，表示端口被占用，这就是TIME_WAIT惹的祸\n\n![image-20230820175849220](https://cdn.davidingplus.cn/images/2025/01/31/image-20230820175849220.png)\n\n因此，setsockapt()就是可以设置这个属性，使得端口能够复用，将那行代码恢复后，就可以正常打开服务器，并且网络状态是这样的\n\n可以看出，之前的TIME_WAIT和现在的LISTEN状态共存了，这就是setsockapt()的作用，当然他不只可以设置端口复用，还有其他功能\n\n![image-20230820180107223](https://cdn.davidingplus.cn/images/2025/01/31/image-20230820180107223.png)\n\n#### 思考\n\n我现在不让客户端异常退出，当服务端异常退出后，我们代码的逻辑可以让客户端阻塞在输入的位置，所以这时我们输入代码然后就可以正常退出程序，但是正常退出程序之后我们发现TIME_WAIT状态不存在，也就是结束了，换句话说客户端正常收到了最后一次ACK，而我们刚才异常退出的时候客户端没办法收到最后一次ACK，所以端口被占用，需要端口复用，这点要注意\n\n但是再想想，服务端也是异常退出的，他怎么收到了第二次ACK呢？这个问题我不知道准确的答案，但是我推测虽然服务端结束了，但是服务端的TCP信息尚未结束，因为服务端还要收到客户端的主动断开请求，这里是服务端先断开，但是被断开方客户端异常退出时就收不到最后一次ACK，所以会卡在TIME_WAIT状态(不是很理解)\n\n**问题的关键点就在于被断开方最后一次ACK到底能否准确收到，我不知道怎么解释，但是TIME_WAIT会告诉我答案，这就是内核相关的东西了，我目前的水平达不到**\n\n不明白其实没关系，只需要知道TIME_WAIT状态会导致端口占用就可以了，我们自己可以用网络命令查看，然后决定是否需要端口复用\n\n## I/O多路复用(I/O多路转接)\n\n### I/O含义\n\n**I/O就是英文单词in out，但是不是指从键盘读入数据叫in或者输出到中断屏幕到out，它指的是我们操作文件或者管道或者套接字，依赖文件描述符，将数据和内存(比如缓冲区)进行通信，写入内存叫in，从内存中读取叫out；比如我们的TCP通信的例子，连接套接字的形式就是文件描述符fd，然后通过他的读写是先存到内存缓冲区的，这就有很多的I/O过程了**\n\n**I/O 多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能。Linux 下实现 I/O 多路复用的系统调用主要有 select、poll 和 epoll。**\n\n### 几种常见的I/O模型\n\n#### 阻塞等待\n\n比如accept()和wait()就是阻塞等待的例子，阻塞等待客户端的连接和子进程的结束，优点就是阻塞在那里不吃CPU的时间片，缺点就是同一时刻只能处理一个操作，效率很低；所以想到用多进程或者多线程解决，但是缺点就是消耗资源\n\n![image-20230821101046107](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821101046107.png)\n\n##### BIO模型\n\n这就是阻塞等待的例子，就是因为read()或者recv()是阻塞的，当我主程序接受客户端连接之后阻塞等待客户端的数据到达，这段时间内主程序没有办法接受其他客户端的连接，所以我们选择多进程或者多线程来解决问题，缺点也显而易见就是消耗资源，但是究其根本原因就是阻塞blocking的问题\n\n![image-20230821101622911](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821101622911.png)\n\n#### 非阻塞，忙轮询\n\n因此我们可以选择就不阻塞了，忙着轮询来询问任务的情况，优点就是提高了程序的执行效率，但是缺点就是需要吃更多的CPU和系统资源\n\n解决方案：使用I/O多路转接技术select/poll/epoll\n\n![image-20230821102216612](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821102216612.png)\n\n##### NIO模型\n\n这里把accept()和read()都设置成为非阻塞的，意味着我程序执行到这里的时候我不阻塞了，但是需要判断是否有客户端连接或者有数据到达，如果没有就继续循环直到有，有就进行相应的处理，但是这样消耗的CPU和资源代价非常大\n\n![image-20230821102411708](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821102411708.png)\n\n### I/O多路转接技术\n\n**在NIO模型下，假设我们的用户非常多，因此每次执行到非阻塞的位置，比如read()我们都需要判断所有的客户是否有数据到达，我们的本意是通过非阻塞来提高程序的效率，但是我们现在每次到这里都要自己询问所有的客户数据是否到达，这不就消耗了CPU和资源嘛，违背了我们的初衷，I/O多路转接技术就是用来解决这个问题，他的目的是委托内核帮我们询问查看有多少客户的数据到达了，然后告诉我们，因此我们只需要调用一次就可以知道哪些客户数据到达了，大大提高了效率**\n\n#### 简单理解\n\n第一种 select/poll\n\n![image-20230821102813978](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821102813978.png)\n\n第二种 epoll\n\n![image-20230821102923936](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821102923936.png)\n\n#### select\n\n主旨思想： \n\n1. **首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中。** \n2. **调用一个系统函数，监听该列表中的文件描述符，直到这些描述符中的一个或者多个进行 I/O 操作时，该函数才返回。 **\n   **a.这个函数是阻塞的 **\n   **b.函数对文件描述符的检测的操作是由内核完成的**\n3. **在返回时，它会告诉进程有多少（哪些）描述符要进行I/O操作。**\n\n~~~cpp\n// sizeof(fd_set) = 128(个字节) 1024(个bit位)\n#include <sys/time.h>\n#include <sys/types.h>\n#include <unistd.h>\n#include <sys/select.h>\nint select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);\n    - 参数：\n    \t- nfds : 委托内核检测的最大文件描述符的值 + 1，传这个参数是是为了提高效率，没必要遍历最大文件描述符之后的，+1是底层实现的逻辑规定的要+1，我猜测可能类似于 for(int i = 0 ; i < nfds + 1 ;++i)，这样刚好最后一个能被遍历到\n    \t- readfds : 要检测的文件描述符的读的集合，委托内核检测哪些文件描述符的读的属性\n    \t\t\t - 一般检测读操作\n    \t\t\t - 对应的是对方发送过来的数据，因为读是被动的接收数据，检测的就是读缓冲区是否有数据，有的话就可以进行读取\n    \t\t\t - 是一个传入传出参数\n    \t- writefds : 要检测的文件描述符的写的集合，委托内核检测哪些文件描述符的写的属性\n            \t  - 一般不检测写操作 \n    \t\t\t - 委托内核检测写缓冲区是不是还可以写数据，没有满就可以继续向其中写入数据\n    \t- exceptfds : 检测发生异常的文件描述符的集合\n    \t- timeout : 设置的超时时间\n        struct timeval {\n            long tv_sec; /* seconds */\n            long tv_usec; /* microseconds */\n        };\n            - NULL : 永久阻塞，直到检测到了文件描述符有变化，才会往下执行并且返回\n            - tv_sec = 0 tv_usec = 0， 不阻塞\n            - tv_sec > 0 tv_usec > 0， 阻塞对应的时间\n            - 返回值 :\n                  -1 : 失败\n                  >0(n) : 检测的集合中有n个文件描述符发生了变化\n// 将参数文件描述符fd对应的标志位设置为0\nvoid FD_CLR(int fd, fd_set *set);\n// 判断fd对应的标志位是0还是1， 返回值 ： fd对应的标志位的值，0，返回0， 1，返回1\nint FD_ISSET(int fd, fd_set *set);\n// 将参数文件描述符fd 对应的标志位，设置为1\nvoid FD_SET(int fd, fd_set *set);\n// fd_set一共有1024 bit, 全部初始化为0\nvoid FD_ZERO(fd_set *set);\n~~~\n\n**在我们的例子当中，我们需要检测的是文件描述符中读的属性，因此我们就将 fd_set 类型中对应要检测的文件描述符的对应的标志位设为1表示我要检测，然后传给select()函数遍历，如果文件描述符为0则表示不用检测跳过，为1则委托内核去帮我们进行检测，如果确实有数据来了就将该标志位仍保持为1，没有则修改为0，最后把修改之后的 readfds 返回，就得到了有数据的集合，但是select()的返回值不会告诉我们哪些值发生了变化，只会告诉我们有几个，n个返回n，至于是那些需要我们自己遍历**\n\n##### 工作过程分析\n\n**在函数执行的过程中，系统先把用户区的这份文件描述符集合拷贝一份到内核当中，然后在内核当中检测标志位并且根据实际情况(比如这里就是哪些文件描述符的读端数据到达了)然后修改标志位，0就是没有，1就是有，然后从内核态重新拷贝到用户态，工作过程大致就是这样**\n\n![image-20230821132937309](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821132937309.png)\n\n##### 代码\n\n~~~cpp\n// Client_Info.h\n#ifndef _CLIENT_INFO_\n#define _CLIENT_INFO_\n\n#include <arpa/inet.h>\n\n#include <cstring>\n\n#define MAX_IPV4_STRING 16\n\nclass Client_Info {\npublic:\n    Client_Info() {\n        __init__();\n    };\n\n    Client_Info& operator=(const Client_Info& _cli_info) {\n        strcpy(this->client_ip, _cli_info.client_ip);\n        this->client_port = _cli_info.client_port;\n\n        return *this;\n    }\n\n    Client_Info(const char* _ip, const in_port_t& _port) {\n        strcpy(this->client_ip, _ip);\n        this->client_port = _port;\n    }\n\n    Client_Info(const Client_Info& _cli_info) {\n        *this = _cli_info;\n    }\n\n    void __init__() {\n        bzero(this->client_ip, sizeof(this->client_ip));\n        this->client_port = 0;\n    }\n\npublic:\n    char client_ip[MAX_IPV4_STRING];\n    in_port_t client_port;\n};\n\n#endif\n~~~\n\n以下是服务端和客户端\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#include \"Client_Info.h\"\n\n#define MAXSIZE 1024\n#define MAX_CLIENT_SIZE 1024\n\n// 全局存放客户端连接的IP和端口\nclass Client_Info cli_infos[MAX_CLIENT_SIZE];\n\n// 全局存放需要检测的文件描述符的数组\nfd_set read_set;\n\nint bigger(const int& val1, const int& val2) {\n    return val1 > val2 ? val1 : val2;\n}\n\nvoid Communicate(const int& _connect_fd) {\n    char* _client_ip = cli_infos[_connect_fd].client_ip;\n    in_port_t& _client_port = cli_infos[_connect_fd].client_port;\n\n    char buf[MAXSIZE] = {0};\n    // 读\n    bzero(buf, sizeof(buf));\n    int len = read(_connect_fd, buf, sizeof(buf) - 1);\n    if (-1 == len) {\n        perror(\"read\");\n        exit(-1);\n    }\n    if (len > 0)\n        printf(\"recv client (ip : %s , port : %d) : %s\", _client_ip, _client_port, buf);\n    else if (0 == len) {  // 客户端关闭\n        printf(\"client ip : %s , port : %d has closed...\\n\", _client_ip, _client_port);\n        // 这里关闭之后需要移除文件描述符集合中的标志位表示我不需要监听这个了\n        FD_CLR(_connect_fd, &read_set);\n        // 关闭文件描述符\n        close(_connect_fd);\n        return;\n    }\n    // 写\n    write(_connect_fd, buf, strlen(buf));\n}\n\nint main() {\n    // 1.创建socket\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 设置一下端口复用\n    int _optval = 1;\n    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEPORT, &_optval, sizeof(_optval));\n\n    // 2.绑定IP和端口\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // IP\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    // 端口\n    server_addr.sin_port = htons(9999);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    printf(\"server has initialized.\\n\");\n\n    // 3.开始监听\n    ret = listen(listen_fd, 8);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    // 使用NIO模型，创建fd_set集合，存放的是需要检测的文件描述符\n    // 全局定义 read_set\n    // 初始化\n    FD_ZERO(&read_set);\n    // 添加需要检测的文件描述符\n    FD_SET(listen_fd, &read_set);\n\t// 定义最大的文件描述符序号(参数里面要加1)\n    int max_fd = listen_fd;\n\n    // 这个地方我不能把read_set集合拿进去让内核进行拷贝修改然后覆盖我的这个\n    // 我们设想这样一种情况，AB都检测，A发数据，B的被修改为0，但是下一次我肯定还要检测B的啊\n\n    while (1) {\n        fd_set tmp_set = read_set;\n        // 调用select系统函数，让内核帮忙检测哪些文件描述符有数据\n        // 这里是在检测listen_fd，因为如果有客户端请求连接了，那么这里listen_fd肯定会有数据进来\n        ret = select(max_fd + 1, &tmp_set, nullptr, nullptr, nullptr);\n        if (-1 == ret) {\n            perror(\"select\");\n            return -1;\n        } else if (0 == ret)\n            // 为0表示超时并且没有检测到有改变的\n            continue;  // 这里我们的设置因为是阻塞的，所以不会走到这里\n        else if (ret > 0) {\n            // 说明检测到了有文件描述符对应缓冲区的数据发生了改变\n            if (FD_ISSET(listen_fd, &tmp_set)) {\n                // 表示有新的客户端连接进来了\n                struct sockaddr_in client_addr;\n                socklen_t client_addr_len = sizeof(client_addr);\n                int connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n\n                if (-1 == connect_fd) {\n                    perror(\"accept\");\n                    return -1;\n                }\n\n                // 获取客户端的信息\n                char ip[MAX_IPV4_STRING] = {0};\n                inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, ip, sizeof(ip));\n\n                in_port_t port = ntohs(client_addr.sin_port);\n\n                // 打印信息\n                printf(\"client ip : %s , port : %d has connected...\\n\", ip, port);\n\n                // 将客户端的信息保存到全局数组中\n                cli_infos[connect_fd] = Client_Info(ip, port);\n\n                // 将新的文件描述符加入到集合中，这样select()就可以监听客户端的数据了\n                FD_SET(connect_fd, &read_set);\n                // 更新max_fd\n                max_fd = bigger(connect_fd, max_fd);\n            }\n\n            // 看完监听的文件描述符，还要看其他的文件描述符标识位\n            for (int i = listen_fd + 1; i < max_fd + 1; ++i) {\n                if (FD_ISSET(i, &tmp_set))\n                    // 表示有数据到来，进行通信，服务端只处理一次，然后又重新检测是否有数据，有数据则又走这段代码\n                    // 并且如果服务端里面处理用循环处理，那么这个客户端一直抢占者服务端，其他服务端没办法发送数据\n                    Communicate(i);\n            }\n        }\n    }\n\n    // 4.关闭连接\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAXSIZE 1024\n\nint main() {\n    // 1.创建套接字\n    int connect_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == connect_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.建立连接\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // 端口\n    server_addr.sin_port = htons(9999);\n    // IP\n    inet_pton(AF_INET, \"127.0.0.2\", &server_addr.sin_addr.s_addr);\n\n    int ret = connect(connect_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"connect\");\n        return -1;\n    }\n\n    printf(\"connected successfully , waiting for communicating.\\n\");\n\n    char buf[MAXSIZE] = {0};\n    // 3.开始通信\n    while (1) {\n        // 写\n        bzero(buf, sizeof(buf));\n        fgets(buf, sizeof(buf), stdin);\n\n        // 增加退出功能\n        if (strcmp(buf, \"quit\\n\") == 0 || strcmp(buf, \"QUIT\\n\") == 0)\n            goto END;\n\n        write(connect_fd, buf, strlen(buf));\n        printf(\"send : %s\", buf);\n\n        // 读\n        bzero(buf, sizeof(buf));\n        int len = read(connect_fd, buf, sizeof(buf) - 1);\n        if (-1 == len) {\n            perror(\"read\");\n            return -1;\n        }\n        if (len > 0)\n            printf(\"recv : %s\", buf);\n        else if (0 == len) {  // 说明写端关闭，也就是服务端关闭\n            printf(\"server has closed...\\n\");\n            break;\n        }\n    }\n\nEND:\n    // 4.关闭连接\n    close(connect_fd);\n\n    return 0;\n}\n~~~\n\n##### 代码分析\n\n好，现在我们来分析一下这段代码\n\n首先我们使用的是，NIO模型，就是不阻塞，而是轮询，所以我们需要使用while循环来实现这个机制，然后在select()基础上我们要确认需要检测的文件描述符的读的状态，所以我们定义 fd_set read_set ，由于监听的listen_fd当有客户端连接的时候也是算有数据进入，对应read_set[]的标志位会改变，所以将其添加进去\n\n~~~cpp\n// 先初始化\nFD_ZERO(&read_set);\n// 添加需要检测的文件描述符\nFD_SET(listen_fd, &read_set);\n~~~\n\n之后进入while循环我们检测是否有变化，有变化则说明有新客户端连接或者连接上的客户端有数据进入，这里我们设置阻塞等待变化，当然也可以设置一个等待的周期时间\n\n注意返回值 ret 代表的是检测到变化的个数，-1表示错误，0表示没有，可以重开循环(但是我们这里不会，因为我们阻塞)；>0则表示有变化，我们可以进行后续处理\n\n~~~cpp\nret = select(max_fd + 1, &tmp_set, nullptr, nullptr, nullptr);\n~~~\n\n可能是新客户端连接或者已连接的客户端发送数据，分别如下：\n\n**新客户端连接**\n\n~~~cpp\n// 表示有新的客户端连接进来了\nstruct sockaddr_in client_addr;\nsocklen_t client_addr_len = sizeof(client_addr);\nint connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n\nif (-1 == connect_fd) {\n    perror(\"accept\");\n    return -1;\n}\n\n// 获取客户端的信息\nchar ip[MAX_IPV4_STRING] = {0};\ninet_ntop(AF_INET, &client_addr.sin_addr.s_addr, ip, sizeof(ip));\n\nin_port_t port = ntohs(client_addr.sin_port);\n\n// 打印信息\nprintf(\"client ip : %s , port : %d has connected...\\n\", ip, port);\n\n// 将客户端的信息保存到全局数组中\ncli_infos[connect_fd] = Client_Info(ip, port);\n\n// 将新的文件描述符加入到集合中，这样select()就可以监听客户端的数据了\nFD_SET(connect_fd, &read_set);\n// 更新max_fd\nmax_fd = bigger(connect_fd, max_fd);\n~~~\n\n我们不看上面打印信息的部分，看最后两句\n\n- 我们将新的connect_fd添加到read_set当中，这样就可以检测了\n- 我们更新的max_fd，这样可以提高效率\n\n**已经连接上的客户端收到数据**\n\n我们就从listen_fd开始遍历，因为listen_fd最开始创建，在普遍情况下是最小的，遍历到max_fd为止\n\n~~~cpp\n// 看完监听的文件描述符，还要看其他的文件描述符标识位\nfor (int i = listen_fd + 1; i < max_fd + 1; ++i) {\n    if (FD_ISSET(i, &tmp_set))\n        // 表示有数据到来，进行通信，服务端只处理一次，然后又重新检测是否有数据，有数据则又走这段代码\n        // 并且如果服务端里面处理用循环处理，那么这个客户端一直抢占者服务端，其他服务端没办法发送数据\n        Communicate(i);\n}\n~~~\n\n接下来我们看通信函数\n\n我们注意到一个细节，就是没有使用while循环，这是为什么呢？\n\n因为如果服务端里面处理用循环处理，那么这个客户端一直抢占者服务端，其他服务端没办法发送数据；\n\n并且我不用循环处理我把数据读了就结束函数，然后又重新开始检测，代码里移除标志位并且关闭文件描述符是在写端关闭的时候，这时候也是合情合理的\n\n~~~cpp\nvoid Communicate(const int& _connect_fd) {\n    char* _client_ip = cli_infos[_connect_fd].client_ip;\n    in_port_t& _client_port = cli_infos[_connect_fd].client_port;\n\n    char buf[MAXSIZE] = {0};\n    // 读\n    bzero(buf, sizeof(buf));\n    int len = read(_connect_fd, buf, sizeof(buf) - 1);\n    if (-1 == len) {\n        perror(\"read\");\n        exit(-1);\n    }\n    if (len > 0)\n        printf(\"recv client (ip : %s , port : %d) : %s\", _client_ip, _client_port, buf);\n    else if (0 == len) {  // 客户端关闭\n        printf(\"client ip : %s , port : %d has closed...\\n\", _client_ip, _client_port);\n        // 这里关闭之后需要移除文件描述符集合中的标志位表示我不需要监听这个了\n        FD_CLR(_connect_fd, &read_set);\n        // 关闭文件描述符\n        close(_connect_fd);\n        return;\n    }\n    // 写\n    write(_connect_fd, buf, strlen(buf));\n}\n~~~\n\n我们的代码中还有一个细节\n\n就是在这里为什么要用tmp_set，有的地方是read_set，有的地方是tmp_set\n\n这个地方我不能把read_set集合拿进去让内核进行拷贝修改然后覆盖我的这个；\n\n我们设想这样一种情况，AB都检测，A发数据，B的被修改为0，但是下一次我肯定还要检测B的啊，这就出现问题了\n\n所以我们想到的解决方案就是使用临时变量，但是像新客户端连接，写端关闭的时候删除文件描述符的检测这些还是要操作read_set，也很好理解\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230821162010058.png\" alt=\"image-20230821162010058\" style=\"zoom: 80%;\" />\n\n#### poll\n\n**poll技术是对select技术进行改进，所以select技术肯定具有缺点**\n\n##### select技术的缺点\n\n当客户端多了的时候，也就是fd多了的时候，就会出现如下的一系列问题\n\n**其中的第四条就是不使用临时 tmp_set 的问题，read_set应该要继续检测的部分被置为0了，就因为这个时候没有数据进来，所以言下之意就是不能重用，每次都需要重置**\n\n![image-20230821162714320](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821162714320.png)\n\n##### poll()\n\n**使用时引头文件 <poll.h>**\n\n~~~cpp\n#include <poll.h>\nstruct pollfd {\n    int fd; /* 委托内核检测的文件描述符 */\n    short events; /* 委托内核检测文件描述符的什么事件 */\n    short revents; /* 文件描述符实际发生的事件 */\n};\n\nstruct pollfd myfd;\nmyfd.fd = 5;\nmyfd.events = POLLIN | POLLOUT;\n\nint poll(struct pollfd *fds, nfds_t nfds, int timeout);\n    - 参数：\n        - fds : 是一个struct pollfd 结构体数组，这是一个需要检测的文件描述符的集合\n        - nfds : 这个是第一个参数数组中最后一个有效元素的下标 + 1\n        - timeout : 阻塞时长\n            0 : 不阻塞\n            -1 : 阻塞，当检测到需要检测的文件描述符有变化，解除阻塞\n            >0 : 阻塞的时长，单位是毫秒\n    - 返回值：\n        -1 : 失败\n        >0（n） : 成功,n表示检测到集合中有n个文件描述符发生变化\n~~~\n\n![image-20230821095539250](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821095539250.png)\n\n##### 代码\n\n代码的架构和前面的几乎没有区别，只有server.cpp进行了修改，这里只放出server.cpp\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <poll.h>\n#include <unistd.h>\n\n#include \"Client_Info.h\"\n\n#define MAXSIZE 1024\n#define MAX_CLIENT_SIZE 1024\n#define MAX_POLLFD_SIZE 1025\n\n// 全局存放客户端连接的IP和端口\nclass Client_Info cli_infos[MAX_CLIENT_SIZE];\n\n// 全局存放需要检测的文件描述符数组\nstruct pollfd fds[MAX_POLLFD_SIZE];\n\nint bigger(const int& val1, const int& val2) {\n    return val1 > val2 ? val1 : val2;\n}\n\nvoid Communicate(const int& _index) {\n    int _connect_fd = fds[_index].fd;\n\n    char* _client_ip = cli_infos[_connect_fd].client_ip;\n    in_port_t& _client_port = cli_infos[_connect_fd].client_port;\n\n    char buf[MAXSIZE] = {0};\n    // 读\n    bzero(buf, sizeof(buf));\n    int len = read(_connect_fd, buf, sizeof(buf) - 1);\n    if (-1 == len) {\n        perror(\"read\");\n        exit(-1);\n    }\n    if (len > 0)\n        printf(\"recv client (ip : %s , port : %d) : %s\", _client_ip, _client_port, buf);\n    else if (0 == len) {  // 客户端关闭\n        printf(\"client ip : %s , port : %d has closed...\\n\", _client_ip, _client_port);\n        // 关闭文件描述符\n        close(_connect_fd);\n        // 将对应的文件描述符置为-1\n        fds[_index].fd = -1;\n        return;\n    }\n    // 写\n    write(_connect_fd, buf, strlen(buf));\n}\n\nint main() {\n    // 1.创建socket\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 设置一下端口复用\n    int _optval = 1;\n    setsockopt(listen_fd, SOL_SOCKET, SO_REUSEPORT, &_optval, sizeof(_optval));\n\n    // 2.绑定IP和端口\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // IP\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    // 端口\n    server_addr.sin_port = htons(9999);\n\n    int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    printf(\"server has initialized.\\n\");\n\n    // 3.开始监听\n    ret = listen(listen_fd, 8);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    // 使用NIO模型，使用poll解决问题\n    // 初始化检测的文件描述符数组\n    for (int i = 0; i < MAX_POLLFD_SIZE; ++i) {\n        fds[i].fd = -1;\n        fds[i].events = POLLIN;  // 表示一会儿要去检测读事件\n    }\n    // 加入监听的文件描述符\n    fds[0].fd = listen_fd;\n\n    // 定义最大的文件描述符的fds[]数组的索引\n    int nfds = 0;\n\n    while (1) {\n        // 调用poll()函数，这是select()函数的改进版本\n        ret = poll(fds, nfds + 1, -1);\n        if (-1 == ret) {\n            perror(\"select\");\n            return -1;\n        } else if (0 == ret)\n            // 为0表示超时并且没有检测到有改变的\n            continue;  // 这里我们的设置因为是阻塞的，所以不会走到这里\n        else if (ret > 0) {\n            // 说明检测到了有文件描述符对应缓冲区的数据发生了改变\n            if (fds[0].revents & POLLIN == POLLIN) {\n                // 表示有新的客户端连接进来了\n                struct sockaddr_in client_addr;\n                socklen_t client_addr_len = sizeof(client_addr);\n                int connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n\n                if (-1 == connect_fd) {\n                    perror(\"accept\");\n                    return -1;\n                }\n\n                // 获取客户端的信息\n                char ip[MAX_IPV4_STRING] = {0};\n                inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, ip, sizeof(ip));\n\n                in_port_t port = ntohs(client_addr.sin_port);\n\n                // 打印信息\n                printf(\"client ip : %s , port : %d has connected...\\n\", ip, port);\n\n                // 将客户端的信息保存到全局数组中\n                cli_infos[connect_fd] = Client_Info(ip, port);\n\n                // 将新的文件描述符加入到事件中，注意文件描述符的优先用小的机制\n                for (int i = 1; i < MAX_POLLFD_SIZE; ++i)\n                    if (fds[i].fd == -1) {\n                        fds[i].fd = connect_fd;\n                        fds[i].events = POLLIN;\n                        // 更新nfds\n                        nfds = bigger(nfds, i);\n                        break;\n                    }\n            }\n\n            // 看完监听的文件描述符，看其他的文件描述符是否收到数据\n            for (int i = 1; i < nfds + 1; ++i) {\n                if (fds[i].revents & POLLIN == POLLIN)\n                    Communicate(i);\n            }\n        }\n    }\n\n    // 4.关闭连接\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n##### 代码分析\n\n首先我们要理解结构体 pollfd 的含义\n\n**这是用来保存委托内核检测的文件描述符；委托内核检测的文件描述符的什么事件，比如读写，类似于select中的read_set；还有检测过后实际发生的事件，比如没有读，就修改，类似于select中的 tmp_set；的一个结构体**\n\n~~~cpp\nstruct pollfd {\n    int fd; /* 委托内核检测的文件描述符 */\n    short events; /* 委托内核检测文件描述符的什么事件 */\n    short revents; /* 文件描述符实际发生的事件 */\n};\n~~~\n\n值得注意的是这些事件的类型和存储方法，是short类型的，我们来看它可以描述哪些事件\n\n![image-20230821095539250](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821095539250.png)\n\n**其实他和文件属性stat变量里面st_mode(表示文件类型和权限)是一个道理，一个bit位表示一个权限，1表示有，0表示没有，因此添加权限应该用 按位或 | ， 这里的事件也是一样的道理，我们一般判断读事件就POLLIN，写事件就POLLOUT**\n\n**第三个参数就是经过检测之后的状态，可以用它来判断是否有检测到读；由于我们设置的event没有变化，所以相对于select()还是好了很多**\n\n**其次，我们查看poll()接口的第一个参数是： struct pollfd *fds，需要一个结构体的数组传入进来，每一个元素就封装了一个文件描述符对应的信息，我们从0开始依次记录，如果该元素的fd为-1就表示没有使用，可以存放新的元素，注意这个下标，或者我们称他为索引，索引的值和文件描述符的值是不同的，为了提高效率我们这么设计，在代码中一定要注意，其他的逻辑没什么区别**\n\n还有一点，我们看如何判断最后的 revents 检测到读信息\n\n**还是前面的思想，每一位对应一个，读对应一位为1，其他为0；当然为什么不是直接相等呢？可能我们设置了其他性质也需要检测，内核处理后还是有了其他的性质为1，我们最好不要冒险，所以这里我们用 & **\n\n~~~cpp\nif (fds[i].revents & POLLIN == POLLIN)\n    //下面的操作\n~~~\n\n#### epoll\n\n**epoll和前面两种技术不同，epoll技术直接在内核态当中进行操作，完全省去了用户态到内核态拷贝的过程，并且由内核通知用户，实现了内核和用户的并发操作，提高了效率。**\n\n##### 工作过程分析\n\nselect技术和poll技术虽然实现方式有所不同，poll技术是select技术的改进，但是他们在实际操作的时候都是先在用户区生成一个表，select就是文件描述符表，对应位置置为1，下标表示为文件描述符；poll技术是用事件表示的，并且定义了我们想要的检测事件和实际发生的事件供我们比对，比如我们想要检测读事件，他返回0则表示没发生，两个都定义出来就免去了我们用临时变量的麻烦；好，这两个都是先在用户区然后拷贝到内核区然后再回来，众所周知，从内核区到用户区的二者切换要消耗CPU资源，所以一旦文件描述符多了，检测的事件多了就会影响性能\n\n**所以才有了epoll的技术，调用epoll之后会直接在内核区生成检测事件的东西，系统会提供给我们epoll的一系列API来帮助我们操作内核中的这块区域，从图中我们可以看出定义为 eventpoll ，里面比较重要的存着 rbr 和 rdlist，前者的数据结构是红黑树，是我们想要检测的事件体，红黑树使得查询和遍历非常快；后者的数据结构是双链表，是检测事件发生变化，在网络编程中就是有读的数据进来或者新客户端连接，用双链表可以直接了当的遍历出来**\n\n**总结一下，二者的区别一是epoll省去了从用户态到内核态相互的切换，直接在内核态操作，效率更高；二是epoll不仅返回了检测到了多少个，而且还直接通过双链表的形式告诉我们哪几个返回了，而select和poll技术并未做到这一点，select技术修改了我们传给他的表，返回值是检测到了多少个，但是哪些变化了需要我们遍历这个以文件描述符为下标的表；poll技术给每个需要检测的文件描述符封装了一个结构体，并且保存了需要检测的事件和实际发生的事件，但是仍然需要我们去遍历poll()参数中的pollfd结构体数组才行；但是epoll却将检测到的事件封装在双链表 rdlist 中，由此可见这就是他的优势**\n\n![image-20230821194458779](https://cdn.davidingplus.cn/images/2025/01/31/image-20230821194458779.png)\n\n##### epoll() \n\n**epoll创建在内核区的东西操作是通过API返回的文件描述符操作的，这也是和select和poll技术不同的地方，select技术用 fd_set 变量(本质是个数组)，poll技术用 pollfd 结构体数组，这些东西在代码中都是在用户区的；而epoll用文件描述符托管也代表内核区的性质**\n\n~~~cpp\n#include <sys/epoll.h>\n// 创建一个新的epoll实例。在内核中创建了一个数据，这个数据中有两个比较重要的数据，一个是需要检测的文件描述符的信息（红黑树），还有一个是就绪列表，存放检测到数据发送改变的文件描述符信息（双向链表）。\nint epoll_create(int size);\n    - 参数：\n    \tsize : 目前没有意义了。随便写一个数，必须大于0\n    - 返回值：\n        -1 : 失败\n        > 0 : 文件描述符，操作epoll实例的\n            \n// 结构类型是联合union，我们一般使用 fd 参数就行了\ntypedef union epoll_data {\n    void *ptr;\n    int fd;\n    uint32_t u32;\n    uint64_t u64;\n} epoll_data_t;\n\nstruct epoll_event {\n    uint32_t events; /* Epoll events */\n    epoll_data_t data; /* User data variable */\n};\n常见的Epoll检测事件events：\n    - EPOLLIN\n    - EPOLLOUT\n    - EPOLLERR\n\n// 对epoll实例进行管理：添加文件描述符信息，删除信息，修改信息\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n    - 参数：\n        - epfd : epoll实例对应的文件描述符\n        - op : 要进行什么操作\n            EPOLL_CTL_ADD: 添加\n            EPOLL_CTL_MOD: 修改\n            EPOLL_CTL_DEL: 删除\n        - fd : 要检测的文件描述符\n        - event : 检测文件描述符什么事情\n            \n// 检测函数\nint epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);\n    - 参数：\n        - epfd : epoll实例对应的文件描述符\n        - events : 传出参数，保存了发送了变化的文件描述符的信息，是一个结构体数组\n        - maxevents : 第二个参数结构体数组的大小\n        - timeout : 阻塞时间\n              0 : 不阻塞\n              -1 : 阻塞，直到检测到fd数据发生变化，解除阻塞\n              > 0 : 阻塞的时长（毫秒）\n        - 返回值：\n            - 成功，返回发送变化的文件描述符的个数 > 0\n            - 失败 -1\n~~~\n\n##### 代码和分析\n\n还是只放server.cpp\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <sys/epoll.h>\n#include <unistd.h>\n\n#include \"Client_Info.h\"\n\n#define MAX_CLIENT_SIZE 1024\n#define MAX_BUF_SIZE 1024\n\n// 全局存放客户端连接的IP和端口\nclass Client_Info cli_infos[MAX_CLIENT_SIZE];\n\nvoid Communicate(const struct epoll_event &_ret_event, const int &_epoll_fd) {\n    int _connect_fd = _ret_event.data.fd;\n    // 读\n    char buf[MAX_BUF_SIZE] = {0};\n    int len = read(_connect_fd, buf, sizeof(buf) - 1);\n    if (-1 == len) {\n        perror(\"read\");\n        exit(-1);\n    }\n\n    if (len > 0)\n        printf(\"client (ip : %s , port : %d) recv : %s\", cli_infos[_connect_fd].client_ip, cli_infos[_connect_fd].client_port, buf);\n    else if (0 == len) {\n        // 写端，客户端关闭连接\n        printf(\"client (ip : %s , port : %d) has closed...\\n\", cli_infos[_connect_fd].client_ip, cli_infos[_connect_fd].client_port);\n        // 从检测事件中删除他\n        epoll_ctl(_epoll_fd, EPOLL_CTL_DEL, _connect_fd, nullptr);\n        // 关闭文件描述符\n        close(_connect_fd);\n\n        return;\n    }\n    // 写\n    write(_connect_fd, buf, strlen(buf));\n}\n\nint main() {\n    // 1.创建socket套接字\n    int listen_fd = socket(AF_INET, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 设置端口复用\n    int _optval = 1;\n    int ret = setsockopt(listen_fd, SOL_SOCKET, SO_REUSEPORT, &_optval, sizeof(_optval));\n    if (-1 == ret) {\n        perror(\"setsockopt\");\n        return -1;\n    }\n\n    // 2.绑定IP和端口\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // IP\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    // 端口\n    server_addr.sin_port = htons(9999);\n\n    ret = bind(listen_fd, (struct sockaddr *)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    // 3.监听端口\n    ret = listen(listen_fd, 8);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    printf(\"server has initialized.\\n\");\n\n    // 4.用epoll技术实现接受客户端和进行通信\n    // 创建epoll示例\n    int epoll_fd = epoll_create(1);\n    if (-1 == epoll_fd) {\n        perror(\"epoll_create\");\n        return -1;\n    }\n\n    // 将监听套接字添加进入检测中\n    struct epoll_event listen_event;\n    listen_event.events = EPOLLIN;     // 检测读\n    listen_event.data.fd = listen_fd;  // 文件描述符\n\n    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &listen_event);\n\n    int _maxevents = MAX_CLIENT_SIZE;\n\n    // 开始检测\n    while (1) {\n        // 这个结构体数组存放了检测到的文件描述符的信息，保存在这里面\n        // 内核中是把双链表中的数据写入到这里\n        struct epoll_event ret_events[_maxevents];\n\n        // 返回值是表示有多少个被检测到了；第三个参数可以一般放数组的最大容量\n        int ret = epoll_wait(epoll_fd, ret_events, _maxevents, -1);\n        if (-1 == ret) {\n            perror(\"epoll_wait\");\n            return -1;\n        }\n\n        // 检测到了，开始处理\n        for (int i = 0; i < ret; ++i) {\n            if (ret_events[i].events && EPOLLIN == EPOLLIN) {\n                if (ret_events[i].data.fd == listen_fd) {\n                    // 表示有新客户端连接\n                    struct sockaddr_in client_addr;\n                    socklen_t client_addr_len = sizeof(client_addr);\n\n                    int connect_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);\n                    if (-1 == connect_fd) {\n                        perror(\"accept\");\n                        return -1;\n                    }\n\n                    // 设置read非阻塞\n                    int flag = fcntl(connect_fd, F_GETFL);\n                    flag |= O_NONBLOCK;\n                    fcntl(connect_fd, F_SETFL, flag);\n                    \n                    // 将客户端信息存入结构体数组，下标用connect_fd代替\n                    inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, cli_infos[connect_fd].client_ip, sizeof(cli_infos[connect_fd].client_ip));\n                    cli_infos[connect_fd].client_port = ntohs(client_addr.sin_port);\n\n                    printf(\"client (ip : %s , port : %d) has connected...\\n\", cli_infos[connect_fd].client_ip, cli_infos[connect_fd].client_port);\n\n                    // 添加到检测中\n                    struct epoll_event connect_event;\n                    connect_event.data.fd = connect_fd;\n                    connect_event.events = EPOLLIN;\n\n                    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, connect_fd, &connect_event);\n                } else  // 客户端接收到数据\n                    Communicate(ret_events[i], epoll_fd);\n            }\n        }\n    }\n\n    // 5.关闭连接\n    close(epoll_fd);\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n这段代码的思路和前面的基本没有区别，就是先创建epoll_create()的示例，由于内核区的数据用文件描述符操作\n\n~~~cpp\nint epoll_fd = epoll_create(1);\n~~~\n\n然后将监听套接字加入到检测当中\n\n~~~cpp\n// 将监听套接字添加进入检测中\nstruct epoll_event listen_event;\nlisten_event.events = EPOLLIN;     // 检测读\nlisten_event.data.fd = listen_fd;  // 文件描述符\n\nepoll_ctl(epoll_fd, EPOLL_CTL_ADD, listen_fd, &listen_event);\n~~~\n\n然后不断循环，调用epoll_wait()接口检测哪些发生了变化\n\n我们来重点关注下这个接口的参数，第一个参数是epoll示例的文件描述符epoll_fd，第二个参数是保存检测到发生变化的结构体数组，类型是epoll_event，第三个参数是这个结构体数组的最大容量，可以自己设定，因为一般放不满，他也是从头开始放所以我们给你一个最大的值 _maxevents 就行，第四个参数是阻塞时间，这里设置-1表示阻塞\n\n~~~cpp\nwhile (1) {\n    // 这个结构体数组存放了检测到的文件描述符的信息，保存在这里面\n    // 内核中是把双链表中的数据写入到这里\n    struct epoll_event ret_events[_maxevents];\n\n    // 返回值是表示有多少个被检测到了；第三个参数可以一般放数组的最大容量\n    int ret = epoll_wait(epoll_fd, ret_events, _maxevents, -1);\n    if (-1 == ret) {\n        perror(\"epoll_wait\");\n        return -1;\n    }\n    \n    //后续代码\n    ...\n}\n~~~\n\n之后就是分新客户端连接和已连接客户端发送数据了\n\n从0遍历到epoll_wait()接口的返回值，因为返回的是检测到的个数，刚好告诉我了我就用\n\n~~~cpp\nfor (int i = 0; i < ret; ++i) {\n    if (ret_events[i].events && EPOLLIN == EPOLLIN) {\n        if (ret_events[i].data.fd == listen_fd) {\n            // 表示有新客户端连接\n            struct sockaddr_in client_addr;\n            socklen_t client_addr_len = sizeof(client_addr);\n\n            int connect_fd = accept(listen_fd, (struct sockaddr *)&client_addr, &client_addr_len);\n            if (-1 == connect_fd) {\n                perror(\"accept\");\n                return -1;\n            }\n\n            // 将客户端信息存入结构体数组，下标用connect_fd代替\n            inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, cli_infos[connect_fd].client_ip, sizeof(cli_infos[connect_fd].client_ip));\n            cli_infos[connect_fd].client_port = ntohs(client_addr.sin_port);\n\n            printf(\"client (ip : %s , port : %d) has connected...\\n\", cli_infos[connect_fd].client_ip, cli_infos[connect_fd].client_port);\n\n            // 添加到检测中\n            struct epoll_event connect_event;\n            connect_event.data.fd = connect_fd;\n            connect_event.events = EPOLLIN;\n\n            epoll_ctl(epoll_fd, EPOLL_CTL_ADD, connect_fd, &connect_event);\n        } else  // 客户端接收到数据\n            Communicate(ret_events[i], epoll_fd);\n    }\n}\n~~~\n\ncommunicate()接口和之前的没什么区别，就针对修改了一点，注意还是不是循环，因为出去了我们走下一次检测也是一样的\n\n~~~cpp\nvoid Communicate(const struct epoll_event &_ret_event, const int &_epoll_fd) {\n    int _connect_fd = _ret_event.data.fd;\n    // 读\n    char buf[MAX_BUF_SIZE] = {0};\n    int len = read(_connect_fd, buf, sizeof(buf) - 1);\n    if (-1 == len) {\n        perror(\"read\");\n        exit(-1);\n    }\n\n    if (len > 0)\n        printf(\"client (ip : %s , port : %d) recv : %s\", cli_infos[_connect_fd].client_ip, cli_infos[_connect_fd].client_port, buf);\n    else if (0 == len) {\n        // 写端，客户端关闭连接\n        printf(\"client (ip : %s , port : %d) has closed...\\n\", cli_infos[_connect_fd].client_ip, cli_infos[_connect_fd].client_port);\n        // 从检测事件中删除他\n        epoll_ctl(_epoll_fd, EPOLL_CTL_DEL, _connect_fd, nullptr);\n        // 关闭文件描述符\n        close(_connect_fd);\n\n        return;\n    }\n    // 写\n    write(_connect_fd, buf, strlen(buf));\n}\n~~~\n\n##### Epoll 的工作模式\n\n- > **LT 模式 （水平触发）** \n  > 假设委托内核检测读事件 -> 检测fd的读缓冲区 \n  > 读缓冲区有数据 - > epoll检测到了会给用户通知 \n  > \ta.用户不读数据，数据一直在缓冲区，epoll 会一直通知 \n  > \tb.用户只读了一部分数据，epoll会通知 \n  > \tc.缓冲区的数据读完了，不通知\n  >\n  > **LT（level - triggered）是缺省的工作方式，并且同时支持 block 和 no-block socket。**在这 种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的 fd 进行 IO 操作。**如果你不作任何操作，内核还是会继续通知你的。**\n\n- > **ET 模式（边沿触发）** \n  > 假设委托内核检测读事件 -> 检测fd的读缓冲区 \n  > 读缓冲区有数据 - > epoll检测到了会给用户通知\n  > a.用户不读数据，数据一致在缓冲区中，epoll下次检测的时候就不通知了 \n  > b.用户只读了一部分数据，epoll不通知\n  > c.缓冲区的数据读完了，不通知\n  >\n  > **ET（edge - triggered）是高速工作方式，只支持 no-block socket。**在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪， 并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述 符不再为就绪状态了。**但是请注意，如果一直不对这个 fd 作 IO 操作（从而导致它再次变成 未就绪），内核不会发送更多的通知（only once）**。 **ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。**\n\n~~~cpp\nstruct epoll_event {\n    uint32_t events; /* Epoll events */\n    epoll_data_t data; /* User data variable */\n};\n常见的Epoll检测事件：\n    - EPOLLIN\n    - EPOLLOUT\n    - EPOLLERR\n    - EPOLLET //设置边沿触发，Epoll技术默认的是水平触发，也就是在读完之前一直通知\n~~~\n\n##### LT模式(水平触发)\n\n**LT模式是检测到有数据，如果我们用户不读或者没有读完，那么下一次仍旧会通知，也就是检测到，直到缓冲区的数据读完了之后才停止通知**\n\n在这里我们把缓冲区的数组大小弄小点\n\n~~~cpp\n// 我将一次读取的大小弄小点\n#define MAX_BUF_SIZE 5\n~~~\n\n然后故意多写点数据来看看输出结果：\n\n客户端\n\n![image-20230822113418607](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822113418607.png)\n\n服务端\n\n![image-20230822113459363](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822113459363.png)\n\n**我们明显可以看出，缓冲区调小之后，一次读不完，然后循环之后仍然能够检测得到，直到将其全部读完**\n\n但是客户端为什么第二次有一部分数据留在缓冲区中没输出出来我就不知道了(这个真不知道)\n\n##### ET模式(边沿触发)\n\n**LT模式循环每次都会被内核提醒，这样的重复提醒对资源还是有很多的浪费的，所以ET模式假设我们已经知道这个提醒了，并且放在心上，马上就去处理它，所以后续内核不会提醒，这就是区别，也是提升效率的关键。因此如何读取到正确完整的数据就成了我们的关键**\n\n首先我们给通信的文件描述符 connect_fd 设置ET属性，也就是加上 EPOLLET 宏\n\n~~~cpp\n// 添加到检测中\nstruct epoll_event connect_event;\nconnect_event.data.fd = connect_fd;\nconnect_event.events = EPOLLIN | EPOLLET;  // 设置边沿触发，结合非阻塞的API使用!!!\n~~~\n\n我们的通信函数保持不变，也就是没有循环操作，并且read()函数阻塞，结果如下：\n\n客户端\n\n![image-20230822114219505](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822114219505.png)\n\n服务端\n\n![image-20230822114228554](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822114228554.png)\n\n可以看出只读取了一次，后续就没有下文了，只有当我第二次手动让客户端检测，比如这里我输入字符，服务端才会继续收到数据，注意上次通信没读完，数据还在缓冲区中，是接着缓冲区读的，如下：\n\n客户端\n\n![image-20230822114407108](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822114407108.png)\n\n服务端\n\n![image-20230822114413347](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822114413347.png)\n\n好，既然想到了读不完，那么我们就需要循环读，但是循环读如果配上阻塞的read()函数，读完了就会阻塞在那里，程序就尬住了，其他工作没办法做，这也是前面提到的需要使用非阻塞non-block的API，因此这里我们需要设置read()为非阻塞\n\n设置read()为非阻塞需要依赖于他的文件描述符，而关于文件描述符有fcntl()函数可以获取或者设置信息\n\n**注意看到这些什么属性或者标志位为int short这种数字类型，第一反应想到用二进制01表示，因为这样最省空间**\n\n~~~cpp\n// 设置非阻塞，否则读完就阻塞在这里，read非阻塞通过文件描述符操作\nint _flag = fcntl(connect_fd, F_GETFL);\n_flag |= O_NONBLOCK;  // 不能把原来的属性设置没了所以先获得\nfcntl(connect_fd, F_SETFL, _flag);\n~~~\n\n紧接着我们也需要修改我们的通信函数\n\n其他地方基本没什么变化，要注意一点：\n\n**当我缓冲区的数据读完了，但是写端没关闭怎么办？因为我们知道写端关闭了返回0，那这里返回什么呢？**\n\n**我们查看了man文档知道返回-1，并且errno会被设置为EAGAIN，这就是非阻塞情况下read()函数数据读完了的返回**\n\n**和之前accept()函数在被软中断，信号处理回收子进程之后变成非阻塞，返回-1，设置errno为EINTR有点类似**\n\n~~~cpp\nvoid Communicate(const struct epoll_event &_ret_event, const int &_epoll_fd) {\n    int _connect_fd = _ret_event.data.fd;\n\n    // ET工作模式不会通知第二次，只有再次变化的时候才会检测到，因此我们需要调用非阻塞的接口把数据读完\n    char buf[MAX_BUF_SIZE] = {0};\n    while (1) {\n        int len = read(_connect_fd, buf, sizeof(buf) - 1);\n\n        if (-1 == len) {\n            // 里面有一种情况就是我写端没有关闭但是我在非阻塞的情况下已经把数据读完了，这个时候就会产生EAGAIN的错误\n            if (errno == EAGAIN) {\n                printf(\"read data over.\\n\");\n                return;\n            }\n\n            perror(\"read\");\n            exit(-1);\n        }\n\n        // 读到正确数据\n        if (len > 0) {\n            printf(\"client (ip : %s , port : %d) recv : %s\\n\", cli_infos[_connect_fd].client_ip, cli_infos[_connect_fd].client_port, buf);\n            write(_connect_fd, buf, strlen(buf));\n            bzero(buf, sizeof(buf));\n        }\n\n        else if (0 == len) {\n            // 写端，客户端关闭连接\n            printf(\"client (ip : %s , port : %d) has closed...\\n\", cli_infos[_connect_fd].client_ip, cli_infos[_connect_fd].client_port);\n            // 从检测事件中删除他\n            epoll_ctl(_epoll_fd, EPOLL_CTL_DEL, _connect_fd, nullptr);\n            // 关闭文件描述符\n            close(_connect_fd);\n\n            return;\n        }\n    }\n}\n~~~\n\n最终我们的程序运行结果就是这样：\n\n客户端\n\n![image-20230822115230225](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822115230225.png)\n\n服务端\n\n可以看出我做的特殊判断也被打印出来了\n\n![image-20230822115243021](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822115243021.png)\n\n这个程序应该还有小bug，但是大体逻辑是没有问题的，这个我就尚不知道了\n\n## UDP\n\n### UDP通信\n\n**相比于TCP，UDP的通信就非常简单了，TCP的服务端需要创建监听的套接字用于监听建立连接，客户端需要使用connect()和服务端建立连接；而UDP创建了用于通信的文件描述符后直接通信即可，注意服务端还是要绑定bind()IP和端口**\n\n![image-20230822145319237](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822145319237.png)\n\n**在UDP中系统专门给我们提供了接口叫 sendto() 和 recvfrom() ；同样的在TCP当中，我们之前一直使用的是read()和write()来操作通信的文件描述符，没问题，但是系统当然也提供了专门的API，叫 send() 和 recv()**\n\n~~~cpp\n#include <sys/types.h>\n#include <sys/socket.h>\n\nssize_t sendto(int sockfd, const void *buf, size_t len, int flags,\n               const struct sockaddr *dest_addr, socklen_t addrlen);\n    - 参数：\n        - sockfd : 通信的fd\n        - buf : 要发送的数据\n        - len : 发送数据的长度\n        - flags : 0，标志，没有什么用，我们设置为0就可以了\n        - dest_addr : 通信的另外一端的地址信息，需要指定，因为没有建立连接不给不知道给谁发\n        - addrlen : 地址的内存大小\n            \nssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, \n                 struct sockaddr *src_addr, socklen_t *addrlen);\n    - 参数：\n        - sockfd : 通信的fd\n        - buf : 接收数据的数组\n        - len : 数组的大小\n        - flags : 0\n        - src_addr : 用来保存另外一端的地址信息，不需要可以指定为NULL\n        - addrlen : 地址的内存大小\n~~~\n\n#### 代码\n\n大体框架没有变，注意UDP中没有建立连接这个概念\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n#define MAX_IPV4_STRING 16\n\nint main() {\n    // 1.创建通信的socket套接字\n    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (-1 == socket_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.绑定IP和端口\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // IP\n    server_addr.sin_addr.s_addr = INADDR_ANY;\n    // 端口\n    server_addr.sin_port = htons(9999);\n\n    int ret = bind(socket_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == socket_fd) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    printf(\"server has initialized.\\n\");\n\n    char buf[MAX_BUF_SIZE] = {0};\n\n    // 3.开始通信\n    while (1) {\n        bzero(buf, sizeof(buf));\n        struct sockaddr_in client_addr;\n        socklen_t client_addr_len = sizeof(client_addr);\n\n        // 读\n        int len = recvfrom(socket_fd, buf, sizeof(buf) - 1, 0, (struct sockaddr*)&client_addr, &client_addr_len);\n        if (-1 == len) {\n            perror(\"recvfrom\");\n            return -1;\n        }\n        // 获得客户端信息\n        char client_ip[MAX_IPV4_STRING] = {0};\n        inet_ntop(AF_INET, &client_addr.sin_addr.s_addr, client_ip, sizeof(client_ip));\n        in_port_t client_port = ntohs(client_addr.sin_port);\n\n        // recvfrom返回0是可以接受的，不像read返回0表示对端关闭连接。因为UDP是无连接的，也就没有所谓的关闭。\n        printf(\"recv client (ip : %s , port : %d) : %s\", client_ip, client_port, buf);\n\n        // 写\n        sendto(socket_fd, buf, strlen(buf), 0, (struct sockaddr*)&client_addr, client_addr_len);\n    }\n\n    // 4.关闭套接字\n    close(socket_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n#define MAX_IPV4_STRING 16\n\nint main() {\n    // 1.创建通信的socket套接字\n    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (-1 == socket_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 存储服务端地址信息\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // IP\n    inet_pton(AF_INET, \"127.0.0.2\", &server_addr.sin_addr.s_addr);\n    // 端口\n    server_addr.sin_port = htons(9999);\n\n    char buf[MAX_BUF_SIZE] = {0};\n\n    static int num = 0;\n\n    // 2.开始通信\n    while (1) {\n        // 写\n        bzero(buf, sizeof(buf));\n        sprintf(buf, \"hello i am client , %d\\n\", num++);\n        printf(\"send : %s\", buf);\n        sendto(socket_fd, buf, strlen(buf), 0, (struct sockaddr*)&server_addr, sizeof(server_addr));\n\n        sleep(1);\n\n        // 读\n        bzero(buf, sizeof(buf));\n\n        int len = recvfrom(socket_fd, buf, sizeof(buf) - 1, 0, nullptr, nullptr);\n        if (-1 == len) {\n            perror(\"recvfrom\");\n            return -1;\n        }\n        // recvfrom返回0是可以接受的，不像read返回0表示对端关闭连接。因为UDP是无连接的，也就没有所谓的关闭。\n        printf(\"recv : %s\", buf);\n    }\n\n    // 4.关闭套接字\n    close(socket_fd);\n\n    return 0;\n}\n~~~\n\n##### 注意\n\n- **recvfrom() 函数的参数，后面两项是可以选择接受对方的信息，可以获得对方的socket地址信息，不要就传nullptr就可以了**\n\n- **sendto() 函数的参数，最后两项也是对方的信息，这是必须要给的，因为TCP没有建立连接同于通信的文件描述符，所以必须要给出对方的信息才可能正确发到；由此我们也可以推出我们的这个 sockfd 可以和很多客户端连接，因此UDP不用多进程或者多线程也可以实现，结果类似如下：**\n\n  ![image-20230822154224472](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822154224472.png)\n\n- **recvfrom 返回0是可以接受的，不像read返回0表示对端关闭连接。因为UDP是无连接的，也就没有所谓的关闭。我们的程序在另一方断开之后会卡住，这里我尚不知道为什么，应该是recvfrom() 内核里面的设计了；我们总之知道 UDP 提供的 recvfrom() 函数返回0是合法的**\n\n- 另外，我想谈谈关于TCP和UDP双方的文件描述符，TCP里面就是connect_fd，UDP里面就是socket_fd\n  我们通过程序查看是否相同，首先是TCP：\n\n  服务端\n  ![image-20230822155038817](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822155038817.png)\n\n  客户端\n  ![image-20230822155057787](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822155057787.png)\n\n  **他们是不相同的，如何理解？**\n  **这是两个进程，TCP的3号文件描述符用在了监听，4号用来和客户端进行通信，客户端也具有自己的文件描述符表，用的自然就是3号文件描述符**\n\n  然后是UDP：\n\n  服务端\n  ![image-20230822155443323](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822155443323.png)\n\n  客户端\n  ![image-20230822155501635](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822155501635.png)\n\n  **两个进程都只建立了一个文件描述符，所以当然各自进程都用自己最小可用的文件描述符就是3啊，这个跟文件描述符引用计数没关系，前提是需要是同一个进程，并且socket套接字指向的东西还是一样的**\n\n### 广播和组播\n\n**广播和多播就是发送方向多个接收方的主机发送消息，也就是一对多，广播是给所有的主机发送消息，只能用在局域网中；多播是给一个多播组中的所有主机发送消息，既可以用于广域网，也可以用于局域网；由于都是一对多，所以TCP的端对端的单播协议明显不适用，而只能用无连接不可靠的UDP协议**\n\n#### 广播\n\n向子网中多台计算机发送消息，并且子网中所有的计算机都可以接收到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为1。 \n\na.只能在局域网中使用。 \n\nb.客户端需要绑定服务器广播使用的端口，才可以接收到广播消息。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230822160604851.png\" alt=\"image-20230822160604851\" style=\"zoom:67%;\" />\n\n~~~cpp\n// 设置广播属性的函数\nint setsockopt(int sockfd, int level, int optname,const void *optval, socklen_t optlen);\n    - sockfd : 文件描述符\n    - level : SOL_SOCKET\n    - optname : SO_BROADCAST\n    - optval : int类型的值，为1表示允许广播\n    - optlen : optval的大小\n~~~\n\n##### 代码(有一处不明白)\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n#define MAX_IPV4_STRING 16\n\n// 广播的IP地址\nconst char* Broadcast_IP = \"127.255.255.255\";\n\nint main() {\n    // 1.创建通信的socket套接字\n    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (-1 == socket_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 开启广播设置\n    int _optval = 1;\n    setsockopt(socket_fd, SOL_SOCKET, SO_BROADCAST, &_optval, sizeof(_optval));\n\n    // 2.绑定IP和端口，其实在这里我们不接受数据，帮不绑定其实无所谓\n    struct sockaddr_in server_addr;\n    // 地址族\n    server_addr.sin_family = AF_INET;\n    // IP\n    inet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr.s_addr);\n    // 端口\n    server_addr.sin_port = htons(9999);\n\n    int ret = bind(socket_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == socket_fd) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    printf(\"server has initialized.\\n\");\n\n    // 封装广播客户端的socket地址\n    struct sockaddr_in All_Client_addr;\n    All_Client_addr.sin_family = AF_INET;\n    All_Client_addr.sin_port = htons(10000);\n    inet_pton(AF_INET, Broadcast_IP, &All_Client_addr.sin_addr.s_addr);\n\n    // 3.开始通信\n    static int num = 0;\n    char buf[MAX_BUF_SIZE] = {0};\n\n    while (1) {\n        // 服务端向所有的客户端广播数据\n        bzero(buf, sizeof(buf));\n        sprintf(buf, \"hello , i am server , num = %d\\n\", num++);\n        printf(\"send : %s\", buf);\n\n        sendto(socket_fd, buf, strlen(buf), 0, (struct sockaddr*)&All_Client_addr, sizeof(All_Client_addr));\n        sleep(1);\n    }\n\n    // 4.关闭套接字\n    close(socket_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n#define MAX_IPV4_STRING 16\n\nint main() {\n    // 1.创建通信的socket套接字\n    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (-1 == socket_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.绑定端口信息，让发送方能够正确找到\n    struct sockaddr_in client_addr;\n    // 地址族\n    client_addr.sin_family = AF_INET;\n    // IP\n    // inet_pton(AF_INET, \"127.0.0.2\", &client_addr.sin_addr.s_addr);  // 这行代码会出问题，但是我也不知道为什么\n    client_addr.sin_addr.s_addr = INADDR_ANY;\n    // 端口\n    client_addr.sin_port = htons(10000);\n\n    int ret = bind(socket_fd, (struct sockaddr*)&client_addr, sizeof(client_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    char buf[MAX_BUF_SIZE] = {0};\n\n    // 2.开始通信\n    while (1) {\n        // 读数据\n        recvfrom(socket_fd, buf, sizeof(buf) - 1, 0, nullptr, nullptr);\n        printf(\"recv : %s\", buf);\n    }\n\n    // 4.关闭套接字\n    close(socket_fd);\n\n    return 0;\n}\n~~~\n\n我们的代码需要做的功能是服务端启动后，即可开始向局域网内的所有主机广播信息，当有客户端连接进来的时候可以收到客户端的信息\n\n**我们先来解释bind()函数，为什么这里服务端和客户端都使用了bind()？**\n\n**bind()函数可以给我们socket()创建出来的文件描述符绑定我们自己设定的IP和端口信息，比如这里我就给服务端绑定了\"127.0.0.1\"和9999的信息，客户端绑定了任意IP(局域网内)和10000端口，IP是次要的，bind()函数绑定socket的时候应该首先考虑到给优先接受数据的一方绑定，比如这里就是客户端，为什么呢？因为我发送方一定需要知道一个具体的端口号我才能发送，在UDP中IP倒不一定必须，因为有可能是广播或者组播，这就不是一个具体的IP了，但是端口号是标识不同主机的进程的，所以发送方一定是根据这个端口号找到你对应的进程的，然后如果我得客户端不绑定，就由系统给我自动分配，那就找不到了，所以这里其实服务端的绑定其实没有必要，但是为了习惯我还是加上了；在TCP中也是一样的，我客户端先向服务端发送数据，在这之前需要建立连接，我也是通过人为指定的端口连接服务端，所以服务端绑定了端口，也就调用了bind()**\n\n但是这里我不明白我给客户端指定IP为 127.0.0.2 收不到服务端广播的消息，必须是局域网内的任意IP，也就是INADDR_ANY才行，这里我不明白\n\n另外还有一点就是广播的发送方要给socket()设置广播属性，就像这样\n\n~~~cpp\n// 开启广播设置\nint _optval = 1;\nsetsockopt(socket_fd, SOL_SOCKET, SO_BROADCAST, &_optval, sizeof(_optval));\n~~~\n\n#### 组播(多播)\n\n**单播地址标识单个 IP 接口，广播地址标识某个子网的所有 IP 接口，多播地址标识一组 IP 接口。 单播和广播是寻址方案的两个极端（要么单个要么全部），多播则意在两者之间提供一种折中方案。多播数据报只应该由对它感兴趣的接口接收，也就是说由运行相应多播会话应用系统的主机上的接口接收。另外，广播一般局限于局域网内使用，而多播则既可以用于局域网，也可以跨广域网使用。** \n\n**a.组播既可以用于局域网，也可以用于广域网** \n\n**b.客户端需要加入多播组，才能接收到多播的数据**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230822160649282.png\" alt=\"image-20230822160649282\" style=\"zoom:80%;\" />\n\n- 组播地址\n\nIP 多播通信必须依赖于 IP 多播地址，在 IPv4 中它的范围从 224.0.0.0 到 239.255.255.255 ， 并被划分为局部链接多播地址、预留多播地址和管理权限多播地址三类:\n\n![image-20230822160933192](https://cdn.davidingplus.cn/images/2025/01/31/image-20230822160933192.png)\n\n- 设置组播\n\n  ![image-20230823114653916](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823114653916.png)\n\n多播的API用的比较少，需要用的时候来查询就可以了，但是要知道工作原理\n\n~~~cpp\nint setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen);\n// 服务器设置多播的信息，外出接口\n    - level : IPPROTO_IP\n    - optname : IP_MULTICAST_IF\n    - optval : struct in_addr\n// 客户端加入到多播组：\n    - level : IPPROTO_IP\n    - optname : IP_ADD_MEMBERSHIP\n    - optval : struct ip_mreq\n        \nstruct ip_mreq {\n    /* IP multicast address of group. */\n    struct in_addr imr_multiaddr; // 组播的IP地址\n    /* Local IP address of interface. */\n    struct in_addr imr_interface; // 本地的IP地址\n};\n\ntypedef uint32_t in_addr_t;\nstruct in_addr {\n    in_addr_t s_addr;\n};\n~~~\n\n##### 代码(和前面同样的问题)\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n#define MAX_IPV4_STRING 16\n\n// 多播的IP地址\nconst char* Multicast_IP = \"239.0.0.10\";\n\nint main() {\n    // 1.创建通信的socket套接字\n    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (-1 == socket_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 设置多播属性，设置外出接口\n    struct in_addr _optval;\n    // 初始化多播地址\n    inet_pton(AF_INET, Multicast_IP, &_optval.s_addr);\n    setsockopt(socket_fd, IPPROTO_IP, IP_MULTICAST_IF, &_optval, sizeof(_optval));\n\n    // 发送方，这里我就不绑定端口了\n\n    printf(\"server has initialized.\\n\");\n\n    // 封装广播客户端的socket地址\n    struct sockaddr_in All_Client_addr;\n    All_Client_addr.sin_family = AF_INET;\n    All_Client_addr.sin_port = htons(10000);\n    inet_pton(AF_INET, Multicast_IP, &All_Client_addr.sin_addr.s_addr);\n\n    // 3.开始通信\n    static int num = 0;\n    char buf[MAX_BUF_SIZE] = {0};\n\n    while (1) {\n        // 服务端向所有的客户端广播数据\n        bzero(buf, sizeof(buf));\n        sprintf(buf, \"hello , i am server , num = %d\\n\", num++);\n        printf(\"send : %s\", buf);\n\n        sendto(socket_fd, buf, strlen(buf), 0, (struct sockaddr*)&All_Client_addr, sizeof(All_Client_addr));\n        sleep(1);\n    }\n\n    // 4.关闭套接字\n    close(socket_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n#define MAX_IPV4_STRING 16\n\n// 多播的IP地址\nconst char* Multicast_IP = \"239.0.0.10\";\n\nint main() {\n    // 1.创建通信的socket套接字\n    int socket_fd = socket(AF_INET, SOCK_DGRAM, 0);\n    if (-1 == socket_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 加入多播组\n    struct ip_mreq _optval;\n    // 初始化\n    _optval.imr_interface.s_addr = INADDR_ANY;\n    inet_pton(AF_INET, Multicast_IP, &_optval.imr_multiaddr.s_addr);\n\n    setsockopt(socket_fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &_optval, sizeof(_optval));\n\n    // 2.绑定端口信息，让发送方能够正确找到\n    struct sockaddr_in client_addr;\n    // 地址族\n    client_addr.sin_family = AF_INET;\n    // IP\n    // inet_pton(AF_INET, \"127.0.0.2\", &client_addr.sin_addr.s_addr);  // 和之前一样的问题\n    client_addr.sin_addr.s_addr = INADDR_ANY;\n    // 端口\n    client_addr.sin_port = htons(10000);\n\n    int ret = bind(socket_fd, (struct sockaddr*)&client_addr, sizeof(client_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    char buf[MAX_BUF_SIZE] = {0};\n\n    // 2.开始通信\n    while (1) {\n        // 读数据\n        recvfrom(socket_fd, buf, sizeof(buf) - 1, 0, nullptr, nullptr);\n        printf(\"recv : %s\", buf);\n    }\n\n    // 4.关闭套接字\n    close(socket_fd);\n\n    return 0;\n}\n~~~\n\n同样的客户端也能收到服务端发送而来的数据\n\n我们同样注意服务端和客户端对于设置多播和加入多播的设置方法\n\n服务端\n\n~~~cpp\n// 多播的IP地址\nconst char* Multicast_IP = \"239.0.0.10\";    \n\n// 设置多播属性，设置外出接口\nstruct in_addr _optval;\n// 初始化多播地址\ninet_pton(AF_INET, Multicast_IP, &_optval.s_addr);\nsetsockopt(socket_fd, IPPROTO_IP, IP_MULTICAST_IF, &_optval, sizeof(_optval));\n~~~\n\n客户端\n\n~~~cpp\n// 多播的IP地址\nconst char* Multicast_IP = \"239.0.0.10\";\n\n// 加入多播组\nstruct ip_mreq _optval;\n// 初始化\n_optval.imr_interface.s_addr = INADDR_ANY;\ninet_pton(AF_INET, Multicast_IP, &_optval.imr_multiaddr.s_addr);\n\nsetsockopt(socket_fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &_optval, sizeof(_optval));\n~~~\n\n## 本地套接字\n\n本地套接字的作用：本地的进程间通信 \n\t有关系的进程间的通信 \n\t没有关系的进程间的通信\n\n**之前我们学过的本地间进程之间通信的方式有：管道(匿名管道pipe，有名管道fifo)；内存映射；信号，信号集；共享内存。记得去复习**\n\n本地套接字实现流程和网络套接字类似，一般呢采用**TCP**的通信流程。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230823123131126.png\" alt=\"image-20230823123131126\" style=\"zoom: 80%;\" />\n\n### API\n\n~~~cpp\n// 本地套接字通信的流程 - tcp\n\n// 服务器端\n1. 创建监听的套接字\n\tint lfd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);\n2. 监听的套接字绑定本地的套接字文件 -> server端\n\tstruct sockaddr_un addr;\n\t// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。addr里面存的就是他的路径\n\tbind(lfd, addr, len);\n3. 监听\n\tlisten(lfd, 100);\n4. 等待并接受连接请求\n\tstruct sockaddr_un cliaddr; // 用的时候记得引头文件 #include <sys/un.h>\n\tint cfd = accept(lfd, &cliaddr, len);\n5. 通信\n\t接收数据：read/recv\n\t发送数据：write/send\n6. 关闭连接\n\tclose();\n\n// 客户端的流程\n1. 创建通信的套接字\n\tint fd = socket(AF_UNIX/AF_LOCAL, SOCK_STREAM, 0);\n2. 监听的套接字绑定本地的套接字文件 -> client端\n\tstruct sockaddr_un addr;\n\t// 绑定成功之后，指定的sun_path中的套接字文件会自动生成。\n\tbind(lfd, addr, len);\n3. 连接服务器\n\tstruct sockaddr_un serveraddr;\n\tconnect(fd, &serveraddr, sizeof(serveraddr));\n4. 通信\n\t接收数据：read/recv\n\t发送数据：write/send\n5. 关闭连接\n\tclose();\n~~~\n\n~~~cpp\n// 头文件: sys/un.h\n#define UNIX_PATH_MAX 108\nstruct sockaddr_un {\n\tsa_family_t sun_family; // 地址族协议 af_local\n\tchar sun_path[UNIX_PATH_MAX]; // 套接字文件的路径, 这是一个伪文件, 大小永远=0\n}\n~~~\n\n###  工作原理\n\n**我们观察他的流程图以及结合上面API的注释，在本地文件socket地址中，由于是本地的通信，我们不使用IPV4地址或者IPV6地址，也就是sockaddr_in和sockadd_in6，我们使用 sockaddr_un 这个结构体来封装本地的信息，这个结构体一个参数是地址族，另一个参数就非常重要了，就是指定我们用于通信的套接字文件的路径，例如图中就是server.sock和client.sock，这是一个伪文件，大小永远都是0，是用来进行本地进程间通信的；这个文件会在磁盘中被创建出来，在通信的时候，在内核中对应了一块缓冲区，如图所示，客户端B发送数据，先将数据写道他的写缓冲区，在发送到服务端的读缓冲区，因此读写双方都必须有一个这个套接字文件的路径，也就是都需要绑定bind()，这就和一般的TCP通信有区别**\n\n![image-20230823124612140](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823124612140.png)\n\n### 代码\n\n这里我第一次使用TCP特有的send()和recv()函数，他们的返回值和什么时候返回我现在还不是很明白，和write()和read()大差不差，但是还是有区别，需要后续对内核源码的学习才能更好的理解\n\n~~~cpp\n// server.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <sys/un.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n\nint main() {\n    // 1.创建socket本地套接字\n    int listen_fd = socket(AF_LOCAL, SOCK_STREAM, 0);\n    if (-1 == listen_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.绑定本地套接字文件\n    struct sockaddr_un server_addr;\n    // 地址族\n    server_addr.sun_family = AF_LOCAL;\n    // 套接字文件绑定了之后自动生成一个文件用于通信\n    strcpy(server_addr.sun_path, \"server.sock\");\n\n    int ret = bind(listen_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    // 3.监听\n    ret = listen(listen_fd, 5);\n    if (-1 == ret) {\n        perror(\"listen\");\n        return -1;\n    }\n\n    // 4.等待客户端连接\n    struct sockaddr_un client_addr;\n    socklen_t client_addr_len = sizeof(client_addr);\n\n    int connect_fd = accept(listen_fd, (struct sockaddr*)&client_addr, &client_addr_len);\n    if (-1 == connect_fd) {\n        perror(\"accept\");\n        return -1;\n    }\n\n    printf(\"client (socket filename : %s) has connected.\\n\", client_addr.sun_path);\n\n    char buf[MAX_BUF_SIZE] = {0};\n    // 5.开始通信\n    while (1) {\n        // 读\n        bzero(buf, sizeof(buf));\n        int len = recv(connect_fd, buf, sizeof(buf) - 1, 0);\n        if (-1 == len) {\n            if (errno == ECONNRESET)  // 报错处理\n                goto CLOSE;\n            perror(\"recv\");\n            return -1;\n        }\n\n        if (len > 0)\n            printf(\"recv : %s\", buf);\n        else if (0 == len) {\n        CLOSE:\n            printf(\"client (socket filename : %s) has closed...\\n\", client_addr.sun_path);\n            break;\n        }\n\n        // 写\n        send(connect_fd, buf, strlen(buf), 0);\n    }\n\n    // 6.关闭连接\n    close(connect_fd);\n    close(listen_fd);\n\n    return 0;\n}\n~~~\n\n~~~cpp\n// client.cpp\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#include <arpa/inet.h>\n#include <sys/un.h>\n#include <unistd.h>\n\n#define MAX_BUF_SIZE 1024\n\nint main() {\n    // 1.创建本地socket套接字\n    int connect_fd = socket(AF_LOCAL, SOCK_STREAM, 0);\n    if (-1 == connect_fd) {\n        perror(\"socket\");\n        return -1;\n    }\n\n    // 2.绑定本地套接字文件\n    struct sockaddr_un client_addr;\n    client_addr.sun_family = AF_LOCAL;\n    strcpy(client_addr.sun_path, \"client.sock\");\n\n    int ret = bind(connect_fd, (struct sockaddr*)&client_addr, sizeof(client_addr));\n    if (-1 == ret) {\n        perror(\"bind\");\n        return -1;\n    }\n\n    // 3.连接客户端\n    struct sockaddr_un server_addr;\n    server_addr.sun_family = AF_LOCAL;\n    strcpy(server_addr.sun_path, \"server.sock\");\n\n    ret = connect(connect_fd, (struct sockaddr*)&server_addr, sizeof(server_addr));\n    if (-1 == ret) {\n        perror(\"connect\");\n        return -1;\n    }\n\n    char buf[MAX_BUF_SIZE] = {0};\n    static int num = 0;\n    // 4.开始通信\n    while (1) {\n        // 写\n        bzero(buf, sizeof(buf));\n        sprintf(buf, \"hello , i am client , num : %d\\n\", num++);\n        printf(\"send : %s\", buf);\n        send(connect_fd, buf, strlen(buf), 0);\n\n        // 读\n        bzero(buf, sizeof(buf));\n        int len = recv(connect_fd, buf, sizeof(buf) - 1, 0);\n        if (-1 == len) {\n            perror(\"recv\");\n            return -1;\n        }\n        if (len > 0)\n            printf(\"recv : %s\", buf);\n        else if (0 == len) {\n            printf(\"server has closed...\\n\");\n            break;\n        }\n\n        sleep(1);\n    }\n\n    return 0;\n}\n~~~\n\n#### 代码分析(细节地方不是很明白)\n\n代码中有很多地方值得我们推敲，我们先来看代码的执行结果：\n\n注意，由于我们是通过套接字文件和内核缓冲区进行联系，因此会创建出来一个套接字文件，只能使用Linux的原生目录！\n\n服务端\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/31/image-20230823151111152.png\" alt=\"image-20230823151111152\" style=\"zoom:80%;\" />\n\n客户端\n\n![image-20230823151122954](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823151122954.png)\n\n可以看出能够正常跑出来，当我们绑定bind()套接字文件之后我们查看目录下多出了两个文件，这两个文件正是用来与内核中缓冲区直接联系并且用于通信的；可以看出他们并没有大小，是一个伪文件\n\n![image-20230823151222376](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823151222376.png)\n\n现在我再次运行服务端或者客户端，发现出现了这样的情况：\n\n报错：bind Address already in use；这正是因为我们创建的套接字文件还在这里没有被释放(删除)导致被占据而没有办法bind()成功导致的，我们将其删除即可\n\n![image-20230823151351101](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823151351101.png)\n\n我们查看代码中的这一部分：\n\n~~~cpp\n// server.cpp\n...\n\n// 5.开始通信\nwhile (1) {\n\t...\n        \n    int len = recv(connect_fd, buf, sizeof(buf) - 1, 0);\n    if (-1 == len) {\n        if (errno == ECONNRESET)  // 报错处理\n            goto CLOSE;\n        perror(\"recv\");\n        return -1;\n    }\n\n\t...\n        \n    else if (0 == len) {\n    CLOSE:\n        printf(\"client (socket filename : %s) has closed...\\n\", client_addr.sun_path);\n        break;\n    }\n\n\t...\n}\n\n...\n~~~\n\n我们发现进行了一个报错的特殊处理，我们试着将其删除再来跑代码，这次我们强制停掉客户端，结果如下：\n\n客户端\n\n![image-20230823152331909](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823152331909.png)\n\n服务端\n\n![image-20230823152340686](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823152340686.png)\n\n可以看出在读数据的时候报错了，错误信息是 Connection rest by peer，我不知道具体原因，但是我猜测大致应该是强制停掉客户端，客户端结束后会给服务端发送一个信号，然后服务端这个时候也在阻塞读，收到这个信号后就不阻塞了(和之前那个软中断类似)，然后发生了错误，但是其实是客户端断开了连接导致的\n\n上网查询后我们发现错误号是 ECONNRESET ，因此特殊处理即可\n\n还是上面的代码，我不做处理，当我让client正常的结束，这里我让while()加了个条件，发现不报错了，走的是 0==len 写端关闭的这里，并且话也正常打印出来了，如下：\n\n客户端\n\n![image-20230823152830630](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823152830630.png)\n\n服务端\n\n![image-20230823152839250](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823152839250.png)\n\n因此这个recv()函数什么时候返回，或者返回什么值，甚至read()的认知都有可能在这里和我的不完全一样，等待后续的进一步研究吧\n\n现在我们在一切代码正确的情况下强制停掉服务端，结果如下：\n\n服务端\n\n![image-20230823153112240](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823153112240.png)\n\n客户端\n\n![image-20230823153119822](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823153119822.png)\n\n我们发现客户端直接停止运行了，没有报错也没有正常的输出，肯定是异常退出，但是这里我确实不知道为什么，可见水很深\n\n说了这么多，其实真正的开发能用就行，但是现在在学习的过程还是要尽量考虑完全，每一步都尽量弄明白\n\n# 第五章 项目实战和总结\n\n我们的最终目标是完成一个web服务器项目\n\n## 阻塞/非阻塞、同步/异步(网络IO)\n\n**典型的一次IO的两个阶段是什么？数据就绪 和 数据读写**\n\n数据就绪：根据系统IO操作的就绪状态\n\n- 阻塞\n- 非阻塞\n\n数据读写：根据应用程序和内核的交互方式\n\n- 同步\n- 异步\n\n结合这张图理解：\n\n- **数据就绪部分，每一个文件描述符在进行读写操作的时候在内核中都对应了一块缓冲区用于临时存放接受到或者写了要发出去的数据，例如，当有数据进来让读缓冲区不为空的时候，就是数据读的就绪的时候，发生在操作系统的内核部分**\n\n  **数据读写部分，用户程序部分，就是用户向文件内写或者读数据，也就是写入缓冲区或者读入缓冲区，然后缓冲区再到内存或者通信就是另一方的缓冲区**\n\n- **同步：我们用户自己定义一个buf[]来存放缓冲区中的数据，代码在执行的时候一点点从sockfd对应的内核缓冲区中搬到我们的buf[]当中，搬移完毕之前代码不会向下执行；这种过程是我们用户应用程序自己搬(因为我们读的时候停在这里了，在这个过程中我们没有办法执行其他工作)，不是操作系统搬完了通知我们**\n\n  **异步：操作系统给我们搬，搬完了通知我们，比较常见的方式是sigio信号，相比同步效率更高，因为搬动过程中应用程序可以干自己的工作，但是要看系统有没有提供接口并且代码的编写也不简单**\n\n![阻塞、非阻塞、同步、异步](https://cdn.davidingplus.cn/images/2025/02/01/阻塞、非阻塞、同步、异步.png)\n\n陈硕：**在处理 IO 的时候，阻塞和非阻塞都是同步 IO，只有使用了特殊的 API 才是异步 IO。**\n\n注意：I/O多路复用(多路转接)技术，select/poll/epoll 三种技术都是同步操作；首先它只能帮我们检测到有多少个客户端是数据就绪的，或者哪几个(epoll)，真正的数据读写操作还是我们自己解决，因此是同步；第二，根据陈硕老师说的话，一般情况我们都是使用同步的I/O，因为异步I/O会导致一些不可预期的问题，并且用的很少，一般只有使用特殊的API才是异步I/O\n\n![image-20230823155027679](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823155027679.png)\n\n**一个典型的网络IO接口调用，分为两个阶段，分别是“数据就绪” 和“数据读写”，数据就绪阶段分为阻塞和非阻塞，表现得结果就是，阻塞当前线程或是直接返回。** \n\n**同步表示A向B请求调用一个网络IO接口时（或者调用某个业务逻辑API接口时），数据的读写都是由请求方A自己来完成的（不管是阻塞还是非阻塞）；异步表示A向B请求调用一个网络IO接口时 （或者调用某个业务逻辑API接口时），向B传入请求的事件以及事件发生时通知的方式，A就可以处理其它逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，通知A处理结果。**\n\n**我们为什么不建议使用异步接口？很大一个原因就是异步接口系统通知用户大部分使用信号，使用信号产生软中断之后，在多进程或者多线程当中可能会出现一些难以想到的问题，不好处理，这也加大了代码的编写复杂程度**\n\n- 同步阻塞\n- 同步非阻塞\n- 异步阻塞\n- 异步非阻塞 **(异步基本上伴着非阻塞使用，因为我们应用程序交给操作系统处理之后我们可以继续往下执行，提高效率)**\n\n## Unix/Linux上的五种IO模型\n\n### 阻塞 blocking\n\n调用者调用了某个函数，等待这个函数返回，期间什么也不做，不停的去检查这个函数有没有返回，必须等这个函数返回才能进行下一步动作。\n\n![image-20230823155137394](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823155137394.png)\n\n### 非阻塞 non-blocking（NIO）\n\n非阻塞等待，每隔一段时间就去检测IO事件是否就绪。没有就绪就可以做其他事。非阻塞I/O执行系统调用总是立即返回**，不管事件是否已经发生，若事件没有发生，则返回-1，此时可以根据 errno 区分这两种情况，对于accept，recv 和 send，事件未发生时，errno 通常被设置成 EAGAIN。**\n\n![image-20230823155156625](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823155156625.png)\n\n### IO复用（IO multiplexing）\n\nLinux 用 select/poll/epoll 函数实现 IO 复用模型，这些函数也会使进程阻塞，但是和阻塞IO所不同的是 这些函数可以同时阻塞多个IO操作。而且可以同时对多个读操作、写操作的IO函数进行检测。直到有数 据可读或可写时，才真正调用IO操作函数。\n\n![image-20230823155217650](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823155217650.png)\n\n### 信号驱动（signal-driven）\n\nLinux 用套接口进行信号驱动 IO，安装一个信号处理函数，进程继续运行并不阻塞，当IO事件就绪，进程收到 SIGIO 信号，然后处理 IO 事件。\n\n![image-20230823155237200](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823155237200.png)\n\n内核在第一个阶段是异步，在第二个阶段是同步；与非阻塞IO的区别在于它提供了消息通知机制，不需要用户进程不断的轮询检查，减少了系统API的调用次数，提高了效率。 \n\n### 异步（asynchronous）\n\nLinux中，可以调用 aio_read 函数告诉内核描述字缓冲区指针和缓冲区的大小、文件偏移及通知的方式，然后立即返回，当内核将数据拷贝到缓冲区后，再通知应用程序\n\n![image-20230823155255891](https://cdn.davidingplus.cn/images/2025/01/31/image-20230823155255891.png)\n\n~~~cpp\n/* Asynchronous I/O control block. */\nstruct aiocb {\n    int aio_fildes; /* File desriptor. */\n    int aio_lio_opcode; /* Operation to be performed. */\n    int aio_reqprio; /* Request priority offset. */\n    volatile void *aio_buf; /* Location of buffer. */\n    size_t aio_nbytes; /* Length of transfer. */\n    struct sigevent aio_sigevent; /* Signal number and value. */\n    \n    /* Internal members. */\n    struct aiocb *__next_prio;\n    int __abs_prio;\n    int __policy;\n    int __error_code;\n    __ssize_t __return_value;\n    \n    #ifndef __USE_FILE_OFFSET64\n        __off_t aio_offset; /* File offset. */\n        char __pad[sizeof (__off64_t) - sizeof (__off_t)];\n    #else\n        __off64_t aio_offset; /* File offset. */\n    #endif\n        char __glibc_reserved[32];\n};\n~~~\n\n## Web Server(网页服务器)\n\n一个 Web Server 就是一个服务器软件（程序），或者是运行这个服务器软件的硬件（计算机）。其主要功能是通过 HTTP 协议与客户端（通常是浏览器（Browser））进行通信，来接收，存储，处理来自客户端的 HTTP 请求，并对其请求做出 HTTP 响应，返回给客户端其请求的内容（文件、网页等）或返 回一个 Error 信息。\n\n![image-20230825104334383](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825104334383.png)\n\n通常用户使用 Web 浏览器与相应服务器进行通信。在浏览器中键入“域名”或“IP地址:端口号”，浏览器则 先将你的域名解析成相应的 IP 地址或者直接根据你的IP地址向对应的 Web 服务器发送一个 HTTP 请求。这一过程首先要通过 TCP 协议的三次握手建立与目标 Web 服务器的连接，然后 HTTP 协议生成针 对目标 Web 服务器的 HTTP 请求报文，通过 TCP、IP 等协议发送到目标 Web 服务器上。\n\n## HTTP协议(应用层的协议)\n\n### 简介\n\n超文本传输协议（Hypertext Transfer Protocol，HTTP）是一个简单的请求 - 响应协议，它通常运行在 TCP 之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。**请求和响应消息的头以 ASCII 形式给出；而消息内容则具有一个类似 MIME 的格式。HTTP是万维网的数据通信的基础。** \n\nHTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万 维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定 义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。\n\n### 概述\n\nHTTP 是一个客户端终端（用户）和服务器端（网站）请求和应答的标准（TCP）。通过使用网页浏览器、网络爬虫或者其它的工具，客户端发起一个HTTP请求到服务器上指定端口（默认端口为80）。我们 称这个客户端为用户代理程序（user agent）。应答的服务器上存储着一些资源，比如 HTML 文件和图 像。我们称这个应答服务器为源服务器（origin server）。在用户代理和源服务器中间可能存在多个“中 间层”，比如代理服务器、网关或者隧道（tunnel）。 \n\n尽管 TCP/IP 协议是互联网上最流行的应用，HTTP 协议中，并没有规定必须使用它或它支持的层。事实 上，HTTP可以在任何互联网协议上，或其他网络上实现。HTTP 假定其下层协议提供可靠的传输。因此，任何能够提供这种保证的协议都可以被其使用。因此也就是其在 TCP/IP 协议族使用 TCP 作为其传输层。 \n\n通常，由HTTP客户端发起一个请求，创建一个到服务器指定端口（默认是80端口）的 TCP 连接。HTTP 服务器则在那个端口监听客户端的请求。一旦收到请求，服务器会向客户端返回一个状态，比 如\"HTTP/1.1 200 OK\"，以及返回的内容，如请求的文件、错误消息、或者其它信息。\n\n### 工作原理\n\n**HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。HTTP 协议采用了请求/响应模型。客户端向服务器发送一个请求报文，请求报文包含请求的方 法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版 本、成功或者错误代码、服务器信息、响应头部和响应数据。**\n\n以下是 HTTP 请求/响应的步骤： \n\n1. 客户端连接到 Web 服务器 一个HTTP客户端，通常是浏览器，与 Web 服务器的 HTTP 端口（默认为 80 ）建立一个 TCP 套接字连接。例如，http://www.baidu.com。（URL） \n2. 发送 HTTP 请求 通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据 4 部分组成。 \n3. 服务器接受请求并返回 HTTP 响应 Web 服务器解析请求，定位请求资源。服务器将资源复本写到 TCP 套接字，由客户端读取。一个 响应由状态行、响应头部、空行和响应数据 4 部分组成。 \n4. 释放连接 TCP 连接 若 connection 模式为 close，则服务器主动关闭 TCP连接，客户端被动关闭连接，释放 TCP 连 接；若connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; \n5. 客户端浏览器解析 HTML 内容 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应 头告知以下为若干字节的 HTML 文档和文档的字符集。客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。\n\n例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程： \n\n1. 浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址; \n2. 解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立 TCP 连接; \n3. 浏览器发出读取文件（ URL 中域名后面部分对应的文件）的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器; \n4. 服务器对浏览器请求作出响应，并把对应的 HTML 文本发送给浏览器; \n5. 释放 TCP 连接; \n6. 浏览器将该 HTML 文本并显示内容。\n\n![image-20230825104527500](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825104527500.png)\n\nHTTP 协议是基于 TCP/IP 协议之上的应用层协议，基于 请求-响应 的模式。HTTP 协议规定，请求从客 户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端 在没有接收到请求之前不会发送响应。\n\n### HTTP请求报文格式\n\n![image-20230825104549067](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825104549067.png)\n\n请求头示例：\n\n~~~http\nGET / HTTP/1.1\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\nCache-Control: max-age=0\nConnection: keep-alive\nCookie: BAIDUID_BFESS=EDD638FDDEE39DA6726BEF39B766F772:FG=1; BIDUPSID=EDD638FDDEE39DA6726BEF39B766F772; PSTM=1692844550; BD_UPN=12314753; ZFY=k1Qc:BgGUBKTsi3GUtqJh0rkU8WABgG3nCPeWyqD:BLRs:C; BA_HECTOR=010g810l2ga525208lag0k0q1ieg58u1o; RT=\"z=1&dm=baidu.com&si=de024639-c7be-4913-b467-d3935e4a8d1b&ss=llpzta3z&sl=0&tt=0&bcn=https%3A%2F%2Ffclog.baidu.com%2Flog%2Fweirwood%3Ftype%3Dperf&ul=vdy&hd=vef\"\nHost: www.baidu.com\nSec-Fetch-Dest: document\nSec-Fetch-Mode: navigate\nSec-Fetch-Site: none\nSec-Fetch-User: ?1\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.37\nsec-ch-ua: \"Not.A/Brand\";v=\"8\", \"Chromium\";v=\"114\", \"Microsoft Edge\";v=\"114\"\nsec-ch-ua-mobile: ?0\nsec-ch-ua-platform: \"Windows\"\n~~~\n\n### HTTP响应报文格式\n\n![image-20230825104624298](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825104624298.png)\n\n响应头示例：\n\n~~~http\nHTTP/1.1 200 OK\nConnection: keep-alive\nContent-Encoding: gzip\nContent-Security-Policy: frame-ancestors 'self' https://chat.baidu.com http://mirror-chat.baidu.com https://fj-chat.baidu.com https://hba-chat.baidu.com https://hbe-chat.baidu.com https://njjs-chat.baidu.com https://nj-chat.baidu.com https://hna-chat.baidu.com https://hnb-chat.baidu.com http://debug.baidu-int.com;\nContent-Type: text/html; charset=utf-8\nDate: Fri, 25 Aug 2023 03:37:36 GMT\nServer: BWS/1.1\nTraceid: 1692934656033891585015847248764579371337\nX-Ua-Compatible: IE=Edge,chrome=1\nTransfer-Encoding: chunked\n\n// 响应正文(和响应头之间有一个空行)\n...\n~~~\n\n### HTTP请求方法\n\nHTTP/1.1 协议中共定义了八种方法（也叫“动作”）来以不同方式操作指定的资源：\n\n1. **GET：向指定的资源发出“显示”请求。使用 GET 方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在 Web Application 中。其中一个原因是 GET 可能会被网络蜘蛛(爬虫)等随意访问。** \n2. HEAD：与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该 资源的信息”（元信息或称元数据）。 \n3. **POST：向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。** \n4. PUT：向指定资源位置上传其最新内容。 \n5. DELETE：请求服务器删除 Request-URI 所标识的资源。 \n6. TRACE：回显服务器收到的请求，主要用于测试或诊断。 \n7. OPTIONS：这个方法可使服务器传回该资源所支持的所有 HTTP 请求方法。用'*'来代替资源名称， 向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。 \n8. CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服 务器的链接（经由非加密的 HTTP 代理服务器）。\n\n### HTTP状态码\n\n所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态 的短语，彼此由空格分隔。\n\n**状态代码的第一个数字代表当前响应的类型：**\n\n- **1xx消息——请求已被服务器接收，继续处理** \n- **2xx成功——请求已成功被服务器接收、理解、并接受** \n- **3xx重定向——需要后续操作才能完成这一请求** \n- **4xx请求错误——请求含有词法错误或者无法被执行** \n- **5xx服务器错误——服务器在处理某个正确请求时发生错误**\n\n虽然 RFC 2616 中已经推荐了描述状态的短语，例如\"200 OK\"，\"404 Not Found\"，但是WEB开发者仍 然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。\n\n![image-20230825104759498](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825104759498.png)\n\n更多状态码: https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660?r=aladdin\n\n## 服务器编程基本框架\n\n虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。\n\n![image-20230825114344227](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825114344227.png)\n\n| 模块         | 功能                       |\n| ------------ | :------------------------- |\n| I/O 处理单元 | 处理客户连接，读写网络数据 |\n| 逻辑单元     | 业务进程或线程             |\n| 网络存储单元 | 数据库、文件或缓存         |\n| 请求队列     | 各单元之间的通信方式       |\n\n**I/O 处理单元是服务器管理客户连接的模块。它通常要完成以下工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是数据的收发不一定在 I/O 处理单元中执行，也可能在 逻辑单元中执行，具体在何处执行取决于事件处理模式。** \n\n**一个逻辑单元通常是一个进程或线程。它分析并处理客户数据，然后将结果传递给 I/O 处理单元或者直接发送给客户端（具体使用哪种方式取决于事件处理模式）。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并发处理。** \n\n**网络存储单元可以是数据库、缓存和文件，但不是必须的。** \n\n**请求队列是各单元之间的通信方式的抽象。I/O 处理单元接收到客户请求时，需要以某种方式通知一个 逻辑单元来处理该请求。同样，多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处 理竞态条件。请求队列通常被实现为池的一部分。**\n\n## 两种高效的事件处理模式\n\n**服务器程序通常需要处理三类事件：I/O 事件、信号及定时事件。有两种高效的事件处理模式：Reactor 和 Proactor，同步 I/O 模型通常用于实现 Reactor 模式，异步 I/O 模型通常用于实现 Proactor 模式。**\n\n### Reactor模式\n\n**要求主线程（I/O处理单元）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作 线程（逻辑单元），将 socket 可读可写事件放入请求队列，交给工作线程处理。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。**\n\n使用同步 I/O（以 epoll_wait 为例）实现的 Reactor 模式的工作流程是：\n\n1. 主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。 \n2. 主线程调用 epoll_wait 等待 socket 上有数据可读。 \n3. 当 socket 上有数据可读时， epoll_wait 通知主线程。主线程则将 socket 可读事件放入请求队列。 \n4. 睡眠在请求队列上的某个工作线程被唤醒，它从 socket 读取数据，并处理客户请求，然后往 epoll 内核事件表中注册该 socket 上的写就绪事件。 \n5. 当主线程调用 epoll_wait 等待 socket 可写。 \n6. 当 socket 可写时，epoll_wait 通知主线程。主线程将 socket 可写事件放入请求队列。 \n7. 睡眠在请求队列上的某个工作线程被唤醒，它往 socket 上写入服务器处理客户请求的结果。\n\nReactor 模式的工作流程：\n\n![image-20230825114619086](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825114619086.png)\n\n### Proactor模式\n\n**Proactor 模式将所有 I/O 操作都交给主线程和内核来处理（进行读、写），工作线程仅仅负责业务逻辑。**\n\n使用异步 I/O 模型（以 aio_read 和 aio_write 为例）实现的 Proactor 模式的工作流程是：\n\n1. 主线程调用 aio_read 函数向内核注册 socket 上的读完成事件，并告诉内核用户读缓冲区的位置， 以及读操作完成时如何通知应用程序（这里以信号为例）。 \n2. 主线程继续处理其他逻辑。 \n3. 当 socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。 \n4. 应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求后，调用 aio_write 函数向内核注册 socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。 \n5. 主线程继续处理其他逻辑。 \n6. 当用户缓冲区的数据被写入 socket 之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。 \n7. 应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭 socket。\n\nProactor 模式的工作流程：\n\n![image-20230825114659772](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825114659772.png)\n\n### 模拟 Proactor 模式\n\n**使用同步 I/O 方式模拟出 Proactor 模式。原理是：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一”完成事件“。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下 来要做的只是对读写的结果进行逻辑处理。**\n\n使用同步 I/O 模型（以 epoll_wait为例）模拟出的 Proactor 模式的工作流程如下：\n\n1. **主线程往 epoll 内核事件表中注册 socket 上的读就绪事件。** \n2. **主线程调用 epoll_wait 等待 socket 上有数据可读。** \n3. **当 socket 上有数据可读时，epoll_wait 通知主线程。主线程从 socket 循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。(注意是主线程读了封装好交给线程池去处理)** \n4. **睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往 epoll 内核事 件表中注册 socket 上的写就绪事件。** \n5. **主线程调用 epoll_wait 等待 socket 可写。** \n6. **当 socket 可写时，epoll_wait 通知主线程。主线程往 socket 上写入服务器处理客户请求的结果。**\n\n同步 I/O 模拟 Proactor 模式的工作流程：\n\n![image-20230825114740311](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825114740311.png)\n\n## 线程池\n\n**我们在之前写多线程的TCP通信的时候，处理客户端的请求是客户端来一个我接受一个，然后创建子线程去处理逻辑，这样的方式我们仔细想一下好嘛？其实并不好，为什么呢？因为我们假设某一时刻同时进来了很多个客户端，服务器在这一瞬间的压力是巨大的，而后因为客户端的不断增多，服务器的压力也在不断的增大，并且由于我们是需要用的时候创建子线程，用完就把子线程给销毁掉，在这个过程中也是非常消耗系统的资源和时间的，所以不推荐使用。所以我们这里用线程池解决这些问题**\n\n**线程池是由服务器预先创建的一组子线程，线程池中的线程数量应该和 CPU 数量差不多。线程池中的所有子线程都运行着相同的代码。当有新的任务到来时，主线程将通过某种方式选择线程池中的某一个子线程来为之服务。相比与动态的创建子线程，选择一个已经存在的子线程的代价显然要小得多。**至于主线程选择哪个子线程来为新任务服务，则有多种方式：\n\n- 主线程使用某种算法来主动选择子线程。最简单、最常用的算法是随机算法和 Round Robin（轮流 选取）算法，但更优秀、更智能的算法将使任务在各个工作线程中更均匀地分配，从而减轻服务器的整体压力。\n- **主线程和所有子线程通过一个共享的工作队列来同步，子线程都睡眠在该工作队列上。当有新的任务到来时，主线程将任务添加到工作队列中。这将唤醒正在等待任务的子线程，不过只有一个子线程将获得新任务的”接管权“，它可以从工作队列中取出任务并执行之，而其他子线程将继续睡眠在工作队列上。**\n\n线程池的一般模型为：\n\n![image-20230825145330177](https://cdn.davidingplus.cn/images/2025/01/31/image-20230825145330177.png)\n\n线程池中的线程数量最直接的限制因素是中央处理器(CPU)的处理器(processors/cores)的数量 N ：如果你的CPU是4-cores的，对于CPU密集型的任务(如视频剪辑等消耗CPU计算资源的任务)来 说，那线程池中的线程数量最好也设置为4（或者+1防止其他因素造成的线程阻塞）；对于IO密集 型的任务，一般要多于CPU的核数，因为线程间竞争的不是CPU的计算资源而是IO，IO的处理一 般较慢，多于cores数的线程将为CPU争取更多的任务，不至在线程处理IO的过程造成CPU空闲导 致资源浪费。\n\n- 空间换时间，浪费服务器的硬件资源，换取运行效率。 \n- 池是一组资源的集合，这组资源在服务器启动之初就被完全创建好并初始化，这称为静态资源。 \n- 当服务器进入正式运行阶段，开始处理客户请求的时候，如果它需要相关的资源，可以直接从池中获取，无需动态分配。 \n- 当服务器处理完一个客户连接后，可以把相关的资源放回池中，无需执行系统调用释放资源。\n\n## 有限状态机\n\n逻辑单元内部的一种高效编程方法：有限状态机（finite state machine）。 \n\n有的应用层协议头部包含数据包类型字段，每种类型可以映射为逻辑单元的一种执行状态，服务器可以 根据它来编写相应的处理逻辑。如下是一种状态独立的有限状态机：\n\n~~~cpp\nSTATE_MACHINE( Package _pack ) {\n    PackageType _type = _pack.GetType();\n    switch( _type ) {\n        case type_A:\n            process_package_A( _pack );\n            break;\n        case type_B:\n            process_package_B( _pack );\n            break;\n    }\n}\n~~~\n\n这是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。 状态之间的转移是需要状态机内部驱动，如下代码：\n\n~~~cpp\nSTATE_MACHINE() {\n\tState cur_State = type_A;\n    while( cur_State != type_C ) {\n        Package _pack = getNewPackage();\n        switch( cur_State ) {\n        case type_A:\n            process_package_state_A( _pack );\n            cur_State = type_B;\n            break;\n        case type_B:\n            process_package_state_B( _pack );\n            cur_State = type_C;\n            break;\n        }\n    }\n}\n~~~\n\n该状态机包含三种状态：type_A、type_B 和 type_C，其中 type_A 是状态机的开始状态，type_C 是状 态机的结束状态。状态机的当前状态记录在 cur_State 变量中。在一趟循环过程中，状态机先通过 getNewPackage 方法获得一个新的数据包，然后根据 cur_State 变量的值判断如何处理该数据包。数据 包处理完之后，状态机通过给 cur_State 变量传递目标状态值来实现状态转移。那么当状态机进入下一 趟循环时，它将执行新的状态对应的逻辑。\n\n## EPOLLONESHOT事件\n\n我们即使可以使用 ET 模式，一个socket 上的某个事件还是可能被触发多次，因为可能这个socket上没读完就有新数据进来了，这在并发程序中就会引起一个问题。比如一个线程在读取完某个 socket 上的数据后开始处理这些数据，而在数据的处理过程中该 socket 上又有新数据可读（EPOLLIN 再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个 socket 的局面。一个socket连接在任一时刻都只被一个线程处理，可以使用 epoll 的 EPOLLONESHOT 事件实现。 \n\n**对于注册了 EPOLLONESHOT 事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次(加入了这个事件之后即使是LT工作模式也只能触发一次)，除非我们使用 epoll_ctl 函数重置该文件描述符上注册的 EPOLLONESHOT 事件。**这样，当一个线程在处理某个 socket 时，其他线程是不可能有机会操作该 socket 的。但反过来思考，注册了 EPOLLONESHOT 事件的 socket 一旦被某个线程处理完毕， 该线程就应该立即重置这个 socket 上的 EPOLLONESHOT 事件，以确保这个 socket 下一次可读时，其 EPOLLIN 事件能被触发，进而让其他工作线程有机会继续处理这个 socket。\n\n## 服务器压力测试\n\nWebbench 是 Linux 上一款知名的、优秀的 web 性能压力测试工具。它是由Lionbridge公司开发。 \n\n- 测试处在相同硬件上，不同服务的性能以及不同硬件上同一个服务的运行状况。 \n- 展示服务器的两项内容：每秒钟响应请求数和每秒钟传输数据量。 \n\n基本原理：Webbench 首先 fork 出多个子进程，每个子进程都循环做 web 访问测试。子进程把访问的结果通过 pipe 告诉父进程，父进程做最终的统计结果。\n\n测试示例\n\n~~~bash\nwebbench -c 1000 -t 30 http://192.168.110.129:10000/index.html\n    参数：\n        -c 表示客户端数\n        -t 表示时间\n~~~\n\n## 项目总体流程实现以及代码\n\n这个项目目前是写的差不多了，但是还有bug，响应报文回写出了些问题，我还没来得及修，太难了！\n\nTODO\n\n### 链接和构建\n\n项目文件放在github上，链接：[https://github.com/DavidingPlus/Linux_Projects/tree/web-server](https://github.com/DavidingPlus/Linux_Projects/tree/web-server)\n\n使用cmake编译项目需要在根目录创建一个build目录，然后进入build目录，之后如下操作进行编译，我设置了项目生成的可执行文件路径在 build 目录下，名称为app\n\n~~~bash\ncmake ..\nmake\n./app\n~~~\n\n","categories":["Linux 学习","用户层"]},{"title":"侯捷老师 C++ 课程","url":"/posts/2abc6e08.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 面向对象高级开发\n\n## Header头文件的防卫式声明\n\n```c++\n//complex.h\n#ifndef __COMPLEX__\n#define __COMPLEX__\n//含义:如果程序没有定义过，那么定义出来，走主体内容；如果程序定义过，第二次include时，那么就不走，直接返回，不会有重复include的动作\n\n/*\n主体内容\n*/\n\n#endif\n```\n\n<!-- more -->\n\n## inline 函数\n\n```c++\nclass complex{\n  public:\n    complex();\n    \n   \tdouble real() const {return re; }//如果函数在类内声明并且定义完成，那么这个函数就是个inline函数\n  private:\n    double re,im;\n};\n\ninline double\nreal(const complex& x){\n    return x.real();\n}//inline的执行速度会快一点!\n```\n\n为了减少时间开销，如果在类体中定义的成员函数中不包括循环等控制结构，C++系统会自动将它们作为内置(inline)函数来处理。\n\nC++要求对一般的内置函数要用关键字inline声明，但对类内定义的成员函数，可以省略inline，因为这些成员函数已被隐含地指定为内置函数。\n\n如果成员函数不在类体内定义，而在类体外定义，系统并不把它默认为内置(inline)函数，调用这些成员函数的过程和调用一般函数的过程是相同的。如果想将这些成员函数指定为内置函数，应当用inline作显式声明。\n\n如果函数太复杂，编译器没有办法把他看成 inline 函数!! 所以我们在类内实现只是为了建议编译器将其看成 inline 函数来提高效率，但是实际上是不是 inline 函数要看编译器，我们也不知道！\n\n## 单例设计模式(构造函数在private部分)\n\n例子：\n\n```c++\n//头文件 Stu.h\n#ifndef __STU__\n#define __STU__\n\n#include <string>\nusing namespace std;\nclass Stu\n{\npublic:\n    static Stu &getInstance();//单例设计模式 在主程序当中只能使用一份这个类的数据 所有共享 所以静态变量放在堆区\n    void setup() {}\n\nprivate:\n    Stu();\n    Stu(int id, string name);\n\n    int _ID;\n    string _name;\n};\n\nStu &Stu::getInstance()\n{\n    static Stu stu;\n    return stu;\n}\n\n#endif\n```\n\n```c++\n//主程序 main.cpp\n#include <iostream>\n#include \"Stu.h\"\n\nint main()\n{\n    // 单例设计模式\n    // 构造函数在private里面 整个类是放在static堆区的 所有用户只用一份这个类的数据\n    auto stu = Stu::getInstance(); // 这样就创造出来了一个类 并且是静态变量!!!程序共享这一份\n\n    return 0;\n}\n```\n\n## const 常量成员函数\n\n```c++\n//complex类\nclass complex\n{\npublic:\n  complex(double r = 0, double i = 0) : re(r), im(i) {}\n    \n  double real() const { return re; }\n  double imag() const { return im; }//成员函数 不改变类成员属性的值 建议加上const修饰，换句话说就是拿数据\n\nprivate:\n  double re, im;\n};\n```\n\n成员函数不改变类成员属性的值建议加上const修饰，换句话说就是拿数据.例如上面的real()和imag()都不改变成员属性的值，所以加上了const修饰。\n\n在上面的例子当中，如果那两个成员函数不加上const，会出现什么情况呢？\n\n```c++\n//主函数\nconst complex c(1,2);//使用者定义这个类是不可以改变的\nstd::cout<<c.real();//打印real()\n```\n\n这是未加const的成员函数\n\n```c++\n  double real() { return re; }\n  double imag() { return im; }\n```\n\n打印real()会出问题，因为使用者不想要改变c里面元素的值，但是这个成员函数在访问的时候不加const，编译器认为有可能会改变成员函数的值，这两者是相互矛盾的，所以会报错，所以需要加上const来保证是不会改变值的。\n\n## 引用(指针常量 指针指向不可修改)\n\n引用的本质: 是一个指针常量\n\n为什么选择引用: 传递非常快，并且可以解决形参修改不改变实参的问题\n\n```c++\nint a=10;\n//自动转换为 int* const ref = &a; 指针常量是指针指向不可改，也说明为什么引用不可更改\nint& ref = a; \nref = 20; //内部发现ref是引用，自动帮我们转换为: *ref = 20;\n```\n\n引用是不可修改的，因为引用本质是指针常量，该指针的值是不可修改的，也就是指向的地址区域(a)是不可以变动的，但是解引用修改指向区域的值是完全没有问题的。\n\n所以考虑到这两个问题，在实际操作过程中尽量传入引用。\n\n## friend 友元\n\n```c++\n//complex类\nclass complex\n{\npublic:\n  complex(double r = 0, double i = 0) : re(r), im(i) {}\n    \n  double real() const { return re; }\n  double imag() const { return im; }//成员函数 不改变类成员属性的值 建议加上const修饰，换句话说就是拿数据\n    \nprivate:\n  double re, im;\n  \n  friend complex &__doapl(complex*, const complex& );//第二个参数传入另一个类对象的引用\n  //friend友元表示另一个类对象可以访问本类当中的私有成员属性\n};\n\ninline complex &\n__doapl(complex *ths, const complex &r)\n{\n  ths->re += r.re;//这里就可以直接访问本类的私有成员属性\n  ths->im += r.im;\n  return *ths;\n}\n```\n\n### 重点：\n\n相同class的各个objects互为friends 友元\n\n还是上面的例子\n\n```c++\n//类内\nint func(const complex& param){ return param.re + param.im;}\n//这里为什么可以直接访问私有成员属性\n//主函数\nc2.func(c1);\n```\n\n两种理解:\n\n1.相同class的各个objects互为友元，所以可以访问私有属性\n\n2.私有成员属性可以类内访问，类外不可以访问，需要访问需要成员函数接口\n\n## return by *\n\n### return by reference\n\n传送着无需知道接收者是以reference接受\n\n```c++\ninline complex&\ncomplex::operator += (const complex &r){\n    return __doapl(this,r);\n}\n```\n\n实现 += 号的重载(复数)\n\n为什么要返回 & ：因为不能创建新对象，我们的目的是修改原对象！！！\n\n这样做可以实现连加操作 c1 += c2 + =c3\n\n关于运算符重载返回reference还有一个例子\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <string>\n#include <ostream>\n\nclass Stu\n{\npublic:\n    // 类内的函数会默认为内置inline函数\n    Stu();\n    Stu(int id, string name) : _ID(id), _name(name) {}\n\n    int getID() { return this->_ID; }\n    string getName() { return this->_name; }\n\nprivate:\n    int _ID;\n    string _name;\n};\n\n//这种特殊的操作符重载只能写在全局，因为写在类里面无法达到 cout<<p 的效果\ninline ostream & //返回ostream标准流的引用\n//关于返回值 需要考虑连传的话需要返回引用!!!\noperator<<(ostream &os, Stu &s)\n{\n    os << s.getID() << ' ' << s.getName() << endl;\n    return cout;\n}\n\nint main()\n{\n    Stu s(1, \"张三\");\n    cout << s;//这样可以实现连 <<\n\n    return 0;\n}\n```\n\n### return by value:\n\n什么时候只能return by value?我们应该优先考虑return by reference，但是在这个函数返回值的时候需要创建一个新的对象的时候只能return by value\n\n```c++\ninline complex\noperator+(const complex &x,const complex &y){\n    return complex(real(x)+real(y),imag(x)+imag(y));\n}\n\nc2=c1+c2;//这行代码的意思是c1+c2创建出来一个新的对象赋值给c2!!!\n```\n\n## class with pointer members 带有指针的类\n\n比较经典的类就是string字符串类,必须有拷贝构造 copy ctor和拷贝赋值 copy op=\n\n```c++\nclass String\n{\npublic:\n    String(const char *cstr = 0);\n    // 只要类带指针，一定要重写以下两个函数!!!\n    // 不重写的话编译器默认的构造函数是浅拷贝 两个指针指向同一块内存对象!!!\n    // 当然这里的拷贝指的是深拷贝\n    String(const String &str);            // 拷贝构造\n    String &operator=(const String &str); // 拷贝赋值\n\n    ~String();\n\n    char *get_c_str() const { return this->_data; }\n\nprivate:\n    char *_data;\n};\n```\n\n当然这里的拷贝指的是深拷贝!!!\n\nBig Three:拷贝构造，拷贝赋值，析构函数!!!!!!\n\n### 拷贝赋值:检测自我赋值\n\n```c++\ninline String &String::operator=(const String &str)\n{\n    // 深拷贝赋值 先把自身杀掉 然后重新创建\n    // 检测自我赋值\n    if (this == &str)\n        return *this;\n\n    delete[] this->_data;\n    // 深拷贝\n    this->_data = new char[strlen(str) + 1];\n    strcpy(this->_data, str._data);\n    return *this;\n}\n```\n\n这里为什么要检测自我赋值：因为不检测自我赋值的话，如果使用者调用自我赋值的时候，第一步就会把唯一的自身这个_data杀掉，后续就没有办法进行了，会出现安全隐患!!!这也是为了安全和严谨性考虑的\n\n## 一些对象的生命期\n\n```c++\nclass complex{ };\n\ncomplex c3(1,2);\n\nint main(){\n    complex c1(1,2);\n    static complex c2(1,2);\n    \n    complex *c4=new complex(1,2);\n    delete c4;\n    \n    return 0;\n}\n```\n\nC++程序在执行时，将内存大方向划分为4个区域\n代码区：存放函数体的二进制代码，由操作系统进行管理。\n全局区：存放全局变量和静态变量以及常量。\n栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。\n堆区：由程序员分配和释放，若程序员不释放，程序结束时由操作系统回收。\n\nc1 :存放在栈当中，当作用域(这里是main函数)结束的时候就会被自动清理\n\nc2 :静态变量，存放于全局静态区，当整个程序结束之后才会被释放\n\nc3: 全局变量，存放于全局区，当整个程序结束之后才会被释放\n\nc4: new出来的，动态分配内存，存放于堆区，注意new了之后记得在作用域结束之前将其delete掉\n\n​      否则会出现内存泄露的问题，当作用域结束之后c4指针会被释放掉，但是他所指向的内存没有被释放!!!一般写析构函数解决这个问题\n\n## new和delete\n\n### new: 先分配内存空间，再调用构造函数\n\n![image-20230412174017480](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412174017480.png)\n\n### delete: 先调用析构函数，再释放内存空间\n\n![image-20230412174017480](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412174017480.png)\n\n### array new 一定要搭配 array delete!!!\n\n![image-20230412185656797](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412185656797.png)\n\n写了 [] 的话编译器才会知道你不仅要删除p这个类对象指针,还要把这个p对象指针指向的数组元素给全部删除掉，因为 String* p既可以表示单个的类对象指针也可以表示类对象数组的首元素地址指针!!! 所以必须要要写 [] ,否则只会删除掉p[0]所对应的元素!!!\n\n## static 静态\n\n静态变量和静态函数很特殊，具体看下面代码:\n\n静态函数由于没有this指针，所以只能处理静态变量!!!\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Account\n{\npublic:\n    static double _rate;                      // 静态成员变量一个程序只有一份，类内声明，类外初始化\n    static void set_rate(const double &rate); // 静态成员函数，调用时可以声明类对象，可以调用作用域直接访问，类外实现，类外实现的时候不用加关键字static,但是要加作用域\n};\ndouble Account::_rate = 8.0;\n\nvoid Account::set_rate(const double &rate)\n{\n    Account::_rate = rate;\n}\n\nint main()\n{\n    cout << Account::_rate << endl;\n    Account::set_rate(7.0);\n    cout << Account::_rate << endl;\n\n    return 0;\n}\n```\n\n### 进一步补充：把构造函数放在 private 里面，单例设计模式\n\n```c++\nclass Stu\n{\npublic:\n    static Stu &getInstance() { return s; }\n    void setup()\n    {\n        ; // 一系列的接口操作\n    }\n\nprivate:\n    Stu();\n    Stu(int id, string name);\n    int _ID;\n    string _name;\n\n    static Stu s;\n};\n```\n\n这里的就是把构造函数放在 private 当中，对外界的接口就是这个 getInstance()，这个函数返回静态变量 s ，只有一份，通过 setup() 接口进行对这个类内成员的访问和修改!!!\n\n```c++\nStu::getInstance().setup();\n```\n\n优化的写法：\n\n由于这里在构建类的时候就引入了静态成员变量，在没有调用的时候可能会导致资源浪费，所以我们将这个静态成员变量在静态函数中创建就好了，在调用的时候创建，然后生命周期一直持续到程序结束\n\n```c++\nstatic Stu& getInstance(){\n\tstatic Stu s;\n\treturn s;\n}\n```\n\n## 模板\n\n### 类模板:\n\n用的时候必须要明确指出里面参数的类型\n\n```c++\ntemplate <typename T>\nclass complex{\n  public:\n    complex();\n  private:\n    T real;\n    T imag;\n};\n\nint main()\n{\n    complex<int>c1();\n    complex<double>c2();\n}\n```\n\n### 函数模板:\n\n用的时候不需要指明函数参数的类型,因为编译器会进行实参的推导\n\n```c++\nclass stone\n{\npublic:\n    stone();\n    stone(int w, int h, int weight) : _w(w), _h(h), _weight(weight) {}\n\n    bool operator<=(const stone &sto) { return this->_weight <= sto._weight; }\n\nprivate:\n    int _w, _h, _weight;\n};\n\n// 全局函数 比大小\ntemplate <typename T>\ninline T &\nmin(T &a, T &b)\n{\n    return a <= b ? a : b ?\n}\n\nint main()\n{\n    int a = 1, b = 2, c;\n    stone a1(1, 2, 3), a2(4, 5, 2), a3;\n    c = min(a, b);\n    a3 = min(a1, a2);\n}\n```\n\n## 命名空间 namespace\n\n将自己写的东西封装在一个命名空间当中，可以防止与其他人名称一样功能不同的问题\n\n```c++\nnamespace std{\n\t;\n}\n```\n\n## 复合 composition\n\n简单来理解就是 一个类包含另一个类对象,本类可以调用另一个类的底层函数\n\n```c++\n//Adapter\ntemplate <class T>\nclass queue\n{\nprotected:\n\tdeque<T> c; //底层容器\npublic:\n    //以下的操作全都是由c的底层函数执行\n    bool empty()const{return c.empty();}\n};\n```\n\n这里其实包含另一种设计模式: Adapter\n\ndeque是双端队列，queue是单端队列，显然deque的功能要比queue功能强大，他完全可以适配(Adapter)queue的功能，所以可以采用复合的方式，queue的成员函数调用deque中的部分成员函数来实现自己的功能!!!\n\n用图可以这样表示:\n\n![image-20230412202635207](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412202635207.png)\n\n### 复合下的构造和析构\n\n构造: 构造由内而外 注意先调用的是内部的**默认**构造，编译器指定的，也符合我们的预期！\n\n析构: 析构由外而内\n\n这些是编译器帮我安排好的，上面是我们希望的设计\n\n![image-20230412203303042](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412203303042.png)\n\n## 委托 Delefgation -- Composition by reference\n\n把复合下面传入的参数类型改为指针!!!\n\n![image-20230412204435460](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412204435460.png)\n\n### Handle/Body (pimpl)\n\n图示的这种写法很有名，左边是用户看到的类，里面有调用的接口这些，右边是真正字符串的类，用来封装字符串的类型这些。\n\nreference counting: 这种写法在这个特殊例子当中可以实现，用户创建了三个String对象，但是每个对象下面对应的 rep 指针指向的对象其实是一块内存，因为他们的字符串是一样的，这样就可以减少内存的开销。\n\n## 继承 inheritance\n\n构造:由内而外 调用父类的**默认**构造函数，编译器指定的，也符合我们的预期！\n\n析构:由外而内\n\n![image-20230412210437066](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412210437066.png)\n\n### 虚函数:\n\noverride 覆写：注意只能用在虚函数这里\n\nnon-virtual 函数: 父类不希望子类重写(override)它\n\nvirtual 函数：父类希望子类重写(override)它，父类对它一般已经有默认定义\n\npure virtual 函数(纯虚函数)：父类希望子类一定要重写(override)它，父类对它没有默认定义，例子：父类是个抽象类\n\n![image-20230412212341135](https://cdn.davidingplus.cn/images/2025/01/30/image-20230412212341135.png)\n\n注意:子类调用父类的函数，如果子类当中对父类的函数进行了override，那么在调用到这个虚函数的时候就会调用子函数覆写的版本，从而实现我们的需求！！！\n\n下面还有个例子:\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Animal\n{\npublic:\n    virtual void speak() = 0;\n};\n\nclass Cat : public Animal\n{\npublic:\n    virtual void speak() { cout << \"喵喵喵\" << endl; }\n};\n\nclass Dog : public Animal\n{\npublic:\n    virtual void speak() { cout << \"汪汪汪\" << endl; }\n};\n\nint main()\n{\n    //用父类对象指针来接受子类对象 来达到子类调用父类对象成员函数的目的\n    Animal *cat = new Cat();\n    cat->speak(); // 喵喵喵\n\n    Animal *dog = new Dog();\n    dog->speak(); // 汪汪汪\n\n    return 0;\n}\n```\n\n  用父类对象指针来接受子类对象 来达到子类调用父类对象成员函数的目的，这样也可以实现多态.\n\n## 转换函数 conversion function\n\n作用：可以用于类型的转换\n\n重载 () 运算符 在括号的前面加上返回的类型，括号内不传参数，返回值由于在括号前面已经指定了，所以省略不写，编译器指定的\n\n```c++\noperator double(){\n    return (double)this->_numerator / (double)this->_denominator;\n}\n```\n\n整体的例子:\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Fraction\n{\npublic:\n    Fraction(int num, int den = 1) : _numerator(num), _denominator(den) {}\n\n    // 转换函数\n    // 没有返回值，转化的类型在括号前面已经指定\n    operator double() const\n    {\n        return (double)this->_numerator / (double)this->_denominator;\n    }\n\nprivate:\n    int _numerator;\n    int _denominator;\n};\n\nint main()\n{\n    Fraction f(3, 5);//这里首先创建了f对象，调用了构造函数\n    double d = 4 + f;\n    //f是个类对象，他怎么能直接和double类型相加呢？\n    //如果写了 + 号运算符重载那么就直接调用即可，但是这里没写啊？\n    //所以这里编译器就去找什么东西可以把f里面的参数变为double 就找到了转换函数 这里的f经过编译之后就返回分数的值 也就是0.6\n    cout << d << endl;//4.6\n\n    return 0;\n}\n```\n\n注意main函数里面的细节!!!\n\n## 函数对象(仿函数) -> 谓词\n\n谓词:\n\n1.函数指针作谓词\n\n2.函数对象(仿函数)作谓词\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <algorithm>\n\n// 函数指针作谓词\nbool Cmp(int val1, int val2)\n{\n    return val1 <= val2;\n}\n\n// 函数对象(仿函数)作谓词\nclass Fuck\n{\npublic:\n    bool operator()(int val1, int val2)\n    {\n        return val1 <= val2;\n    }\n};\n\nint main()\n{\n    vector<int> nums{5, 3, 4, 2, 1};\n    // sort(nums.begin(), nums.end(), Cmp);\n    sort(nums.begin(), nums.end(), Fuck());\n    for_each(nums.begin(), nums.end(), [&](int val)\n             { cout << val << ' '; });\n    cout << endl;\n\n    return 0;\n}\n```\n\n仿函数(函数对象): function like classes\n\n在类里面重载 () 运算符\n\n```c++\ntemplate <class T>\nclass identity{\npublic:\n    const T& operator()(const T& x){return x;}\n}\n```\n\n调用的时候 identity() 这样就是一个函数对象\n\n标准库里面有很多仿函数，这些仿函数都继承了一些标准库里面的父类，这些父类大小为0，没有成员函数。(标准库)\n\n## 模板补充: 成员模板 member template\n\n到目前为止，三种模板: 类模板 函数模板 成员模板\n\n![image-20230413163206633](https://cdn.davidingplus.cn/images/2025/01/30/image-20230413163206633.png)\n\n注意看注释进行理解!!!\n\n```c++\n#include <iostream>\nusing namespace std;\n\n// Base1 鱼类 Derived1 鲫鱼\n// Base2 鸟类 Derived2 麻雀\n// 相应的有继承关系\nclass Base1\n{\n};\nclass Derived1 : public Base1\n{\n};\n\nclass Base2\n{\n};\nclass Derived2 : public Base2\n{\n};\n\n// 现在定义一个pair类\ntemplate <class T1, class T2>\nstruct Pair\n{\n    T1 _first;\n    T2 _second;\n    Pair();\n    Pair(const T1 &a, const T2 &b) : _first(a), _second(b) {}\n\n    // 注意这里有一个Pair的拷贝赋值\n    template <class U1, class U2>\n    Pair(const Pair<U1, U2> &p) : _first(p._first), _second(p._second) {}\n    // 这里怎么理解\n    // 如果传入的类型是 T1 鱼类 T2 鸟类\n    // 然后在调用拷贝赋值的时候传入的类型是 U1 鲫鱼 U2 麻雀\n    // 显然 鲫鱼是鱼类 麻雀是鸟类 所以是可以传入的\n    // 这个成员模板需要满足的条件就是 p._first这里是可以给自身的成员属性 _first 进行赋值的,在这里满足的是继承的关系\n};\n\nint main() { return 0; }\n```\n\n这里其实就有考虑指针指向的问题\n\n```c++\nclass Derived1 : public Base1 { };\nBase1 *ptr=new Derived1;//这么写是完全ok的\n```\n\n还是考虑 Base1 是鱼类，Derived1 是 鲫鱼，然后我们用鱼类的指针去指向鲫鱼对象，这显然是可以的，因为鲫鱼很明显是鱼，所以这么写是完全ok的。\n\n并且恰好这么写可以使得子类调用父类的虚函数来实现不同的虚函数功能。\n\n## 命名空间\n\n```c++\n#include <iostream>\nusing namespace std;\n\nnamespace my1\n{\n    static void test()\n    {\n        cout << \"I am in namespace my1\" << endl;\n    }\n}\n\nnamespace my2\n{\n    static void test()\n    {\n        cout << \"I am in namespace my2\" << endl;\n    }\n}\n\nint main()\n{\n    my1::test();\n    my2::test();\n\n    return 0;\n}\n```\n\n两个命名空间，即使里面的函数名称一样，传入参数等等方面完全一样，甚至还是静态的，虽然静态的存放于全局静态区只有一份，但是这里用了两个不同的命名空间将他们分割开来，这样就导致两个函数本质上是不同的，从下面的使用就可以看出来了。\n\n## explicit\n\nnon-explicit-one-argument ctor(构造函数)\n\n```c++\nclass Fraction\n{\npublic:\n    // non-explicit-one-argument ctor\n    Fraction(int num, int den = 1) : _numerator(num), _denominator(den) {}\n\n    //这是上面提到的转换函数\n    operator double() const\n    {\n        return (double)this->_numerator / (double)this->_denominator;\n    }\n\nprivate:\n    int _numerator;\n    int _denominator;\n};\n```\n\n我们先将转换函数去掉，重载加号运算符\n\n```c++\nclass Fraction\n{\npublic:\n    // non-explicit-one-argument ctor\n    Fraction(int num, int den = 1) : _numerator(num), _denominator(den) {}\n\t\n    //重载加号运算符\n    Fraction operator+(const Fraction& f){ ; }\nprivate:\n    int _numerator;\n    int _denominator;\n};\n\nint main(){\n    Fraction f(3,5);\n    Fraction d=f+4;\n    //到这里的时候编译器发现f和4没办法直接相加 即使写了重载 因为需要传入Fraction类型\n    //但是编译器看构造函数 默认值den=1 意思是可以传入一个参数，这就和现在的4很贴切了\n    //所以编译器会将4转化为Fraction类对象和f进行相加得到对象d\n}\n```\n\n如果两个同时存在\n\n```c++\nclass Fraction\n{\npublic:\n    // non-explicit-one-argument ctor\n    Fraction(int num, int den = 1) : _numerator(num), _denominator(den) {}\n    \n    //conversion function\n    operator double() const\n    {\n        return (double)this->_numerator / (double)this->_denominator;\n    }\n\t\n    //重载加号运算符\n    Fraction operator+(const Fraction& f){ ; }\nprivate:\n    int _numerator;\n    int _denominator;\n};\n\nint main(){\n    Fraction f(3,5);\n    Fraction d=f+4;\n    //按照上面的思路是一种走法\n    //但是有了转换函数之后编译器发现,f可以先转化为double数字再和4求和，求完和之后再转化为Fraction对象，这就是另一种思路了\n    //所以 二义性 报错\n}\n```\n\n现在如果加上关键字 explicit 呢？\n\n```c++\nclass Fraction\n{\npublic:\n    // explicit-one-argument ctor\n    explicit Fraction(int num, int den = 1) : _numerator(num), _denominator(den) {}\n    //explict关键字的含义 防止类构造函数的隐式自动转换\n    //就是说这里由于只需要传入一个参数，所以编译器很可能会把数字隐式转化为Fraction对象\n    //但是加上了explict之后,明确指出不要让编译器这么干，要生成Fraction对象只能显式调用构造函数!!!!\n    \n    //conversion function\n    operator double() const\n    {\n        return (double)this->_numerator / (double)this->_denominator;\n    }\n\t\n    //重载加号运算符\n    Fraction operator+(const Fraction& f){ ; }\nprivate:\n    int _numerator;\n    int _denominator;\n};\n\nint main(){\n    Fraction f(3,5);\n    Fraction d=f+4;//这里仍然会错，因为4不会被转化为Fraction了，也就没有办法直接相加\n    double e=f+4;//这里显然就可以了，因为存在转换函数\n}\n```\n\n这个关键字 explicit 绝大部分都是用在构造函数前面来防止其他类型的隐式转换!!!!\n\n## pointer-like classes 关于智能指针和迭代器\n\n### 智能指针: 用一个类来模拟一般指针的作用\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstruct Foo\n{\n    void method(void);\n};\n\ntemplate <class T>\nclass shared_ptr\n{\npublic:\n    shared_ptr(T *p) : _px(p) {}\n\n    //智能指针必然需要重载这两个运算符\n    T &operator*() const\n    {\n        return *(this->_px);\n    }\n\n    T *operator->() const\n    {\n        return this->_px;\n    }\n\nprivate:\n    T *_px;\n};\n\nint main()\n{\n    shared_ptr<Foo> sp(new Foo);\n    Foo f(*sp);\n    sp->method();//这个就相当于 _px->method();\n\n    return 0;\n}\n```\n\n### 迭代器: iterator 其本质也是一种智能指针\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <list>\n#include <algorithm>\n\nvoid test()\n{\n    list<int> l{5, 2, 4, 3, 1};\n    //方法一\n    //注意这个迭代器类型怎么写的\n    for (list<int>::iterator iter = l.begin(); iter != l.end(); ++iter)\n        cout << *iter << ' ';\n    cout << endl;\n\n    // 方法2\n    for_each(l.begin(), l.end(), [&](int val)\n             { cout << val << ' '; });\n    cout << endl;\n}\n\nint main()\n{\n    test();\n    return 0;\n}\n```\n\n## specialization 模板特化\n\n对于一个泛型模板，我们调用的时候里面的接口都是一样的。但是如果我们发现有的特殊的类型在某个函数下有更加好的实现方法，这个时候就可以用模板特化来操作了。可以类比子类继承父类(抽象类)的虚函数，特殊化实现，本质是一样的。\n\n![image-20230413211543101](https://cdn.davidingplus.cn/images/2025/01/30/image-20230413211543101.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\ntemplate <class Type>\nstruct Fuck\n{\n};\n\n// 模板特化\ntemplate <>\nstruct Fuck<int>\n{\n    int operator()(int val) const { return val; }\n};\n\n//注意模板特化的语法\ntemplate <>\nstruct Fuck<string>\n{\n    string operator()(string ch) const { return ch; }\n};\n\ntemplate <>\nstruct Fuck<double>\n{\n    double operator()(double val) const { return val; }\n};\n\nint main()\n{\n\t// 匿名对象\n    cout << Fuck<int>()(1) << endl;\n    cout << Fuck<string>()(\"fuck\") << endl;\n    cout << Fuck<double>()(3.14) << endl;\n\n    return 0;\n}\n```\n\n模板特化语法第一行要加上，第二行就是具体类型类的具体操作\n\n```c++\ntemplate <>\nclass Fuck<type>{\n  \t;  \n};\n```\n\n## partial specialization 模板偏特化\n\n个数的偏\n\n```c++\ntemplate<typename T,typename Alloc= ...>\nclass Vector{\n    ...\n};\n\n//模板偏特化 就只特定其中的某个或者某几个元素 其实还是一个模板\ntemplate<typename Alloc= ...>\nclass Vector<bool,Alloc>{\n    ...\n};\n```\n\n范围的偏\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntemplate <typename T>\nstruct TC // 泛化的TC类模板\n{\n    void functest()\n    {\n        cout << \"泛化版本\" << endl;\n    }\n};\n// 偏特化：模板参数范围上的特化版本\ntemplate <typename T>\nstruct TC<const T> // const的特化版本\n{\n    // 对特化版本做单独处理\n    void functest()\n    {\n        cout << \"偏特化const版本\" << endl;\n    }\n};\ntemplate <typename T>\nstruct TC<T *> // T* 的特化版本\n{\n    void functest()\n    {\n        cout << \"const T*特化版本\" << endl;\n    }\n};\ntemplate <typename T>\nstruct TC<T &> // T& 的特化版本\n{\n    void functest()\n    {\n        cout << \"T &左值引用特化版本\" << endl;\n    }\n};\n\ntemplate <typename T>\nstruct TC<T &&> // T&& 的特化版本\n{\n    void functest()\n    {\n        cout << \"T &&右值引用特化版本\" << endl;\n    }\n};\n\nvoid test()\n{\n    TC<double> td;\n    td.functest();\n\n    TC<const double> td2;\n    td2.functest();\n\n    TC<double *> tpd;\n    tpd.functest();\n\n    TC<const double *> tpd2;\n    tpd2.functest();\n\n    TC<int &> tcyi;\n    tcyi.functest();\n\n    TC<int &&> tcyi2;\n    tcyi2.functest();\n}\n\nint main()\n{\n\ttest();\n    //泛化版本\n\t//偏特化const版本\n\t//const T*特化版本\n\t//const T*特化版本\n\t//T &左值引用特化版本\n\t//T &&右值引用特化版本\n\n    return 0;\n}\n```\n\n# C++标准库 体系结构与内存分析\n\n## 第一讲：STL标准库和泛型编程\n\n### STL 体系结构\n\n六大部件: 容器 分配器 算法 迭代器 适配器 仿函数\n\n容器：各种数据结构\n\n算法：algorithm\n\n迭代器：泛型指针，重载了 * -> ++ --操作的类\n\n仿函数：从实现的角度看是重载了 operator() 的类\n\n适配器：一种修饰容器，仿函数或者迭代器接口的东西\n\n分配器：负责空间的配置和管理\n\n![image-20230414100854356](https://cdn.davidingplus.cn/images/2025/01/30/image-20230414100854356.png)\n\n 以下有一个程序的例子几乎包含了所有的元素：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230414114802698.png\" alt=\"image-20230414114802698\" style=\"zoom: 67%;\" />\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n    int ia[6] = {27, 210, 12, 47, 109, 83};\n    vector<int, allocator<int>> vi(ia, ia + 6);\n\n    cout << count_if(vi.begin(), vi.end(), not1(bind2nd(less<int>(), 40))) << endl;\n    return 0;\n}\n```\n\n下面来解释这里面所用到的东西:\n\n1. vector是容器，这里的用法和一般的使用方法不同，这里给出了分配器模板的指定参数\n\n2. count_if第三个参数，本意是想比较迭代器 * iter 和40 的大小，然后使用的仿函数，但是less<int>()这个系统自带的仿函数的实现是这样的\n\n   ```c++\n     template<typename _Tp>\n       struct less : public binary_function<_Tp, _Tp, bool>\n       {\n         _GLIBCXX14_CONSTEXPR\n         bool\n         //从这里可以看出他需要两个参数\n         operator()(const _Tp& __x, const _Tp& __y) const\n         { return __x < __y; }\n       };\n   ```\n\n   一般仿函数的用法:\n\n   ```c++\n   vector<int>v{5,3,4,6,8};\n   sort(v.begin(),v.end(),less<int>());//仿函数作谓词\n   ```\n\n   所以这里用 **bind2nd** 将迭代器和40绑定在一起，也叫 function adapter(binder)。\n\n   然后最外面 **not1** 一样的，将条件取反，所以求的就是大于等于40的元素个数了,function adapter(negator)\n\n### 基于范围的 for 语句\n\n个人感觉有点像python里面的 for i in range()\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n\n// 遍历vector容器\ntemplate <typename Type>\nvoid print(vector<Type> container)\n{\n    for (auto elem : container)\n        cout << elem << ' ';\n    cout << endl;\n}\n\nint main()\n{\n    print(vector<int>{1, 5, 6, 9, 7, 5, 3, 10});\n\n    vector<double> nums{1.1, 2.5, 6.33, 15.66, 1.44, 2.52};\n    print(nums);\n\n    // 稍微修改一下\n    // 注意传入引用才能修改实参!!!!!\n    for (auto &elem : nums)\n        elem -= 1; // 减一\n    print(nums);\n\n    return 0;\n}\n```\n\n### 容器的结构和分类\n\n总体来讲分为两类:\n\n序列容器 Sequence Containers\n\n关联式容器 Associate Containers 关联式容器采用键值对的方式存储数据，因此这一种容器查找元素的效率最高，最方便\n\n无序容器 Unordered Containers 是关联式容器的一种，c++11新出的\n\n相比于关联式容器的特点：\n\n- 无序容器内部存储的**键值对是无序**的，各键值对的存储位置取决于该键值对中的键\n- 和关联式容器相比，无序容器擅长**通过指定键查找对应的值**（平均时间复杂度为 O(1)）；\n- 但对于使用迭代器遍历容器中存储的元素，无序容器的执行效率则不如关联式容器。\n\n![image-20230414161555294](https://cdn.davidingplus.cn/images/2025/01/30/image-20230414161555294.png)\n\n### HashTable Separate Chaining\n\n![image-20230414171828137](https://cdn.davidingplus.cn/images/2025/01/30/image-20230414171828137.png)\n\n### Sequence Containers 序列容器\n\n#### array(c++11)\n\narray是STL自带的数组类，其本质就是一个固定大小的数组，里面存放的元素类型由用户指定\n\n```c++\nvoid test()\n    {\n        srand(time(NULL));\n\n        const size_t _size = 100;\n        array<int, _size> arr;\n\n        for (int i = 0; i < _size; ++i)\n            // 随机数 0-100\n            arr[i] = rand() % 101;\n        // 打印一些信息\n        cout << \"arr.size()= \" << arr.size() << endl;\n        cout << \"arr.front()= \" << arr.front() << endl;\n        cout << \"arr.back()= \" << arr.back() << endl;\n        cout << \"arr.data()= \" << arr.data() << endl;\n    \tcout<< \" &arr[0]= \" << &arr[0] << endl;//第四行和第五行得到的结果是一样的\n    }\n```\n\narray封装了固定长度数组的一些函数接口，其中data()函数是得到这个数组的首元素地址，也就是第五行，所以四五行结果相同\n\n#### vector\n\n```c++\nvoid test(int length)\n    {\n        srand(time(NULL));\n\n        vector<int> v;\n        for (int i = 0; i < length; ++i)\n            v.push_back(rand() % 101);\n        // 打印\n        cout << \"v.size()= \" << v.size() << endl;\n    \tcout << \"v.max_size()= \" << v.max_size() << endl;//这里的max_size()是指vector容器能装下的最大的大小\n        cout << \"v.front()= \" << v.front() << endl;\n        cout << \"v.back()= \" << v.back() << endl;\n        cout << \"v.data()= \" << v.data() << endl;\n        cout << \"&v[0]=\" << &v[0] << endl;\n        cout << \"v.capacity()= \" << v.capacity() << endl;\n    }\n```\n\n这里得到我指定size是10000的时候，capacity是16384，恰好是2的14次方，那么为什么是这样呢？\n\nvector当空间不够的时候如何开辟空间：**2倍开辟**!!!\n\n比如现在有2个元素，想要放入第三个，空间不够会新开辟，那么新开辟之后vector的空间大小是4\n\n即:\n\n```c++\n// v.size() == 3\n// v.capacity() == 4\n```\n\n所以当 size==10000的时候，capacity为16384也不奇怪了\n\n并且**内存开辟成长机制**：\n\n当空间不够的时候，vector容器会去内存中找另一块空间是现在2倍的空间，重新开辟内存，并且把现在的内存释放掉，把现在的数据迁移到新的2倍内存当中去!!!!\n\n#### list\n\n![image-20230415143355398](https://cdn.davidingplus.cn/images/2025/01/30/image-20230415143355398.png)\n\nlist是个双端循环链表，注意不仅是双向链表，还是循环的!!!!\n\n```c++\n    void test(int length)\n    {\n        srand(time(NULL));\n\n        list<int> l;\n        for (int i = 0; i < length; ++i)\n            l.push_back(rand() % 101);//list 提供了back和front两种插入方法,因为有begin()和end()迭代器\n        cout << \"l.size()= \" << l.size() << endl;\n        cout << \"l.max_size()= \" << l.max_size() << endl;\n        //注意 front和back的三种得到方式\n        cout << \"l.front()= \" << l.front() << endl;\n        cout << \"l.front()= \" << *l.begin() << endl;\n        cout << \"l.front()= \" << *(++l.end()) << endl;\n\n        cout << \"l.back()= \" << l.back() << endl;\n        cout << \"l.back()= \" << *(--l.end()) << endl;\n        auto iter = --l.begin();\n        cout << \"l.back()= \" << *(--iter) << endl;\n    }\n```\n\n得到首部和尾部的方式:\n\n1.内置函数 front()和back()\n\n2.使用迭代器 begin() 和 end()\n\n注意这里的迭代器是首闭尾开的形式,就是begin() 指向的第一个元素，end() 指向的最后一个元素的下一个没有值的内存空间,所以上一个区域就是最后一个元素的值 --end()\n\n由于这个双端链表在内存中最后一个元素的末尾还多了一块未分配值的空间，考虑到是循环的，所以++end()就代表第一块元素的空间\n\n但是，由于**大部分的迭代器没有重载 + 和 - 运算符(vector容器有)**，那么在求的时候不能直接用这两个符号，而得使用重载的++ 和 -- 运算符!!!!!!!\n\n#### forward_list(c++11)\n\n![image-20230415143409298](https://cdn.davidingplus.cn/images/2025/01/30/image-20230415143409298.png)\n\n本质就是一个单向链表，非循环链表\n\n```c++\n    void test(int length)\n    {\n        srand(time(NULL));\n\n        forward_list<int> fl;\n        for (int i = 0; i < length; ++i)\n            fl.push_front(rand() % 101); // 只提供头插法,因为尾插法太慢了\n        cout << \"fl.max_size()= \" << fl.max_size() << endl;\n        cout << \"fl.front()= \" << fl.front() << endl;\n        cout << \"fl.front()= \" << *(fl.begin()) << endl;\n        // cout << \"fl.back()= \" << *(--fl.end()) << endl; // error 没有重载 -- 运算符 只重载++运算符\n        // 不存在 fl.back() 接口\n        // 也不存在fl.size()接口\n    }\n```\n\n注意这个单向链表只有头插法，原因是尾插法每次都要遍历到最后，太慢了，头插法效率更高,所以这个容器也**不存在back()函数接口**\n\n这个单向链表begin()和end()迭代器都存在，但是大部分的时候遍历是使用begin()迭代器，因为**只重载了 ++ 运算符，未重载 -- 运算符!!!**\n\n还有一点与list不同,这个容器**没有 size() 接口**!!!我也不知道为什么，标准库没有提供这个接口\n\n#### slist\n\n这个容器的实现和 forward_list 相同，只不过这个容器是c++之前就有了，而 forward_list 是c++11新提出的\n\n```c++\n//头文件\n#include <ext\\slist>\n```\n\n#### deque\n\n双端开口队列\n\n![image-20230415145105415](https://cdn.davidingplus.cn/images/2025/01/30/image-20230415145105415.png)\n\n但是在实现的时候采用的是**分段连续**的机制：\n\n它真实的结构如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230415145711652.png\" alt=\"image-20230415145711652\" style=\"zoom:67%;\" />\n\n到99的时候，迭代器进行++的操作，需要进行判断走到了这一块内存的末尾，需要移步到下一个buffer的起始位置，也就是0，这就需要对++和--操作符进行重载!!!\n\n```c++\n    void test(int length)\n    {\n        srand(time(NULL));\n        deque<int> d;\n        for (int i = 0; i < length; ++i)\n            d.push_back(rand() % 101);\n        cout << \"d.size()= \" << d.size() << endl;\n        cout << \"d.max_size()= \" << d.max_size() << endl;\n        cout << \"d.front()= \" << d.front() << endl;\n        cout << \"d.back()= \" << d.back() << endl;\n    }\n```\n\n和前面的使用没有大区别,只是**deque不是循环的，而是两端延升的**\n\n####  stack\n\ndeque的功能可以实现stack的所有功能，可以用复合composition的方式来实现stack类\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230415150557574.png\" alt=\"image-20230415150557574\" style=\"zoom: 67%;\" />\n\n#### queue\n\n同stack，略\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230415150706680.png\" alt=\"image-20230415150706680\" style=\"zoom:67%;\" />\n\n###  Associate Containers 关联式容器\n\n关联式容器每个元素都存在 key 和 value，这样才能使得查询效率大大提高\n\n#### 红黑树\n\n#### Multiset 和 set\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230415154938692.png\" alt=\"image-20230415154938692\" style=\"zoom:67%;\" />\n\n这种容器的 **key 和 value 值相同!**!!!!\n\n这两个容器的底层都是用**二叉树**(红黑树)实现的，元素在插入的时候都会被**进行自动排序(从小到大)**，唯一的不同点是，Multiset允许插入重复的元素，而set不允许出现重复的元素\n\n```c++\n    void test(int length)\n    {\n        srand(time(NULL));\n        set<int> s;\n        for (int i = 0; i < length; ++i)\n            s.insert(rand());//注意插入的接口是insert()\n        cout << \"s.size()= \" << s.size() << endl;\n        cout << \"s.max_size()= \" << s.max_size() << endl;\n        // s.begin() s.end() 存在接口\n        // 迭代器存在，因为底层是用二叉树实现的，并且进行了自动排序，所以肯定可以遍历，这个就是学底层的时候该考虑的问题\n    }\n```\n\n**注意：Multiset 和 set 不能使用 [ ] 来做下标访问!!!!!** \n\n第一，底层是红黑树，第二，标准库未重载 [ ] 符号!!!\n\n\n\n#### Multimap 和 map\n\n这种容器就有分别的 **key 和 value** 了，两者不一定相同，每个元素都是有两个元素!!!底层是用**红黑树**实现的!!!!!\n\n插入元素的时候会**按照key进行排序(从小到大)**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230415154949602.png\" alt=\"image-20230415154949602\" style=\"zoom:67%;\" />\n\n```c++\n    void test(int length)\n    {\n        srand(time(NULL));\n        map<int, int> m;\n        for (int i = 0; i < length; ++i)\n            m.insert(pair<int, int>(i, rand()));\n\n        cout << \"m.size()= \" << m.size() << endl;\n        cout << \"m.max_size()= \" << m.max_size() << endl;\n        // m.begin() m.end() 存在\n    }\n```\n\n同set一样，由于底层是用红黑树实现的，所以查询的时候也有迭代器接口，并且效率很高\n\nmap不能有重复的，这里的**重复判断是看 key** !!!!!! 两个value相同但是key不同是合法的!!! Multimap 就可以有相同的key!!!\n\n**注意：Multimap不能使用 [ ] 来做下标访问!!!! Map可以，类似于python字典的用法!!!**\n\n原因类似见上\n\n\n\n#### 哈希表(其实原本名字前缀是hash,现在改名叫unordered)\n\n#### unordered_multiset 和 unorder_set\n\n**key和value值相同**，与上面不同的是这个本质是用**哈希表**实现的!\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230415160759007.png\" alt=\"image-20230415160759007\" style=\"zoom:67%;\" />\n\n```c++\nvoid test(int length)\n    {\n        srand(time(NULL));\n        unordered_set<int> us;\n        for (int i = 0; i < length; ++i)\n            us.insert(rand());\n\n        cout << \"us.size()= \" << us.size() << endl;\n        cout << \"us.max_size()= \" << us.max_size() << endl;\n        cout << \"us.bucket_count()= \" << us.bucket_count() << endl;//篮子的大小\n        cout << \"us.load_factor()= \" << us.load_factor() << endl;//装载因子=元素个数/篮子个数\n        cout << \"us.max_load_factor()= \" << us.max_load_factor() << endl;\n        cout << \"us.max_bucket_count()= \" << us.max_bucket_count() << endl;//最大的篮子个数,和最大元素个数相同\n    }\n```\n\nunordered_set 通过一个**哈希函数**，将对象的值映射到一个数组下标，这个数组下标对应的是unordered_set中的一个“桶”，表示所有可以映射到这个下标的元素的集合，通常用链表表示。\n\n这个vector数组我一般形象的称其为**篮子**。\n\n篮子扩充机制：**当元素个数size()不断增加，达到篮子个数bucket_count()的时候，vector容器进行近似2倍的扩充**，具体略\n\n所以，**篮子个数一定大于元素个数**!!!!\n\n\n\n#### unordered_multimap 和 unordered_map\n\n与上面的大概相同，不同的是，传入的数据类型是一个**键值对 pair<keyType,valueType>**\n\n其他略，具体实现后面再谈\n\n### 使用分配器 allocator\n\n这部分先了解怎么使用分配器，后面会有专题来讲解分配器的原理\n\n![image-20230415165550803](https://cdn.davidingplus.cn/images/2025/01/30/image-20230415165550803.png)\n\n**虽然分配器有申请内存空间并且归还内存空间的接口，但是不建议直接使用分配器，因为这样分配器的负担太重了。而应该去使用容器，让分配器给容器分配空间，这样的效率会高很多!!!**\n\n## 第二讲：分配器 迭代器\n\n###  OOP(面向对象编程)和GP(泛型编程)\n\nOOP将 data 和 methods 结合在一起,GP却将他们两个分开来\n\n采用GP:\n\n1.容器Containers和算法Algorithms可以各自闭门造车，通过迭代器Iterator连接起来即可\n\n2.算法ALgorithms通过迭代器Iterator确定操作范围，并通过Iterator取用Container元素\n\n### 随机访问迭代器\n\n随机访问迭代器 RandomAccessIterator：能够随机访问容器中的任一元素，例如vector单端数组\n\n这样的迭代器可以进行+ -号的运算，例如:\n\n```c++\nauto mid=(v.begin()+v.end())/2 //随访访问迭代器才可以这么操作\n```\n\n提到这里，就不得不提一下算法库里的全局函数 sort() 了\n\n**sort()函数内部实现的机制调用了随机访问迭代器，进行了+-的运算，所以能调用的前提只能是随机访问迭代器，比如vector,deque**\n\n**所以由于list不满足这个迭代器，所以他不能调用全局sort函数，只能用自己类实现的sort函数，即 l.sort()**\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <list>\n#include <algorithm>\n\ntemplate <typename Type>\nvoid print(list<Type> &l)\n{\n    for_each(l.begin(), l.end(), [&](auto val)\n             { cout << val << ' '; });\n    cout << endl;\n}\n\nint main()\n{\n    list<int> l;\n    for (int i = 0; i < 10; ++i)\n        l.push_back(9 - i);\n    print(l);\n    // sort(l.begin(), l.end(), less_equal<int>());//用不了 因为他不是RandomAccessIterator Error!!!\n    l.sort(less_equal<int>());\n    print(l);\n\n    return 0;\n}\n```\n\n### GP 泛型编程举一个例子\n\n```c++\n#include <iostream>\nusing namespace std;\n\nnamespace fuck\n{\n    template <typename Type>\n    inline const Type &max(const Type &a, const Type &b)\n    {\n        return a < b ? b : a;\n    }\n\n    template <typename Type, class functor>\n    inline const Type &max(const Type &a, const Type &b, functor &cmp)\n    {\n        return cmp(a, b) ? b : a;\n    }\n}\n\nbool strCmp(const string &s1, const string &s2)\n{\n    return s1.size() < s2.size();\n}\n\nvoid test()\n{\n    cout << \"max of zoo and hello: \" << fuck::max(string(\"zoo\"), string(\"hello\")) << endl;         // zoo\n    cout << \"max of zoo and hello: \" << fuck::max(string(\"zoo\"), string(\"hello\"), strCmp) << endl; // hello\n}\n\nint main()\n{\n    test();\n    return 0;\n}\n```\n\n这个例子很简单，就不多做解释了\n\n### 重载new运算符 operator new\n\n![image-20230416094923459](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416094923459.png)\n\n可以看到，在c++当中，new关键字在调用之后都会走到c语言的malloc函数来分配内存，然后malloc函数分配内存的机制就是上面那个内存块所示\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095052581.png\" alt=\"image-20230416095052581\" style=\"zoom: 67%;\" />\n\nsize所包含的内容才是我想要的存放数据的内容部分，但是malloc会给我们开辟比size更大的空间，这些在另一门课里面会具体谈到。\n\n### 分配器 allocators\n\n#### VC6 allocator\n\nVC6里面的分配器具体实现如下图：\n\n![image-20230416095559995](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095559995.png)\n\n分配器当中最重要的就是 **allocate 函数 和 deallocate 函数**\n\n从上图中可以看出，VC提供的分配器在分配的时候，allocate函数在调用的时候会调用 new 关键字，也就是会调用 malloc 函数\n\n在释放内存的时候调用deallocate 函数，也就是调用delete关键字，最终就是调用free 函数\n\n结论：\n\n![image-20230416095953933](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416095953933.png)\n\n对于这个allocator，如果硬要用的话可以这么使用\n\n```c++\n    // 建立分配器\n    int *p = allocator<int>().allocate(512, (int *)0);\n    // 归还\n    allocator<int>().deallocate(p, 512);//在归还的时候还需要之前的大小，所以非常不好用!!!\n```\n\n#### BC++ allocator\n\nBC5 STL中对分配器的设计和VC6一样，没有特殊设计\n\n![image-20230416101021861](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416101021861.png)\n\n操作略\n\n#### GCC2.9 allocator\n\n和前面两个一样，也没有特殊设计，就是简单的调用malloc 和 free分配和释放内存\n\n![image-20230416101451151](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416101451151.png)\n\n右边这一段注释的意思就是虽然这里实现了符合标准的allocator，但是他自己的容器从来不去用这些分配器，这些分配器都有一个致命的缺点，就是因为本质是在调用mallloc和free函数，根据前面的内存分配机制很容易看出会产生很多的其他空间，从而被浪费，所以开销相对比较大，一般不用\n\n#### GCC2.9 自己使用的分配器：alloc(不是allocator!!!)\n\n这个分配器想必比allocator要好用的多\n\n![image-20230416102010067](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416102010067.png)\n\n其具体实现如下：\n\n![image-20230416102442772](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416102442772.png)\n\n**怎么实现的呢？设计了16个链表，每个链表管理特定大小的区块，#0管理8个字节，#1管理16，以此类推，最后#15管理168个字节。所有使用这个分配器的元素的大小会被调整到8的倍数，比如50的大小会被调整到56。如果该链表下面没有挂内存块，那么会向操作系统用malloc函数申请一大块内存块，然后做切割，之后分出一块给该容器，用单项链表存储。这样的好处是避免了cookie的额外开销，减少了内存浪费。**\n\n这个东西的缺陷到内存管理里面去讲。\n\n#### GCC4.9 使用的分配器：allocator(不是alloc!!!)\n\n![image-20230416105043344](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416105043344.png)\n\n发现 allocator 是继承的父类 new_allocator\n\n![image-20230416105348361](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416105348361.png)\n\n**发现GCC4.9使用的分配器和之前的分配器没什么区别，没有特殊设计，就是调用的malloc函数和free函数，不知道为什么(这个团队没解释)**\n\n**但是但是！GCC4.9里面的__pool_alloc就是GCC2.9里面的alloc,非常好用的那个**\n\n![image-20230416110401962](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416110401962.png)\n\n### 容器之间的关系\n\n容器与容器之间的关系基本上都是复合的关系，比如set/multiset和map/multimap底层都是由rbtree红黑树实现的等等，具体见下图\n\n![image-20230416154815162](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416154815162.png)\n\n### 区别size()和sizeof()\n\n以容器list为例，list.size()和sizeof(list)是没有直接的大小联系的（单项链表forward_list不存在size()方法）\n\n```c++\n//在vscode+linux g++编译器中\n    list<char> l;\n    for (int i = 0; i < 26; ++i)\n        l.push_back('a' + i);\n\n    cout << l.size() << endl;  // 26\n    cout << sizeof(l) << endl; // 24\n```\n\nl.size()指的是容器中存放的元素个数；sizeof(l)指的是需要形成list这个容器需要这个类所占的内存有多大，list类里面不仅存放了链表的指针，还有其他的成员属性来配合控制这个容器的运行.所以sizeof(l)和这个元素的个数一般没有关系。\n\n### 深入探索 list\n\nGCC2.9是这样写的\n\n![image-20230416160403390](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416160403390.png)\n\n可以看出，list里面非常重要的一点设计就是**委托**设计，**即list本身的类并不是实际的双向链表，用户所能操作的这个类其实可以看作双向链表的管理类，里面有成员函数，迭代器，还有一根指向双向链表的指针，实际的双向链表结构就如上面所示,__list_node，这个才是真正的存储结构**，这也是为什么sizeof()和size()是不一样的，因为设计者很好的把二者分开了，使得用户和写代码的人都能很好的管理自己的部分。\n\n由于list的存储是不连续的，所以相应的他的迭代器也需要是智能指针，需要重载++和--运算符，(注意list的迭代器不是随机访问迭代器，所以不能使用+ -号运算符，也不能使用算法库的函数sort()，而需要使用自带的函数sort() )那么就应该是一个类了。**进而推得所有的容器(除了vector和array)的迭代器，最好都写成一个类来实现。**\n\n#### list的迭代器\n\n这个迭代器最重要的就是重载 ++ 运算符，也就是前置++和后置++\n\n![image-20230416163304200](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416163304200.png)\n\n前置++和后置++的区别就是后置++的参数列表里面会有一个占位符int来表示他是后置++\n\n```c++\n//前置++\nself& operator++(){\n    node=(link_type)((*node).next);\n    return *this;\n}\n//这里的self是指迭代器这个类，是个别名。这个实现还是比较容器理解的\n//注意返回的是迭代器新的位置所以可以返回引用类型\n```\n\n```c++\n//拷贝构造\n__list_iterator(const iterator& x):node(x.node){}\n```\n\n```c++\n//重载*\nreference operator*()const{return (*node).data;}\n```\n\n```c++\n//后置++\nself operator++(int){\n\tself tmp=*this;\n    //这一步仔细看看，可能会调用拷贝构造(=)，可能也会调用*重载，但是*重载明显不符合要求\n    //再加上 = 在前面，所以调用的是拷贝构造，*this已经被看作拷贝构造的参数，拷贝出来了一个新的原位置迭代器!!!!\n\t++*this;\n    //前置++\n\treturn tmp;\n}\n//注意由于需要返回原位置的迭代器，而现在的迭代器已经改变了，所以最好新创建一个，return by value\n```\n\n#### 关于为什么后置++不能返回引用，比较有说服力的还有如下的原因：\n\n```c++\nint i=2,j=2;\ncout<< ++++i << j++++ << endl;\n```\n\n**我们尝试将i和j分别进行前置和后置++分别加两次，c++的编译器允许前置++连续加，但是不允许后置++连续加，我们知道想要连续加的条件就是要返回引用继续修改原本的值，所以既然不允许连续后置++，那么就return by value，直接创建一个新对象**\n\n然后类在重载这两个运算符的时候也会向编译器自带的规则看起，也不允许后置++连续加，所以就只能return by value\n\n#### 关于 * 和 & 运算符的重载\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <list>\n\nclass fuck\n{\npublic:\n    void print() { cout << \"hello\" << endl; }\n    fuck(int data = 0) : _data(data) {}//构造函数，可以将int类型转化为类对象\n\n    int getData() { return this->_data; }\n\nprivate:\n    int _data;\n};\n\nint main()\n{\n    list<fuck> l{1, 2, 3, 6, 5, 8, 8, 9};\n    auto iter = l.begin();//取得首个元素迭代器\n    //*iter取得的是 fuck 对象,iter->取得的是 fuck对象指针\n    //对于简单的类型 iter->没什么作用，比如int，这时候*iter就代表了value，但是对于类对象那就不一样了\n    cout << (*iter).getData() << endl;\n    iter->print();\n\n    return 0;\n}\n```\n\n*和->的具体实现,Type是类的类型\n\n```c++\ntypedef Type& reference;\ntypedef Type* pointer;\n//* 返回的是类对象\nreference operator*(){\n    return *(this->node);//node是迭代器当中存放的链表指针对象\n}\n//-> 返回的是类对象指针\npointer operator->(){\n    return &(operator*());\n}\n```\n\n#### G4.9 和 G2.9的区别\n\n具体区别就如下图所示：\n\n![image-20230416171855901](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416171855901.png)\n\n在4.9版本当中\n\n![image-20230416174305071](https://cdn.davidingplus.cn/images/2025/01/30/image-20230416174305071.png)\n\n**刻意在list尾端加上一段空白的区域来复合STL迭代器前闭后开的特征!!!但是相应的这个设计的复杂度又大大增加了。**\n\n### 迭代器的设计原则\n\nIterator需要遵循的原则：在调用算法的时候，iterator作为中间桥梁连接容器和算法，所以算法需要知道Iterator的很多东西\n\n**算法需要知道迭代器的必要信息，进而决定采取最优化的动作**\n\n![image-20230419170456164](https://cdn.davidingplus.cn/images/2025/01/30/image-20230419170456164.png)\n\n在C++标准库当中设计出五种标准类型:\n\n```c++\niterator_category;\n//迭代器的分类：只读，只写，允许写入型算法在迭代器区间上进行读写操作(Forward Iterator)，可双向移动，Random Access Iterator\ndifference_type;//用来表示迭代器之间的距离，也可以用来表示一个容器的最大容量\nvalue_type;//迭代器所指对象的类型\n\nreference;\npointer;//最后两个基本没用到\n```\n\n这五种类型被称作 **associated type 相关类型**；迭代器本身必须定义出来，以便回答算法\n\n![image-20230419170815213](https://cdn.davidingplus.cn/images/2025/01/30/image-20230419170815213.png)\n\n比如我自己写一下链表list的五个相关类型\n\n```c++\n//GCC4.9版本\ntemplate <class _Type>\nstruct List_Iterator\n{\n    typedef std::bidirectional_iterator_tag _iterator_category;\n    typedef ptrdiff_t _difference_type;\n    typedef _Type _value_type;\n    typedef _Type& _reference;\n    typedef _Type* _pointer;\n};\n```\n\n**引出问题：算法调用的时候传进去的可能不是个迭代器，可能是个指针，这个时候该怎么办呢？**\n\n当然，指针是个**退化**的迭代器!!!\n\n### Traits 萃取机\n\n![image-20230419190233258](https://cdn.davidingplus.cn/images/2025/01/30/image-20230419190233258.png)\n\n**Iterator Traits用于区分是 class Iterators (也就是一般的迭代器)还是 non-class Iterators(即 native pointer)；两种情况对应不同的的处理!!**\n\n在算法和迭代器之间加一层中间层Iterator traits来进行判断，好针对性的进行设计!!!\n\n具体怎么做呢？\n\n这时候算法里面就不能直接问迭代器的五个类型了，因为 native pointer 里面没有这五个参数,所以需要间接通过Traits去问!!!\n\n下面的例子先回答了一个问题 value_type\n\n```c++\ntemplate <typename I,...>\nvoid algorithm(...){\n    typename iterator_traits<I>::value_type v1;//通过traits去问\n}\n\n//如果是class Iterator在这里\ntemplate <class I>\nstruct iterator_traits{\n    typedef typename I::value_type value_type;\n}\n\n//两个模板偏特化 pointer to T\ntemplate <class T>\nstruct iterator_traits<T*>{\n    typedef T value_type;\n}\n\n//pointer to const T\ntemplate <class T>\nstruct iterator_traits<const T*>{\n    typedef T value_type; //注意是T而不是const T\n    //为什么是 T 而不是 const T？因为 value_type主要目的是去声明变量，const T没办法声明变量!!!\n}\n```\n\n下面把指针的全回答完毕\n\n```c++\n//pointer to T\ntemplate <class T>\nstruct iterator_traits<T*>{\n    typedef random_access_iterator_tag iterator_category;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef ptrdiff_t difference_type;\n}\n//pointer to const T\ntemplate <class T>\nstruct iterator_traits<const T*>{\n    typedef random_access_iterator_tag iterator_category;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef ptrdiff_t difference_type;\n}\n```\n\n## 第三讲：容器\n\n### 深入探索vector\n\n其实自己都可以封装一个vector，当然所有的功能是不现实的，但是基本的功能还是可以\n\n#### GCC2.9的设计\n\n直观感受就是简洁明了\n\n![image-20230419192921703](https://cdn.davidingplus.cn/images/2025/01/30/image-20230419192921703.png)\n\n这里面有三根泛型指针，start，finish和end_of_storage\n\n**下面就是比较重要的push_back()查数据，引出后面的二倍扩展空间!!!**\n\n![image-20230419195537174](https://cdn.davidingplus.cn/images/2025/01/30/image-20230419195537174.png)\n\n**else这里，调用insert_aux之后为什么还要进行一次判断呢？**\n\n**这是因为由于insert_aux是一个辅助函数，那么在实际操作过程中可能会被其他类函数调用，比如insert，在这些函数的实现逻辑当中是需要进行判断的。**\n\n![image-20230419195610102](https://cdn.davidingplus.cn/images/2025/01/30/image-20230419195610102.png)\n\n**这段源码的大致意思就是：capacity不够了就在内存中找另一块2倍大小的内存用于存放新的vector，把原来的元素拷贝过去然后把原来的vector杀掉，各种值迁移到新内存这边去!!!**\n\n**至于拷贝安插点后的原内容是因为这里可能会被insert函数给调用，这个部分是insert函数的逻辑!!!**\n\n**Vector容器的迭代器**\n\n既然vector是一个连续空间，那么iterator就不必要设置成为class了，只需要设置为pointer就可以\n\n```c++\n//所以如上所示，vector的迭代器是一根指针\ntypedef value_type* iterator; // T*\n```\n\n#### GCC4.9的设计\n\n复杂，依托答辩\n\n![image-20230419201320469](https://cdn.davidingplus.cn/images/2025/01/30/image-20230419201320469.png)\n\n### 深入探索 deque 和 queue , stack\n\n#### deque\n\ndeque 双端队列的实现结构：\n\n![image-20230420164335846](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420164335846.png)\n\n**具体实现：将deque的存储划分为若干个等大的区域，每个区域的首元素用一个指针存放在一个vector容器中(就是图中的map数组)，当缓冲区buffer的左端或者右端不够的时候，就新开一个缓冲区放在左边和右边，存入元素，并且把该buffer的首指针存入map数组的左边或者右边。因此deque的迭代器的就分为：**\n\n**first 该缓冲区的首地址；last 该缓冲区的末尾(首闭尾开)；cur 元素的位置；node 存入map数组的指针!!!**\n\n下面看一下deque的具体源代码设计：\n\n**GCC2.9:**\n\n![image-20230420170120084](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170120084.png)\n\n其中第三个参数 Bufsiz 是可以人为指定缓冲区的大小\n\n![image-20230420170739434](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170739434.png)\n\n从这里可以看出，上面调用了一个函数，如果 BufSiz 不为0，那么就设置大小为人为指定；如果为0，则表示设置为预设的值，需要查看要存放的类型的大小，大于512就指定一个缓冲区只放这一个元素，个数设置为1；小于的话就计算出个数，计算出个数之后就可以知道缓冲区的大小了\n\n![image-20230420170150250](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420170150250.png)\n\n这个迭代器里面也包含了五个必要类型，写的非常严谨，也有了四个需要的参数!!!\n\n**Insert函数:**\n\n![image-20230420172205138](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420172205138.png)\n\n如果是在头部和尾部插入，那么和push_front()和push_back()没有区别\n\n如果在中间插入就调用赋值函数 insert_aux()\n\n![image-20230420172617688](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420172617688.png)\n\n由于在中间插入必然会导致元素的拷贝过程，为了减少开销，提高效率，我们需要判断元素在deque靠近start和finish哪一端的位置，这样可以更好的去选择操作的方向\n\n**deque如何模拟连续空间操作？(操作符重载)**\n\n![image-20230420173341877](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420173341877.png)\n\n**deque 的 - 号操作符重载**\n\n由于 deque 存储的缓冲区buffer机制，我们必须判断两个迭代器之间有多少个缓冲区buffer，然后再根据计算公式来进行计算得出两个迭代器之间元素的个数\n\n具体就是这样!\n\n**根据两个迭代器的node指针找到map数组里面两个指针距离的位置就可以知道两个中间差了多少个缓冲区buffer了，再加上本缓冲区内的距离就是两个迭代器之间的元素个数!!!**\n\n![image-20230420173832550](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420173832550.png)\n\n**++ 和 -- 操作符重载**\n\n注意需要判断迭代器移动过程中是否超越了本缓冲区的界限移入另一个缓冲区!!!\n\n一个比较好的编码习惯就是后++调用前++；后--调用前--\n\n![image-20230420174307662](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420174307662.png)\n\n**+= + 号操作符重载**\n\n在 += 运算符重载中，需要注意判断迭代器位置移动之后有没有超越边界，如果超越了边界，需要进行相应的边界修改\n\n![image-20230420193008988](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193008988.png)\n\n+= 如果没有正确的缓冲区需要切换到正确的缓冲区；如果是正确的缓冲区那就很简单了\n\n**-= - 号运算符重载**\n\n用的是+=和+号的重载\n\n![image-20230420193316669](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193316669.png)\n\n**GCC 4.9:** 依托答辩\n\n![image-20230420193754702](https://cdn.davidingplus.cn/images/2025/01/30/image-20230420193754702.png)\n\n#### queue\n\n**内部存了一个 deque 容器，二者形成了复合 composition 关系**\n\nqueue内部的函数，deque能完全满足它，所以调用 deque 的成员函数就可以了!!!\n\n![image-20230421103130501](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421103130501.png)\n\n**queue和stack，关于其iterator和底层容器**\n\n**stack和queue不允许遍历，也不提供iterator!!!!**\n\n因为他们的模式是先进后出和先进先出，这样的模式不允许能访问到任意位置的元素\n\n![image-20230421104600566](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104600566.png)\n\n**关于stack和queue的内部支撑容器，上面讲的是deque，其实也可以用list**\n\n默认提供的是deque，这个效率比较快一点\n\n![image-20230421104609426](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104609426.png)\n\n**stack可以用vector做底部支撑；queue不可以用vector!!!**\n\n因为vector没有 pop_front() 函数!!!\n\n![image-20230421104723249](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421104723249.png)\n\n**关于其他的底部容器支撑，stack和queue都不可以选用set或者map做底部容器支撑，因为他们两个也没有相应的函数提供!!!**\n\n![image-20230421105352734](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421105352734.png)\n\n关于这些底部容器支撑，如果你没有调用它不存在的函数，那其实调用还是可以的，但是总体来看是不行的!!!\n\n### 自己手写了一个简单的二叉树(创建二叉树函数不会)\n\n```c++\n//TreeNode.h\n#ifndef __TREENODE__\n#define __TREENODE__\n\nenum Left_Right\n{\n    Left,\n    Right\n};\n\n// 定义结点类\n#include <iostream>\ntemplate <class Type>\nstruct TreeNode\n{\n    typedef Type __ValueType;\n    typedef TreeNode<__ValueType> __NodeType;\n    typedef __NodeType *__pointer;\n\n    __ValueType val;\n    __pointer left;\n    __pointer right;\n\n    void __init__();\n    void insert(__ValueType val, bool is_left = Left); // 1为左 0为右 默认为做左\n\n    void PreOrder();\n    void InOrder();\n    void PostOrder();\n    void visit();\n};\n\n// 虽然不给节点写构造函数但是写一个初始化没问题的\ntemplate <class Type>\ninline void TreeNode<Type>::__init__()\n{\n    this->left = nullptr;\n    this->right = nullptr;\n}\n\n// 插入子树\ntemplate <class Type>\ninline void TreeNode<Type>::insert(__ValueType val, bool is_left)\n{\n    if (is_left == Left)\n    {\n        if (this->left)\n        {\n            cout << \"leftnode has already be used.\" << endl;\n            return;\n        }\n        __pointer newNode = new TreeNode<__ValueType>;\n        newNode->__init__();\n        newNode->val = val;\n        this->left = newNode;\n    }\n    else\n    {\n        if (this->right)\n        {\n            cout << \"rightnode has already be used.\" << endl;\n            return;\n        }\n        __pointer newNode = new TreeNode<__ValueType>;\n        newNode->__init__();\n        newNode->val = val;\n        this->right = newNode;\n    }\n}\n\n// visit\ntemplate <class Type>\ninline void TreeNode<Type>::visit()\n{\n    cout << this->val << endl;\n}\n\n// 遍历\ntemplate <class Type>\ninline void TreeNode<Type>::PreOrder()\n{\n    if (!this)\n        return;\n    visit();\n    left->PreOrder();\n    right->PreOrder();\n}\n\ntemplate <class Type>\ninline void TreeNode<Type>::InOrder()\n{\n    if (!this)\n        return;\n    left->InOrder();\n    visit();\n    right->InOrder();\n}\n\ntemplate <class Type>\ninline void TreeNode<Type>::PostOrder()\n{\n    if (!this)\n        return;\n    left->PostOrder();\n    right->PostOrder();\n    visit();\n}\n\n#endif\n```\n\n```c++\n//BinaryTree.h\n#ifndef __BINARTTREE__\n#define __BINARTTREE__\n#include \"TreeNode.h\"\n\nenum Order\n{\n    pre,\n    in,\n    post\n};\n\n// 写一个全局函数来删除二叉树\ntemplate <typename Type>\ninline void deleteNodes(TreeNode<Type> *node)\n{\n    if (node->left)\n        deleteNodes(node->left);\n    if (node->right)\n        deleteNodes(node->right);\n    delete node;\n}\n\n// 定义整颗二叉树类\ntemplate <class Type>\nclass BinaryTree\n{\n    typedef Type __ValueType;\n    typedef TreeNode<__ValueType> __NodeType;\n    typedef __NodeType &__reference;\n    typedef __NodeType *__pointer;\n\npublic:\n    // BinaryTree();\n    explicit BinaryTree(__ValueType val = NULL); // 不给默认值就是NULL\n    ~BinaryTree() { deleteTree(); }\n    void deleteTree();\n    void printTree(Order ord);\n    __reference getroot() const { return *root; }\n\nprivate:\n    __pointer root;\n};\n\n// 构造函数\ntemplate <class Type>\ninline BinaryTree<Type>::BinaryTree(__ValueType val)\n{\n    root = new TreeNode<Type>;\n    root->val = val;\n    root->left = nullptr;\n    root->right = nullptr;\n}\n\n// 整棵树的析构函数\ntemplate <class Type>\ninline void BinaryTree<Type>::deleteTree()\n{\n    deleteNodes(root);\n}\n\n// 前序遍历\ntemplate <class Type>\ninline void BinaryTree<Type>::printTree(Order ord)\n{\n    switch (ord)\n    {\n    case pre:\n        root->PreOrder();\n        break;\n    case in:\n        root->InOrder();\n        break;\n    case post:\n        root->PostOrder();\n        break;\n    }\n}\n\n#endif\n```\n\n```c++\n//main.cpp\n#include <iostream>\nusing namespace std;\n#include \"BinaryTree.h\"\n\n/*\n       1\n   3         2\n4    6    8\n    7        0\n*/\nnamespace test\n{\n    BinaryTree<int> sample()\n    {\n        BinaryTree<int> tree(1);\n        tree.getroot().insert(3, Left);\n        // left\n        auto leftNode = tree.getroot().left;\n        leftNode->insert(4, Left);\n        leftNode->insert(6, Right);\n        auto leftNode2 = leftNode->right;\n        leftNode2->insert(7, Left);\n        // right\n        tree.getroot().insert(2, Right);\n        auto rightNode = tree.getroot().right;\n        rightNode->insert(8, Left);\n        auto rightNode2 = rightNode->left;\n        rightNode2->insert(0, Right);\n\n        return tree;\n    }\n}\n\nint main()\n{\n    auto tree = test::sample();\n\n    tree.printTree(pre); // 1 3 4 6 7 2 8 0\n    cout << endl;\n    tree.printTree(in); // 4 3 7 6 1 8 0 2\n    cout << endl;\n    tree.printTree(post); // 4 7 6 3 0 8 2 1\n\n    return 0;\n}\n```\n\n### rb_Tree 红黑树\n\n红黑树是一种高度平衡的二叉搜寻树；由于它保持尽量的平衡，非常有利于search和insert的操作，并且在改变了元素的操作之后会继续保持树状态的平衡\n\n#### 红黑树 rb_Tree 与二叉平衡树 AVL 的对比：\n\n![image-20230421175541816](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421175541816.png)\n\n**为什么要有红黑树？**\n\n大多数二叉排序树 BST 的操作（查找、最大值、最小值、插入、删除等等）都是 O(h)O(h)O(h) 的时间复杂度，h 为树的高度。但是对于斜树而言（BST极端情况下出现），BST的这些操作的时间复杂度将达到  O(n) 。为了保证BST的所有操作的时间复杂度的上限为  O(logn)，就要想办法把一颗[BST树](https://www.zhihu.com/search?q=BST树&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1246106121})的高度一直维持在logn，而红黑树就做到了这一点，红黑树的高度始终都维持在logn，n 为树中的顶点数目。\n\nrb_Tree和AVL相比，虽然AVL更加平衡，但是条件更加苛刻，**红黑树追求的是大致平衡。** AVL 树比红黑树更加平衡，但AVL树在插入和删除的时候也会存在大量的旋转操作。**所以涉及到频繁的插入和删除操作，切记放弃AVL树，选择性能更好的红黑树；当然，如果你的应用中涉及的插入和删除操作并不频繁，而是查找操作相对更频繁，那么就优先选择 AVL 树进行实现**\n\n红黑树**提供遍历操作以及迭代器iterator**，但是这个迭代器是**只读迭代器**，因为**不能修改节点上元素的值**，如果修改了元素的值，那么会导致大小关系发生变化，整个红黑树的平衡性就发生变化了\n\n图中第三段，按理来说红黑树的元素是不能通过迭代器修改元素值的，但是这个红黑树后面是用于set和map容器的，set的key和value相等不能修改；但是map的key和value没有必然联系，排序和查找都是基于key来进行的，value可以任意修改，所以可以通过迭代器修改value，这么做做是正确的\n\n红黑树的设计当中存在两种设计 **insert_unique() 和 insert_equal()** ，表示key可以重复或者不重复，这样就可以引申出 set和 multiset，mal和 multimap\n\n#### 标准库对红黑树的实现:\n\n![image-20230421182526116](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421182526116.png)\n\n**这里标准库里面的value不是指我们理解的value值，这里的value是key和data合起来叫做value，也就是一整个节点的类型；第三个参数是说我们怎么样从这个节点value当中把重要的key拿出来!!!第四个参数是说如何根据key来进行比较，因为后续要进行排序操作!!!**\n\n在rb_tree类当中，它的设计和我的设计差不多，都是把树和节点分开的来设计，所以在树rb_tree当中只用了三个参数来向外表现\n\n```c++\nsize_type node_count;//节点的数量\nlink_type header;//头节点(类型是指针)\nCompare key_compare;//比较key的函数指针或者仿函数\n```\n\n**在红黑树的结构里有一个 header 节点，他的元素值为空，跟list的设计一样，前闭后开的区间!!!**\n\n这样的设计会使后面的实现方便很多\n\n![image-20230421182650170](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421182650170.png)\n\n虽然红黑树不推荐直接使用，因为更好的做法是使用上层容器；但是可以简单的使用一下来测试我们对其的理解\n\n```c++\nrb_tree<int,int,identity<int>,less<int>,alloc>;\n//key和value类型相同，说明key和data是一个东西(否则返回的value不可 能是int类型而应该是个类)，这样的话从value中取出key就可以使用写好的identity函数对象，即你传什么给我我就给你返回什么\n```\n\n使用红黑树的测试程序:(新版本的名称有些变化)\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <bits/stl_tree.h>\n\nint main()\n{\n    _Rb_tree<int, int, _Identity<int>, less<int>, allocator<int>> rbtree;\n    cout << rbtree.size() << endl;  // 0\n    cout << sizeof(rbtree) << endl; // 48 跟插不插元素没关系，因为里面存的是节点指针d\n    cout << rbtree.empty() << endl; // 1\n\n    rbtree._M_insert_unique(3);\n    rbtree._M_insert_unique(8);\n    rbtree._M_insert_unique(5);\n    rbtree._M_insert_unique(9);\n    rbtree._M_insert_unique(13);\n    rbtree._M_insert_unique(3);      // unique 所以3插不进去\n    cout << rbtree.size() << endl;   // 5\n    cout << rbtree.empty() << endl;  // 0\n    cout << rbtree.count(3) << endl; // 1\n\n    rbtree._M_insert_equal(3); // equal 所以3能插进去\n    rbtree._M_insert_equal(3);\n    cout << rbtree.size() << endl;   // 7\n    cout << rbtree.empty() << endl;  // 0\n    cout << rbtree.count(3) << endl; // 3\n\n    return 0;\n}\n```\n\n### 基于红黑树的set和map\n\n#### set/multiset\n\n由于set/multiset的key和value相同，所以没有办法通过迭代器修改元素的值，也就是修改key，error\n\nset插入元素使用 insert_unique()；multiset可以重复，使用 insert_equal()\n\n![image-20230421192116968](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421192116968.png)\n\n注意不能修改迭代器的值，const_iterator，以下是示例代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <set>\n#include <vector>\n\nint main()\n{\n    vector<int> v{1, 3, 5, 4, 6, 8, 8, 9};\n    for (int &val : v)\n        ++val;\n    for (int &val : v)\n        cout << val << ' ';\n    cout << endl;\n\n    //会自动排序\n    set<int, less<int>> s{3, 1, 5, 4, 6, 8, 8, 9};\n    // for (int &val : s) // 这里就会报错,因为这个的迭代器是不可以更改值的\n    //     ++val;\n    for (int val : s)\n        cout << val << ' ';\n    cout << endl;\n\n    return 0;\n}\n```\n\n#### map/multimap\n\n**map没有办法通过迭代器修改key的值，但是可以用过迭代器修改value的值!!!!!**\n\nmap插入元素使用 insert_unique()；multimap 可以重复，使用 insert_equal()\n\n![image-20230421194843419](https://cdn.davidingplus.cn/images/2025/01/30/image-20230421194843419.png)\n\n**key_type和data_type被包装成为一个pair<const Key,T>；注意这里const修饰代表key无法修改，然后value_type是真正的存放类型，然后select1st代表拿取pair里面的第一个元素!!!!**\n\n使用红黑树测试map：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <bits/stl_tree.h>\n\n// 源代码这么写的，我没看懂\ntemplate <class T>\nstruct SelectFirst\n{\n    template <class Pair>\n    typename Pair::first_type &\n    operator()(Pair &x) const\n    {\n        return x.first;\n    }\n\n    // typename T::first_type &\n    // operator()(T &x) const\n    // {\n    //     return x.first;\n    // }\n};\n\nint main()\n{\n    typedef int Key_Type;\n    typedef pair<const int, char> Value_Type;\n\n    // _Rb_tree<Key_Type, Value_Type, _Select1st<Value_Type>, less<int>> rbtree;\n    _Rb_tree<Key_Type, Value_Type, SelectFirst<Value_Type>, less<int>> rbtree; // error\n    // select1st怎么写不知道\n    cout << rbtree.size() << endl;  // 0\n    cout << sizeof(rbtree) << endl; // 48 跟插不插元素没关系，因为里面存的是节点指针d\n    cout << rbtree.empty() << endl; // 1\n\n    rbtree._M_insert_unique(make_pair(3, 'a'));\n    rbtree._M_insert_unique(make_pair(8, 'b'));\n    rbtree._M_insert_unique(make_pair(5, 'c'));\n    rbtree._M_insert_unique(make_pair(9, 'd'));\n    rbtree._M_insert_unique(make_pair(13, 'e'));\n    rbtree._M_insert_unique(make_pair(3, 'f')); // unique 所以3插不进去\n    cout << rbtree.size() << endl;              // 5\n    cout << rbtree.empty() << endl;             // 0\n    cout << rbtree.count(3) << endl;            // 1\n\n    rbtree._M_insert_equal(make_pair(3, 'a')); // equal 所以3能插进去\n    rbtree._M_insert_equal(make_pair(3, 'a'));\n    cout << rbtree.size() << endl;   // 7\n    cout << rbtree.empty() << endl;  // 0\n    cout << rbtree.count(3) << endl; // 3\n\n    return 0;\n}\n```\n\n其他都没什么，其中第三个模板参数SelectFirst<>(我自己写的)不是很理解为什么这么写\n\n```c++\ntemplate <class T>//不明白这里为什么要用两次模板并且第一次的模板参数没啥用\nstruct SelectFirst\n{\n    template <class Pair>\n    typename Pair::first_type &\n    operator()(Pair &x) const\n    {\n        return x.first;\n    }\n};\n```\n\n使用map的示例代码:\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <map>\n\nint main()\n{\n    // 第一个参数是key(不可修改,所以进去后红黑树会自动转为const类型),第二个参数是data\n    //元素会按照key自动排序!!!\n    map<int, char, less<int>> m{make_pair(9, 'a'),\n                                make_pair(5, 'b'),\n                                make_pair(6, 'c'),\n                                make_pair(4, 'd'),\n                                make_pair(8, 'c'),\n                                make_pair(9, 'b'),\n                                make_pair(6, 'd'),\n                                make_pair(1, 'a')};\n    m[0] = 'f';\n    for (auto &val : m)\n    {\n        //key不可修改，但是data可以修改\n        cout << val.first << ' ' << m[val.first] << endl;//类似于py的字典\n        val.second++;\n        cout << val.first << ' ' << val.second << endl;\n    }\n\n    return 0;\n}\n```\n\n### map独特的 operator [ ]!!!\n\n**作用：根据key传回data。注意只有map有，因为key不为data并且key是独一无二的!!!**\n\n**如果key不存在的话，就会创建这个key并且data使用默认值!!!**(和py的字典差不多)\n\n![image-20230422140640649](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422140640649.png)\n\n使用二分查找在有序的key当中查找目标key，如果找不到的话就进行insert操作创建一个新的key！！！\n\n### hashtable 散列表\n\n哈希表的设计\n\n![image-20230422143136762](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422143136762.png)\n\n**在有限的空间之下根据哈希函数将元素(分为key和data)的key映射成为hashcode放到对应的位置下面，key下面用一个链表将key和data串起来!!!!**\n\n**由于bucket数组存的是链表指针，这个链表如果串的元素太多了之后那么搜索效率会大大降低，这个状态就是非安全状态。程序员的经验告诉我们当所有的链表下面串的元素个数大于buckets数组的大小的时候就比较危险了。**\n\n**这个时候需要打散hashtable，增大buckets数组的size，一般是两倍左右，并且数组的size最好是质数，并且将元素按照新的hash规则重新插入链表中!!!!**\n\n总结就是：不能让hashtable下面串的链表太长，太长了需要增加buckets的size来打散哈希表重新回到安全状态。\n\nGCC下面的buckets数组的size是这么确定的：**大致都是2倍附近的质数**\n\n![image-20230422144338234](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422144338234.png)\n\n来看看hashtable的实现：\n\n![image-20230422145128498](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422145128498.png)\n\nValue代表key和data集合，key就是键值，HashFcn代表哈希函数，就是如何把key映射为编号hashcode，ExtractKey代表如何从value里面取出key；EqualKey代表如何判断两个key相同!!!\n\n至于是单向链表还是双向链表，这个就看不同的版本了。\n\n**参数模板里面最难的一点就是决定hashtable的hash函数，怎么样将hash的key值映射为hashcode!!!**\n\n参考系统提供的hash模板函数\n\n**注意：hash函数(一般是个仿函数)返回的值应该是一个编号，也就是 size_t**\n\n![image-20230422154019414](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422154019414.png)\n\n定义了hash函数，然后什么也不做，后面进行一些特化的处理!!!\n\n![image-20230422154054412](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422154054412.png)\n\n注意这里的hash函数设计，我们在将key转化为hashcode的过程中，可以任意设计hash函数使得转化成为的hashcode**尽量不重复，尽量够乱!!!**\n\n**在算出hashcode之后还要放入篮子，这个时候就很简单了，就把hashcode求篮子的size的余数就可以知道放在哪里了!!!!**(现在基本都是这么做的)\n\n![image-20230422155807393](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422155807393.png)\n\n使用hashtable的例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <hashtable.h>\n#include <cstring>\n\nstruct eqstr\n{\n    bool operator()(const char *str1, const char *str2) const\n    {\n        return strcmp(str1, str2) == 0;\n    }\n};\n\n// 如果是自己设计就可以这么设计\ninline size_t _hash_string(const char *s)\n{\n    size_t ret = 0;\n    for (; *s != '\\n'; ++s)\n        ret = 10 * ret + *s;\n    return ret;\n}\nstruct fuck\n{\n    size_t operator()(const char *s) const { return _hash_string(s); }\n};\n\n\nint main()\n{\n    __gnu_cxx::hashtable<const char *, const char *,\n                         hash<const char *>, // 标准库没有提供 hash<std::string>!!!!\n                         _Identity<const char *>,\n                         eqstr> \n                 // 不能直接放入strcmp，因为我们需要判断是否相同，返回的是true和false;而strcmp返回的是1 0 -1，接口不太一致\n        ht(50, hash<const char *>(), eqstr());// 这个东西没有默认空的构造函数，需要提供一些东西\n    // 从这里可以看出直接使用hashtable非常难用\n\n    ht.insert_unique(\"kiwi\");\n    ht.insert_unique(\"plum\");\n    ht.insert_unique(\"apple\");\n    for_each(ht.begin(), ht.end(), [&](auto data)\n             { cout << data << endl; });\n\n    // cout << hash<int>()(32) << endl;\n    return 0;\n}\n```\n\n## 第四讲：算法\n\n### 算法概述\n\n![image-20230422162235208](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422162235208.png)\n\n算法没有办法直接面对容器，他需要借助中间商迭代器才可以，换句话说，算法不关系容器是怎么样的，只关心容器提供给我的迭代器是怎么样的，而迭代器的设计的符号重载是普适的，这样就可以适用于大多数容器了。\n\n### 迭代器的五种分类：注意这五种都是类!!!\n\n![image-20230422162614061](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422162614061.png)\n\nrandom_access_iterator_tag 随机访问迭代器：可以跳着访问，任意一个都可以访问(重载了+ - += -= ++ -- 运算符)\n\nbidirectional_iterator_tag 双向访问迭代器：可以往前走或者往后走，但是一次只能走一格(重载了 ++ -- 运算符)\n\nfarward_iterator_tag 单向访问迭代器：只能向一个方向走，inin一次只能走一格\n\n打印一下各种容器的iterator_category\n\n![image-20230422163446874](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422163446874.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <array>\n#include <vector>\n#include <map>\n#include <list>\n#include <forward_list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <bits/stream_iterator.h>\n\n// 可以只指定值不给参数\nvoid __display_category(random_access_iterator_tag)\n{\n    cout << \"random_access_iterator\" << endl;\n}\nvoid __display_category(bidirectional_iterator_tag)\n{\n    cout << \"bidirectional_iterator\" << endl;\n}\nvoid __display_category(forward_iterator_tag)\n{\n    cout << \"forward_iterator\" << endl;\n}\nvoid __display_category(output_iterator_tag)\n{\n    cout << \"output_iterator\" << endl;\n}\nvoid __display_category(input_iterator_tag)\n{\n    cout << \"input_iterator\" << endl;\n}\n\ntemplate <typename I>\nvoid display_category(I iter)\n{\n    // 加上typename是为了是 I 就是迭代器类型(目前这么理解)\n    typename iterator_traits<I>::iterator_category cagy; // 去问萃取剂这个迭代器是什么类型\n    __display_category(cagy);\n}\n\nint main()\n{\n    display_category(array<int, 10>::iterator());\n    display_category(vector<int>::iterator());\n    display_category(list<int>::iterator());\n    display_category(forward_list<int>::iterator());\n    display_category(deque<int>::iterator());\n\n    display_category(set<int>::iterator());\n    display_category(map<int, int>::iterator());\n    display_category(multiset<int>::iterator());\n    display_category(multimap<int, int>::iterator());\n    display_category(unordered_set<int>::iterator());\n    display_category(unordered_map<int, int>::iterator());\n    display_category(unordered_multiset<int>::iterator());\n    display_category(unordered_multimap<int, int>::iterator());\n\n    // 这两个不太一样，是从适配器adapter产生的\n    display_category(istream_iterator<int>());\n    display_category(ostream_iterator<int>(cout, \"\"));\n\n    return 0;\n}\n```\n\n### iterator_category对算法的效率影响\n\n不同的迭代器类型会导致在访问的过程中效率有区别\n\n![image-20230422171334117](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422171334117.png)\n\n**注意对右边代码的解读，这个distance函数是找两个迭代器之间的距离(ptrdiff_t 类型)，然后就问萃取机迭代器的类型是什么？然后针对函数调不同的重载函数就可以了!!!**\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <list>\n\ntemplate <typename Iterator, typename Distance>\ninline Iterator &_advance(Iterator &iter, Distance n, std::random_access_iterator_tag)\n    {\n        iter += n;\n        return iter;\n    }\n\ntemplate <typename Iterator, typename Distance>\ninline Iterator &_advance(Iterator &iter, Distance n, std::bidirectional_iterator_tag)\n    {\n        if (n >= 0)\n            while (n--)\n                ++iter;\n        else\n            while (n++)\n                --iter;\n        return iter;\n    }\n\ntemplate <typename Iterator, typename Distance>\ninline Iterator &_advance(Iterator &iter, Distance n, std::input_iterator_tag)\n    {\n        while (n--)\n            ++iter;\n        return iter;\n    }\n\ntemplate <typename Iterator, typename Distance>\ninline Iterator Advance(Iterator iter, Distance n)\n    // 这里最好不传入引用类型，因为第一下面没有更改iter的值，不用担心实参形参的问题；\n    // 第二，外部可能传入的是begin()和end()这类没有办法直接修改的迭代器\n    // 我们在使用的时候都是声明了一个运动迭代器，他的初值是begin(),这样来操作的\n    // 所以传入引用会出问题，最好传值，但是后面就可以传入引用了，因为我们是创建了一个新的迭代器对象\n    {\n        typedef typename std::iterator_traits<Iterator>::iterator_category Iterator_Category;\n        return _advance(iter, n, Iterator_Category());\n    }\n\nint main()\n{\n    vector<int> v{3, 5, 6, 7};\n    cout << *myadvance().Advance(v.begin() + 2, -1) << endl; // 5\n    list<int> l{3, 5, 6, 7, 12};\n    cout << *myadvance().Advance(l.begin(), 4) << endl; // 12\n\n    return 0;\n}\n```\n\n注意注释的内容，为什么这里该传引用，这里不该传引用!!!\n\n**从这里我们可以看出，迭代器类型的不同会导致算法效率的不同，但是我们不是通过模板特化来实现的，是通过函数重载来实现的!!!**\n\n**算法源码对 iterator_category 的暗示:**\n\n![image-20230422183037284](https://cdn.davidingplus.cn/images/2025/01/30/image-20230422183037284.png)\n\n因为上面的迭代器都是模板，但是有些算法在实现的过程中只对某种类型的迭代器有效，所以设计者会暗示迭代器的类型来方便阅读和修改!!!\n\n### 算法源代码剖析\n\nC++ STL 库里面的标准算法格式\n\n```c++\ntemplate <typename Iterator>\nstd::Algorithm(Iterator iter1,Iterator iter2){\n    ...\n}\n\n//带比较的参数 一般是仿函数\ntemplate <typename Iterator,typename Cmp>\nstd::Algorithm(Iterator iter1,Iterator iter2,Cmp cmp){\n    ...\n}\n```\n\n#### accumulate\n\n遍历整个容器对每个元素进行操作(可以是累加)然后返回值\n\n![image-20230423113446373](https://cdn.davidingplus.cn/images/2025/01/30/image-20230423113446373.png)\n\n测试accumulate：\n\n```c++\nint myfunc(int x, int y)\n{\n    return x + 2 * y;\n}\n\nstruct myclass\n{\n    int operator()(int x, int y) const { return x + 3 * y; }\n} myobj;\n\nvoid test_accumulate()\n{\n    cout << \"test_accumulate()..........\" << endl;\n    int init = 100;\n    int nums[] = {10, 20, 30};\n\n    cout << \"using default accumulate: \";\n    cout << accumulate(nums, nums + 3, init); // 160\n    cout << '\\n';\n\n    cout << \"using functional's minus: \";\n    // minus 减法 仿函数\n    cout << accumulate(nums, nums + 3, init, minus<int>()); // 40\n    cout << '\\n';\n\n    cout << \"using custom function: \";\n    cout << accumulate(nums, nums + 3, init, myfunc); // 220\n    cout << '\\n';\n\n    cout << \"using custom object: \";\n    cout << accumulate(nums, nums + 3, init, myobj); // 280\n    cout << '\\n';\n}\n```\n\n自己实现以下accumulate:\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <list>\n#include <bits/stl_numeric.h> //accumulate\n#include <string>\n\nstruct Sum_Square\n{\n    template <class Value_Int>\n    inline Value_Int &operator()(Value_Int &val, Value_Int val_iter)\n    {\n        val += val_iter * val_iter;\n        return val;\n    }\n};\n\nstruct String_Append\n{\n    template <class Value_String>\n    inline Value_String &operator()(Value_String &val, Value_String val_iter)\n    {\n        val_iter.append(\" \");\n        val.append(val_iter);\n        return val;\n    }\n};\n\nstruct Algorithm\n{\n    template <class Iterator, class Value_Type>\n    inline static Value_Type Accumulate(Iterator begin, Iterator end, Value_Type val)\n    {\n        for (; begin != end; ++begin)\n            val += *begin;\n        return val;\n    }\n\n    template <class Iterator, class Value_Type, class Binary_Operation>\n    inline static Value_Type Accumulate(Iterator begin, Iterator end, Value_Type val, Binary_Operation binary_op)\n    {\n        for (; begin != end; ++begin)\n            val = binary_op(val, *begin);\n        return val;\n    }\n};\n\nint main()\n{\n    vector<int> v{5, 3, 6, 9, 10};\n    cout << Algorithm::Accumulate(v.begin(), v.end(), 0 << endl; // 33\n    cout << Algorithm::Accumulate(v.begin(), v.end(), 0, Sum_Square()) << endl; // 251\n    list<string> l{\"hello\", \"I\", \"want\", \"to\", \"fuck\", \"you\", \"my\", \"friend.\"};\n    cout << Algorithm::Accumulate(l.begin(), l.end(), string(), String_Append()) << endl;\n\n    return 0;\n}\n```\n\n#### for_each\n\n容器的遍历算法\n\n![image-20230423171745364](https://cdn.davidingplus.cn/images/2025/01/30/image-20230423171745364.png)\n\n自己实现一下for_each\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <algorithm>\n\nstruct Algorithm\n{\n    template <class Iterator, class Function>\n    //为什么要返回 Function 仿函数呢?(或者函数指针)\n    inline static Function For_each(Iterator first, Iterator last, Function f)\n    {\n        for (; first != last; ++first)\n            f(*first); // 注意是直接把数据传递给函数 f\n        return f;\n    }\n};\n\nint main()\n{\n    vector<int> v1{2, 5, 3, 6, 9};\n    vector<int> v2;\n\n    // 不修改v1的值\n    Algorithm::For_each(v1.begin(), v1.end(), [&](int val)\n                        { val*=2;v2.push_back(val); });\n\n    for_each(v1.begin(), v1.end(), [&](auto val)\n             { cout << val << ' '; });\n    cout << endl;\n\n    for (auto val : v2)\n        cout << val << ' ';\n    cout << endl;\n\n    return 0;\n}\n```\n\n看到for_each的返回值，我不得不思考为什么要返回Function仿函数呢？(很少情况下函数指针)\n\n**原因是：可以监视仿函数对象在经过这个for_each操作之后的状态**\n\n```c++\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n/*\n    for_each()它可以返回其仿函数(返回所传入的函数对象的最终状态).\n    这样我们就可以通过for_each()的返回值来获取仿函数的状态.\n*/\n\n/* 仿函数 */\nclass CSum\n{\npublic:\n    CSum() { m_sum = 0; }\n\n    void operator()(int n) { m_sum += n; }\n\n    int GetSum() const { return m_sum; }\n\nprivate:\n    int m_sum;\n} cs;\n\nint main()\n{\n    vector<int> vi;\n    for (int i = 1; i <= 100; i++)\n        vi.push_back(i);\n    // 通过for_each返回值访问其最终状态(返回所传入的函数对象的最终状态).\n    cs = for_each(vi.begin(), vi.end(), cs); // 返回的是一个新创建的对象，未返回引用，不会修改实参\n    cout << cs.GetSum() << endl;\n\n    return 0;\n}\n```\n\n#### replace,replace_if,replace_copy,replace_copy_if\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <algorithm>\n\ntemplate <typename Container>\nvoid print(Container con)\n{\n    for (auto val : con)\n        cout << val << ' ';\n    cout << endl;\n}\n\nstruct Algorithm\n{\n    template <class Iterator, class Value_Type>\n    inline static void Replace(Iterator first, Iterator last, const Value_Type oldval, const Value_Type newval)\n    {\n        for (; first != last; ++first)\n            if (*first == oldval)\n                *first = newval;\n    }\n\n    template <class Iterator, class Value_Type, class Predicate>\n    // 给一个谓词来判断条件是否更改\n    inline static void Replace_if(Iterator first, Iterator last, Predicate pred, const Value_Type newval)\n    {\n        for (; first != last; ++first)\n            if (pred(*first))//这里谓词传递的参数只有一个值\n                *first = newval;\n    }\n\n    // 上面的算法当中传入的参数只有一个值，没传入如果需要比较的基准值\n    template <class Value_Type>\n    bool operator()(const Value_Type &val)\n    {\n        return val > 5;//我们肯定不想在内部手动更改这个5，而是想在外面写代码的时候把5写进去\n    }\n    // 为了解决这个问题需要引用仿函数适配器 functor adapter\n    // 标准库提供的 bind2nd() 用法 bind2nd(greater<int>,val)\n};\n\nint main()\n{\n    vector<int> v{1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    print(v);\n\n    Algorithm::Replace(v.begin(), v.end(), 1, 66);\n    print(v);\n\n    vector<int> v2{1, 1, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    Algorithm::Replace_if(v2.begin(), v2.end(), bind2nd(greater<int>(), 5), 666);\n    print(v2);\n\n    vector<int> v3;\n    v3.resize(v.size()); // 注意这里要给v3预分配空间，不然会段错误\n    replace_copy(v.begin(), v.end(), v3.begin(), 10, 50);\n    print(v3);\n\n    return 0;\n}\n```\n\n#### count,count_if\n\n这个差不多就不写了\n\n![image-20230423175336384](https://cdn.davidingplus.cn/images/2025/01/30/image-20230423175336384.png)\n\n为什么要返回difference_type呢？\n\n算法通过萃取机询问迭代器，迭代器之间的间距类型怎么表示，这个类型就是difference_type\n\n标准库的定义是 ptrdiff_t，也就是 long long，这下就可以理解了\n\n有些容器自带的成员函数，比如图中的，这些函数的执行效率肯定比全局的执行效率更高!!!\n\n#### find,find_if\n\n循序式查找，效率并不是很高，找不到返回last迭代器\n\n![image-20230423202430305](https://cdn.davidingplus.cn/images/2025/01/30/image-20230423202430305.png)\n\n#### sort\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <array>\n#include <algorithm>\n\ntemplate <typename Container>\nvoid print(Container con)\n{\n    for (auto val : con)\n        cout << val << ' ';\n    cout << endl;\n}\n\nbool myfunc(int i, int j)\n{\n    return i < j;\n}\n\nstruct myclass\n{\n    bool operator()(int i, int j) { return i < j; }\n} myobj;\n\nint main()\n{\n    array<int, 8> arr = {32, 71, 12, 45, 26, 80, 53, 33};\n    vector<int> v(arr.begin(), arr.end());\n    print(v);\n\n    // using default comparison (operator <)\n    sort(v.begin(), v.begin() + 4); // 排序前四个 12 32 45 71 26 80 53 33\n    print(v);\n\n    // using function as comp\n    sort(v.begin() + 4, v.end(), myfunc); // 12 32 45 71 26 33 53 80\n    print(v);\n\n    // using object as comp\n    sort(v.begin(), v.end(), myobj); // 12 26 32 33 45 53 71 80\n    print(v);\n\n    // reverse iterators\n    sort(v.rbegin(), v.rend(), less<int>()); // 80 71 53 45 33 32 26 12\n    print(v);\n\n    return 0;\n}\n```\n\n![image-20230423203719337](https://cdn.davidingplus.cn/images/2025/01/30/image-20230423203719337.png)\n\n**注意一点的是stl标准库里面的 sort 函数要求的是 random_access_iterator_tag!!!!!**\n\n**所以list和forward_list没办法调用，只能调用他们自己的类函数sort!!!**\n\n#### binary_search(通过二分查找确定元素在不在容器当中)\n\n**二分查找一定只能适用于一个有序序列!!!!并且在库函数当中只能用于升序序列!!!!**\n\n![image-20230423210411376](https://cdn.davidingplus.cn/images/2025/01/30/image-20230423210411376.png)\n\n使用例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <algorithm>\n#include <vector>\n\ntemplate <typename Container>\nvoid Sort(Container &con) // 传引用，不然不改变实参\n{\n    sort(con.begin(), con.end());\n}\n\ntemplate <typename Container>\nvoid rSort(Container &con) // 传引用，不然不改变实参\n{\n    sort(con.rbegin(), con.rend());\n}\n\ntemplate <typename Container>\nvoid print(Container &con) // 传引用，不然不改变实参\n{\n    for (auto val : con)\n        cout << val << ' ';\n    cout << endl;\n}\n\nnamespace Fuck\n{\n    template <typename Random_Iterator, typename Value_Type>\n    bool __Binary_Search(Random_Iterator first, Random_Iterator last, const Value_Type &val,\n                         random_access_iterator_tag)\n    {\n        // 先做一个检查 val比 *first大 那么找不到\n        if (val < *first)\n            return false;\n\n        while (first != last)\n        {\n            Random_Iterator mid = first + (last - first) / 2; // 没有两个迭代器相加的重载版本!!!!\n            if (*mid > val)\n                last = mid; // 注意last要满足前闭后开\n            else if (*mid < val)\n                first = ++mid;\n            else\n                return true;\n        }\n        return false;\n    }\n\n    template <typename Random_Iterator, typename Value_Type>\n    bool __Binary_Search(Random_Iterator first, Random_Iterator last, const Value_Type &val,\n                         random_access_iterator_tag, int) // 多一个int代表降序\n    {\n        // 先做一个检查 val比 *first大 那么找不到\n        if (val > *first)\n            return false;\n\n        while (first != last)\n        {\n            Random_Iterator mid = first + (last - first) / 2; // 没有两个迭代器相加的重载版本!!!!\n            if (*mid > val)\n                first = ++mid;\n            else if (*mid < val)\n                last = mid; // 注意last要满足前闭后开\n            else\n                return true;\n        }\n        return false;\n    }\n\n    template <typename Iterator, typename Value_Type>\n    // 写了一个random_access_iterator的重载\n    bool Binary_Search(Iterator first, Iterator last, const Value_Type &val)\n    {\n        // 想办法让其可以适用于降序序列\n        typedef typename iterator_traits<Iterator>::iterator_category Iterator_Category;\n        if (*first < *(last - 1)) // 升序 保持前闭后开的规则!!!\n            return __Binary_Search(first, last, val, Iterator_Category());\n        else\n            return __Binary_Search(first, last, val, Iterator_Category(), true);\n    }\n}\n\nint main()\n{\n    vector<int> v{1, 3, 6, 8, 7, 9, 2, 0};\n\n    Sort(v); // 0 1 2 3 6 7 8 9\n    print(v);\n    cout << Fuck::Binary_Search(v.begin(), v.end(), 2) << endl;\n    // cout << binary_search(v.begin(), v.end(), 5) << endl;\n    rSort(v);\n    print(v);\n    cout << Fuck::Binary_Search(v.begin(), v.end(), 2) << endl;\n\n    return 0;\n}\n```\n\n## 第五讲：仿函数 适配器\n\n### 仿函数 functors(注意要继承)\n\n标准库提供的三大类型的仿函数：算术类 逻辑运算类 相对运算类\n\n![image-20230424161751257](https://cdn.davidingplus.cn/images/2025/01/30/image-20230424161751257.png)\n\n还有之前提到过的几个仿函数：\n\n![image-20230424162149742](https://cdn.davidingplus.cn/images/2025/01/30/image-20230424162149742.png)\n\n标准库的示范：\n\n![image-20230424162843434](https://cdn.davidingplus.cn/images/2025/01/30/image-20230424162843434.png)\n\n**注意到一点：标准库提供的functors都存在继承关系!!!!只有这样才算是真正融入了STL体系，这样才能更好的运作。**\n\n**仿函数的 adaptable可适配 条件**\n\n![image-20230424163242826](https://cdn.davidingplus.cn/images/2025/01/30/image-20230424163242826.png)\n\n**STL规定，每个Functor都应该挑选适当的类来继承，因为适配器adapter会提出一些问题!!!!**\n\n**什么叫adaptable?如果你希望自己的仿函数是可以被适配器调整的话，那么就继承一个适当的类，这样可以完成更多的操作!!!为什么要继承呢？因为可能在被adapter改造的时候可能会问这些问题。这也和算法问迭代器的五个问题一样，那里是通过迭代器的萃取机 Iterator Traits (也叫迭代器适配器 Iterator Adapters )去问的，这里同理通过继承的关系去回答adapter的问题!!!**\n\n### 适配器 Adapter\n\n存在多种 Adapters ，还是那张图，注意关系\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230424170726596.png\" alt=\"image-20230424170726596\" style=\"zoom:67%;\" />\n\nAdapter的关键是：\n\n**这个Adapter要去改造某个东西(比如图中的container，functor，iterator)，这里就有两种解决方式，第一种是继承的方式，就是Adapter继承这个东西，拥有这个东西的属性来进行改造；第二种是内含的方式，Adapter内部有这个东西来进行改造!!!!**\n\n**在标准库里面的实现绝大多数都是内含的方式!!!**\n\n一下就是一些适配器的例子：\n\n#### 容器适配器：stack,queue\n\n![image-20230424172134280](https://cdn.davidingplus.cn/images/2025/01/30/image-20230424172134280.png)\n\n这个之前用过很多次了，就是把默认的容器拿进来进行改造，比如这里给的默认值是 deque ，改造之后能够以一种全新的面貌展现给用户，能够更加准确的针对用户的需要来进行相应的操作。\n\n#### 函数适配器：binder2nd\n\n![image-20230425185823723](https://cdn.davidingplus.cn/images/2025/01/30/image-20230425185823723.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <algorithm>\n\nnamespace fuck\n{\n    // 自己写一个bind2nd和binder2nd\n    // 仔细敲打一下这段代码\n    // 这里暗示了需要传入的是一个二元运算符 然后下面的类型名称是继承里面写好的类型名称\n    template <class Binary_Op>\n    class _BinderSecond\n    // 不继承这一行也可以运作，但是没办法进行后续的改造\n    // 这里就不继承了!!!\n    // : public unary_function<typename Binary_Op::first_argument_type, typename Binary_Op::second_argument_type>\n    {\n    protected:\n        Binary_Op op;\n        typename Binary_Op::second_argument_type value; // 第二参数 需要设定的固定值\n    public:\n        // ctor\n        _BinderSecond(const Binary_Op &x, const typename Binary_Op::second_argument_type &y)\n            : op(x), value(y) {}\n\n        typename Binary_Op::result_type\n        operator()(const typename Binary_Op::first_argument_type &x)\n        {\n            return op(x, value);\n        }\n    };\n\n    template <class Binary_Op, class Value_Type>\n    inline _BinderSecond<Binary_Op> _BindSecond(const Binary_Op &op, const Value_Type &val)\n    {\n        typedef typename Binary_Op::second_argument_type second_type;//这句话就是adapter在问问题\n        return _BinderSecond(op, second_type(val));\n    };\n}\n\nint main()\n{\n\n    vector<int> v{1, 3, 2, 5, 9, 8, 7, 6, 4, 10};\n    cout << count_if(v.begin(), v.end(),\n                     fuck::_BindSecond(less<int>(), 5)) // 绑定第二参数\n         << endl;\n\n    return 0;\n}\n```\n\n注意其中的一些代码：\n\n```c++\ntypename Binary_Op::second_argument_type value;\n```\n\n**为什么要加上 typename ，是为了通过编译，因为这个时候我们不知道Binary_Op是什么类型，然后如果他是我们想要的，也就是其中含有这个类型定义，那么就能通过编译，否则在这里就会报错!!!!**\n\n**仿函数functors的可适配(adaptable)条件**\n\n继承(因为adapter会问问题，提问类型)，是一个functor\n\n![image-20230425191652925](https://cdn.davidingplus.cn/images/2025/01/30/image-20230425191652925.png)\n\n#### 函数适配器：not1\n\n![image-20230425194548756](https://cdn.davidingplus.cn/images/2025/01/30/image-20230425194548756.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <algorithm>\n\nnamespace fuck\n{\n    // 对谓词做否定\n    template <class Predicate>\n    class _unary_negate\n        // 继承为了后续的改造\n        : public unary_function<typename Predicate::argument_type, bool>\n    {\n    protected:\n        Predicate pred;\n\n    public:\n        // ctor\n        _unary_negate(const Predicate &x) : pred(x) {}\n        \n        bool operator()(const typename Predicate::argument_type &x) const\n        {\n            return !pred(x);\n        }\n    };\n\n    template <class Predicate>\n    inline _unary_negate<Predicate> _Not1(const Predicate &pred)\n    {\n        return _unary_negate<Predicate>(pred);\n    }\n}\n\nint main()\n{\n    vector<int> v{1, 3, 2, 5, 9, 8, 7, 6, 4, 10};\n    cout << count_if(v.begin(), v.end(),\n                     fuck::_Not1(bind2nd(less<int>(), 5))) // 绑定第二参数\n         << endl;\n\n    return 0;\n}\n```\n\n**观察发现这些adapter的实现方法基本都是一个模板辅助函数，调用一个模板类，这个类里面有构造函数和小括号重载!!!!**\n\n#### 新型适配器：bind(since c++11)\n\n右边是老版本，左边是新版本!!!\n\n![image-20230425194051698](https://cdn.davidingplus.cn/images/2025/01/30/image-20230425194051698.png)\n\n可见bind的实现是非常复杂的!!!!\n\n下面是对bind的一些测试：\n\n![image-20230425200558918](https://cdn.davidingplus.cn/images/2025/01/30/image-20230425200558918.png)\n\n**bind 可以绑定：**\n\n**functions函数；function objects 函数对象(仿函数)；**\n\n**member functions 成员函数；data members 成员属性**\n\n前两个比较好理解，其中第三个和第四个的绑定规则是：\n\n**注意第一个参数传入的是传的是地址!!!!**\n\n**member functions, _1;**\n\n**data members,_1**\n\n**必须有第二个参数，第二个参数必须是必须是某个object的地址，可以是一个占位符，在调用的时候被外界指定!!!**\n\n**第一个参数可以理解为调用类里面的什么接口，第二个参数可以理解为谁来调用!!!!**\n\n使用例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <functional>\nusing namespace std::placeholders; // 使用占位符 _1 _2 _3这些\n#include <vector>\n#include <algorithm>\n\ndouble my_divide(double x, double y)\n{\n    return x / y;\n}\n\nstruct MyPair\n{\n    double a, b;\n    double multiply() { return a * b; }\n};\n\nvoid Bind_Functions()\n{\n    // binding functions\n    auto fn_five = bind(my_divide, 10, 2); // return 10.0/2.0\n    cout << fn_five() << endl;             // 5\n\n    auto fn_half = bind(my_divide, _1, 2); // return x/2.0\n    cout << fn_half(10) << endl;           // 5\n\n    auto fn_rounding = bind(my_divide, _2, _1); // 第一参数为除数，第二参数为被除数 return y/x\n    cout << fn_rounding(10, 2) << endl;         // 0.2\n\n    auto fn_invert = bind<int>(my_divide, _1, _2); // int 代表希望返回的类型 return int(x/y)\n    cout << fn_invert(10, 3) << endl;              // 3\n}\n\nvoid Bind_Members()\n{\n    MyPair ten_two{10, 2};\n\n    auto bound_memfn = bind(&MyPair::multiply, _1); // return x.multiply()\n    cout << bound_memfn(ten_two) << endl;           // 20\n\n    auto bound_memdata = bind(&MyPair::a, ten_two); // return tentwo.a\n    cout << bound_memdata() << endl;                // 10\n\n    auto bound_memdata2 = bind(&MyPair::b, _1); // return x.b\n    cout << bound_memdata2(ten_two) << endl;    // 2\n\n    vector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    auto _fn = bind(less<int>(), _1, 5);\n    cout << count_if(v.cbegin(), v.cend(), _fn) << endl;\n    cout << count_if(v.begin(), v.end(), bind(less<int>(), _1, 5)) << endl;\n}\n\nint main()\n{\n    Bind_Functions();\n    Bind_Members();\n\n    return 0;\n}\n```\n\n#### 迭代器适配器：rbegin，rend\n\n![image-20230425203641882](https://cdn.davidingplus.cn/images/2025/01/30/image-20230425203641882.png)\n\n这个迭代器就是在正向迭代器的基础之上进行改造的迭代器!!!\n\n#### 迭代器适配器：inserter(没弄懂)\n\n![image-20230425205345712](https://cdn.davidingplus.cn/images/2025/01/30/image-20230425205345712.png)\n\n注意copy是已经写死的函数，那么如何才能改变他的行为呢？\n\n**答案是借助操作符重载，本例子就是重载了 = 号运算符就是实现了由赋值操作变为插入操作了!!!!**\n\n## 第六讲：STL周围的细碎知识点\n\n### 一个万用的 hash function\n\n![image-20230426151146418](https://cdn.davidingplus.cn/images/2025/01/30/image-20230426151146418.png)\n\n**系统提供了一个非常不错的hashcode生成函数 hash_val() ，括号里面把元素的所有参数全部放进去就好！**\n\n#### hash_val(参数包)\n\n```c++\n    // 1\n\ttemplate <typename... Types> // ... 的含义 接受任意数量的模板参数\n    inline size_t hash_val(const Types &...args)\n\t//创建一个种子，将种子和参数包绑定在一起\n    {\n        size_t seed = 0;\n        hash_val(seed, args...);//调用2号重载 修改seed\n        return seed;//最后返回seed就是最终的hashcode\n    }\n\n\t// 2\n    template <typename Type, typename... Types>\n    inline void hash_val(size_t &seed, const Type &val, const Types &...args)\n    {\n        //注意这个函数接受的参数，有一个val,本来传入的是n个元素的参数包，出现val之后，就将其分开，分为1和n-1来处理\n        hash_combine(seed, val);//取出一个参数来对seed进行修改!!!!\n        hash_val(seed, args...);//处理剩余 n-1 个参数包 递归操作\n    }\n\n\t// 3\n    template <typename Type>\n    inline void hash_val(size_t &seed, const Type &val)\n\t//最终当只剩下一个参数的时候就最后更改一次就行了\n    {\n        hash_combine(seed, val);\n    }\n\n    template <typename Type>\n    inline void hash_combine(size_t &seed, const Type &val)\n    {\n        seed ^= std::hash<Type>()(val) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n        //前面第一个参数是调用系统提供的哈希函数，后面这些加和左移右移是为了让其更加混乱，没有规律可言\n    }\n```\n\n上面的例子不是很好理解，这里写一个打印string的例子方便加深理解：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <string>\n\nclass StringPrint\n{\npublic:\n    inline void myprint(const string &str)\n    {\n        _myprint(str);\n        cout << endl;\n    }\n\n    template <typename... Types>\n    inline void myprint(const string &str, const Types &...args)\n    {\n        _myprint(str, args...);\n        cout << endl;\n    }\n\n    template <typename... Types>\n    void foo(const Types &...args)\n    {\n        //当我们想要知道包中有多少元素时，可以使用sizeof...运算符，该运算符返回一个常量表达式，并且不会对其实参求值\n        cout << sizeof...(Types) << endl; // 类型参数数目\n        cout << sizeof...(args) << endl;  // 函数参数数目\n    }\n\nprivate:\n    inline void _myprint(const string &str)\n    {\n        cout << str;\n    }\n\n    // 接受参数包，参数包是占位符的替换\n    template <typename Type, typename... Types>\n    inline void _myprint(const string &str, const Type &val, const Types &...args)\n    {\n        // 一个字符一个字符的读，直到碰到占位符 %\n        for (auto iter = str.begin(); iter != str.end(); ++iter)\n        {\n            if (*iter != '%')\n                cout << *iter;\n            else\n            {\n                // 是占位符\n                cout << val;\n                string newstr = string(++iter, str.end());\n                _myprint(newstr, args...);//创建新的字符串并且传进去进行递归，注意不要忘了 return 递归出口\n                return;\n            }\n        }\n    }\n} myPrint;\n\nint main()\n{\n    myPrint.myprint(\"Hello , I'm % , % years old.\", \"David\", 20);\n    myPrint.foo(\"Hello , I'm % , % years old.\", \"David\", 20);\n    myPrint.myprint(\"fuck you!\");\n    myPrint.foo(\"fuck you!\");\n\n    return 0;\n}\n```\n\n#### Hash函数的三种形式\n\n1.仿函数 functor\n\n2.函数指针\n\n```c++\n//仿函数\nclass CustomerHash\n{\npublic:\n    size_t operator()(const Customer &c) const\n    {\n        return HashFunction().hash_val(c.fname, c.lname, c.no);\n    }\n};\n\n//函数指针\nsize_t customer_hash_func(const Customer &c)\n{\n    // 第一种思路就是这个类里面简单类型的hashcode全部相加\n    // 但是这么做的话设计者认为比较天真，没办法达到非常乱的结构\n    return HashFunction().hash_val(c.fname, c.lname, c.no);\n}\n\n//注意在main函数创建的时候传入参数的时候需要注意\nint main(){\n    unordered_set<Customer, CustomerHash> custset;\n\n    using function_pointer = size_t (*)(const Customer &); // 定义函数指针\n    unordered_set<Customer, function_pointer> custset2; //传入的是函数指针的形式!!!\n    \n    return 0;\n}\n```\n\n3.特化的版本\n\n对于 unorder_set or unorder_map，如果不给hash函数，那么默认会使用系统的 hash<value_type>，这个时候可以通过这个对其进行特化处理\n\n```c++\n// 放在std内表示在标准库std里面进行操作修改\nnamespace std\n{\n    template <>\n    class hash<Customer>\n    {\n        size_t operator()(const Customer &c)\n        {\n            return HashFunction().hash_val(c.fname, c.lname, c.no);\n        }\n    };\n}\n```\n\n可以在我们的代码中对std里面的系统提供的hash函数进行特化版本的处理来实现\n\n### tuple\n\ntuple是c++11新引入的一个好东西，他可以传入一个参数包，参数包里面可以放入任意大小，任意类型\n\n![image-20230427111200767](https://cdn.davidingplus.cn/images/2025/01/30/image-20230427111200767.png)\n\n示例代码:\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <string>\n#include <tuple>\n#include <complex>\n#include <typeinfo>\n#include \"29_tuple_print.h\"\n\nvoid test()\n{\n    cout << \"string,sizeof = \" << sizeof(string) << endl;                   // 32\n    cout << \"double,sizeof = \" << sizeof(double) << endl;                   // 8\n    cout << \"float,sizeof = \" << sizeof(float) << endl;                     // 4\n    cout << \"int,sizeof = \" << sizeof(int) << endl;                         // 4\n    cout << \"complex<double>,sizeof = \" << sizeof(complex<double>) << endl; // 16\n\n    tuple<string, int, int, complex<double>> t;\n    cout << \"tuple<string,int,int,complex<double>,sizeof = \" << sizeof(t) << endl; // 56\n\n    tuple<int, float, string> t1(41, 6.3, \"nico\");\n    cout << \"tuple<int,float,string>,sizeof = \" << sizeof(t1) << endl;              // 40\n    cout << \"t1: \" << get<0>(t1) << ' ' << get<1>(t1) << ' ' << get<2>(t1) << endl; // 取出其中的元素用法\n\n    auto t2 = make_tuple(22, 44.0, \"stacy\");\n    get<1>(t1) = get<1>(t2);\n    cout << \"t1: \" << get<0>(t1) << ' ' << get<1>(t1) << ' ' << get<2>(t1) << endl;\n    cout << \"t2: \" << get<0>(t2) << ' ' << get<1>(t2) << ' ' << get<2>(t2) << endl;\n\n    // 比较大小\n    if (t1 < t2)\n        cout << \"t1 < t2\" << endl;\n    else if (t1 > t2)\n        cout << \"t1 > t2\" << endl;\n    else\n        cout << \"t1 == t2\" << endl;\n    t1 = t2; // 赋值操作\n    cout << t2 << endl;\n\n    typedef tuple<int, float, string> TupleType;\n    cout << tuple_size<TupleType>::value << endl; // 3\n\n    typedef tuple_element<1, TupleType>::type Type1; // float\n    cout << typeid(Type1).name() << endl;            // f\n\n    tuple<int, float, string> t3(77, 1.1, \"more light\");\n    int i1;\n    float f1;\n    string s1;\n    tie(i1, f1, s1) = t3; // 将这t3的三个属性绑定到这三个变量上面\n    cout << \"i1 = \" << i1 << \" f1 = \" << f1 << \" s1= \" << s1 << endl;\n}\n\nint main()\n{\n    test();\n\n    return 0;\n}\n```\n\n**这里面就有学问了，重载 这个参数包的 左移运算符(代码建议重复看!!!!)**\n\n```c++\n#ifndef __TUPLEPRINT__\n#define __TUPLEPRINT__\n\n#include <iostream>\nusing namespace std;\n\n// get<> 尖括号里面不能放入变量，只能放入一个常量!!!!\ntemplate <typename Tuple, size_t N>\nstruct tuple_print\n{\n    inline static void print(const Tuple &t, ostream &out)\n    {\n        tuple_print<Tuple, N - 1>::print(t, out);\n        out << ' ' << get<N - 1>(t);\n        // 为什么要反着写？\n        // 因为递归出来打印的顺序是从0 到 n-1!!!!\n    }\n};\n\n// 递归出口\ntemplate <typename Tuple>\nstruct tuple_print<Tuple, 1>\n{\n    inline static void print(const Tuple &t, ostream &out)\n    {\n        out << get<0>(t);\n    }\n};\n\n// 重载 左移运算符\n#include <tuple>\ntemplate <typename... Types>\ninline ostream &\noperator<<(ostream &out, const tuple<Types...> &t)\n{\n    // decltype 可以得出变量的类型\n    // 模板参数里面可以放入一个常量，根据常量不同的大小可以调用不同的重载或者特化版本\n    tuple_print<decltype(t), sizeof...(Types)>::print(t, out);\n    return out;\n}\n\n#endif\n```\n\n那么这个这么好用的tuple是怎么实现的呢？\n\n![image-20230427112849536](https://cdn.davidingplus.cn/images/2025/01/30/image-20230427112849536.png)\n\n**他的大概意思就是接受参数包，然后将参数包分为1和n-1，本类继承上一级(n-1)的类，以此往上继承；由于本类当中的成员是head，就是这个1对应的元素，所以继承过后本类会获得所有的元素，可以通过head和tail接口进行调用!!!!!!**\n\n注意图中右上角的继承关系!!!\n\ntuple里面有两个head和tail函数，这两个在现在的c++里面不太好用，因为新加了很多东西，接口也变了，所以就不用了\n\n# C++ 2.0 新特性\n\n## 第一讲：语言\n\n### variatic templates 参数包\n\n**在类模板中，模板参数包必须是最后一个模板形参. 而在函数模板中则不必!!!!**\n\n![image-20230427170952730](https://cdn.davidingplus.cn/images/2025/01/30/image-20230427170952730.png)\n\n这个之前提过了，就不细谈了\n\n下面那三个分别对应：\n\n```c++\ntypename... Types //模板参数包\nconst Types&... args //函数参数类型包\nprint(args...) //函数参数包\n```\n\n利用参数包也可以实现万用的hashcode的实现: 之前写过就不细看了\n\n![image-20230427171431489](https://cdn.davidingplus.cn/images/2025/01/30/image-20230427171431489.png)\n\n### 零碎知识点\n\n#### nullptr\n\n```c++\n#include <iostream>\nusing namespace std;\n\nvoid f(int)\n{\n    cout << \"call of int\" << endl;\n}\n\nvoid f(void *)\n{\n    cout << \"call of void*\" << endl;\n}\n\nint main()\n{\n    f(0); // calls f(int)\n    // f(NULL);    // 这里会报错，因为NULL既可以指是int 也可以是指针\n    f(nullptr); // calls f(void*)\n\n    return 0;\n}\n```\n\n#### auto\n\n提醒：不要有了auto就以后都不写类型了，能不用就不用，除非是在类型名太长或者太复杂的类型才用一下，我们心里需要明白这到底是怎么类型，不要编译器知道了我们不知道\n\n```c++\n#include <iostream>\nusing namespace std;\n\n//函数的返回值也可以是auto\nauto Func(const int &val)\n{\n    return val > 0;\n}\n\nint main()\n{\n    // 注意函数指针的写法\n    auto func = [](const int &val) -> bool\n    {\n        return val > 0;\n    };\n    bool (*func2)(const int &val) = Func;\n\n    cout << func(1) << endl;\n    cout << func2(-1) << endl;\n\n    return 0;\n}\n```\n\n### initializer_list<>\n\n#### uniform initialization 统一初始化\n\n任何初始化动作都可以用一个共同语法：{ //填入值 }\n\n```c++\nint values[] {1,2,3};\nvector<string>cities{\n\"Berlin\",\"New York\",\"London\"\n};\n```\n\n示例代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n\ntemplate <typename Container>\ninline void print(const Container &con)\n{\n    for (auto val : con)\n        cout << val << ' ';\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> v{1, 2, 3};\n    vector<string> cities{\n        \"Berlin\", \"New York\", \"London\"};\n    print(v);\n    print(cities);\n\n    return 0;\n}\n```\n\n在编译器看到 {} 的时候会自动创建出来一个 initializer_list，这是一个类，具体代码实现如下：\n\n```c++\ntemplate <class _E>\n// 这个东西背后是一个 array ,编译器在看见大括号的时候就会预先准备一个 array\nclass initializer_list\n{\npublic:\n    typedef _E value_type;\n    typedef const _E &reference;\n    typedef const _E &const_reference;\n    typedef size_t size_type;\n    typedef const _E *iterator;\n    typedef const _E *const_iterator;\n\nprivate:\n    iterator _M_array;\n    size_type _M_len;\n\n    // The compiler can call a private constructor.\n    // 编译器在这里能调用私有的构造函数(编译器可以，我们不可以)\n    // 到这里会把array的头指针和长度传递给array参数,本身并没有内含array(有点像委托)\n    constexpr initializer_list(const_iterator __a, size_type __l)\n        : _M_array(__a), _M_len(__l) {}\n\npublic:\n    constexpr initializer_list() noexcept\n        : _M_array(0), _M_len(0) {}\n\n    // Number of elements.\n    constexpr size_type\n    size() const noexcept { return _M_len; }\n\n    // First element.\n    constexpr const_iterator\n    begin() const noexcept { return _M_array; }\n\n    // One past the last element.\n    constexpr const_iterator\n    end() const noexcept { return begin() + size(); }\n};\n```\n\n**关于这个类的拷贝构造，可以看由于在类里面没有对拷贝构造的重写，导致两个initializer_list在拷贝的时候是浅拷贝，两个指针指向同一块内存空间，可能会出现危险，这个需要注意**\n\nSTL的容器是如何引入initializer_list的？\n\n![image-20230430111248498](https://cdn.davidingplus.cn/images/2025/01/30/image-20230430111248498.png)\n\ninitializer_list<>里面内置了一个array数组的指针和这个数组的长度，编译器会读取{}里面的元素来进行容器的插入操作以实现初始化操作\n\n示例代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n#include <initializer_list>\n#include <string>\n\nclass Algorithm\n{\npublic:\n    // 传入的是一个initializer_list<>\n    template <typename Value_Type>\n    inline Value_Type\n    _min(const initializer_list<Value_Type> &init_list)\n    {\n        return Min(init_list.begin(), init_list.end());\n    }\n\n    template <typename Value_Type>\n    inline Value_Type\n    _max(const initializer_list<Value_Type> &init_list)\n    {\n        return Max(init_list.begin(), init_list.end());\n    }\n\nprivate:\n    template <typename Input_Iterator>\n    inline typename iterator_traits<Input_Iterator>::value_type\n    Min(Input_Iterator first, Input_Iterator last)\n    {\n        auto Min = *first;\n        for (; first != last; ++first)\n            Min = Min <= *first ? Min : *first;\n        return Min;\n    }\n\n    template <typename Input_Iterator>\n    inline typename iterator_traits<Input_Iterator>::value_type\n    Max(Input_Iterator first, Input_Iterator last)\n    {\n        auto Max = *first;\n        for (; first != last; ++first)\n            Max = Max >= *first ? Max : *first;\n        return Max;\n    }\n};\n\ntemplate <typename Container>\ninline void print(const Container &con)\n{\n    for (auto val : con)\n        cout << val << ' ';\n    cout << endl;\n}\n\nint main()\n{\n    vector<int> v1{2, 5, 7, 13, 69, 83, 50};\n    vector<int> v2({2, 5, 7, 13, 69, 83, 50});\n    vector<int> v3;\n    v3 = {2, 5, 7, 13, 69, 83, 50};\n    v3.insert(v3.begin() + 2, {0, 1, 2, 3, 4});\n    print(v3);\n\n    cout << Algorithm()._max({54, 16, 48, 5}) << endl;\n    cout << Algorithm()._min({string(\"Ace\"), string(\"Hello\"), string(\"Fuck\"), string(\"Zion\")}) << endl;\n\n    return 0;\n}\n```\n\n### explicit\n\n**explicit for ctor taking one argument**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstruct Complex\n{\n    int real, imag;\n\n    explicit Complex(int re, int im = 0) : real(re), imag(im) {}\n    //explict关键字的含义 防止类构造函数的隐式自动转换\n    //就是说这里由于只需要传入一个参数，所以编译器很可能会把数字隐式转化为Complex对象\n    //但是加上了explict之后,明确指出不要让编译器这么干，要生成Complex对象只能显式调用构造函数!!!!\n\n    Complex operator+(const Complex &x)\n    {\n        return Complex(real + x.real, imag + x.imag);\n    }\n};\n\ninline ostream &\noperator<<(ostream &os, const Complex &x)\n{\n    os << '(' << x.real << ',' << x.imag << ')';\n    return os;\n}\n\nint main()\n{\n    Complex c1(12, 5);\n    // Complex c2 = c1 + 5; // 加了explicit关键字就不允许编译器直接把5转化为 Complex 类型了\n    cout << c1 << endl;\n\n    return 0;\n}\n```\n\n这是一个实参加上 explicit 关键字的情况，前面已经提过很多了\n\n**explicit for ctors taking more than one argument**\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <initializer_list>\n\nstruct P\n{\n    P(int a, int b) { cout << \"P (int a , int b) \" << endl; }\n    // P(initializer_list<int>) { cout << \"P (initializer_list<int>) \" << endl; }\n    explicit P(int a, int b, int c) { cout << \"explicit P (int a , int b , int c) \" << endl; }\n};\n\nint main()\n{\n    P p1(77, 5);\n    P p2{77, 5};\n    P p3 = {77, 5};\n\n    P p4{77, 5, 42};\n    // 这个是可以的,因为它既可以看作传入了三个参数，也可以看作传入了初始化序列\n    // 而如果像下面一样加上括号并且有 explicit 关键字就只能传入 三个参数的形式\n\n    P p5({77, 5, 42}); \n    // 这个在有 explicit 关键字的情况下没有办法把 initializer_list 的形式转化为 a,b,c 的形式，会报错\n\n    return 0;\n}\n```\n\n### =delete,=default\n\n```c++\n#include <iostream>\nusing namespace std;\n\n// 如果已经定义了一个ctor，那么编译器就不会给一个默认的ctor\nclass Zoo\n{\npublic:\n    Zoo(int i1, int i2) : d1(i1), d2(i2) {}\n    Zoo(const Zoo &) = delete; // delete表示我不要这一个重载\n    Zoo(Zoo &&) = default;     // default表示我需要这一个重载并且是编译器默认提供给我的这个重载\n    Zoo &operator=(const Zoo &) = default;\n    Zoo &operator=(const Zoo &&) = delete;\n\n    virtual ~Zoo() {}\n\nprivate:\n    int d1, d2;\n};\n\nint main()\n{\n    Zoo z1(1, 2);\n    // Zoo z2(z1); // 无法使用因为他是已删除的函数\n\n    return 0;\n}\n```\n\n一般是应用在 Big 3 上面，即 构造函数，拷贝构造，拷贝赋值和析构函数\n\n![image-20230504191205113](https://cdn.davidingplus.cn/images/2025/01/30/image-20230504191205113.png)\n\n其中出现了右值引用，这个目前不了解\n\n```c++\nZoo(const Zoo&)=delete;// copy ctor\nZoo(Zoo&&)=default;// move ctor\n```\n\n一个更细的例子：\n\n![image-20230504191639232](https://cdn.davidingplus.cn/images/2025/01/30/image-20230504191639232.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Foo\n{\npublic:\n    // ctor\n    Foo(int i) : _i(i) {}\n    Foo() = default;\n\n    // copy ctor\n    Foo(const Foo &x) : _i(x._i) {}\n    // Foo(const Foo &) = default; // error 都已经定义出来了还要默认的，不行\n    // Foo(const Foo &) = delete;  // error 都已经定义出来又不要了，不行\n\n    // copy assign\n    Foo &operator=(const Foo &x)\n    {\n        _i = x._i;\n        return *this;\n    }\n\n    // Foo &operator=(const Foo &x) = default; // error 都已经定义出来了还要默认的，不行\n    // Foo &operator=(const Foo &x) = delete;  // error 都已经定义出来又不要了，不行\n\n    // void func1() = default; // error 一般的函数没有默认版本，只能用于 big five上面\n    void func2() = delete; // delete可以用在任何函数上面(=0 只能用于 virtual 函数)\n\n    // ~Foo() = delete;//error 不能删除析构函数，这会导致使用Foo对象错误!!!!\n    ~Foo() = default;\n\nprivate:\n    int _i;\n};\n\nint main()\n{\n    Foo f1; // 如果不写 Foo() = default 编译器不会提供默认构造函数，会报错\n    Foo f2(5);\n    Foo f3(f1);\n    f3 = f2;\n\n    return 0;\n}\n```\n\n对于一个空的类，编译器在处理的时候会提供默认的big 3，即 构造函数，拷贝构造，拷贝赋值，析构函数\n\n```c++\nclass Empty{ };\n\n//空的，但是编译器会提供\nclass Empty{\npublic:\n    //ctor\n    Empty(){ ... }\n    //copy ctor\n    Empty(const Empty& rhs){ ... }\n    //copy assign\n    Empty& operator=(const Empty& rhs){ ... }\n    //dctor\n    ~Empty(){ ... }\n}\n\n//以下代码对于一个空类是合法的\n{\n    Empty e1;\n    Empty e2(e1);\n    e2=e1;\n}\n```\n\n那么我们怎么确认是用默认的还是自己写的呢？\n\nclasses with or without pointer members!!!!\n\n**带有指针的类基本上都需要重写 big 3；不带指针的基本都不需要写!!!!!**\n\n#### No-Copy and Private-Copy\n\n![image-20230504201206953](https://cdn.davidingplus.cn/images/2025/01/30/image-20230504201206953.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstruct Nocopy\n{\n    Nocopy() = default;\n    Nocopy(const Nocopy &) = delete;            // no copy\n    Nocopy &operator=(const Nocopy &) = delete; // no assign\n    ~Nocopy() = default;\n};\n\nstruct NoDtor\n{\n    NoDtor() = default;\n    ~NoDtor() = delete; // 非常不建议这么去做\n};\n\nvoid testNoDtor()\n{\n    // NoDtor nd;//栈区对象的生命周期在这个函数结束就销毁了，这时候会自动调用dtor，没有则报错\n    NoDtor *p = new NoDtor; // 动态开辟是允许的，但是无法销毁\n    // delete p;               // 不允许销毁\n}\n\nclass PrivateCopy\n{\nprivate:\n    // 这个类无法被一般的代码调用，但是可以被friend和member调用copy\n    // 如果要禁止，不仅需要放到private里面，还要加上 = delete\n    PrivateCopy(const PrivateCopy &);\n    PrivateCopy &operator=(const PrivateCopy &);\n\npublic:\n    PrivateCopy() = default;\n    ~PrivateCopy();\n};\n\nint main()\n{\n    testNoDtor();\n\n    return 0;\n}\n```\n\n### Alias(化名) Template (template typedef) 模板的化名\n\n![image-20230504202940442](https://cdn.davidingplus.cn/images/2025/01/30/image-20230504202940442.png)\n\n**值得注意的是下面两个没办法实现我们想要的结果!!!!**\n\n#### test_moveable函数测试\n\n这么写始终会报错，看起来是没有办法把容器和容器模板的类型分开来进行传入的\n\n![image-20230504213412890](https://cdn.davidingplus.cn/images/2025/01/30/image-20230504213412890.png)\n\n所以可以这么写：\n\n![image-20230504213510643](https://cdn.davidingplus.cn/images/2025/01/30/image-20230504213510643.png)\n\n### template template parameter 双重模板参数\n\n![image-20230505102818021](https://cdn.davidingplus.cn/images/2025/01/30/image-20230505102818021.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n#define SIZE 1e6\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n\ntemplate <typename Type>\ninline void output_static_data(const Type &obj)\n{\n    cout << \"static_data: \" << endl; // 输出静态成员\n}\n\n// template template paremeter 双重模板参数\ntemplate <class Value_Type,\n          template <class> // 这样写表示 Container模板使用 Value_Type 类型\n          class Container>\n// 这里由于传入的是容器，绝大多数的容器都有两个参数，第一个是元素类型，第二个是分配器，然而分配器又是以元素类型的模板\n// 编译器无法推导第二个分配器的参数，虽然有默认值，所以就需要用到 Alias 来设置\nclass XCls\n{\nprivate:\n    Container<Value_Type> c;\n\npublic:\n    XCls()\n    {\n        for (long i = 0; i < SIZE; ++i)\n            c.insert(c.end(), Value_Type());\n\n        output_static_data(Value_Type());\n        Container<Value_Type> c1(c);\n        Container<Value_Type> c2(std::move(c));\n        c1.swap(c2);\n    }\n};\n\n#include <ext/pool_allocator.h>\nnamespace Alias\n{\n    template <typename Value_Type>\n    using Vec = vector<Value_Type, __gnu_cxx::__pool_alloc<Value_Type>>;\n\n    template <typename Value_Type>\n    using Lst = list<Value_Type, __gnu_cxx::__pool_alloc<Value_Type>>;\n\n    template <typename Value_Type>\n    using Deq = deque<Value_Type, __gnu_cxx::__pool_alloc<Value_Type>>;\n}\n\nusing namespace Alias;\nint main()\n{\n    XCls<string, Vec> c;\n    XCls<string, Lst> c2;\n    XCls<string, Deq> c3;\n\n    return 0;\n}\n```\n\n### type alias 类型化名\n\ntype alias 和 typedef 没有任何的不同\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <vector>\n\n// type alias 和 typedef 没有任何的不同\nnamespace Test\n{\n    void test01(int, int)\n    {\n        cout << \"test01\" << endl;\n    }\n\n    template <typename T>\n    struct Container\n    {\n        using Value_Type = T;\n    };\n\n    template <class CharT>\n    using mystring = std::basic_string<CharT, std::char_traits<CharT>>;\n\n    template <class Container>\n    void fn2(const Container &con)\n    {\n        using Value_Type = typename iterator_traits<typename Container::iterator>::value_type;\n        cout << \"fn2\" << endl;\n    }\n}\n\nusing namespace Test;\nint main()\n{\n    // func现在指向参数如下的函数\n    using func = void (*)(int, int);\n    func f1 = test01;\n    f1(1, 1);\n\n    mystring<char> str;\n\n    fn2(vector<int>());\n\n    return 0;\n}\n```\n\n### noexcept 保证不会抛出异常\n\n**我们必须通知C++(特别是 std::vector)，move ctor 和 move assignment 和 dtor不会抛出异常，前两个都是右值引用**\n\n**以vector为例，vector容器在扩充空间的时候，是以2倍空间扩充，需要新找一块内存将当前的数据移动到新数据块中，这就需要用到 move ctor，并且如果不是noexcept，vector不敢调用它，只有是noexcept的时候vector才会调用它**\n\n注意：growable containers只有两种：vector和deque\n\n![image-20230505152557462](https://cdn.davidingplus.cn/images/2025/01/30/image-20230505152557462.png)\n\n至于move ctor和move assignment，到后面再说\n\n### override 覆写 特用于虚函数重写上面\n\n**这个需要保证子类和父类这个虚函数的名称，返回值，参数类型，个数，位置完全相同!!!!!**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstruct Base\n{\n    virtual void func(float) { cout << \"Base func float\" << endl; }\n};\n\nstruct Derived1 : public Base\n{\n    // 第一个是定义了一个新的虚函数,不是override\n    virtual void func(int) { cout << \"Derived1 func int\" << endl; }\n    // 第二个才是上面父类的override\n    virtual void func(float) override { cout << \"Derived1 func float\" << endl; }\n};\n\nint main()\n{\n    Derived1().func(1.1);\n\n    return 0;\n}\n```\n\n### final\n\n用来修饰class表示不允许类继承自己；用来修饰虚函数virtual表示不允许子类override这个函数\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstruct Base1 final // final表示不允许有类继承自己\n{\n};\n\n//  error\n// struct Derived1 : Base1\n// {\n// };\n\nstruct Base2\n{\n    virtual void f() final; // final表示不允许子类覆写这个函数\n};\n\nstruct Derived2 : Base2\n{\n    // void f(); //error\n};\n\nint main()\n{\n\n    return 0;\n}\n```\n\n### decltype\n\n用来得到一个表达式的类型，有三大应用:\n\n1.declare return types\n\n```c++\n#include <iostream>\nusing namespace std;\n\nnamespace Test {\ntemplate <typename Value_Type1, typename Value_Type2>\nauto add(const Value_Type1& x, const Value_Type2& y)\n    -> decltype(x + y) {  // 不写在前面是因为编译器先后次序编译不认识x,y，所以放在后面用 -> 来指明auto的类型\n    return x + y;\n}\n}  // namespace Test\n\nusing namespace Test;\nint main() {\n    cout << add(1, 2) << endl;\n    cout << add(1.1, 2) << endl;\n\n    return 0;\n}\n```\n\n2.in metaprogramming 元编程 就是用在泛型里面\n\n3.lambdas\n\n一个应用：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <set>\n#include <string>\n\nnamespace Test {\n\nclass Person {\npublic:\n    Person() = default;\n    Person(string firstname, string lastname)\n        : _firstname(firstname), _lastname(lastname) {}\n\npublic:\n    string _firstname;\n    string _lastname;\n};\n\nostream&\noperator<<(ostream& os, const Person& p) {\n    os << '(' << p._firstname << ',' << p._lastname << ')';\n    return os;\n}\n\nauto CmpPerson = [](const Person& p1, const Person& p2) {\n    return (p1._lastname < p2._lastname) ||\n           (p1._lastname == p2._lastname) && (p1._firstname < p2._firstname);\n};\n\nstruct Cmp\n    : binary_function<Person, Person, bool> {\n    // 被比较的不能被修改，编译器非常灵敏，需要加上const\n    bool operator()(const Person& p1, const Person& p2) const {\n        return (p1._lastname < p2._lastname) ||\n               (p1._lastname == p2._lastname) && (p1._firstname < p2._firstname);\n    }\n} cmps;\n\ntemplate <typename Container>\ninline void print(const Container& con) {\n    for (auto val : con)\n        cout << val << ' ';\n    cout << endl;\n}\n\n}  // namespace Test\n\nusing namespace Test;\nint main() {\n    Person p1(\"John\", \"Wall\");\n    Person p2(\"David\", \"Paul\");\n    Person p3(\"Steve\", \"Paul\");\n\n    // 这里需要如果括号里不给CmpPerson参数，会调用CmpPerson的默认构造函数，不幸的是没有默认构造，所以需要给出\n    set<Person, decltype(CmpPerson)> s({p1, p2, p3}, CmpPerson);\n    print(s);\n    return 0;\n}\n```\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230505195009665.png\" alt=\"image-20230505195009665\" style=\"zoom:67%;\" />\n\n### lambdas\n\n![image-20230505190504411](https://cdn.davidingplus.cn/images/2025/01/30/image-20230505190504411.png)\n\n[ ]里可以指定是以 value 还是以 reference 的形式传入，( )后面那三个东西是可选的，但是只要有一个出现那么( )就必须写出来，所以建议都写上( )\n\n```c++\n#include <iostream>\nusing namespace std;\n\nint main() {\n    []() -> void {\n        cout << \"hello lambda\" << endl;\n    }();  // 前三个是格式 最后一个括号代表调用\n\n    auto I = []() -> void {\n        cout << \"hello lambda\" << endl;\n    };\n    I();\n\n    int id1 = 0, id2 = 0;\n    // 为什么下面打印出来是0 1 2\n    // 因为这里的id1传进去是0，还没走到下面\n    // 由于是 value 传递，所以是copy操作，内部的id不会影响外面的id\n    auto f = [id1, &id2]() mutable {\n        // 如果不写 mutable ，这个id进来之后只能read only，不能++\n        cout << \"id1: \" << id1 << ',' << \"id2: \" << id2 << endl;\n        ++id1;\n        ++id2;\n    };\n\n    // 上面lambda表达式的相对接近的写法(不对等，有小区别)\n    // class Functor {\n    // private:\n    //     int id1;  // copy of outside id1\n    //     int id2;  // reference of outside id2\n\n    // public:\n    //     void operator()() {\n    //         cout << \"id1: \" << id1 << ',' << \"id2: \" << id2 << endl;\n    //         ++id1;\n    //         ++id2;\n    //     }\n    // };\n    // Functor f;\n\n    id1 = 42, id2 = 42;\n    f();  // 0 42\n    f();  // 1 43\n    f();  // 2 44\n    cout << id1 << ' ' << id2 << endl;\n\n    return 0;\n}\n```\n\n与上一个的例子联系起来，也让我们对set的底层实现有了更多的理解\n\n**这也解释了为什么在传入lambda的时候需要在括号里面指定这个函数变量，看他的构造就行了**\n\n![image-20230505195056962](https://cdn.davidingplus.cn/images/2025/01/30/image-20230505195056962.png)\n\n所以在functor和lambda之后，选择functor显然会稍微好一点\n\n另一个例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <algorithm>\n#include <vector>\n\nclass LambdaFunctor {\npublic:\n    LambdaFunctor(int x, int y)\n        : _x(x), _y(y) {}\n\n    bool operator()(int val) {\n        return val > _x && val < _y;\n    }\n\nprivate:\n    int _x;\n    int _y;\n};\n\ntemplate <typename Value_Type>\ninline void printVector(const vector<Value_Type>& vec) {\n    for (auto val : vec)\n        cout << val << ' ';\n    cout << endl;\n}\n\nint main() {\n    int x = 30, y = 100;\n\n    vector<int> v1{5, 28, 50, 83, 70, 590, 245, 59, 24};\n    vector<int> v2{5, 28, 50, 83, 70, 590, 245, 59, 24};\n\n    // 注意remove系列操作是假remove，需要erase才能真正删除\n    auto newEnd1 = remove_if(v1.begin(), v1.end(), [x, y](int val) {\n        return val > x && val < y;\n    });\n    v1.erase(newEnd1, v1.end());\n\n    v2.erase(remove_if(v1.begin(), v1.end(), LambdaFunctor(x, y)), v2.end());\n\n    printVector(v1);\n    printVector(v2);\n\n    return 0;\n}\n```\n\n### variadic templates\n\n之前已经提到过很多次了，举一些例子：\n\n```c++\n#include <iostream>\nusing namespace std;\n\nstatic int value = 0;\n\nnamespace Test {\ninline void _func() {}\n\ntemplate <typename Value_Type, typename... Types>\ninline void _func(const Value_Type& firstArg, const Types&... args) {\n    ++value;\n    _func(args...);\n}\n\n// 包装\ntemplate <typename... Types>\ninline void func(const Types&... args) {\n    _func(args...);\n    cout << \"value: \" << value << endl;\n}\n\n}  // namespace Test\n\nusing namespace Test;\nint main() {\n    func(1, 2, 3, 4, 5);             // 5\n    func(\"string\", \"fuck\", 2, 1.2);  // 9\n\n    return 0;\n}\n```\n\n第二个例子：用c++模拟printf函数(简易版)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nnamespace Print {\n// 代码中抛出异常的部分先不管\n// 用参数包重写printf函数 理解\ninline void myprintf(const char* str) {\n    while (*str) {\n        if (*str == '%' && *(++str) != '%')  // 已经没有参数包了还有控制符号，不对劲，抛出异常\n            throw runtime_error(\"invalid format string: missing arguments.\");\n        cout << *str++;\n    }\n}\n\ntemplate <typename Value_Type, typename... Types>\ninline void myprintf(const char* str, const Value_Type& val, const Types&... args) {\n    while (*str) {\n        if (*str == '%' && *(++str) != '%') {  // 遇到控制符号了\n            cout << val;\n            myprintf(++str, args...);\n            return;\n        }\n        cout << *str++;\n    }\n    throw logic_error(\"extra arguments provided to myprintf\");\n}\n}  // namespace Print\n\nusing namespace Print;\nint main() {\n    myprintf(\"hello\\n\");\n\n    int* pi = new int;\n    // 但是这么模拟有一个很大的问题，就是控制符号我们没去管，但是介于只是一个简单的模拟，还是可以的\n    myprintf(\"%d %s %p %f\\n\", 15, \"This is Ace.\", pi, 3.1415926535);\n    delete pi;\n\n    return 0;\n}\n```\n\n### 打印tuple(这个例子非常巧妙)\n\n![image-20230505213553781](https://cdn.davidingplus.cn/images/2025/01/30/image-20230505213553781.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <bitset>\n#include <string>\n#include <tuple>\n\nnamespace PRINT {\n\ntemplate <int index, int max, typename... Args>\nstruct Tuple_Print {\n    inline static void print(ostream& os, const tuple<Args...>& t) {\n        os << get<index>(t) << (index + 1 != max ? \",\" : \"\");  // 如果不是最后一个就是 , 号\n        Tuple_Print<index + 1, max, Args...>::print(os, t);\n    }\n};\n\n// 递归终点\ntemplate <int max, typename... Args>\nstruct Tuple_Print<max, max, Args...> {\n    inline static void print(ostream& os, const tuple<Args...>& t) {}\n};\n\n}  // namespace PRINT\n\ntemplate <typename... Args>\ninline ostream&\noperator<<(ostream& os, const tuple<Args...>& t) {\n    os << \"[\";\n    PRINT::Tuple_Print<0, sizeof...(Args), Args...>::print(os, t);\n    return os << \"]\";\n}\n\nint main() {\n    cout << make_tuple(7.5, string(\"hello\"), bitset<16>(377), 42) << endl;\n\n    return 0;\n}\n```\n\n## 第二讲：标准库\n\n### 右值引用\n\n记住：\n\n- **左值 != 左值引用**\n- **右值 != 右值引用**\n\nLvalue：只能出现在operator = 左边\n\nRvalue：只能出现再operator = 右边\n\n**临时对象是一个右值，右值不能出现在 = 号的左边，临时对象tmp一定被当作右值!!!!!**\n\n注意copy ctor和move ctor之间的区别：\n\n![image-20230514163001551](https://cdn.davidingplus.cn/images/2025/01/30/image-20230514163001551.png)\n\n**move()：标准库提供的可以把左值变为右值的函数**\n\n**Perfect Forwarding:在途中把Vtype(buf)(右值)交给Mystring的move ctor的时候会先经过insert函数在调用move ctor，这就有一个中间传递的过程，所以如何做到Perfect Forwarding是一个非常重要的事情，确保该传递的信息不能丢失**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230514170850534.png\" alt=\"image-20230514170850534\" style=\"zoom:67%;\" />\n\nUnperfect Forwarding\n\n![image-20230514171027632](https://cdn.davidingplus.cn/images/2025/01/30/image-20230514171027632.png)\n\nPerfect Forwarding的具体实现：\n\n![image-20230516105734995](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516105734995.png)\n\n写一个 move aware class\n\n![image-20230516114646497](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516114646497.png)\n\n在 move ctor 当中，为什么要把原来的指针设为nullptr呢？(打断)\n\n**这是因为假如传入的右值对象是临时对象，临时对象的生命周期就只有这一句代码，执行完过后就会被释放，如果不打断，对于这里的string而言，就会调用析构函数把这个临时对象以及临时对象指向的区域给释放掉，因此就影响到了_data的部分，虽然这个临时对象今后不再用了，但是我们还是要把它与我们偷来的数据进行打断，并且配套的在析构函数的部分将其释放，否则会出现上面的问题**\n\nmove ctor和move asgn的测试\n\nMyString.h\n\n```c++\n#ifndef _MYSTRING_H_\n#define _MYSTRING_H_\n\nusing namespace std;\n#include <cstring>\n#include <iostream>\n#include <string>\n// 写一个 move aware class\nclass Mystring {\npublic:\n    static size_t DCtor;  // 累计 default-ctor呼叫次数\n    static size_t Ctor;   // 累计 ctor呼叫次数\n    static size_t CCtor;  // 累计 copy-ctor呼叫次数\n    static size_t CAsgn;  // 累计 copy-asgn呼叫次数\n    static size_t MCtor;  // 累计 move-ctor呼叫次数\n    static size_t MAsgn;  // 累计 move-asgn呼叫次数\n    static size_t Dtor;   // 累计 default-ctor呼叫次数\nprivate:\n    char* _data;\n    size_t _len;\n\n    void _init_data(const char* s) {\n        _data = new char[_len + 1];\n        memcpy(_data, s, _len);  // 这是一个深拷贝\n        _data[_len] = '\\0';\n    }\n\npublic:\n    // default-ctor\n    Mystring() : _data(nullptr), _len(0) { ++DCtor; }\n\n    // ctor\n    Mystring(const char* p) : _len(strlen(p)) {\n        ++Ctor;\n        _init_data(p);\n    }\n\n    // copy-ctor\n    Mystring(const Mystring& str) : _len(str._len) {\n        ++CCtor;\n        _init_data(str._data);\n    }\n\n    // copy-asgn\n    Mystring& operator=(const Mystring& str) {\n        ++CAsgn;\n        // 自我赋值检查\n        if (this != &str) {\n            _len = str._len;\n            _init_data(str._data);\n        } else\n            throw invalid_argument(\"cannot assign yourself.\");\n        return *this;\n    }\n\n    // move ctor, with noexcept\n    Mystring(Mystring&& str) noexcept : _data(str._data), _len(str._len) {  // 指针相同表示指向同一块内存，就是一个偷的动作，是浅拷贝!!!\n        // 完事之后将原来的str处理一下，能够传入右值引用都表示今后这个东西不用了\n        // 所以不用了，但是也不要删除掉\n        ++MCtor;\n        str._len = 0;\n        str._data = nullptr;  // 重要!!!\n    }\n\n    // move asgn, with noexcept\n    Mystring& operator=(Mystring&& str) {\n        ++MAsgn;\n        // 自我赋值检查\n        if (this != &str) {\n            _data = str._data;\n            _len = str._len;\n\n            str._len = 0;\n            str._data = nullptr;\n        }\n        return *this;\n    }\n\n    // dtor\n    virtual ~Mystring() {\n        ++DCtor;\n        if (_data)\n            delete _data;\n    }\n\n    // operator <\n    bool operator<(const Mystring& rhs) const {  // 为了set\n        return string(this->_data) < string(rhs._data);\n    }\n\n    // operator ==\n    bool operator==(const Mystring& rhs) const {  // 为了set\n        return string(this->_data) == string(rhs._data);\n    }\n\n    char* get() const { return _data; }\n};\n\n// 初始化静态变量\nsize_t Mystring::DCtor = 0;  // 累计 default-ctor呼叫次数\nsize_t Mystring::Ctor = 0;   // 累计 ctor呼叫次数\nsize_t Mystring::CCtor = 0;  // 累计 copy-ctor呼叫次数\nsize_t Mystring::CAsgn = 0;  // 累计 copy-asgn呼叫次数\nsize_t Mystring::MCtor = 0;  // 累计 move-ctor呼叫次数\nsize_t Mystring::MAsgn = 0;  // 累计 move-asgn呼叫次数\nsize_t Mystring::Dtor = 0;   // 累计 default-ctor呼叫次数\n\n// 处理hashcode 放在std中和标准库合并\nnamespace std {\ntemplate <>\nstruct hash<Mystring> {\n    size_t operator()(const Mystring& s) {\n        return hash<string>()(string(s.get()));\n    }\n};\n}  // namespace std\n\n#endif\n```\n\nMyStrNoMove.h\n\n```c++\n#ifndef _MYSTRNOMOVE_H_\n#define _MYSTRNOMOVE_H_\n\nusing namespace std;\n#include <cstring>\n#include <iostream>\n#include <string>\n\nclass MyStrNoMove {\n    // 拿掉move ctor和 move asgn\npublic:\n    static size_t DCtor;  // 累计 default-ctor呼叫次数\n    static size_t Ctor;   // 累计 ctor呼叫次数\n    static size_t CCtor;  // 累计 copy-ctor呼叫次数\n    static size_t CAsgn;  // 累计 copy-asgn呼叫次数\n    static size_t MCtor;  // 累计 move-ctor呼叫次数\n    static size_t MAsgn;  // 累计 move-asgn呼叫次数\n    static size_t Dtor;   // 累计 default-ctor呼叫次数\nprivate:\n    char* _data;\n    size_t _len;\n\n    void _init_data(const char* s) {\n        _data = new char[_len + 1];\n        memcpy(_data, s, _len);  // 这是一个深拷贝\n        _data[_len] = '\\0';\n    }\n\npublic:\n    // default-ctor\n    MyStrNoMove() : _data(nullptr), _len(0) { ++DCtor; }\n\n    // ctor\n    MyStrNoMove(const char* p) : _len(strlen(p)) {\n        ++Ctor;\n        _init_data(p);\n    }\n\n    // copy-ctor\n    MyStrNoMove(const MyStrNoMove& str) : _len(str._len) {\n        ++CCtor;\n        _init_data(str._data);\n    }\n\n    // copy-asgn\n    MyStrNoMove& operator=(const MyStrNoMove& str) {\n        ++CAsgn;\n        // 自我赋值检查\n        if (this != &str) {\n            _len = str._len;\n            _init_data(str._data);\n        } else\n            throw invalid_argument(\"cannot assign yourself.\");\n        return *this;\n    }\n\n    // dtor\n    virtual ~MyStrNoMove() {\n        ++DCtor;\n        if (_data)\n            delete _data;\n    }\n\n    // operator <\n    bool operator<(const MyStrNoMove& rhs) const {  // 为了set\n        return string(this->_data) < string(rhs._data);\n    }\n\n    // operator ==\n    bool operator==(const MyStrNoMove& rhs) const {  // 为了set\n        return string(this->_data) == string(rhs._data);\n    }\n\n    char* get() const { return _data; }\n};\n\n// 初始化静态变量\nsize_t MyStrNoMove::DCtor = 0;  // 累计 default-ctor呼叫次数\nsize_t MyStrNoMove::Ctor = 0;   // 累计 ctor呼叫次数\nsize_t MyStrNoMove::CCtor = 0;  // 累计 copy-ctor呼叫次数\nsize_t MyStrNoMove::CAsgn = 0;  // 累计 copy-asgn呼叫次数\nsize_t MyStrNoMove::MCtor = 0;  // 累计 move-ctor呼叫次数\nsize_t MyStrNoMove::MAsgn = 0;  // 累计 move-asgn呼叫次数\nsize_t MyStrNoMove::Dtor = 0;   // 累计 default-ctor呼叫次数\n\n// 处理hashcode 放在std中和标准库合并\nnamespace std {\ntemplate <>\nstruct hash<MyStrNoMove> {\n    size_t operator()(const MyStrNoMove& s) {\n        return hash<string>()(string(s.get()));\n    }\n};\n}  // namespace std\n\n#endif\n```\n\ntest.h\n\n```c++\n#ifndef _TEST_H_\n#define _TEST_H_\n\n#include <ctime>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <set>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n#include \"25_MyStrNoMove.h\"\n#include \"25_Mystring.h\"\n\nnamespace Test {\n//--------------------------------------------------------\ntemplate <typename MyString>\nvoid output_static_data(const MyString &str) {\n    cout << typeid(str).name() << \"--\" << endl;\n    cout << \"CCtor= \" << MyString::CCtor\n         << \" MCtor= \" << MyString::MCtor\n         << \" CAsgn= \" << MyString::CAsgn\n         << \" MAsgn= \" << MyString::MAsgn\n         << \" Dtor= \" << MyString::Dtor\n         << \" Ctor= \" << MyString::Ctor\n         << \" DCtor= \" << MyString::DCtor\n         << endl;\n}\n\n// test_moveable\ntemplate <typename M, typename NM>\nvoid test_moveable(M c1, NM c2, long &value) {\n    char buf[10];\n\n    // 测试 moveable\n    cout << \"\\ntest, with moveable elements\" << endl;\n    typedef typename iterator_traits<typename M::iterator>::value_type V1type;\n    clock_t timeStart = clock();\n    for (long i = 0; i < value; ++i) {\n        snprintf(buf, 10, \"%d\", rand());\n        auto ite = c1.end();\n        c1.insert(ite, V1type(buf));\n    }\n    cout << \"construction, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n    cout << \"size()= \" << c1.size() << endl;\n    output_static_data(*(c1.begin()));\n\n    timeStart = clock();\n    M c11(c1);\n    cout << \"copy, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n\n    timeStart = clock();\n    M c12(std::move(c1));\n    cout << \"move copy, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n\n    timeStart = clock();\n    c11.swap(c12);\n    cout << \"swap, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n\n    // 测试 non-moveable\n    cout << \"\\ntest, with non-moveable elements\" << endl;\n    typedef typename iterator_traits<typename NM::iterator>::value_type V2type;\n    timeStart = clock();\n    for (long i = 0; i < value; ++i) {\n        snprintf(buf, 10, \"%d\", rand());\n        auto ite = c2.end();\n        c2.insert(ite, V2type(buf));\n    }\n\n    cout << \"construction, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n    cout << \"size()= \" << c2.size() << endl;\n    output_static_data(*(c2.begin()));\n\n    timeStart = clock();\n    NM c21(c2);\n    cout << \"copy, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n\n    timeStart = clock();\n    NM c22(std::move(c2));\n    cout << \"move copy, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n\n    timeStart = clock();\n    c21.swap(c22);\n    cout << \"swap, milli-seconds : \" << double(clock() - timeStart) / 1000 << endl;\n}\n//--------------------------------------------------------\n\n// 将标识位 清0\nvoid clear() {\n    Mystring::DCtor = 0;\n    Mystring::Ctor = 0;\n    Mystring::CCtor = 0;\n    Mystring::CAsgn = 0;\n    Mystring::MCtor = 0;\n    Mystring::MAsgn = 0;\n    Mystring::Dtor = 0;\n\n    MyStrNoMove::DCtor = 0;\n    MyStrNoMove::Ctor = 0;\n    MyStrNoMove::CCtor = 0;\n    MyStrNoMove::CAsgn = 0;\n    MyStrNoMove::MCtor = 0;\n    MyStrNoMove::MAsgn = 0;\n    MyStrNoMove::Dtor = 0;\n}\n\n// test_vector\nvoid test_vector(long &value) {\n    cout << \"\\ntest_vector().......... \\n\";\n    test_moveable(vector<Mystring>(), vector<MyStrNoMove>(), value);\n    cout << endl;\n}\n\n// test_list\nvoid test_list(long &value) {\n    cout << \"\\ntest_list().......... \\n\";\n    test_moveable(list<Mystring>(), list<MyStrNoMove>(), value);\n    cout << endl;\n}\n\n// test_deque\nvoid test_deque(long &value) {\n    cout << \"\\ntest_deque().......... \\n\";\n    test_moveable(deque<Mystring>(), deque<MyStrNoMove>(), value);\n    cout << endl;\n}\n\n// test_multiset\nvoid test_multiset(long &value) {\n    cout << \"\\ntest_multiset().......... \\n\";\n    test_moveable(multiset<Mystring>(), multiset<MyStrNoMove>(), value);\n    cout << endl;\n}\n\n// test_unordered_multiset\n// void test_unordered_multiset(long &value) {\n//     cout << \"\\ntest_unordered_multiset().......... \\n\";\n//     test_moveable(unordered_multiset<Mystring>(), unordered_multiset<MyStrNoMove>(), value);\n//     cout << endl;\n// }\n}  // namespace Test\n\n#endif\n```\n\nmain.cpp\n\n```c++\n#include <iostream>\nusing namespace std;\n#include \"25_MyStrNoMove.h\"\n#include \"25_Mystring.h\"\n#include \"25_test.h\"\n\nint main() {\n    long value = 3 * 10e5;\n\n    Test::test_vector(value);\n    Test::clear();\n\n    Test::test_list(value);\n    Test::clear();\n\n    Test::test_deque(value);\n    Test::clear();\n\n    Test::test_multiset(value);\n    Test::clear();\n\n    // Test::test_unordered_multiset(value);\n    // Test::clear();\n\n    return 0;\n}\n```\n\n执行结果：\n\n![image-20230516165803938](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516165803938.png)\n\n### 适配器 Adapter 补充\n\n#### X适配器：ostream_iterator\n\n可以用来连接 cout\n\n![image-20230516203937375](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516203937375.png)\n\n```c++\n#include <algorithm>  //std::copy\n#include <iostream>   //std::cout\n#include <iterator>   //std::ostream_iterator\n#include <vector>     //std::vector\n\nint main() {\n    std::vector<int> v;\n    for (int i = 0; i < 10; ++i) v.push_back(i * 10);\n\n    std::ostream_iterator<int> out_it(std::cout, \",\");\n    std::copy(v.begin(), v.end(), out_it);\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n\n#### istream_iterator\n\n可以用来连接 cin\n\n![image-20230516205607537](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516205607537.png)\n\n```c++\n#include <iostream>  //std::cin std::cout\n#include <iterator>  //std::istream_iterator\n\nint main() {\n    double value1, value2;\n    std::cout << \"Please,insert two values: \";\n    std::istream_iterator<double> eos;             // end-of-stream iterator\n    std::istream_iterator<double> iter(std::cin);  // stdin iterator\n\n    if (iter != eos)\n        value1 = *iter;\n    ++iter;\n    if (iter != eos)\n        value2 = *iter;\n\n    std::cout << value1 << \" * \" << value2 << \" == \" << value1 * value2 << std::endl;\n\n    return 0;\n}\n```\n\n#### type traits\n\n![image-20230516212207244](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516212207244.png)\n\n以前的版本由于标准的限制，最好写自定义类的时候也要带上这个 __type_traits<>\n\nC++2.0 新版本\n\n**trivial 不重要的**\n**POD plain old data 平淡的旧风格的，指的就是C风格的，也就是只有成员变量没有成员方法**\n\n![image-20230516221129783](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221129783.png)\n\n![image-20230516221225536](https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221225536.png)\n\ntype traits 测试\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230516221737119.png\" alt=\"image-20230516221737119\" style=\"zoom:67%;\" />\n\ntype_traits 实现 is_void(了解)\n\n![image-20230517141545661](https://cdn.davidingplus.cn/images/2025/01/30/image-20230517141545661.png)\n\n```C++\n#include <iostream>\nusing namespace std;\n#include <type_traits>\n\n// my_isVoid 简单版本\ntemplate <class Value_Type>\nstruct my_isVoid : public false_type {};\n\n// 特化版本\ntemplate <>\nstruct my_isVoid<void> : public true_type {};\n\nint main() {\n    cout << my_isVoid<int>::value << endl;\n    cout << my_isVoid<void>::value << endl;\n\n    return 0;\n}\n```\n\n# 内存管理\n\n## 第一讲：primitives\n\n### c++应用程序\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230518140540645.png\" alt=\"image-20230518140540645\" style=\"zoom:67%;\" />\n\n#### c++内存的基本工具\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230518140911306.png\" alt=\"image-20230518140911306\" style=\"zoom:50%;\" />\n\n测试程序：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <complex>\n#include <ext/pool_allocator.h>\n\nint main() {\n    // 三种使用方法\n    void* p1 = malloc(512);  // 512 bytes\n    cout << p1 << endl;\n    free(p1);\n\n    complex<int>* p2 = new complex<int>;\n    cout << p2 << endl;\n    delete p2;\n\n    void* p3 = ::operator new(512);  // 512 bytes\n    cout << p3 << endl;\n    ::operator delete(p3);\n\n// 以下使用 C++ 标准库提供的 allocators。\n// 虽然接口都有标准规格，但是调用方式略有区别\n#ifdef _MSC_VER\n    // 以下兩函數都是 non-static，定要通過 object 調用。以下分配 3 個 ints.\n    int* p4 = allocator<int>().allocate(3, (int*)0);\n    allocator<int>().deallocate(p4, 3);\n#endif\n\n#ifdef __BORLANDC__\n    // 以下兩函數都是 non-static，定要通過 object 調用。以下分配 5 個 ints.\n    int* p4 = allocator<int>().allocate(5);\n    allocator<int>().deallocate(p4, 5);\n#endif\n\n//调用这一个\n#ifdef __GNUC__\n    // 以下兩函數都是 static，可通過全名調用之。以下分配 512 bytes.\n    // void* p4 = alloc::allocate(512);\n    // alloc::deallocate(p4, 512);\n\n    // 以下兩函數都是 non-static，定要通過 object 調用。以下分配 7 個 ints.\n    void* p4 = allocator<int>().allocate(7);\n    cout << p4 << endl;\n    allocator<int>().deallocate((int*)p4, 7);\n\n    // 以下兩函數都是 non-static，定要通過 object 調用。以下分配 9 個 ints.\n    void* p5 = __gnu_cxx::__pool_alloc<int>().allocate(9);\n    cout << p5 << endl;\n    __gnu_cxx::__pool_alloc<int>().deallocate((int*)p5, 9);\n#endif\n\n    return 0;\n}\n```\n\n### new expression\n\n使用new关键字之后编译器会把这串代码翻译为如下：\n\n![image-20230518143501227](https://cdn.davidingplus.cn/images/2025/01/30/image-20230518143501227.png)\n\n**new关键字使用之后重要的就执行了两步，第一步是分配内存，第二步是调用构造函数**\n\n#### delete expression\n\n与new相对应的就有delete关键字\n\n**delete关键字使用的时候执行了两步，第一步是调用析构函数，第二步是释放内存**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230518150122803.png\" alt=\"image-20230518150122803\" style=\"zoom:67%;\" />\n\n上面两副图片当中，**通过指针，构造函数不能被直接调用，而析构函数可以被直接调用**\n\n**如果非要调用的话，可以用 placement new** (现在不理解什么意思)\n\n```c++\nnew(p) Complex(1,2);\n```\n\n以下是一个测试程序：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <string>\n\nclass A {\npublic:\n    A() = default;\n    A(int id) : _id(id) { cout << \"ctor. this = \" << this << \" id = \" << id << endl; }\n    ~A() { cout << \"dtor. this = \" << this << endl; }\n\n    int _id;\n};\n\nint main() {\n    string* pstr = new string;\n    cout << \"str= \" << *pstr << endl;\n\n    // pstr->string::string(\"hello\");  // ‘class std::__cxx11::basic_string<char>’ has no member named ‘string’\n    // pstr->~string();//crash\n\n    cout << \"str= \" << *pstr << endl;\n\n    A* pA = new A(1);\n    cout << pA->_id << endl;  // 1\n\n    // pA->A::A(3);//cannot call constructor ‘A::A’ directly\n    // A::A(5);\n\n    cout << pA->_id << endl;\n\n    delete pA;\n\n    return 0;\n}\n```\n\n### array new,array delete\n\n注意：array new 一定要搭配 array delete，否则就极容易发生内存泄漏\n\n**这个内存泄露对于尤其是class with pointers，通常带有影响**\n\n因为对于没有指针的类，只需要释放这个类对象的指针就可以了，因此调用一次和三次的dtor没有明显的区别，换句话说就是这个类的dtor是trivial(不重要的)，但是带有指针的类就不一样了\n\n比如下面string那个例子，只换起一次dtor，那么三个string指向的东西只被释放了一个，然后整体就被释放了，剩余的两块内存怎么办呢？因此会导致内存泄漏\n\n![image-20230518154018869](https://cdn.davidingplus.cn/images/2025/01/30/image-20230518154018869.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n#define size 3\n\nclass A {\npublic:\n    A() : _id(0) { cout << \"default ctor. this = \" << this << \" id = \" << _id << endl; }\n    A(int id) : _id(id) { cout << \"ctor. this = \" << this << \" id = \" << _id << endl; }\n    ~A() { cout << \"dtor. this = \" << this << \" id = \" << _id << endl; }\n\npublic:\n    int _id;\n};\n\nint main() {\n    A* buf = new A[size];  // A必须有默认构造函数，否则会报错\n    A* tmp = buf;\n\n    cout << \"buf= \" << buf << \" tmp= \" << tmp << endl;\n\n    for (int i = 0; i < size; ++i)\n        new (tmp++) A(i);  // placement new , ctor 三次\n\n    cout << \"buf= \" << buf << \" tmp= \" << tmp << endl;\n\n    delete[] buf;  // dtor 3次，次序反过来 3 2 1\n\n    return 0;\n}\n```\n\n执行结果\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230518160118276.png\" alt=\"image-20230518160118276\" style=\"zoom:67%;\" />\n\n#### 内存分布\n\n内存的底层开辟和释放都是调用的malloc和free，那么调用了malloc之后会给我们的内存分布就如下所示：\n\n![image-20230518161942376](https://cdn.davidingplus.cn/images/2025/01/30/image-20230518161942376.png)\n\n可以浅谈一下这个内存是怎么分配的(后面都会进行深入的探究，以及每一块的作用)\n\n**Demo对象：3个int，占据12个字节，3个总共36个字节；**\n\n**由于他带有指针，所以需要额外记录这个数组对象包含Demo的个数，4个字节；**\n\n**这个真正有效的数据区域上下(黄色的部分)，分别占据32 + 4 个字节；**\n\n**内存块上下的两个cookie，各自4个字节，总共8个字节；**\n\n**上面一共加起来84个字节，需要调整到16个字节的倍数，也就是96个字节，多出的12个字节存放在Pad中**\n\n### placement new\n\n**placement new允许我们将对象建造在已经分配好的内存当中！！**\n\n![image-20230518163205880](https://cdn.davidingplus.cn/images/2025/01/30/image-20230518163205880.png)\n\n**编译器翻译成为的那三个操作，在 placement new 下面，第一条由于传入了一个指针，那么会调用重载的版本，其实就是表示不用新开内存，把原来的给我就行；然后第三条编译器就调用构造函数在已有的内存上进行创建对象初始化!!!!**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Complex {\npublic:\n    Complex() : _re(0), _im(0) {}\n    Complex(double re, double im) : _re(re), _im(im) {}\n\npublic:\n    double _re, _im;\n};\n\nint main() {\n    char* buf = new char[sizeof(Complex) * 3];\n    // 现在想把一个Complex对象动态开辟在buf的一个Complex单元，调用placement new\n    Complex* pc = new (buf) Complex(1, 2);\n\n    delete[]buf;\n    \n    return 0;\n}\n```\n\n#### 重载\n\n![image-20230518164140667](https://cdn.davidingplus.cn/images/2025/01/30/image-20230518164140667.png)\n\n**重载比较多的就是在类中去重载 operator new和 operator delete，这样编译器在调用new或者delete关键字解析到那两步的时候就会优先调用我们重载的版本，在我们重载的版本当中可以设计一些专用于这个类的设计，这样或许能够提高效率和节省开销**\n\n在类里面重载\n\n![image-20230518170044346](https://cdn.davidingplus.cn/images/2025/01/30/image-20230518170044346.png)\n\n ![image-20230518171104774](https://cdn.davidingplus.cn/images/2025/01/30/image-20230518171104774.png)\n\ndelete中的第二参数是optional的，可以写也可以不写\n\n#### 重载示例\n\n在类当中进行简单的重载，和全局的输出做对比\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <string>\n\nclass Foo\n{\npublic:\n    int _id;\n\npublic:\n    Foo() : _id(0) { cout << \"default ctor.this = \" << this << \" id = \" << _id << endl; }\n    Foo(int id) : _id(id) { cout << \"ctor.this = \" << this << \" id = \" << _id << endl; }\n\n    // virtual\n    virtual ~Foo() { cout << \"dtor.this = \" << this << \" id = \" << _id << endl; }\n\n    static void *operator new(size_t size);\n    static void operator delete(void *ptr, size_t size);\n    static void *operator new[](size_t size);\n    static void operator delete[](void *ptr, size_t size);\n};\n\nvoid *Foo::operator new(size_t size)\n{\n    Foo *p = static_cast<Foo *>(malloc(size));\n    cout << \"Foo::operator new(), size = \" << size << \"\\treturn : \" << p << endl;\n    return p;\n}\n\nvoid Foo::operator delete(void *ptr, size_t size)\n{\n    cout << \"Foo::operator delete(), ptr = \" << ptr << \"\\tsize = \" << size << endl;\n    free(ptr);\n}\n\nvoid *Foo::operator new[](size_t size)\n{\n    Foo *p = static_cast<Foo *>(malloc(size));\n    cout << \"Foo::operator new[](), size = \" << size << \"\\treturn : \" << p << endl;\n    return p;\n}\n\nvoid Foo::operator delete[](void *ptr, size_t size)\n{\n    cout << \"Foo::operator delete[](), ptr = \" << ptr << \"\\tsize = \" << size << endl;\n    free(ptr);\n}\n\nint main()\n{\n    cout << \"sizeof(Foo) = \" << sizeof(Foo) << endl\n         << endl;\n\n    cout << \"Foo------------------------------------------------------------\" << endl;\n\n    Foo *p = new Foo;\n    delete p;\n\n    cout << endl;\n\n    Foo *pArray = new Foo[5]{1, 2, 3, 4, 5};\n    delete[] pArray;\n\n    cout << endl\n         << \"Global------------------------------------------------------------\" << endl;\n\n    Foo *p2 = ::new Foo;\n    ::delete p2;\n\n    cout << endl;\n\n    Foo *pArray2 = ::new Foo[5]{1, 2, 3, 4, 5};\n    ::delete[] pArray2;\n\n    return 0;\n}\n```\n\n输出结果：\n\n![image-20230528130010432](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528130010432.png)\n\n**注意：**\n\n我们可以重载class member operator new()，可以写出多个版本，前提是每一个版本都必须声明独特的参数列，并且第一个参数是size_t，其余参数以new指定的placement arguments为初值，出现在new(...)当中的就是所谓的placement arguments.\n\n这样就可以写出很多的placement new.\n\n例如：\n\n```c++\nvoid * Foo::operator new(size_t size,long extra,char ch);\n//这么用\nFoo* pf=new(300,'c') Foo;\n```\n\n测试代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <string>\n\nclass Bad\n{\n};\n\nclass Foo\n{\npublic:\n    Foo() { cout << \"Foo::Foo()\" << endl; }\n    Foo(int)\n    {\n        cout << \"Foo::Foo(int)\" << endl;\n        throw Bad(); // 故意在这里抛出异常，测试调用placement operator delete\n    }\n\n    //(1) 這個就是一般的 operator new() 的重載\n    void *operator new(size_t size)\n    {\n        cout << \"operator new(size_t size), size= \" << size << endl;\n        return malloc(size);\n    }\n\n    //(2) 這個就是標準庫已經提供的 placement new() 的重載 (形式)\n    //    (所以我也模擬 standard placement new 的動作, just return ptr)\n    void *operator new(size_t size, void *start)\n    {\n        cout << \"operator new(size_t size, void* start), size= \" << size << \"  start= \" << start << endl;\n        return start;\n    }\n\n    //(3) 這個才是嶄新的 placement new\n    void *operator new(size_t size, long extra)\n    {\n        cout << \"operator new(size_t size, long extra)  \" << size << ' ' << extra << endl;\n        return malloc(size + extra);\n    }\n\n    //(4) 這又是一個 placement new\n    void *operator new(size_t size, long extra, char init)\n    {\n        cout << \"operator new(size_t size, long extra, char init)  \" << size << ' ' << extra << ' ' << init << endl;\n        return malloc(size + extra);\n    }\n\n    //(5) 這又是一個 placement new, 但故意寫錯第一參數的 type (它必須是 size_t 以滿足正常的 operator new)\n    //!  \tvoid* operator new(long extra, char init) { //[Error] 'operator new' takes type 'size_t' ('unsigned int') as first parameter [-fpermissive]\n    //!\t  \tcout << \"op-new(long,char)\" << endl;\n    //!    \treturn malloc(extra);\n    //!  \t}\n\n    // 以下是搭配上述 placement new 的各個 called placement delete.\n    // 當 ctor 發出異常，這兒對應的 operator (placement) delete 就會被喚起.\n    // 應該是要負責釋放其搭檔兄弟 (placement new) 分配所得的 memory.\n    //(1) 這個就是一般的 operator delete() 的重載\n    void operator delete(void *, size_t)\n    {\n        cout << \"operator delete(void*,size_t)  \" << endl;\n    }\n\n    //(2) 這是對應上述的 (2)\n    void operator delete(void *, void *)\n    {\n        cout << \"operator delete(void*,void*)  \" << endl;\n    }\n\n    //(3) 這是對應上述的 (3)\n    void operator delete(void *, long)\n    {\n        cout << \"operator delete(void*,long)  \" << endl;\n    }\n\n    //(4) 這是對應上述的 (4)\n    // 如果沒有一一對應, 也不會有任何編譯報錯\n    void operator delete(void *, long, char)\n    {\n        cout << \"operator delete(void*,long,char)  \" << endl;\n    }\n\nprivate:\n    int m_i;\n};\n\n//-------------\nvoid test_overload_placement_new()\n{\n    cout << \"test_overload_placement_new()..........\" << endl;\n\n    Foo start; // Foo::Foo\n\n    Foo *p1 = new Foo;            // op-new(size_t)\n    Foo *p2 = new (&start) Foo;   // op-new(size_t,void*)\n    Foo *p3 = new (100) Foo;      // op-new(size_t,long)\n    Foo *p4 = new (100, 'a') Foo; // op-new(size_t,long,char)\n\n    Foo *p5 = new (100) Foo(1);      // op-new(size_t,long)  op-del(void*,long)\n    //这里故意调用int版本的构造函数，在构造函数当中会抛出异常\n    //为什么会抛出异常呢？因为我们担心这个placement operator new 我们已经分配出来的空间用在构造函数上面不够\n    //不够的时候怎么办呢？内存都已经分配出来了，那就只能释放掉，调用相应的placement operator delete\n    Foo *p6 = new (100, 'a') Foo(1); //\n    Foo *p7 = new (&start) Foo(1);   //\n    Foo *p8 = new Foo(1);            //\n                                     // VC6 warning C4291: 'void *__cdecl Foo::operator new(unsigned int)'\n                                     // no matching operator delete found; memory will not be freed if\n                                     // initialization throws an exception\n}\n\nint main()\n{\n    test_overload_placement_new();\n\n    return 0;\n}\n```\n\n**注意这里：**\n\n```C++\nFoo *p5 = new (100) Foo(1);\n//这里故意调用int版本的构造函数，在构造函数当中会抛出异常\n//为什么会抛出异常呢？因为我们担心这个placement operator new 我们已经分配出来的空间用在构造函数上面不够\n//不够的时候怎么办呢？内存都已经分配出来了，那就只能释放掉，调用相应的placement operator delete\n```\n\n**只有这种情况下，ctor中抛出异常，对应的operator delete才会被调用起来；如果不写，那就是放心这个构造函数并且不去处理这个异常**\n\n#### basic_string使用new(extra)申请扩充量\n\n![image-20230528141445828](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528141445828.png)\n\n### per-class allocator 版本1 (重点看)\n\n设计一个小型的内存池，小型的内存分配器，目前是第一版本\n\n![image-20230528144912141](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528144912141.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Screen\n{\npublic:\n    Screen() = default;\n    Screen(int x) : _i(x){};\n    int get() const { return _i; }\n\n    inline void *operator new(size_t);\n    inline void operator delete(void *, size_t);\n\nprivate:\n    Screen *next; // 这种设计会引发一个疑问，就是多消耗了一个指针的内存空间，但是可以抹除数组元素之间的cookie，只在数组头尾放cookie\n    static Screen *freeStore;\n    static const int screenChunk;\n\nprivate:\n    int _i;\n};\nScreen *Screen::freeStore = nullptr;\nconst int Screen::screenChunk = 24;\n\nvoid *Screen::operator new(size_t size)\n{\n    Screen *p;\n    if (!freeStore)\n    {\n        // linked list 是空的，所以攫取一大塊 memory\n        // 以下呼叫的是 global operator new\n        size_t chunk = screenChunk * size; // 这是乘法，计算需要的字节数\n        freeStore = p =\n            reinterpret_cast<Screen *>(new char[chunk]);\n        // 將分配得來的一大塊 memory 當做 linked list 般小塊小塊串接起來\n        for (; p != &freeStore[screenChunk - 1]; ++p)\n            p->next = p + 1;\n        p->next = 0;\n    }\n    p = freeStore;\n    freeStore = freeStore->next;\n    return p;\n}\n\n//! void Screen::operator delete(void *p)\t\t//(1)\nvoid Screen::operator delete(void *p, size_t) //(2)二擇一\n{\n    // 將 deleted object 收回插入 free list 前端\n    (static_cast<Screen *>(p))->next = freeStore;\n    freeStore = static_cast<Screen *>(p);\n}\n\n//-------------\nvoid test_per_class_allocator_1()\n{\n    cout << \"test_per_class_allocator_1().......... \\n\";\n\n    cout << sizeof(Screen) << endl; // 8\n\n    size_t const N = 100;\n    Screen *p[N];\n\n    for (int i = 0; i < N; ++i)\n        p[i] = new Screen(i);\n\n    // 輸出前 10 個 pointers, 用以比較其間隔\n    for (int i = 0; i < 10; ++i)\n        cout << p[i] << endl;\n\n    for (int i = 0; i < N; ++i)\n        delete p[i];\n}\n\nvoid test_global_allocator()\n{\n    cout << \"test_global_allocator().......... \\n\";\n\n    cout << sizeof(Screen) << endl; // 8\n\n    size_t const N = 100;\n    Screen *p[N];\n\n    for (int i = 0; i < N; ++i)\n        p[i] = ::new Screen(i);\n\n    // 輸出前 10 個 pointers, 用以比較其間隔\n    for (int i = 0; i < 10; ++i)\n        cout << p[i] << endl;\n\n    for (int i = 0; i < N; ++i)\n        ::delete p[i];\n}\n\nint main()\n{\n    test_per_class_allocator_1();\n    cout << endl\n         << endl;\n    test_global_allocator();\n\n    return 0;\n}\n```\n\n执行结果：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230528145254800.png\" alt=\"image-20230528145254800\" style=\"zoom:67%;\" />\n\n可以看出，设计之后的内存之间没有了cookie，节省了空间，这就是我们自己的一个小型内存池\n\n#### per-class allocator2 版本2\n\n**和前面的思路基本一样：就是要一大块内存，当数组形式要进来分配内存的时候，如果这一大块内存还有空间，就链在后面就行；如果没有了，就要再要一大块空间进行同样的操作就可以了，最后在前后加上cookie就可以了。而这一切的发生都必须依赖于静态变量static headOfFreeList!!!!他在整个程序中只有一份，当然可以标识。**\n\n![image-20230528150844128](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528150844128.png)\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Airplane {  // 支援 customized memory management\nprivate:\n    struct AirplaneRep {\n        unsigned long miles;\n        char type;\n    };\n\nprivate:\n    union {\n        AirplaneRep rep;  // 此針對 used object\n        Airplane *next;   // 此針對 free list\n    };\n\npublic:\n    unsigned long getMiles() { return rep.miles; }\n    char getType() { return rep.type; }\n    void set(unsigned long m, char t) {\n        rep.miles = m;\n        rep.type = t;\n    }\n\npublic:\n    static void *operator new(size_t size);\n    static void operator delete(void *deadObject, size_t size);\n\nprivate:\n    static const int BLOCK_SIZE;\n    static Airplane *headOfFreeList;\n};\n\nAirplane *Airplane::headOfFreeList;\nconst int Airplane::BLOCK_SIZE = 512;\n\nvoid *Airplane::operator new(size_t size) {\n    // 如果大小錯誤，轉交給 ::operator new()\n    if (size != sizeof(Airplane))\n        return ::operator new(size);\n\n    Airplane *p = headOfFreeList;\n\n    // 如果 p 有效，就把list頭部移往下一個元素\n    if (p)\n        headOfFreeList = p->next;\n    else {\n        // free list 已空。配置一塊夠大記憶體，\n        // 令足夠容納 BLOCK_SIZE 個 Airplanes\n        Airplane *newBlock = static_cast<Airplane *>(::operator new(BLOCK_SIZE * sizeof(Airplane)));\n        // 組成一個新的 free list：將小區塊串在一起，但跳過\n        // #0 元素，因為要將它傳回給呼叫者。\n        for (int i = 1; i < BLOCK_SIZE - 1; ++i)\n            newBlock[i].next = &newBlock[i + 1];\n        newBlock[BLOCK_SIZE - 1].next = 0;  // 以null結束\n\n        // 將 p 設至頭部，將 headOfFreeList 設至\n        // 下一個可被運用的小區塊。\n        p = newBlock;\n        headOfFreeList = &newBlock[1];\n    }\n    return p;\n}\n\n// operator delete 接獲一塊記憶體。\n// 如果它的大小正確，就把它加到 free list 的前端\nvoid Airplane::operator delete(void *deadObject,\n                               size_t size) {\n    if (deadObject == 0)\n        return;\n    if (size != sizeof(Airplane)) {\n        ::operator delete(deadObject);\n        return;\n    }\n\n    Airplane *carcass =\n        static_cast<Airplane *>(deadObject);\n\n    carcass->next = headOfFreeList;\n    headOfFreeList = carcass;\n}\n\n//-------------\nvoid test_per_class_allocator_2() {\n    cout << \"test_per_class_allocator_2().......... \\n\";\n\n    cout << sizeof(Airplane) << endl;  // 8\n\n    size_t const N = 100;\n    Airplane *p[N];\n\n    for (int i = 0; i < N; ++i)\n        p[i] = new Airplane;\n\n    // 隨機測試 object 正常否\n    p[1]->set(1000, 'A');\n    p[5]->set(2000, 'B');\n    p[9]->set(500000, 'C');\n    cout << p[1] << ' ' << p[1]->getType() << ' ' << p[1]->getMiles() << endl;\n    cout << p[5] << ' ' << p[5]->getType() << ' ' << p[5]->getMiles() << endl;\n    cout << p[9] << ' ' << p[9]->getType() << ' ' << p[9]->getMiles() << endl;\n\n    // 輸出前 10 個 pointers, 用以比較其間隔\n    for (int i = 0; i < 10; ++i)\n        cout << p[i] << endl;\n\n    for (int i = 0; i < N; ++i)\n        delete p[i];\n}\n\nvoid test_global_allocator() {\n    cout << \"test_global_allocator().......... \\n\";\n\n    cout << sizeof(Airplane) << endl;  // 8\n\n    size_t const N = 100;\n    Airplane *p[N];\n\n    for (int i = 0; i < N; ++i)\n        p[i] = ::new Airplane;\n\n    // 隨機測試 object 正常否\n    p[1]->set(1000, 'A');\n    p[5]->set(2000, 'B');\n    p[9]->set(500000, 'C');\n    cout << p[1] << ' ' << p[1]->getType() << ' ' << p[1]->getMiles() << endl;\n    cout << p[5] << ' ' << p[5]->getType() << ' ' << p[5]->getMiles() << endl;\n    cout << p[9] << ' ' << p[9]->getType() << ' ' << p[9]->getMiles() << endl;\n\n    // 輸出前 10 個 pointers, 用以比較其間隔\n    for (int i = 0; i < 10; ++i)\n        cout << p[i] << endl;\n\n    for (int i = 0; i < N; ++i)\n        ::delete p[i];\n}\n\nint main() {\n    test_per_class_allocator_2();\n    cout << endl\n         << endl;\n    test_global_allocator();\n\n    return 0;\n}\n```\n\n执行结果：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230528151704324.png\" alt=\"image-20230528151704324\" style=\"zoom:67%;\" />\n\n**但是这个设计有一个问题，就是你一次性拿了很多的内存，假如剩下的空白内存还很多的话，在释放的时候理应将他们还给内存，但是在上面的operator delete当中并没有将其归还给操作系统，这样不能说好也不能说不好。首先就是归还这个技术操作太难了，其次就是虽然我没有归还，但是我也没有发生内存泄漏啊，这一段内存还是在我的手上，只是被归入了freeList当中而已。**\n\n#### static allocator 版本3\n\n上面的内存分配的设计对于某个指定的类是非常有效果的，但是我们不可能对于每一个类都这么干吧，所以我们需要找到一个普遍的设计方法来解决这个问题。\n\n所以我们把上面的操作(挖一大块内存......)封装成为一个类，这个类就叫做allocator\n\n![image-20230528152603160](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528152603160.png)\n\nstatic allocator具体可以在类里面就这么用，内存管理复杂的方面就交给这个类去管理了，不用我们对每一个类都特殊处理\n\n![image-20230528153147163](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528153147163.png)\n\n**注意一点就是，static变量需要在类外初始化或者定义，如图就是类外的定义。**\n\n那么allocator里面具体干什么呢？回顾一下\n\n![image-20230528153255732](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528153255732.png)\n\n测试代码：\n\n```C++\n#include <complex>\n#include <iostream>\nusing namespace std;\n#include \"__allocator.h\"\n\n// macro 宏\n#define DECLARE_POOL_ALLOC()                                           \\\npublic:                                                                \\\n    void *operator new(size_t size) { return myAlloc.allocate(size); } \\\n    void operator delete(void *p) { myAlloc.deallocate(p, 0); }        \\\n                                                                       \\\nprotected:                                                             \\\n    static __allocator myAlloc;\n\n#define IMPLEMENT_POOL_ALLOC(class_name) \\\n    __allocator class_name::myAlloc;\n\nclass Foo {\n    DECLARE_POOL_ALLOC()\npublic:\n    long L;\n    string str;\n\npublic:\n    Foo(long l) : L(l) {}\n};\n// in class implementation file\nIMPLEMENT_POOL_ALLOC(Foo)\n\n//  in class definition file\nclass Goo {\n    DECLARE_POOL_ALLOC()\npublic:\n    complex<double> c;\n    string str;\n\npublic:\n    Goo(const complex<double> &x) : c(x) {}\n};\n// in class implementation file\nIMPLEMENT_POOL_ALLOC(Goo)\n\n//-------------\nvoid test_static_allocator() {\n    cout << \"test_static_allocator().......... \\n\";\n\n    {\n        cout << endl;\n        Foo *p[100];\n\n        cout << \"sizeof(Foo)= \" << sizeof(Foo) << endl;\n        for (int i = 0; i < 23; ++i) {  // 23,任意數, 隨意看看結果\n            p[i] = new Foo(i);\n            cout << p[i] << ' ' << p[i]->L << endl;\n        }\n        // Foo::myAlloc.check();\n\n        for (int i = 0; i < 23; ++i) {\n            delete p[i];\n        }\n        // Foo::myAlloc.check();\n\n        cout << endl;\n    }\n\n    {\n        cout << endl;\n        Goo *p[100];\n\n        cout << \"sizeof(Goo)= \" << sizeof(Goo) << endl;\n        for (int i = 0; i < 17; ++i) {  // 17,任意數, 隨意看看結果\n            p[i] = new Goo(complex<double>(i, i));\n            cout << p[i] << ' ' << p[i]->c << endl;\n        }\n        // Goo::myAlloc.check();\n\n        for (int i = 0; i < 17; ++i) {\n            delete p[i];\n        }\n        // Goo::myAlloc.check();\n\n        cout << endl;\n    }\n}\n\nint main() {\n    test_static_allocator();\n\n    return 0;\n}\n```\n\n执行结果：\t\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230528160530816.png\" alt=\"image-20230528160530816\" style=\"zoom:67%;\" />\n\n#### macro for static allocator 版本4 (偷懒)\n\n因为上面的static allocator的格式写的非常固定，所以我们可以想办法给他简化一下，偷偷懒\n\n用C++中的宏来替代，可以得出很多有趣的东西\n\n![image-20230528155257804](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528155257804.png)\n\n改进后的代码：\n\n```c++\n// macro 宏\n#define DECLARE_POOL_ALLOC()                                           \\\npublic:                                                                \\\n    void *operator new(size_t size) { return myAlloc.allocate(size); } \\\n    void operator delete(void *p) { myAlloc.deallocate(p, 0); }        \\\n                                                                       \\\nprotected:                                                             \\\n    static __allocator myAlloc;\n\n#define IMPLEMENT_POOL_ALLOC(class_name) \\\n    __allocator class_name::myAlloc;\n\nclass Foo {\n    DECLARE_POOL_ALLOC()\npublic:\n    long L;\n    string str;\n\npublic:\n    Foo(long l) : L(l) {}\n};\n// in class implementation file\nIMPLEMENT_POOL_ALLOC(Foo)\n\n//  in class definition file\nclass Goo {\n    DECLARE_POOL_ALLOC()\npublic:\n    complex<double> c;\n    string str;\n\npublic:\n    Goo(const complex<double> &x) : c(x) {}\n};\n// in class implementation file\nIMPLEMENT_POOL_ALLOC(Goo)\n```\n\n### global allocator 标准库的那个非常棒的alloc\n\n![image-20230528160553832](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528160553832.png)\n\n### new handler\n\n当operator new没有能力为我们分配成功我们所申请的memory的时候，会抛出异常 std::bad_alloc，我们应该要采取一些措施来应对这个\n\n如果想要编译器一定要返回0而不是抛出异常的话可以这么做:\n\n```c++\nnew(nothrow) Foo;\n```\n\n当然标准库在抛出异常之前会调用依次可以由用户指定的handler，如何设计如下所示：\n\n![image-20230528171600254](https://cdn.davidingplus.cn/images/2025/01/30/image-20230528171600254.png)\n\n这样就可以在抛出异常之前自定义一些处理操作，例如Abort()或者exit()等等\n\n设计良好的new handler有两个作用：\n\n- 让更多的内存可用\n- 调用abort()或者exit()\n\n**注意：new handler必须return void，然后没有参数**\n\n```c++\n#include <assert.h>\nusing namespace std;\n#include <iostream>\n\n// new handler必须return void，然后没有参数\nvoid noMoreMemory() {\n    cerr << \"out of memory\\n\";\n    abort();\n}\n\nvoid test_set_new_handler() {\n    cout << \"test_set_new_handler().......... \\n\";\n\n    set_new_handler(noMoreMemory);\n\n    int* p = new int[100000000000000];  // well, so BIG!\n    assert(p);\n\n    p = new int[100000000000000];  //[Warning] integer constant is too large for its type\n    assert(p);\n}\n\nint main() {\n    test_set_new_handler();\n\n    return 0;\n}\n```\n\n在这个程序当中，如果不调用abort()函数，那么程序就会卡在这一行，\n\n```c++\n int* p = new int[100000000000000];  // well, so BIG!\n```\n\n会一直输出自定义的错误信息 out of memory\n\n### =default,=delete\n\n注意：\n\n**=default 只能用default只能用在big three中，即default ctor(默认构造),copy/move asgn(拷贝/移动赋值),copy/move ctor(拷贝/移动构造),dtor(析构函数)当中，因为其他的函数编译器没有提供默认的版本**\n\n=delete 则不限\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Foo {\npublic:\n    long _x;\n\npublic:\n    Foo(long x = 0) : _x(x) {}\n\n    // 这两个东西不能default，因为编译器没有默认的版本，default只能用在big three当中，即default ctor,copy/move asgn,copy/move ctor,dtor当中\n    // static void *operator new(size_t size) = default;                 //[Error] cannot be defaulted\n    // static void operator delete(void *pdead, size_t size) = default;  //[Error] cannot be defaulted\n    static void *operator new[](size_t size) = delete;\n    static void operator delete[](void *pdead, size_t size) = delete;\n};\n\nclass Goo {\npublic:\n    long _x;\n\npublic:\n    Goo(long x = 0) : _x(x) {}\n\n    static void *operator new(size_t size) = delete;\n    static void operator delete(void *pdead, size_t size) = delete;\n};\n\nvoid test_delete_and_default_for_new() {\n    cout << \"test_delete_and_default_for_new().......... \\n\";\n\n    Foo *p1 = new Foo(5);\n    delete p1;\n    // Foo* pF = new Foo[10];\t//[Error] use of deleted function 'static void* Foo::operator new [](size_t)'\n    // delete [] pF;\t\t\t//[Error] use of deleted function 'static void Foo::operator delete [](void*, size_t)'\n\n    // Goo* p2 = new Goo(7);\t//[Error] use of deleted function 'static void* Goo::operator new(size_t)'\n    // delete p2;\t\t\t\t//[Error] use of deleted function 'static void Goo::operator delete(void*, size_t)'\n    Goo *pG = new Goo[10];\n    delete[] pG;\n}\n\nint main() {\n    test_delete_and_default_for_new();\n\n    return 0;\n}\n```\n\n## 第二讲：std::allocator\n\n### malloc\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230529203344173.png\" alt=\"image-20230529203344173\" style=\"zoom:67%;\" />\n\n**当我们调用malloc函数的时候，图当中block size的部分是真实的存放我们的数据的地方，除此之外还会有其他的东西，在上下会有两包东西分别叫debug header和debug tail(这个是什么现在不去管)，在整个部分的上下会有固定两个大小的cookie，记录这一段区块的大小(只有区块大小相同才可以去除cookie)，也就是类似于前面per-class allocator的设计，VC6是上下各四个字节共八个字节；然后他要求这个内存块必须要满足字节数是16的倍数(不同的设计可能不同)，需要有一个pad块来进行调整，整个就是malloc分配给我们的内存**\n\n### 不同版本allocator的实现\n\n不同的编译器对于分配器allocator的实现都是不一样的，下面将举几个版本的例子：\n\n#### VC6\n\n![image-20230529204213232](https://cdn.davidingplus.cn/images/2025/01/30/image-20230529204213232.png)\n\nVC6的版本里面没有做特殊设计，就是调用operator new/delete，进而调用malloc，free，没有对内存进行特殊管理\n\n#### BC5\n\n![image-20230529205010426](https://cdn.davidingplus.cn/images/2025/01/30/image-20230529205010426.png)\n\n同样BC5的版本也没有做特殊设计\n\n#### Gc2.9\n\n![image-20230529210322971](https://cdn.davidingplus.cn/images/2025/01/30/image-20230529210322971.png)\n\nGc2.9的分配器allocator也没有做特殊设计\n\n但是Gc2.9的容器使用的分配器却不是这个allocator，而是一个设计的非常好的alloc\n\n![image-20230529210616933](https://cdn.davidingplus.cn/images/2025/01/30/image-20230529210616933.png)\n\n下面将会介绍\n\n#### pool alloc(Gc4.9) 非常棒的版本\n\n以下是Gc2.9和Gc4.9对这个的实现\n\n![image-20230529211045422](https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211045422.png)\n\n![image-20230529211059007](https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211059007.png)\n\nGc4.9有很多扩充的alloctors，其中 __gnu_cxx::__pool_alloc<> 就是这个非常好的分配器\n\n调用这个非常好的分配器的时候还要引入头文件\n\n```c++\n#include <ext/pool_allocator.h>\n```\n\n**注意：Gc4.9当中标准库使用的分配器并不是这个很好的alloc,而是上面提到的allocator!!!**\n\n#### Gc4.9标准分配器allocator(不是alloc)的实现\n\n![image-20230529211708274](https://cdn.davidingplus.cn/images/2025/01/30/image-20230529211708274.png)\n\n这个分配器就是一般的调用malloc和free，不做特殊设计\n\n**那么使用alloc不适用allocator的好处是什么呢？**\n\n**答案是去除了cookie，比如放入一百万个元素，使用cookie就节省了八百万个字节的空间，这样减少了内存开销**\n\n### Gc2.9 std::alloc(很好的分配器)的实现\n\n![image-20230530104526960](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530104526960.png)\n\n**这个东西的基本原理和我们设计的per-class allocator是一样的，但是现在他设计了16条free_list,分别管理不同大小的内存，大小从小到大，8个字节，16个字节等等等；如果用户需要的大小不是8的倍数会被调整到8的倍数，然后进入对应的链表中；在该链表中一次性去取一大块的内存，在图中的设计中是20为标准量，比如可以取20*32字节的内存，这样相邻的之间就没有cookie，新的需求进来之后如果还有空间就移动指针存储就好了，没有就继续挖一大块，这样就形成了去除cookie，也是一个非常好的内存池的设计；现在如果需要的内存大小超过这个链表可以维护的最大大小，这个分配器就不用这么精妙的设计去做了，因为数据块的大小比cookie大多了，浪费是可以接受的，这个时候就调用一般的malloc就可以了**\n\n关于挖内存，这个设计还有一些细节：\n\n**当挖内存的时候，比如就32字节的那块，如果设计者设计的是20*32，但是实际上挖出来的是2个20块，每一块32个字节；其中前20块就给32字节的区块去用，后20块作为备用区块(战备池)，暂时不处理，可以给负责其他大小的区块取用以此节省空间。比如这时候要64个字节，按理来说应该7号链表去挖，但是他观察到3号链表的后备区块有空间，他的指针就指向这一块，所以图中这两块是连续的，也就是说这个后备区块可以存放10个64字节的空间**\n\n所以每次要的时候都是要两倍的空间，留相同大小(这里是20个)的空间作为战备池(memory pool)\n\n#### embedded pointers 内嵌入式指针\n\n![image-20230530112053633](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530112053633.png)\n\n关于free_list的指针：\n\n这个设计非常巧妙，由于分配的次序和归还的次序在实际操作的过程中可能并不是完全符合逆向，所以对于free_list他们的内存可能不是完全连续的，这很正常\n\n但是呢，free_list之间是用指针传递的，本身是一个链表，也就不存在连续不连续的问题了\n\n**因此，free_list指向的每一个区块都是提前挖出来的内存块，为了存放下一个free块的指针，这里借用了这一个区块的前4个字节(64位电脑是8个字节)作为指针，指向下一块free内存，当这一块内存被分配给用户的时候，数据值会覆盖掉这个指针，但是没有关系，这个时候我的free_list已经通过这个指针指向下一块free内存了，这一块内存也就不属于free_list的范畴了，属于用户持有的内存了**\n\n那么为什么要这么设计呢？如果额外拿出4或者8个字节来分配给指针，一个cookie上下加起来才8个字节，那不是相当于消除了原来的cookie增添了新的指针负担吗？所以需要使用embedded pointers\n\n那么这里考虑到一个问题，就是如果客户需要的空间本来就小于4或者8个即一个指针的大小，那这个时候指针是不是就不能借用了呢？这是正确的，但是对于工业级别的绝大多数情况，客户需要的大小肯定都是大于一根指针的大小的，所以不太需要担心这个问题\n\n### Gc2.9 std::alloc 运行一瞥(一个非常好的设计) 1-13\n\n01\n\n![image-20230530124448776](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530124448776.png)\n\n02\n\n**注意：这些链表都是指向的是free_list，而不是用户分配到的内存块**\n\n![image-20230530124835651](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530124835651.png)\n\n在申请内存的时候，比如申请32字节，free_list上没有，首先去找战备池有没有合适的，没有的话就在#3(对应32字节)下面申请 32 * 20 * 2 + RoundUp(0>>4) = 1280的空间\n\n注意：\n\n1.**在实作的时候，总是优先先把分配好的内存放到战备池当中，然后再分配出去内存，比如给一块给用户，剩余19块挂在free_list[3]上面**，不这么实现其实问题也不大，但是标准库这么实现了代码会漂亮很多\n\n2.**RoundUp(0>>4)是一个函数，表示一个追加量**，是实现这个的这个公司设计的，具体原因不清楚，表示把一个数字调整到一定的边界，后面再说，一开始(目前)是0\n\n然后对于cookie，在我们这样的设计之后，这一整块是用malloc拿到的，所以这一整块上下会有两个cookie\n\n03\n\n![image-20230530130901615](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530130901615.png)\n\n接上，现在我申请64字节，free_list上没有，肯定是优先查看战备池的空间，这里够用，**所以把战备池当中的一块分给用户，剩余9块挂在free_list[7]上面，注意的是这两块空间在内存上是连续的!这时战备池用光了**\n\n**规定：在后面在战备池上面取出空间去划分的时候，一次性划分的个数不能超过20个!!!!**\n\n04\n\n![image-20230530132204861](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530132204861.png)\n\n现在继续申请96字节，free_list上没有，战备池为空，需要重新申请内存，申请96 * 20 * 2 + RoundUp(1280>>4) 的内存大小，其中一块给用户，19块放到free_list[11]上，剩余的2000就是战备池\n\n注意：关于追加量的计算\n\n**RoundUp(x>>4)：用目前的累计申请量(例如现在没申请前是1280)右移4位，即除以16，然后调到8的边界**\n\n可以看出这个追加量会越来越大，随着内存的开辟\n\n05\n\n![image-20230530133728815](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530133728815.png)\n\n现在申请88字节，即#10，free_list上没有，先看战备池，最多可以划出20块，20 * 88 < 2000 ，则划分20块出去，战备池剩余2000 - 88 * 20 = 240个字节的大小\n\n划分出去的空间一块给用户，剩余19块传到free_list[10]上面去\n\n06\n\n![image-20230530134659332](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530134659332.png)\n\n连续申请三次88字节，由于free_list[10]上有空间，直接分配给用户即可，将free_list[10]指针后移\n\n07\n\n![image-20230530135356839](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530135356839.png)\n\n接着申请8字节，free_list上没有，先看战备池，由于8 * 20 < 240 ，分配出去，战备池空间还剩80，划分出一块给用户，剩余的挂在free_list[0]上面，战备池剩余80\n\n08\n\n![image-20230530135902882](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530135902882.png)\n\n**碎片处理：**\n\n这时候申请104字节大小，free_list上没有，上一次的战备池剩余80，连一个都没有办法满足；**这个时候会把这个80挂载到#9号的free_list[9]上面，这个时候战备池就为空了，然后重新用malloc申请内存**，各项参数如上所示\n\n09\n\n![image-20230530192809660](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530192809660.png)\n\n申请112个字节，free_list上没有，先找战备池，由于112 * 20 = 2240 < 2408，所以分配出去，现在战备池剩余168\n\n10\n\n![image-20230530193556966](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530193556966.png)\n\n申请48个字节，free_list上没有，找战备池，168 / 48 = 3，分配3个出去，一个给用户，剩下两个挂在free_list[5]上，战备池剩余24\n\n11\n\n![image-20230530194432937](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530194432937.png)\n\n**现在申请72，free_list上没有，先找战备池，24满足不了，那么会申请内存，但是现在为了观察系统边界，手动将系统堆的大小设置小，现在如果在索取内存就超出边界了，显然不行，所以满足不了这次申请，那么就找距离72最近的free_list，在这里就是80，即9号，上面有一个空白的区块，好，把他切成72 + 8 的形式，72分配给用户，8就是战备池，这个时候 #8 和 #9 都没有free_list，他们的链表都是空的!!!!**\n\n12\n\n![image-20230530200004843](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200004843.png)\n\n再申请72，没有free_list,，战备池不够，同时好的又malloc失败了，这个时候只有去找 #10 的空白区块了，**先处理原来的战备池，将其挂到#0号free_list的首部，即如图所示，**然后把 #10 号的第一个空白区块分成72和16，72给用户，16作为战备池\n\n13 山穷水尽\n\n![image-20230530200614422](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200614422.png)\n\n申请120，#14 没有free_list，战备池空间不够，malloc好的不出意外又失败了，这个时候就去找#15，哦豁没有，找不到，那么就g啦！！！战备池归0\n\n针对目前的这个现状，可以做一些思考：\n\n![image-20230530200925564](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530200925564.png)\n\n- 图中还有很多空白的区块未分配给用户，那么可不可以把白色的小区块合并成为大区块给用户呢？(难度太高了)\n- system heap还剩余 10000 - 9688 = 312，可不可以把剩下的312继续用光呢？\n\n### Gc2.9  std::alloc的源码剖析\n\n**第二级分配器：第二级分配器就是上面提到的alloc，当这个分配器分配不出内存的时候，实际上不会立即山穷水尽，会调用第一级分配器调用new_handler来对分配不出内存进行处理**\n\n![image-20230530215144034](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530215144034.png)\n\n模板参数 bool threads和int inst，在我们目前所研究的范围当中都没有派上用场\n\nRound_Up()：计算追加量\n\nembedded pointers：嵌入式指针\n\n**在这个类里面最先定义这个指针成员，也就达到了我们需要的借用头部作为指针，后面容器进来之后覆盖并且移动指针到下一个位置就可以了**\n\n```c++\nunion obj{\n\tunion obj* free_list_link;\n};\n```\n\nfree_list[]：静态，全局只有一份，代表那16个链表\n\nFREELIST_INDEX()：计算数组下标，计算出由第几号链表提供服务\n\n战备池相关\n\n- start_free：指向pool首部\n- end_free：指向pool尾部\n\nhead_size：统计累计分配量\n\n还有两个函数目前尚不清楚怎么实现：\n\n**refill()：从内存池中申请空间并构建free list，然后从free list中分配空间给用户**\n\n**chunk_alloc()：从内存池中分配空间**\n\n![image-20230530220728994](https://cdn.davidingplus.cn/images/2025/01/30/image-20230530220728994.png)\n\n然后就是最重要的allocate()和deallocate()函数\n\nallocate函数中：**如果需要的空间太大超过范围就调用第一级分配器；然后去查询free_list当中是否可以分配，如果可以分配那么就分配就好了；如果没有就调用refill()函数，从内存池中申请空间并且构建free_list，然后分配一块给用户，至于是战备池还是战备池不够处理碎片然后malloc申请，或者是malloc失败去找后面的空白区块，这就是refill的事情了，现在尚不清楚**\n\ndeallocate函数中：**如果空间太大，调用第一级，与allocate配套；否则把free_list[]指针前移**\n\n**那么问题来了，为什么这里不调用free()释放还给操作系统呢？**\n\n**前面知道，由于各种原因，free_list[]的指向并不一定是连续的，但是他们之间是用链表实现的，给我们的感官是这样的；不连续的话贸然去free()就可能会出问题，所以他不还给操作系统**（个人感觉这里不是很合理）\n\n**另一个问题就是没有对这个p指针进行检查，如果他不是这个分配器给出来的指针，他指向空间的大小可能就不是8的倍数，这样如果执行这段代码可能就会造成不可逆转的结果了**\n\n![image-20230531095651457](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531095651457.png)\n\nrefill()函数：\n\n这个函数的作用就是在free_list没有空间的时候，内部调用chunk_alloc()申请内存池并且分配给用户和free_list，然后把申请到的free_list给串起来\n\n然后拿一大块内存的事情就交给chunk_alloc()函数去实现\n\n![image-20230531095545741](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531095545741.png)\n\n![image-20230531105901120](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531105901120.png)\n\nchunk_alloc()函数：\n\n这里就是去要一大块内存，先去看战备池，他这里是先看能不能满足最大的需求，就是规定的战备池最多提供20块，不能的话看能切出几块，然后修改指针；\n\n**如果无法满足那么就代表战备池无法满足，那么就把这个碎片进行处理(给他放到对应的free_list的首部)，然后准备计算接下来需要malloc拿到的空间，然后尝试去拿取；malloc拿到的空间前面提到是2 * 20 * 32 比如，先全部放到战备池当中，然后切出一半来给用户和free_list分配；失败了说明系统heap空间不够了，那么就尝试去这个大小的链表后面去找可用的空间，将其一块分为用户和战备池，如果这还找不到就山穷水尽，g!**\n\n![image-20230531110714412](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531110714412.png)\n\n然后就剩下一些类外的初始化和typedef的操作了\n\n整合了一下代码：\n\n```c++\n//第一级分配器\n#ifndef _STD_ALLOC_1ST_H_\n#define _STD_ALLOC_1ST_H_\n\n#define __THROW_BAD_ALLOC            \\\n    cerr << \"out of memory\" << endl; \\\n    exit(1)\n//----------------------------------------------\n// 第1級配置器。\n//----------------------------------------------\ntemplate <int inst>\nclass __malloc_alloc_template {\nprivate:\n    static void *oom_malloc(size_t);\n    static void *oom_realloc(void *, size_t);\n    static void (*__malloc_alloc_oom_handler)();\n\npublic:\n    static void *allocate(size_t n) {\n        void *result = malloc(n);  // 直接使用 malloc()\n        if (0 == result)\n            result = oom_malloc(n);\n        return result;\n    }\n    static void deallocate(void *p, size_t /* n */) {\n        free(p);  // 直接使用 free()\n    }\n    static void *reallocate(void *p, size_t /* old_sz */, size_t new_sz) {\n        void *result = realloc(p, new_sz);  // 直接使用 realloc()\n        if (0 == result)\n            result = oom_realloc(p, new_sz);\n        return result;\n    }\n    static void (*set_malloc_handler(void (*f)()))() {  // 類似 C++ 的 set_new_handler().\n        void (*old)() = __malloc_alloc_oom_handler;\n        __malloc_alloc_oom_handler = f;\n        return (old);\n    }\n};\n//----------------------------------------------\ntemplate <int inst>\nvoid (*__malloc_alloc_template<inst>::__malloc_alloc_oom_handler)() = 0;\n\ntemplate <int inst>\nvoid *__malloc_alloc_template<inst>::oom_malloc(size_t n) {\n    void (*my_malloc_handler)();\n    void *result;\n\n    for (;;) {  // 不斷嘗試釋放、配置、再釋放、再配置…\n        my_malloc_handler = __malloc_alloc_oom_handler;\n        if (0 == my_malloc_handler) {\n            __THROW_BAD_ALLOC;\n        }\n        (*my_malloc_handler)();  // 呼叫處理常式，企圖釋放記憶體\n        result = malloc(n);      // 再次嘗試配置記憶體\n        if (result)\n            return (result);\n    }\n}\n\ntemplate <int inst>\nvoid *__malloc_alloc_template<inst>::oom_realloc(void *p, size_t n) {\n    void (*my_malloc_handler)();\n    void *result;\n\n    for (;;) {  // 不斷嘗試釋放、配置、再釋放、再配置…\n        my_malloc_handler = __malloc_alloc_oom_handler;\n        if (0 == my_malloc_handler) {\n            __THROW_BAD_ALLOC;\n        }\n        (*my_malloc_handler)();  // 呼叫處理常式，企圖釋放記憶體。\n        result = realloc(p, n);  // 再次嘗試配置記憶體。\n        if (result)\n            return (result);\n    }\n}\n//----------------------------------------------\n\ntypedef __malloc_alloc_template<0> malloc_alloc;\n\ntemplate <class T, class Alloc>\nclass simple_alloc {\npublic:\n    static T *allocate(size_t n) {\n        return 0 == n ? 0 : (T *)Alloc::allocate(n * sizeof(T));\n    }\n    static T *allocate(void) {\n        return (T *)Alloc::allocate(sizeof(T));\n    }\n    static void deallocate(T *p, size_t n) {\n        if (0 != n)\n            Alloc::deallocate(p, n * sizeof(T));\n    }\n    static void deallocate(T *p) {\n        Alloc::deallocate(p, sizeof(T));\n    }\n};\n\n#endif\n```\n\n```c++\n//第二级分配器\n#ifndef _STD_ALLOC_2ND_H_\n#define _STD_ALLOC_2ND_H_\n\n#include \"std_alloc_1st.h\"\nusing namespace std;\n#include <iostream>\n\n// 第二級配置器\n//----------------------------------------------\nenum {\n    __ALIGN = 8\n};  // 小區塊的上調邊界\nenum {\n    __MAX_BYTES = 128\n};  // 小區塊的上限\nenum {\n    __NFREELISTS = __MAX_BYTES / __ALIGN\n};  // free-lists 個數\n\n// 本例中兩個 template 參數完全沒有派上用場\ntemplate <bool threads, int inst>\nclass __default_alloc_template {\nprivate:\n    // 實際上應使用 static const int x = N\n    // 取代 enum { x = N }, 但目前支援該性質的編譯器不多\n\n    static size_t ROUND_UP(size_t bytes) {\n        return (((bytes) + __ALIGN - 1) & ~(__ALIGN - 1));\n    }\n\nprivate:\n    union obj {\n        union obj *free_list_link;\n    };\n\nprivate:\n    static obj *volatile free_list[__NFREELISTS];\n    static size_t FREELIST_INDEX(size_t bytes) {\n        return (((bytes) + __ALIGN - 1) / __ALIGN - 1);\n    }\n\n    // Returns an object of size n, and optionally adds to size n free list.\n    static void *refill(size_t n);\n\n    // Allocates a chunk for nobjs of size \"size\".  nobjs may be reduced\n    // if it is inconvenient to allocate the requested number.\n    static char *chunk_alloc(size_t size, int &nobjs);\n\n    // Chunk allocation state.\n    static char *start_free;\n    static char *end_free;\n    static size_t heap_size;\n\npublic:\n    static void *allocate(size_t n)  // n must be > 0\n    {\n        obj *volatile *my_free_list;  // obj** my_free_list;\n        obj *result;\n\n        if (n > (size_t)__MAX_BYTES) {\n            return (malloc_alloc::allocate(n));\n        }\n\n        my_free_list = free_list + FREELIST_INDEX(n);\n        result = *my_free_list;\n        if (result == 0) {\n            void *r = refill(ROUND_UP(n));\n            return r;\n        }\n\n        *my_free_list = result->free_list_link;\n        return (result);\n    }\n\n    static void deallocate(void *p, size_t n)  // p may not be 0\n    {\n        obj *q = (obj *)p;\n        obj *volatile *my_free_list;  // obj** my_free_list;\n\n        if (n > (size_t)__MAX_BYTES) {\n            malloc_alloc::deallocate(p, n);\n            return;\n        }\n        my_free_list = free_list + FREELIST_INDEX(n);\n        q->free_list_link = *my_free_list;\n        *my_free_list = q;\n    }\n\n    static void *reallocate(void *p, size_t old_sz, size_t new_sz);\n};\n//----------------------------------------------\n// We allocate memory in large chunks in order to\n// avoid fragmentingthe malloc heap too much.\n// We assume that size is properly aligned.\n// We hold the allocation lock.\n//----------------------------------------------\ntemplate <bool threads, int inst>\nchar *\n__default_alloc_template<threads, inst>::\n    chunk_alloc(size_t size, int &nobjs) {\n    char *result;\n    size_t total_bytes = size * nobjs;\n    size_t bytes_left = end_free - start_free;\n\n    if (bytes_left >= total_bytes) {\n        result = start_free;\n        start_free += total_bytes;\n        return (result);\n    } else if (bytes_left >= size) {\n        nobjs = bytes_left / size;\n        total_bytes = size * nobjs;\n        result = start_free;\n        start_free += total_bytes;\n        return (result);\n    } else {\n        size_t bytes_to_get =\n            2 * total_bytes + ROUND_UP(heap_size >> 4);\n        // Try to make use of the left-over piece.\n        if (bytes_left > 0) {\n            obj *volatile *my_free_list =\n                free_list + FREELIST_INDEX(bytes_left);\n\n            ((obj *)start_free)->free_list_link = *my_free_list;\n            *my_free_list = (obj *)start_free;\n        }\n        start_free = (char *)malloc(bytes_to_get);\n        if (0 == start_free) {\n            int i;\n            obj *volatile *my_free_list, *p;\n\n            // Try to make do with what we have. That can't\n            // hurt. We do not try smaller requests, since that tends\n            // to result in disaster on multi-process machines.\n            for (i = size; i <= __MAX_BYTES; i += __ALIGN) {\n                my_free_list = free_list + FREELIST_INDEX(i);\n                p = *my_free_list;\n                if (0 != p) {\n                    *my_free_list = p->free_list_link;\n                    start_free = (char *)p;\n                    end_free = start_free + i;\n                    return (chunk_alloc(size, nobjs));\n                    // Any leftover piece will eventually make it to the\n                    // right free list.\n                }\n            }\n            end_free = 0;  // In case of exception.\n            start_free = (char *)malloc_alloc::allocate(bytes_to_get);\n            // This should either throw an exception or\n            // remedy the situation. Thus we assume it\n            // succeeded.\n        }\n        heap_size += bytes_to_get;\n        end_free = start_free + bytes_to_get;\n        return (chunk_alloc(size, nobjs));\n    }\n}\n//----------------------------------------------\n// Returns an object of size n, and optionally adds\n// to size n free list.We assume that n is properly aligned.\n// We hold the allocation lock.\n//----------------------------------------------\ntemplate <bool threads, int inst>\nvoid *__default_alloc_template<threads, inst>::\n    refill(size_t n) {\n    int nobjs = 20;\n    char *chunk = chunk_alloc(n, nobjs);\n    obj *volatile *my_free_list;  // obj** my_free_list;\n    obj *result;\n    obj *current_obj;\n    obj *next_obj;\n    int i;\n\n    if (1 == nobjs)\n        return (chunk);\n    my_free_list = free_list + FREELIST_INDEX(n);\n\n    // Build free list in chunk\n    result = (obj *)chunk;\n    *my_free_list = next_obj = (obj *)(chunk + n);\n    for (i = 1;; ++i) {\n        current_obj = next_obj;\n        next_obj = (obj *)((char *)next_obj + n);\n        if (nobjs - 1 == i) {\n            current_obj->free_list_link = 0;\n            break;\n        } else {\n            current_obj->free_list_link = next_obj;\n        }\n    }\n    return (result);\n}\n//----------------------------------------------\ntemplate <bool threads, int inst>\nchar *__default_alloc_template<threads, inst>::start_free = 0;\n\ntemplate <bool threads, int inst>\nchar *__default_alloc_template<threads, inst>::end_free = 0;\n\ntemplate <bool threads, int inst>\nsize_t __default_alloc_template<threads, inst>::heap_size = 0;\n\ntemplate <bool threads, int inst>\ntypename __default_alloc_template<threads, inst>::obj *volatile __default_alloc_template<threads, inst>::free_list[__NFREELISTS] = {\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n};\n\n//----------------------------------------------\n// 令第2級配置器的名稱為 alloc\nusing alloc = __default_alloc_template<false, 0>;\n\n#endif\n```\n\n```c++\n//测试程序\n#include <iostream>\nusing namespace std;\n#include \"std_alloc_2nd.h\"\n\nvoid test_G29_alloc() {\n    cout << \"test_global_allocator_with_16_freelist().......... \\n\";\n\n    void *p1 = alloc::allocate(120);\n    void *p2 = alloc::allocate(72);\n    void *p3 = alloc::allocate(60);  // 不是 8 倍數\n\n    cout << p1 << endl\n         << p2 << endl\n         << p3 << endl;\n\n    alloc::deallocate(p1, 120);\n    alloc::deallocate(p2, 72);\n    alloc::deallocate(p3, 60);\n\n    // 以下, 不能搭配容器來測試, 因為新版 G++ 對於 allocator 有更多要求 (詢問更多 typedef 而 alloc 都無法回答)\n    // 它其實就是 G4.9 __pool_alloc，所以讓 G4.9容器使用 __pool_alloc 也就等同於這裡所要的測試\n    /*\n        vector<int, simple_alloc<int,alloc>> v;\n        for(int i=0; i< 1000; ++i)\n            v.push_back(i);\n        for(int i=700; i< 720; ++i)\n            cout << v[i] << ' ';\n    */\n}\n\nint main() {\n    test_G29_alloc();\n\n    return 0;\n}\n```\n\n执行结果：\n\n![image-20230531113514416](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531113514416.png)\n\n### Gc2.9 std::alloc观念大整理\n\n![image-20230531112717690](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531112717690.png)\n\n假设这里list<>使用的分配器是std::alloc，list除了本身的Foo之外，还带有list的两根指针，如果sizeof(Foo) + 2 * 指针大小 < 128，那么可以调用alloc分配器；\n\n第二行list<>容器调用push_back()插入操作，Foo(1)是临时对象，放在栈区，然后调用copy ctor，把他放到alloc创造的空间当中，这一段空间不带有cookie；\n\n第二个操作把一个由malloc动态开辟出来带有cookie的空间copy到alloc创造的空间当中，同样也不带有cookie\n\n![image-20230531133126758](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531133126758.png)\n\n注意等号判断的写法，这里推荐把右值放在等号左边，为什么呢？\n\n**这样的话，如果我不小心把 == 号写成了 = 号，那么 0 = start_free是没办法通过的，会报错，如果交换顺序则会通过，造成的后果是非常严重的，所以强烈建议判断 == 的时候把右值放在等号左边！！**\n\n![image-20230531134700621](https://cdn.davidingplus.cn/images/2025/01/30/image-20230531134700621.png)\n\n**当没有内存可以分配的时候，分配器会去找已有的内存，也就是上面往后找一块free_list下的内存块划分给用户和战备池，如果这都没有的话就g啦。但是当时我们提到过，可以把剩余的内存(比如9688到10000还有312)，可以把剩余的内存减半再减半，直到可以被分配出来，这样不是可以更好的利用内存吗？想法是肯定的，但是上面说在多进程的机器上会带来大灾难，这里的理解不一了，一种理解是这不是更好的利用内存了嘛？另一种是你把内存尽可能的使用了，其他人怎么办呢？Gc2.9选择了后者，如果想实现前者，也不是不可以，只是难度比较大**\n\n另外一个问题就是他的deallocate()函数不进行内存的归还，这也是受限制于这个设计先天的缺陷吧，链表指来指去，内存不一定连续，这样就没有把握free内存\n\n测试代码：\n\n```c++\n#include <iostream>\nusing namespace std;\n#include <ext/pool_allocator.h>\n#include <list>\n#include <vector>\n\ntemplate <typename Value_Type>\nusing listPool = list<Value_Type, __gnu_cxx::__pool_alloc<Value_Type>>;\n\nstatic long long countNew = 0;\nstatic long long countDel = 0;\nstatic long long countArrayNew = 0;\nstatic long long countArrayDel = 0;\nstatic long long timesNew = 0;\n\n// 两个函数\nvoid* myAlloc(size_t size) {\n    return malloc(size);\n}\n\nvoid myFree(void* ptr) {\n    free(ptr);\n}\n\n// 重载全局operator new/delete\ninline void* operator new(size_t size) {\n    // cout << \"global new(), \\t\" << size << \"\\t\";\n    countNew += size;\n    ++timesNew;\n\n    return myAlloc(size);\n}\n\ninline void* operator new[](size_t size) {\n    // cout << \"global new[](), \\t\" << size << \"\\t\";\n    countArrayNew += size;\n\n    void* p = myAlloc(size);\n    cout << p << endl;\n    return p;\n\n    return myAlloc(size);\n}\n\n// 天啊, 以下(1)(2)可以並存並由(2)抓住流程 (但它對我這兒的測試無用).\n// 當只存在 (1) 時, 抓不住流程.\n// 在 class members 中二者只能擇一 (任一均可)\n//(1)\ninline void operator delete(void* ptr, size_t size) {\n    // cout << \"global delete(ptr,size), \\t\" << ptr << \"\\t\" << size << endl;\n    countDel += size;\n    myFree(ptr);\n}\n//(2)\ninline void operator delete(void* ptr) {\n    // cout << \"global delete(ptr), \\t\" << ptr << endl;\n    myFree(ptr);\n}\n\n//(1)\ninline void operator delete[](void* ptr, size_t size) {\n    // cout << \"global delete[](ptr,size), \\t\" << ptr << \"\\t\" << size << endl;\n    countArrayDel += size;\n    myFree(ptr);\n}\n//(2)\ninline void operator delete[](void* ptr) {\n    // cout << \"global delete[](ptr), \\t\" << ptr << endl;\n    myFree(ptr);\n}\n\nvoid test_overload_global_new() {\n    cout << \"test_overload_global_new().......... \\n\"\n         << endl;\n\n    //***** 測試時, main() 中的其他測試全都 remark, 獨留本測試 *****\n    {\n        cout << \"::countNew= \" << ::countNew << endl;  // 0\n        cout << \"::countDel= \" << ::countDel << endl;  // 0\n        cout << \"::timesNew= \" << ::timesNew << endl;  // 0\n\n        string* p = new string(\"My name is Ace\");  // jjhou global new(), 4 \t(註：這是 string size)\n                                                   // jjhou global new(), 27\t(註：這是 sizeof(Rep)+extra)\n        delete p;                                  // jjhou global delete(ptr), 0x3e3e48\n                                                   // jjhou global delete(ptr), 0x3e3e38\n\n        cout << \"::countNew= \" << ::countNew << endl;  // 31 ==> 4+27\n        cout << \"::timesNew= \" << ::timesNew << endl;  // 2\n        cout << \"::countDel= \" << ::countDel << endl;  // 0 <== 本測試顯然我永遠觀察不到我所要觀察的\n                                                       //       因為進不去 operator delete(ptr,size) 版\n\n        p = new string[3];  // jjhou global new[](), 16 (註：其中內含 arraySize field: 4 bytes,\n                            // 所以 16-4 = 12 ==> 4*3, 也就是 3 個 string 每個佔 4 bytes)\n        // jjhou global new(), 13  \t//Nil string\n        // jjhou global new(), 13\t//Nil string\n        // jjhou global new(), 13\t//Nil string\n\n        delete[] p;  // jjhou global delete(ptr),   0x3e3e88\n                     // jjhou global delete(ptr),   0x3e3e70\n                     // jjhou global delete(ptr),   0x3e39c8\n                     // jjhou global delete[](ptr), 0x3e3978\n\n        cout << \"::countNew= \" << ::countNew << endl;            // 70 ==> 4+27+13+13+13\n        cout << \"::timesNew= \" << ::timesNew << endl;            // 5\n        cout << \"::countArrayNew= \" << ::countArrayNew << endl;  // 16 (這個數值其實對我而言無意義)\n\n        // 測試: global operator new 也會帶容器帶來影響\n        vector<int> vec(10);  // jjhou global new(), \t40  \t0x3e3ea0  (註：10 ints)\n                              // 註：vector object 本身不是 dynamic allocated.\n        vec.push_back(1);\n        // jjhou global new(), \t80\t\t0x3e3ed0\n        // jjhou global delete(ptr), \t0x3e3ea0\n        vec.push_back(1);\n        vec.push_back(1);\n\n        cout << \"::countNew= \" << ::countNew << endl;  // 190 ==> 70+40+80\n        cout << \"::timesNew= \" << ::timesNew << endl;  // 7\n\n        list<int> lst;                                 // 註：list object 本身不是 dynamic allocated.\n        lst.push_back(1);                              // jjhou global new(), \t12\t(註：每個 node是 12 bytes)\n        lst.push_back(1);                              // jjhou global new(), \t12\n        lst.push_back(1);                              // jjhou global new(), \t12\n        cout << \"::countNew= \" << ::countNew << endl;  // 226 ==> 190+12+12+12\n        cout << \"::timesNew= \" << ::timesNew << endl;  // 10\n\n        // jjhou global delete(ptr), \t0x3e3978\n        // jjhou global delete(ptr), \t0x3e39c8\n        // jjhou global delete(ptr), \t0x3e3e70\n        // jjhou global delete(ptr), \t0x3e3ed0\n    }\n\n    cout << endl\n         << endl;\n\n    {\n        // reset countNew\n        countNew = 0;\n        timesNew = 0;\n\n        // list<double, __gnu_cxx::__pool_alloc<double>> lst;\n        // 上一行改用 C++/11 alias template 來寫 :\n        listPool<double> lst;\n\n        for (int i = 0; i < 1000000; ++i)\n            lst.push_back(i);\n        cout << \"::countNew= \" << ::countNew << endl;  // 16752832 (注意, node 都不帶 cookie)\n        cout << \"::timesNew= \" << ::timesNew << endl;  // 122\n    }\n\n    cout << endl\n         << endl;\n\n    {\n        // reset countNew\n        countNew = 0;\n        timesNew = 0;\n        list<double> lst;\n        for (int i = 0; i < 1000000; ++i)\n            lst.push_back(i);\n        cout << \"::countNew= \" << ::countNew << endl;  // 16000000 (注意, node 都帶 cookie)\n        cout << \"::timesNew= \" << ::timesNew << endl;  // 1000000\n    }\n}\n\nint main() {\n    // 为了防止刷屏我把operator new/delete里面输出的内容给注释了\n    test_overload_global_new();\n\n    return 0;\n}\n```\n\n执行结果：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/01/30/image-20230531143041896.png\" alt=\"image-20230531143041896\" style=\"zoom: 80%;\" />\n\n## 第四讲：loki::allocator\n\n第三讲将malloc和free，太难了，这部分暂时没听.\n\n### Loki::allocator设计\n\n**Loki分配器和std::alloc分配器的区别，std::alloc分配器的致命伤是他要到一大块内存之后进行设计，然后分配给用户之后，用户发出释放内存的操作的时候，分配器内部的实现是不归还给操作系统的，他很霸道，官方的解释是一是实现很难，二是归还这个操作可能在多任务进程中会影响其他进程的操作，而Loki分配器就解决了这个问题**\n\n如何设计？\n\n![image-20230609153221116](https://cdn.davidingplus.cn/images/2025/01/30/image-20230609153221116.png)\n\n三层结构如上：\n\n最下层Chunk，存放这一块的指针，这一块的索引和目前还可以供应的区块\n\n中间层FixedAllocator，存放vector< Chunk >和两根指向Chunk的指针\n\n最上面的层SmallObjAllocator，**也就是用户面对的层次**，存放vector< FixedAllocator >和两根指向FixedAllocator的指针\n\n**至于为什么要指向某两个，这两个可能还有其他的特殊作用，这个后面再说**\n\n### 源代码\n\n#### Chunk类\n\n![image-20230609155142232](https://cdn.davidingplus.cn/images/2025/01/30/image-20230609155142232.png)\n\n这些函数都是高层的类调用底层的类的，我们用户在实际操作的时候没有必要直接调用这个\n\nInit()函数：挖出一大块内存用于操作，单位大小和区块个数都经过了调整\n\nReset()函数：对这大块内存进行分配，就是标出Chunk那三块， 其中用流水线的方式表示索引，把最前面一个字节的空间占据l来当作索引，概念类似于embedded pointer(嵌入式指针)，只不过这里是嵌入式索引\n\n**重头戏：allocate()和deallocate()**\n\n![image-20230609160227418](https://cdn.davidingplus.cn/images/2025/01/30/image-20230609160227418.png)\n\n**allocate()函数：在初始化Init()函数之后调用allocate()函数，这个时候每一个block的大小都是blocksize，firstAvaliableBlock代表了这个时候第一块空白的内存，存放的是索引，就是从0开始按顺序去数，并且优先度最高，它里面存放的区块索引是之前设计好的，就是第二高的优先度，第一块内存分配给用户之后，第二块就上来了，变成了firstAvailableBlock的内容，然后blocksAvailable减减**\n\n![image-20230609161327736](https://cdn.davidingplus.cn/images/2025/01/30/image-20230609161327736.png)\n\n**deallocate()函数：给一个指针，当然需要先判断这跟指针位于哪个Chunk结构当中，这就一个一个去查询(查询指针的位置)就好了，找到之后把这一块内存free掉，做allocate()函数的逆操作，把目前状态的firstAvailable的区块索引填入该区块，然后该区块索引取代他成为firstAvailableBlock，然后blocksAvailable加加，这就保证了操作的严谨和自洽**\n\n\n\n#### FixedAllocator类\n\nFixedAllocator类的结构：\n\n![image-20230711103421403](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711103421403.png)\n\n除了存放vector< Chunk >之外，还有两根指针，**用来标识最近一次alloc的Chunk和dealloc的Chunk，这么做的含义是，可以从这个最近的区块当中看是否可以继续分配或者回收来提高效率**\n\nAllocate代码：\n\n![image-20230711103208976](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711103208976.png)\n\n**如果标识allocChunk为0(例如最开始的时候没有分配内存)或者allocChunk指向的blockAvailable为0代表没有课余空间，那么表明allocChunk不可用，需要从头重新开始查找**\n\n**在查找过程中如果发现可用的，记下地址然后去分配，如果没有可用的(都用光了)，这时候加一个新的chunk进去用于新的分配!!!**\n\n**注意加了新的chunk之后记得更改allocChunk和deallocChunk的值，allocChunk就设置为改Chunk就可以，因为这是新生成的，可以进行分配；deallocChunk设置为头部**\n\n**但是为什么要重设呢？因为vector在push_back操作中可能出现2倍扩张导致move的问题，这个时候原来的指针就失效了，显然需要重新设置!!!**\n\ndeallocate代码：\n\n![image-20230711110249938](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711110249938.png)\n\n拿到一个需要释放的指针，先找到需要释放的Chunk区块，通过VicinityFind()实现，然后通过DoDeallocate()进行释放\n\nVicinityFind()函数：\n\n![image-20230711111102518](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711111102518.png)\n\n他这种写法其实没有特别的数学依据，大致思想就是从上一个deallocChunk开始，将其分为上下两个部分，上面找一个，下面找一个，直到找到对应的区块，然后进行修改\n\n但是如果给的p不是Chunk分配拿出的指针，那么显然是找不到的，所以会死循环\n\nDoDeallocate()函数：\n\n![image-20230711111833403](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711111833403.png)\n\n这里要注意如果回收之后这一块Chunk变为全空，需要把这一块进行回收嘛？这就不是内存分配的重点了\n\n## 第五讲：other issues\n\n### new_allocator\n\n![image-20230711142511891](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142511891.png)\n\n![image-20230711142536025](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142536025.png)\n\n![image-20230711142846401](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711142846401.png)\n\n这几个版本实现不同，但是其实本质上没有进行额外的设计，就是对c runtime libirary里面malloc和free的调用\n\n### array_allocator\n\n![image-20230711143546194](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711143546194.png)\n\n**这个分配器的目的是分出一块静态内存array(C++数组)，然后分配给用户，由于是静态，所以不需要进行回收，因此按道理来说不需要deallocate()。但是分配器都需要提供这些统一的接口，所以他do nothing.**\n\n**注意第二个模板参数传入的参数必须是array<>!!!**\n\n例子：\n\n静态数组充当分配单元\n\n![image-20230711144447440](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711144447440.png)\n\n动态开辟的空间充当分配单元\n\n![image-20230711144615462](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711144615462.png)\n\n### debug_allocator\n\n![image-20230711145211456](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711145211456.png)\n\n**用途：包裹其另一个分配器分配的空间，添加一个extra的空间用来记录分配的大小(类似于cookie，因为cookie当中也记录着整块的大小)**\n\n**但是感觉没什么用，试想一下我刚好去除了cookie构造了一个不错的内存池，然后用这个debug_allocator又添加了一个类似于cookie的debug header，这不是很鸡肋嘛**\n\n### Gc2.9使用的std::alloc (__pool_alloc)\n\n太熟悉啦！\n\n![image-20230711145521073](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711145521073.png)\n\n### bitmap_allocator\n\n**该分配器就allocate()和deallocate()函数做了两种；**\n\n**就容器需要的元素种类个数为1和以上做了区分，但是实际上绝大多数情况下容器存放的东西都是一种类型，不同的类型很少**\n\n![image-20230711150915653](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711150915653.png)\n\n下面他的设计用图示实现\n\n#### allocate过程：\n\n![image-20230711154726911](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711154726911.png)\n\n**还是以内存池的形式，挖出一大块内存然后进行分配。在这里这个团队设计的是一开始挖出64个指定类型的区块，然后填上bitmap，use count和一个头部记录super block size，因此这一整块就叫做super block。**\n\n**注意bitmap是怎么确定大小的，bitmap里面存的是16进制数，数组的形式，一个数组值4个字节，也就是可以放图中的4 * 16 = 64 个block的状态，1代表已存放，0代表未存放**\n\n**整个super block大小的计算如上**\n\n**对于整个bitmap_allocator的控制，使用的是自己设计的一个建议__mini_vector，因为标准库的vector底层还有分配器，用他的话就相当于套娃了，这里就是一个简单的版本，里面同样有三根指针，然后同样是2倍扩充，机制是一样的**\n\n当填充进数据：\n\n![image-20230711155355589](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155355589.png)\n\n记得修改use count；\n\n**修改bitmap数组的值，这里的顺序是反着来的，已分配设为0，未分配设为1，图中的1110代表 block的前四位 第一位0 分配出去了，所以就是E**\n\n当第一个super_block用尽，启动第二个super_block：\n\n![image-20230711155536393](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155536393.png)\n\nblock的个数由64加倍，变为128；然后记得修改__mini_vector的值，记得vector是两倍成长的\n\n继续：\n\n![image-20230711155719096](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711155719096.png)\n\n当需要启动第三个super_block的时候，这个时候进行2倍扩张，就变成了4个区块\n\n这个团队规定：如果不全回收，分配规模不断增大；如果全回收了下一次规模减半\n\n**这个vector的value_type并没有限制，因为他的每一个区块都是在自己的value_type之下构成的，我的vector只起了一个管理的作用!!!**\n\n**从图中也可以看出我们的vector里面存放的只是两根指针，指向值的第一个block和最后一个block!!!**\n\n#### deallocate过程：\n\n![image-20230711161106242](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711161106242.png)\n\n**如果把第一个super block全回收了，那么第一个super block会被放入一个free_list当中(最多64个，多了会被归还给操作系统)用作下一个分配的备用空间，然后在__mini_vector当中，会把第一个元素给删除掉，做类似于erase()的操作，只不过erase()函数需要减少size的，但是这里并没有减少，只是看起来是将元素向前推了，多出的空间就是空白**\n\n![image-20230711161901208](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711161901208.png)\n\n![image-20230711162120179](https://cdn.davidingplus.cn/images/2025/01/30/image-20230711162120179.png)\n\n整个过程大致就是这样\n\n### 谈谈const\n\n![image-20230712145001503](https://cdn.davidingplus.cn/images/2025/01/30/image-20230712145001503.png)\n\n**当成员函数的const和non-const版本同时存在，const对象只能调用const版本，non-const对象只能调用non-const版本**\n\n**因此，const也是区分函数是否相同的标志，同一个函数加上const和不加就相当于是一个重载的版本了**\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass Fuck {\npublic:\n    void fuck() const {\n        cout << \"const version\" << endl;\n    }\n\n    void fuck() {\n        cout << \"non-const version\" << endl;\n    }\n};\n\nvoid test() {\n    const Fuck f1;\n    f1.fuck();// const version\n\n    Fuck f2;\n    f2.fuck();// non-const version\n}\n\nint main() {\n    test();\n\n    return 0;\n}\n```\n\n","categories":["Cpp 学习"]},{"title":"计算机网络 期末复习","url":"/posts/fe75e45c.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 第一章 计算机网络和因特网\n\n## 计算机网络的两大功能\n\n* 连通性\n* 共享性\n\n## Internet具体构成\n\n* 数以亿计的**计算互连设备、通信链路、分组交换**：路由器和交换机\n\n<!-- more -->\n\n  * 主机（host）=端系统（end system）\n\n    * 运行网络应用程序\n\n  * 通信链路(link)\n\n    双绞线,光纤, 无线电频谱, 卫星\n    传输速率 = 带宽(bandwidth)\n    带宽单位为bps，bit per second每秒传输的位数，例如百兆光纤就是100M bps，实际传输使用的单位为BPS，1B=8bit，所以传输速率为100/8=12.5M BPS，就是12.5MB/s\n    通信链路只有极限带宽，例如5号线极限带宽为300M，不能接千兆网卡，只能接百兆网卡\n    网卡有传输的能力，传输速率取决于网卡能传输的能力，例如百兆，千兆网卡\n\n  * 分组(packet)交换：\n\n    - 路由器（Router）和交换机（Switch）\n    - 交换机：形成局域网\n    - 路由器：链接互联网\n\n## 协议的基本要素\n\n* **语法：语法即是用户数据与控制信息的结构和格式**\n* **语义：语义即是需要发出控制信息，以及完成的动作与做出的响应**\n* **同步：同步可以理解为时序，即是对事件实现顺序的详细说明**\n\n## 网络核心\n\n![image-20230626202145007](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626202145007.png)\n\n### 电路交换\n\n电话交换机接通电话线的方式成为电路交换\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230621153107716.png\" alt=\"image-20230621153107716\" style=\"zoom:67%;\" />\n\n* **每次会话预留沿其路径（线路）所需的独占资源**－－电话网\n\n* 从主机A到主机B经一个电路交换网络需要多长时间发送一个640Kb的文件?\n  **电路交换的频分和时分**\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230621153149234.png\" alt=\"image-20230621153149234\" style=\"zoom:67%;\" />\n\n  举例子：\n\n  ![image-20230608113428494](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608113428494.png)\n\n* 过程\n\n  * 建立连接\n    * 会一直霸占着这条路径\n  * 传输数据 \n  * 释放连接   \n\n* 优点\n\n  * 传输速度快、高效\n  * 实时\n\n* 缺点\n\n  * 资源利用率低\n  * 新建连接需要占据一定的时间，甚至比通话的时间还长\n\n\n\n###  多路复用\n\n* 数据以离散的数据块通过网络来发送\n  - 分片分配到会话\n  - 分片没有被会话使用的情况下，分片空载(不共享)\n  - 电路级性能（有保证）\n  - 要求呼叫建立－－建立一个专门的端到端线路(意味着每个链路上预留一个线路)\n  - 链路带宽分片\n\n频分－frequency division\n\n时分－time division\n\n### 分组交换\n\n![image-20230625162813284](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625162813284.png)\n\n每个端到端的**数据流被划分成分组**\n\n- **所有分组共享网络资源**\n\n- **每个分组使用全部链路带宽**\n\n- 资源按需使用 \n\n  ![image-20230608125358197](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608125358197.png)\n\n### 报文交换\n\n![image-20230625162842346](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625162842346.png)\n\n## 比较分组交换与电路交换：\n\n![image-20230625162932841](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625162932841.png)\n\n* 分组交换允许更多的用户使用网络\n* ![image-20230608124857481](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608124857481.png)\n* **优势**\n  * **适合大量的突发数据传输**\n  * **资源共享**\n  * **简单，无需连接**\n* **缺点**\n  * **过渡竞争导致分组延迟与丢失**\n  * **需要可靠数据传输、拥塞控制协议**\n\n## 网络的分类\n\n![image-20230608130446056](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608130446056.png)\n\n* 图中FDM频分，TDM时分\n* **虚电路网络一定是面向连接的**\n* 数据报网络既可以提供面向连接的服务，也可以提供无连接的服务\n\n## 四种时延\n\n  1.节点**处理时延**nodal processing delay：分析地址部分，进行差错检验等花费的时间\n\n\t检查错误位\n\t选择输出链路\n\t高速路由器处理延迟－微秒级\n\n2. **排队时延**queueing delay：在进入路由器之后等待处理的时间\n\n等待被发送到输出链路上的时间\n取决于路由器的拥塞程度\n\n3. **传输(发送)时延**Transmission delay：**从发送分组的第一个bit算起，到该分组最后一个分组被发送完毕需要的时间**\n\nR=链路带宽 (bps)\nL=分组长度 (bits)\n发送分组比特流的时间 = L/R\n\n4. **传播时延**Propagation delay：一个比特从链路一端传播到另一端所需要的时间\n\nd = 物理链路的长度\ns = 介质的信号传播速度 (~2x108 m/sec)\n传播延迟 = d/s\n注意: s和R是两个完全不同的速度参量!\n\n![image-20230608132042272](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608132042272.png)\n\n### 总的节点延迟\n\n![image-20230608132348394](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608132348394.png)\n\n* dproc = **处理时延**\n* dqueue = **排队时延**\n* dtrans = **传输时延**\n* dprop = **传播时延**\n\n![image-20230608142947297](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608142947297.png)\n\n## 流量强度\n\n### 流量强度=分组长度L*平均分组到达率a/链路带宽R\n\nL=分组长度 (bits)\n\na=平均分组到达率 average packet arrival rate\n\nR=链路带宽 (bps)\n\n**流量强度：traffic intensity = La/R**\n\n### 流量强度与延迟关系\n\nLa/R ~ 0: 分组稀疏到达,无队列,平均排队延迟极小接近于0\n\nLa/R -> 1: 分组猝发到达,形成队列,队列长度迅速增加,排队延迟大幅增大\n\nLa/R > 1: 输出队列平均位到达速率超过送走这些位的极限速率，输出队列持续增长，排队延迟趋于无穷大\n\n![image-20230621155021702](https://cdn.davidingplus.cn/images/2025/02/02/image-20230621155021702.png)\n\n## 分组丢失\n\n- **路由器输入链路和输出链路的缓冲区容量有限**\n- 当分组到达路由器**输入链路**发现缓冲区已满，则路由器只好丢弃分组\n- 当分组在路由器内部要**转发到输出链路**时发现输出缓冲区队列已满，路由器只好丢弃分组\n- 丢失的分组可能被前路由节点、源节点重传，或不重传\n- 丢包率或分组丢失率（packet loss rate/ratio）\n\n## 吞吐量\n\n* 网络吞吐量：\n\n  * 单位时间内**整个网络传输数据的速率或分组数**\n\n* bps或data packets per second\n\n* 吞吐量: 接收端接收到数据的比特速率 (bps )\n\n  瞬时吞吐量: 某一瞬间的吞吐量\n\n  平均吞吐量: 一段时间内的吞吐量均值\n\n## 各层次常用协议\n\n### 分层次结构\n\n![image-20230626145237281](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626145237281.png)\n\n### 应用层\n\n* 支持网络应用，报文传\n* FTP, SMTP, STTP\n\n### 传输层\n\n* 主机**进程间**的数据段传送\n* TCP、UDP\n\n### 网络层\n\n* **主机与主机**间分组传送\n\n* IP、路由协议\n\n### 链路层\n\n* **相邻网络节点间**的数据帧传送\n* PPP(Point to Point Protocol)，Ethernet\n\n### 物理层\n\n* 物理介质上的比特传送\n\n* 对等实体:\n  *  两台计算机上**同一层**所属的程序、进程或实体称为该层的对等程序、对等进程或对等实体\n\n![image-20230608195253093](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608195253093.png)\n\n# 第二章 应用层\n\n![image-20230625144139781](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625144139781.png)\n\n## 两种方式\n\n### 客户机/服务器 CS\n\n![image-20230625144543419](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625144543419.png)\n\n* 服务器：具有客户资源\n  * **总是打开的主机**\n  * 具有固定的、**众所周知的IP地址**\n  * 主机群集常被用于创建强大的虚拟服务器\n\n* 客户机：发出请求和接受数据\n  * 同服务器端通信\n  * 可以间断的同服务器连接\n  * 可以拥有**动态IP地址**\n  * **客户机相互之间不直接通信**\n\n### 对等 P2P方式\n\n![image-20230625144650971](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625144650971.png)\n\n## 进程通信\n\n* 进程\n  * 运行在端系统中的程序\n* 同一主机上的两个进程通过**内部进程通信机制**进行通信\n* 不同主机上的进程通过**交换报文**相互通信\n\n## 套接字\n\n* 又叫应用程序编程接口API\n\n## 进程寻址\n\n**IP地址+端口号**\n\n## web应用和HTTP\n\n* 网页\n\n* 由许多**对象**组成\n\n* **对象就是文件**，可以是HTML文件, JPEG图像, Java applet, 音频文件…\n\n  **多数网页由单个基本HTML文件和若干个所引用的对象构成**\n\n  * 每一个对象对应一个URL\n\n### 使用TCP：HTTP属于应用层，使用运输层的TCP进行传输\n\n* 1 客户初始化一个与**HTTP服务器80端口**的TCP连接(创建套接字)\n* 2 HTTP服务器接受来自客户的TCP连接请求, 建立连接\n* 3 Browser (HTTP client)和Web服务器 (HTTP server) **交换HTTP消息**(应用层协议消息)包括**HTTP请求和响应消息**\n* 4 最后结束，关闭TCP连接\n\n### HTTP是无状态协议\n\n* **HTTP服务器不维护客户先前的状态信息**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622095533346.png\" alt=\"image-20230622095533346\" style=\"zoom:67%;\" />\n\n### 非持久的HTTP连接\n\n![image-20230625160406926](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625160406926.png)\n\n* **每个TCP连接上只传送一个对象**，下载多个对象需要建立多个TCP连接\n\n* **HTTP/1.0使用非持久HTTP连接**\n\n* **非持久HTTP**详解\n\n  * 假设用户输入URL http://www.someSchool.edu/someDepartment/home.index 网页由1个HTML文件, 和10个jpeg图像构成\n  * 解析步骤\n\n  > 第一步：**建立TCP连接**\n  >\n  > * HTTP客户机初始化与服务器主机中HTTP服务器的**TCP连接**\n  > * 服务器中HTTP服务器**在80端口监听TCP连接**。收到请求连接，接受，建立连接，通知客户\n  >\n  > 第二步：**HTTP请求连接**\n  >\n  > * HTTP客户发送HTTP请求消息，包含**URL到TCP连接套接字**，消息指出客户所需要的**web对象**\n  > * HTTP服务器接受请求消息，产生一个**响应消息**，包含**被请求对象**，并发送这个消息到自身TCP连接套接字\n  > * **HTTP服务器结束TCP连接**\n  > * HTTP **客户接收**包含html文件的响应消息, 显示html. **解析**html文件，**找出10个jpeg对象**\n  > * **对十个引用对象重复上述操作(图中是并行的，串行的话需要一个一个按顺序来)**\n\n* 在非持久HTTP连接下，上述只需4RTT\n\n* **由于是非持续的，那么建立一次连接服务器返回消息之后就会断开连接，所以先建立TCP连接，发HTTP请求得到HTML对象，然后解析得到10个图片对象然后重新建立连接发送请求就得到对象了**\n\n* ![image-20230608210341182](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608210341182.png)\n\n* 缺点：\n\n  * 每个对象都需要2个RTT\n  * OS必须为每个TCP连接分配主机资源\n  * **大量客户的并发TCP连接形成服务器的严重负担**\n\n\n\n### 持久HTTP连接\n\n![image-20230625160449725](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625160449725.png)\n\n* **一个TCP连接上可以传送多个对象，也就是说建立TCP连接之后正常状态下等整个过程结束之后再断开，保证了持续性**\n* HTTP/1.1默认使用持久HTTP连接\n\n* 例题\n\n* ![image-20230608203521193](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608203521193.png)\n\n#### **不带流水线**(可以理解为串行)的持久HTTP连接\n\n- 客户先前响应消息收到,才发出新的请求消息\n- 每个引用对象经历1个RTT\n- ![51d4b34b494701d54e1445b79c393b2a](https://cdn.davidingplus.cn/images/2025/02/02/51d4b34b494701d54e1445b79c393b2a.png)\n\n#### 带流水线(可以理解为并行)的持久HTTP连接：最优解决方案\n\n- **HTTP/1.1默认使用**\n- 客户遇到1个引用对象就发送请求消息\n- 所有**引用对象只经历1个RTT**\n- ![image-20230608212737400](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608212737400.png)\n\n例子：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622101111027.png\" alt=\"image-20230622101111027\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622101120944.png\" alt=\"image-20230622101120944\" style=\"zoom: 80%;\" />\n\n### 响应时间模型\n\n* 定义往返时间RTT(Round-Trip Time):\n  * 响应时间:\n    - **1个RTT用于建立TCP连接**\n    - **1个RTT用于HTTP请求/响应消息的交互**\n    - **Html文件传输时间**\n  * **total = 2RTT+transmit time**\n* ![81f81feea0f30624e939411a8a1771e9](https://cdn.davidingplus.cn/images/2025/02/02/81f81feea0f30624e939411a8a1771e9.png)\n\n## HTTP报文格式\n\n* 请求报文（ASCII文本：易于人读的格式）\n\n![e36fc86eacfb811e01e5153481be1c8b](https://cdn.davidingplus.cn/images/2025/02/02/e36fc86eacfb811e01e5153481be1c8b.png)\n\n![c73668035eb8368cfebbce616778980a](https://cdn.davidingplus.cn/images/2025/02/02/c73668035eb8368cfebbce616778980a.png)\n\n* 响应报文\n\n![c3a4c084ae3a8e18b7a99cbdc7023330](https://cdn.davidingplus.cn/images/2025/02/02/c3a4c084ae3a8e18b7a99cbdc7023330.png)\n\n## cookie：跟踪用户\n\n**cookie文件是存在用户本地的!!!**\n\n**把无状态的Http协议进行状态化!!!**\n\n![image-20230625160547504](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625160547504.png)\n\n![image-20230625160642445](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625160642445.png)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622102736462.png\" alt=\"image-20230622102736462\" style=\"zoom:80%;\" />\n\nCookie和隐私：\n\n- Cookies允许网站更加了解你\n- 你可以给网站提供名字和e-mail给网站\n- 广告公司通过网站获得信息\n- **Cookies不适合游动用户**\n\n## web缓存(代理服务器)\n\n![image-20230626151239998](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626151239998.png)\n\n![image-20230625160723037](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625160723037.png)\n\n- **目标：在不访问服务器的情况下满足用户的Http请求**(代表**起始服务器**满足HTTP请求)\n- 一般有ISP(Internet服务提供商)架设\n\n**所有HTTP请求指向缓存**\n\n- **对象在缓存中：缓存器返回对象**\n- **否则缓存器向起始服务器发出请求，接收对象后转发给客户机**\n- 这么看起来缓存既可以充当服务器给用户返回对象，也可以充当客户端向起始服务器发送请求\n\n**为什么需要Web服务器？**\n\n- 减少对客户机请求的响应时间\n- 减少内部网络与接入链路上的通信量\n- 能从整体上大大降低因特网上的Web流量\n\n**条件get方法**\n\n**确认缓存服务器中的对象是否为最新的**，使用户拿到最新的数据\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622103720853.png\" alt=\"image-20230622103720853\" style=\"zoom: 67%;\" />\n\nweb缓存中的文件都有两个附加字段，last-modified最近一次修改时间和expires有效时间\n\n先请求web缓存，如果未过期，则直接返回；如果过期了，则请求原始服务器\n\n![image-20230625160849149](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625160849149.png)\n\n**web缓存向原始服务器发送请求，包含last-modified，和自己的进行比对，如果相同则返回304 not modified，不附加其他数据，如果已更改，就返回已更改的对象**\n\n![image-20230625161204742](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625161204742.png)\n\n## FTP文件传送协议\n\n### 概念\n\n![image-20230625154249351](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625154249351.png)\n\n### 主动模式\n\n![image-20230625154416832](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625154416832.png)\n\n### 被动模式\n\n![image-20230625154502992](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625154502992.png)\n\n## 电子邮件\n\n![image-20230626152139341](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626152139341.png)\n\n结构：**用户代理，邮件服务器，电子邮件使用的协议**\n\n![image-20230625154716555](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625154716555.png)\n\n![image-20230622104337427](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622104337427.png)\n\n过程\n\n![image-20230625154835044](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625154835044.png)\n\n**用户代理(UA)：**\n\n用户和电子邮件系统的接口\n\n用户代理向用户提供一个很友好的接口来发送和接收邮件，用户代理至少应当具有**撰写、显示和邮件处理**的功能\n\n**邮件服务器：**\n\n它的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况（已交付、被拒绝、丢失等）。\n\n**邮件服务器采用客户/服务器方式工作，**\n\n但它必须能够同时充当客户和服务器邮件发送协议和读取协议∶\n\n邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，如SMTP;\n\n邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3\n\n**SMTP用的是“推”（Push）的通信方式，POP3用的是“拉”（Pull）的通信方式**\n\n**电子邮件格式与MIME**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622104736561.png\" alt=\"image-20230622104736561\" style=\"zoom: 80%;\" />\n\n**多用途网际邮件扩充（MIME）**\n\n**由于SMTP只能传送一定长度的ASCII码，**\n\n许多其他**非英语国家的文字**（如中文、俄文，甚至带重音符号的法文或德文）就**无法传送**，\n\n且**无法传送可执行文件及其他二进制对象**，因此提出了用途网络邮件扩充\n\n### SMTP\n\n* Simple Mail Transfer Protocol\n\n* 客户使用 **TCP** 来可靠传输邮件消息到 **服务器端口号25**\n\n* **直接传送**: 发送服务器到接收服务器\n\n* 传输的3个阶段\n\n  * **连接建立(握手)**\n\n    发件人的邮件发送到发送方的邮件服务器的缓存中；\n\n    SMTP客户每隔一段时间就对邮件缓存扫描一次，如果发现有邮件就建立TCP连接\n\n  * **邮件消息的传输**\n\n    连接建立后，就可开始传送邮件。邮件的传送从 **MAIL 命令开始**，MAIL 命令后面有发件人的地址\n\n  * **连接释放(结束)**\n\n    邮件发送完毕后，SMTP 客户应**发送 QUIT 命令**。\n\n    SMTP 服务器**返回的信息是 221（服务关闭）**，表示 SMTP 同意释放TCP 连接\n\n* 命令/应答的交互\n\n  * 命令: ASCII文本格式\n  * 应答: 状态码及其短语\n\n* ![image-20230608215240462](https://cdn.davidingplus.cn/images/2025/02/02/image-20230608215240462.png)\n\n  ![0c3043dbb05cd1054b89892ab63b6d91](https://cdn.davidingplus.cn/images/2025/02/02/0c3043dbb05cd1054b89892ab63b6d91.png)\n\n* SMTP总结\n\n  * SMTP使用**持久连接**\n  * SMTP 要求邮件消息(header & body)必须是**7-bit ASCII**、\n\n* SMTP与HTTP的比较\n\n  * HTTP：**拉**协议\n  * SMTP：**推**协议\n  * HTTP: **每个对象封装在它各自的HTTP响应消息中发送**\n\n  * SMTP: **一个邮件内各个对象置于同一个邮件消息的多目部分发送**\n\n  ![image-20230622105516615](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622105516615.png)\n\n#### Mime\n\n**SMTP协议只能传送7bit的ASCII码文本数据，不能传可执行文件或者其他二进制对象**\n\n**SMTP不能传送多媒体文件，以及其他非英语国家的文字**\n\n**解决不能传送ASCII码数据的问题，一处多用途因特网邮件扩展MIME**\n\n**MIME还可以用于面向非ASCII码的Http！！！**\n\n![image-20230625155233199](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625155233199.png)\n\n### POP3和IMAP\n\nPOP也使用**客户/服务器的工作方式，在传输层使用TCP，端口号为110**。**IMAP4使用143**\n\nPOP有两种工作方式：\n\n**\"下载并保留\"和\"下载并删除\"**\n\n![image-20230625155503271](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625155503271.png)\n\n### 基于万维网的电子邮件\n\n![image-20230625155648766](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625155648766.png)\n\n### 邮件消息的格式\n\n* SMTP: 用来交换邮件消息的协议\n\n* RFC 822: **文本邮件消息格式标准**\n\n* 信头－头部行。如：\n\n  To:\n\n  From:\n\n  Subject:\n\n  这些头部不同于SMTP命令!\n\n  信体\n\n  邮件消息也必须是**ASCII字符**\n\n![93400a13f66ec3fee0072db5cd87baa4](https://cdn.davidingplus.cn/images/2025/02/02/93400a13f66ec3fee0072db5cd87baa4.png)\n\n## DNS\n\n### 关于主机名和域名\n\n![image-20230625162532115](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625162532115.png)\n\n### 概述\n\n![image-20230625151306770](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625151306770.png)\n\n### 域名系统\n\n![image-20230625151534819](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625151534819.png)\n\n* 功能\n  * **主机名到IP地址的转换**\n  * 主机别名：**一个主机可以有一个规范主机名和多个主机别名**\n  * **邮件服务器别名**\n  * **负载分配**：DNS实现冗余服务器：一个IP地址集合可以对应于同一个规范主机名\n* 特点：\n  * 分布式数据库：一个由分层DNS服务器实现的分布式数据库\n  * 应用层协议：DNS服务器实现域名转换 (域名/地址转换)\n\n* 为什么不集中式DNS？\n  * 单点故障\n  * 巨大访问量\n  * 远距离集中式数据库\n  * 维护\n  * 难以扩展\n\n* DNS分类\n\n![01194854ec68d8c2968c6345bddb268d](https://cdn.davidingplus.cn/images/2025/02/02/01194854ec68d8c2968c6345bddb268d.png)\n\n![image-20230625151837823](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625151837823.png)\n\n或者这么划分\n\n![image-20230625152255881](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625152255881.png)\n\n**根名字服务器**\n\n* 根名字服务器负责**记录顶级域名服务器的信息**\n\n**顶级域名服务器**\n\n* **负责顶级域名** com, org, net, edu, etc, 和**所有国家的顶级域名** uk, fr, ca, jp.\n\n**权威DNS服务器**\n\n在因特网上具有公共可访问主机（如Web服务器和邮件服务器）的每个组织机构必须提供公共可访问的DNS记录，\n\n这些记录将这些主机的名字映射为IP地址。\n\n组织机构的权威DNS服务器负责保存这些DNS记录。\n\n**多数大学和公司维护它们的基本权威DNS服务器**\n\n**本地DNS服务器**\n\n* 严格来说不属于该服务器的层次结构\n\n* **每个ISP（如居民区ISP、公司、大学）都有一个本地DNS也叫默认服务器**\n\n  当**主机发出DNS请求时，该请求被发往本地DNS服务器**。\n\n  起着**代理的作用**，转发请求到层次结构中。\n\n### 递归查询\n\n![9bbc0133011b7d318f02f94cdf59f468](https://cdn.davidingplus.cn/images/2025/02/02/9bbc0133011b7d318f02f94cdf59f468.png)\n\n### 迭代查询\n\n![b3dd4197116b05590c97e05ffcb62375](https://cdn.davidingplus.cn/images/2025/02/02/b3dd4197116b05590c97e05ffcb62375.png)\n\n总结\n\n**递归查询：我帮你查了，妈的；查不到我让你帮我查，查到了告诉我**\n\n**迭代查询：我不知道，但是我可以让你去找别人**\n\n**注意，本地域名服务器查不到直接向跟域名服务器请求，然后才是接下来的操作**\n\n**本地主机中也有DNS高速缓存，当高速缓存有的时候就不需要进入本地域名服务器了**\n\n![image-20230625152530509](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625152530509.png)\n\n#### 例题\n\n![image-20230625153307625](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625153307625.png)\n\n### DNS缓存和权威DNS记录更新\n\n![image-20230625153001648](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625153001648.png)\n\n* **一旦名字服务器获得DNS映射, 它将缓存该映射到局部内存**\n* **服务器在一定时间后将丢弃缓存信息**\n* **本地DNS服务器可以缓存TLD服务器的IP地址**\n\n### DNS记录\n\nRR 格式: (name, value, type,ttl)\n\n* Type=A（Address地址）\n  * name = 主机名\n    value = IP地址\n* Type=CNAME（canonical别名）\n  * name = 主机别名：www.ibm.com的真名为servereast.backup2.ibm.com\n    value = 真实的规范主机名\n\n* Type=NS（ name server ）\n  * name = 域名（如foo.com）\n    value = 该域权威名字服务器的主机名\n\n* Type=MX（mail exchange）\n  * name =邮件服务器的主机别名\n    value =邮件服务器的真实规范主机名\n\n![image-20230622111347168](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622111347168.png)\n\n### DNS协议\n\n* **查询报文与应答报文** , 但具有**同样的报文格式**\n\n* 报文头部\n\n  * **标识符: 16位**，查询和应答报文使用相同的标识符\n\n  * 标志:有若干个标志构成，分别标识不同的功能\n\n    查询/应答－0/ 1\n\n    查询希望是/非递归查询－1/0\n\n    应答可/否获得(支持)递归查询－1/0\n\n    应答是/否来自权威名字服务器－1/ 0\n\n![5c49159ae32dd32689a578363d97854b](https://cdn.davidingplus.cn/images/2025/02/02/5c49159ae32dd32689a578363d97854b.png)\n\n## 应用层协议小节\n\n![image-20230622103454264](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622103454264.png)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230626153219335.png\" alt=\"image-20230626153219335\" style=\"zoom:67%;\" />\n\n# 第三章 运输层\n\n**运输层通信的双方是进程到进程，而网络层是主机到主机**\n\n![image-20230624154115769](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624154115769.png)\n\n**运输层屏蔽了下层网络核心的细节，使应用进程看起来就好像是两个运输层实体之间有一条端到端的逻辑通信通道!!!**\n\n**运输层使用端口号来区分不同的应用进程！！！**\n\n![image-20230624154451660](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624154451660.png)\n\n## 概念\n\n**从通信和信息处理的角度看，传输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层**\n\n**传输层位于网络层之上，它为运行在不同主机上的进程之间提供了逻辑通信，而网络层提供主机之间的逻辑通信。**\n\n**显然，即使网络层协议不可靠（网络层协议使分组丢失、混乱或重复），传输层同样能为应用程序提供可靠的服务**\n\n**传输层提供应用进程之间的逻辑通信（即端到端的通信）**\n\n**与网络层的区别是，网络层提供的是主机之间的逻辑通信复用和分用。**\n\n在两个不同的**主机**上运行的**应用程序之间提供逻辑通信**\n\n* 传输层协议运行在**端系统**\n\n  * 发送方: 将**应用程序报文**分成**数据段**传递给网络层\n\n  * 接受方: 将**数据段重新组装成报文**传递到应用层\n\n* **两个进程**之间的逻辑通信\n* 可靠, 增强的网络层服务\n\n## 端口号\n\n**引入端口号的原因：不同操作系统对进程PID的表示不同，为了统一，就是用端口号来在网络中表示应用层的不同进程**\n\n![image-20230624155032903](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624155032903.png)\n\n##  多路复用和多路分解\n\n![image-20230626192530115](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626192530115.png)\n\n![image-20230626153907760](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626153907760.png)\n\n**应用层把应用层数据协议单元交给运输层，运输层判断采用udp还是tcp，分别封装为udp对应的用户数据报和tcp对应的tcp报文段，这称作复用，将对应数据交给网络层封装成IP数据报，这称作IP复用，接收方采取相反的策略即可**\n\n![image-20230624155324468](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624155324468.png)\n\n* 多路复用\n  * 多个**套接字收集数据**，用首部封装数据，然后将报文段传递到网络层\n* 多路分解\n  * 将接收到的**数据段传递到正确的套接字**\n\n![image-20230610092926777](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610092926777.png)\n\n* 多路分解工作过程\n  * 主机收到**IP数据报**\n    * 每个**数据报**有**源IP地址，目的IP地址**\n    * 每个**数据报搬运一个数据段**\n    * 每个**数据段**有源和目的端口号\n    * 主机用IP地址和端口号指明数据段属于哪个合适的套接字\n    * ![image-20230610093454073](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610093454073.png)\n\n![image-20230610095201477](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610095201477.png)\n\n![image-20230610095208923](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610095208923.png)\n\n**应用层的协议对应的运输层协议以及端口号**\n\n![image-20230624155741355](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624155741355.png)\n\n## TCP和UDP的对比\n\n**udp无连接，tcp有连接**\n\n![image-20230624160900650](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624160900650.png)\n\n**udp支持单播，多播和广播，而tcp只支持单播(建立连接)**\n\n![image-20230624161026024](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624161026024.png)\n\n**udp面向应用报文，tcp面向字节流**\n\n**udp仅加上一个udp数据首部；**\n\n**tcp将应用层协议数据单元视作连续的字节流，以字节为基础进行发送，然后在接受方重新拼接**\n\n![image-20230624161311376](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624161311376.png)\n\n**udp提供无连接不可靠的服务，tcp提供面向连接的可靠服务**\n\n![image-20230624161607588](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624161607588.png)\n\n**udp和tcp的首部不同**\n\n![image-20230624161902155](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624161902155.png)\n\n## UDP\n\n**UDP使用应用层协议提供可靠性!!!!!**\n\n### 概述\n\n* 提供**尽力而为**的服务\n* 数据报可能**丢失**、**传递失序的报文到应用程序**\n* **无连接**\n* **UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付**\n\n### UDP 存在原因\n\n* 无需建立连接，**减少延迟**\n* **简单**，在发送者和接受者之间不需要连接状态\n* **很小的数据段首部**。首部开销小，只有 **8 个字节**\n* **没有拥塞控制**，UDP 能够用尽可能快的速度传递\n* UDP 支持一对一、一对多、多对一和多对多的交互通信\n\n![image-20230610100140495](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610100140495.png)\n\n### 首部\n\n* UDP首部格式\n* ![image-20230622113800850](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622113800850.png)\n* ![image-20230610100226345](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610100226345.png)\n  * 首部字段8字节，4个字段，每个字段2字节\n  * 长度是首部和数据的总长度\n  * 源端口： 源端口号，**需要对方回信时选用**，不需要时全部置0\n  * 长度：UDP的数据报的长度（包括首部和数据）其最小值为8（只有首部）\n  * 校验和：检测UDP数据报在传输中是否有错，有错则丢弃。该字段是可选的，当源主机不想计算校验和，则直接令该字段全为0\n* 校验和的计算![image-20230610100731124](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610100731124.png)\n  * **17是协议代号，表示UDP**\n  * 伪首部的作用：\n    * **伪首部既不向下传送也不向上递交，而只是为了计算校验和**\n    * 通过**伪首部的IP地址检验**，UDP可以确认该数据报是不是发送给本机IP地址的\n    * 通过伪首部的**协议字段检验**，UDP可以确认IP有没有把不应该传给UDP而应该传给别的高层的数据报传给了UDP\n    * 伪首部的UDP长度=UDP数据包的UDP包长度字段值\n    * 识别一个通信应用需要**5个因素**。\"**源IP地址\"、\"目标IP地址\"、\"源端口\"、\"目标端口\"、\"协议号\"**。UDP首部只包含了（源端口和目标端口），用此来校验，如果其他三项信息被破坏，极有可能导致应收包应用收不到，不应该收包的应用收到。为此，有必要在通信中，验证这5项的识别码是否正确，就引入了伪首部的概念。\n\n### 校验和\n\n#### 伪首部(12个字节)\n\n![image-20230626154652376](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626154652376.png)\n\n**在计算校验和的时候，UDP数据报之前需要加上 12B 的伪首部，伪首部并不是UDP的真正首部，只是在计算校验和的时候，加在前面构成一个临时的数据报，校验和既不向下传送也不向上递交，只是为了计算校验和**\n\n![image-20230610104343725](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610104343725.png)\n\n* 校验和例子\n  ![image-20230622114417726](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622114417726.png)\n\n  * 求和时产生的进位必须回卷到结果上![image-20230610104505148](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610104505148.png)\n  * **累加和按位取反得到校验和**\n\n  ![image-20230626154905222](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626154905222.png)\n\n## TCP\n\n### MSS\n\n- **MSS: TCP 报文段中数据字段的最大长度，而 MSS 通常根据 MTU（最大链路层帧）来设置。**\n\n**熟知端口号：0-1023；可提供 2^16个 不同端口**\n\n**TCP 是在不可靠的 IP 层之上实现的可靠的(rdt服务)数据传输协议，它主要解决传输的可靠、有序、无丢失和不重复问题。**\n\n### 特点\n\n* 点到点：\n\n  * 面向连接的运输层协议\n  * 一个发送者，一个接收者\n  * 可靠按序的**字节流**\n\n* 可靠：\n\n  * 提供可靠的交付服务\n  * 传输的数据无差错，不丢失，不重复且有序\n\n* 面向字节流：\n\n  * 虽然应用程序和 TCP的交互是一次一个数据块（大小不等）\n  * 但TCP把应用程序交下来的数据仅视为一连串的**无结构的字节流**\n\n* 全双工数据：\n\n  * 允许通信双方的应用进程在任何时候都能发送数据\n  * 发送和接受双方都设有发送缓存和接收缓存，临时存放双方通信的数据\n  * 同一个连接上的**双向数据流**\n  * **MSS: 最大报文段长**\n\n  \n\n* 没有信息边界\n\n  * 流水线\n\n* TCP**拥塞控制**设置窗口大小\n\n  * 收发缓冲区\n\n* 面向连接\n\n  * 在数据交换前握手\n  * 初始化发送方和接收方数据\n\n* **流量控制**\n\n  * **发送方不会淹没接收方**\n\n### 报文段结构\n\n报文段分为首部和数据两个部分\n\n#### **MSS：TCP允许的最大数据段长度!!!不包含TCP首部!!!**\n\n#### 首部(20固定长度+40扩展首部)\n\n##### 序号\n\n**32bit，指出本报文段数据载荷的第一个字节的序号**\n\n![image-20230624194645563](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624194645563.png)\n\n##### 确认号\n\n代表希望收到的下一个数据载荷第一个字节的序号，页是最前面所有数据的确认\n\n![image-20230624194827426](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624194827426.png)\n\n**在建立连接之后所有的报文段都设置ACK=1，ACK=0的数据无效**\n\n![image-20230624194924537](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624194924537.png)\n\n##### 数据偏移\n\n**4bit，并且以4字节为单位，实际上指出了TCP首部的长度，实际大小取决于扩展首部**![image-20230624195352270](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624195352270.png)\n\n##### 保留\n\n占6bit，保留为今后使用，目前设置为0\n\n![image-20230624195520027](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624195520027.png)\n\n##### 窗口\n\n**指出发送本报文一方的接收窗口**\n\n![image-20230624195651516](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624195651516.png)\n\n##### 校验和\n\n**计算检验和时需要加上12字节的伪首部，和udp一样**\n\n![image-20230624195812962](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624195812962.png)\n\n##### SYN同步标志位\n\n![image-20230624200003160](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624200003160.png)\n\n##### FIN终止标志位\n\n![image-20230624200030220](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624200030220.png)\n\n##### RST复位标志位\n\n![image-20230624200101317](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624200101317.png)\n\n##### PSH推送标志位\n\n![image-20230624200125573](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624200125573.png)\n\n##### URG紧急标志位\n\n![image-20230624200206137](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624200206137.png)\n\n##### 选项\n\n![image-20230624200330171](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624200330171.png)\n\n##### 填充\n\n![image-20230624200343658](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624200343658.png)\n\n* 首部格式 **20字节**\n\n![image-20230611111822653](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611111822653.png)\n\n> 源端口目的端口：2字节\n>\n> **序号Seq**：**4字节**，TCP连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的**数据的第一个字节的序号**\n>\n> **确认号**：**期望接收**的下一个报文段的数据的第一个字节的序号；如果是N，则表示到序号 N-1 为止，所有数据都正确收到\n>\n> 数据偏移：**4比特，以32为为单位，首指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远；因此当此字段的值为 15 时，达到 TCP 首部的最大长度 60B**\n>\n> 紧急位 URG：URG=1时，表明紧急指针字段有效。它告诉系统此报文段中有**紧急数据**，应尽快传送（相当于高优先级的数据）\n>\n> **确认位 ACK：确认。只有当ACK=1时确认号字段才有效。当ACK=0时，确认号无效；TCP规定，在连接建立之后所有传送的报文段都必须把ACK置为1**\n>\n> 推送位 PSH：接收方TCP收到PSH=1的报文段，**就尽快地交付给接收应用进程，而不再等到整个缓存都填满后再向上交付**\n>\n> 同步位 SYN：**SYN=1 表示这是一个连接请求或连接接收报文**\n>\n> 终止位 FIN：**用来释放一个连接**。当 FIN = 1时，表明此报文段的发送方的数据已发送完毕，并要求释放传输连接。\n>\n> RST：当RST=1时表示出现严重差错，必须释放连接重新建立连接\n>\n> FIN：FIN=1，表明次报文段的发送端数据已发送完毕并要求释放连接\n>\n> 窗口：2字节，让对方设置发送窗口的依据。单位是字节\n>\n> 检验和：2字节，**检验首部和数据两个部分。计算检验和时，要在TCP报文段前面加上12字节的伪首部(和UDP相同)**\n>\n> 保留字段：6位，全为0\n\n![image-20230611115955959](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611115955959.png)\n\n### 可靠数据传输\n\n基本概念\n\n![image-20230624112452840](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624112452840.png)\n\n**有线链路误码率较低，一般交给运输层来进行处理；但是无线链路易受干扰，误码率比较高，要求数据链路层必须提供可靠数据传输服务**\n\n![image-20230624113111919](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624113111919.png)\n\n#### 停等协议SW\n\n![image-20230624141846466](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624141846466.png)\n\n确认与否认：\n\n**发送方发送一个数据分组之后，必须停止下来等待接收方对于该分组的确认ACK，确认之后才能进行下一个分组的发送，如果发生误码，接收方通过fcs段检测到误码之后就会发送NAK，发送方就重传该分组，所以在收到确认之前，发送方不能删除该分组的缓存**\n\n超时重传：\n\n**若分组发生丢失，这种情况在数据链路层的传递不太容易发生，但是在不同网络之间，通过路由器连接形成的复杂网络系统下就是经常发生的事情，这个时候需要设置一个超市定时器，如果超时了仍然没有收到确认，那么有可能发生了丢失，立即重传**\n\n![image-20230624142621012](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624142621012.png)\n\n确认丢失：\n\n确认ACK丢失了，超时进行重传，那么接收方如何判断收到的是相同的分组呢？\n\n给发送数据的分组加上序号，**在停等协议中使用01即可，一个bit位**，当接收方发现两个数据相同则丢弃；\n\n那么如果确认分组迟到了呢？第四个图\n\nACK0迟到了，导致超时重传DATA0，接收方收到DATA0之后将其丢弃并且发送ACK，那么这个时候发送方就受到了两个一样的确认分组了，同理带上序号，ACK0第二次收到就被丢弃；在前面收到ACK0的时候发送DATA1，接收方收到并且发送ACK1，这就和前面的不同了，所以可以接着发送下一个数据\n\n**由此可见，序号的作用是用来判断该分组和上一个分组是否相同，所以用01就可以了，一个bit位**\n\n信道利用率\n\n![image-20230624143449246](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624143449246.png)\n\n信道利用率一般比较低，如果超时重传那更低了，所以产生了另外两种协议\n\n#### 回退N帧协议GBN\n\n**是一种连续ARQ协议**\n\n无差错情况\n\n**发送窗口和接收窗口，在回退N帧协议中，接收窗口大小固定为1，发送方看情况**\n\n**假设这里用3个bit，也就是0-7；发送窗口的大小取值范围为![image-20230624144647008](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624144647008.png)，这里取5**，取1就是停等协议\n\n**发送方在发送的过程中，可以连续将发送窗口内的分组发给接收方，假设正确接收，每接受一个，接收方就返回一个ACK确认分组，并且把接收窗口后移，发送方接收到确认分组之后就把发送窗口后移，并且可以将确认完的分组将缓存中删除了**\n\n**注意，接受并且后移的时候分组的序号要和窗口当前的序号相匹配**\n\n![image-20230624144535472](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624144535472.png)\n\n累计确认\n\n接收方可以不用一个一个发送确认，可以用累计确认，比如ACK1表示1及其以前的所有分组被正确接收，也就是0 1\n\n这里假设发送ACK1和ACK4，ACK1丢失了，但是可以通过ACK4得知已经正确接收，所以省掉了重传的步骤\n\n**即使发生确认分组丢失，发送方也不一定就必须重传!**\n\n并且还可以减少网络资源的占用，减小接收方的开销等等\n\n![image-20230624145045893](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624145045893.png)\n\n有差错情况\n\n**这里5号分组发生了误码，被接受方丢弃了，剩余的分组与接收窗口不匹配，接收方无法接受，只能将这四个分组丢弃**\n\n![image-20230624145401922](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624145401922.png)\n\n**丢弃之后，每丢弃一个序号不匹配的分组，就发送一个已经接受的ACK，这里就是ACK4，发送方接收到这些确认分组之后，就知道发送出现了问题，根据具体实现来确定收到几个重复确认来重传，总之，要么就是不等计时器重传，要么就是等待计时器结束然后进行重传**\n\n**数据链路层的ACK和运输层的ack有区别，数据链路层的ACKn标识n及其以前的数据分组被正确接收**\n\n![image-20230624145520200](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624145520200.png)\n\nGO-Back-N\n\n![image-20230624145758063](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624145758063.png)\n\n**发送窗口超过上限举例**\n\n发送窗口在这里的范围显示是：1< Wt <=7，不能取8，当取8时如下\n\n发送方一次性发送0-7，接收方正确接收并且发送累计确认ACK7，但是确认分组丢失了，于是超时之后重传该分组，重复分组进来之后发现0和0匹配，可以接受，但是这个时候接受的是重复的分组，就出现了问题\n\n**接收方无法分辨新旧分组!!!!**\n\n![image-20230624145910991](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624145910991.png)\n\n总结\n\n![image-20230624150405134](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624150405134.png)\n\n#### 选择重传协议SR\n\n选择重传的接收窗口应该大于1，接收方只能按序接受正确到达的数据分组\n\n**选择重传应采用逐一确认而不是累计确认!!!**\n\n![image-20230624150914306](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624150914306.png)\n\n举例：\n\n本例中Wt==Wr==4\n\n**发送方发送0-3号分组，接收方接受的时候2号分组丢失了，接收方先接受01，发送确认分组，然后将接收窗口后移；接受3号分组，但是不能将接收窗口后移，因为接收到的是失序分组，然后返回ACK3**\n\n![image-20230624152052366](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624152052366.png)\n\n**发送方接收到01分组确认之后就将发送窗口后移，这时候45在里面，可以发送45号数据分组；与此同时，发送方接收到了3号确认分组，将3号分组的定时器暂停避免超时重传，表示已经收到，但是这个时候不能移动发送窗口，因为发送方收到的是失序的确认分组，需要等待2号分组定时器超时，然后进行重传**\n\n![image-20230624152248624](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624152248624.png)\n\n**超时之后重传2号分组，在这之前也许45号分组已经被正确接受，但是由于失序，不能移动接收窗口，发送方接受到确认之后，由于确认分组失序，不能移动发送窗口，并且需要暂停45计时器，现在就只剩下2号分组的重传了**\n\n![image-20230624152555898](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624152555898.png)\n\n**2号分组被正确接收后终于有序，接受窗口后移；发送方接收到确认分组后终于有序，发送窗口后移；进而可以进行后续的传输**\n\n![image-20230624152732620](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624152732620.png)\n\n发送，接受窗口尺寸问题\n\n![image-20230624152941675](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624152941675.png)\n\n**注意这里和回退N帧区别，一个是 2^(n-1)，一个是2^n -1**\n\n![image-20230624152948624](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624152948624.png)\n\n![image-20230624152934773](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624152934773.png)\n\n如果超出界限举例\n\n这个例子最大取4，我们取5\n\n**发送方发送0-4，接收方接受并且返回确认分组，但是0号确认丢失，发送窗口不能移动；但是接收窗口移动了，如图所示**\n\n**一段时间过后重传0号分组，接收方窗口中0存在，可以接受，但是这个0并不是我们想要的0，就导致了无法区分新旧数据分组；**\n\n**如果大小合适接收窗口中应该没有0，这个时候接收方知道确认分组丢失了，所以重新发送确认分组ACK0，发送方接受，正常运作**\n\n![image-20230624153312495](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624153312495.png)\n\n总结\n\n![image-20230624153631576](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624153631576.png)\n\n#### Tcp可靠数据传输的实现\n\n##### 比较\n\n![image-20230626163659858](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626163659858.png)\n\n![image-20230626162902828](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626162902828.png)\n\n**是以上上面三种协议为基础实现的，并没有独立使用哪一种**\n\n**TCP以字节为单位的滑动窗口实现可靠数据传输**\n\n![image-20230624172017010](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624172017010.png)\n\n补充：\n\n![image-20230624172654441](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624172654441.png)\n\n#### 利用率(重要!!!)\n\n**注意RTT是往返时延，L/R就是指的是传输速率!!!**\n\n![image-20230626160221179](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626160221179.png)\n\n![image-20230626160321100](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626160321100.png)\n\n##### 例题：\n\n![image-20230624172950070](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624172950070.png)\n\n**注意这里细节：**\n\n**序号500开始，再发送500，最后一个字节是999，ACK是期望收到，所以是ACK1000！！！**\n\n**TCP规定只能对按序到达的最高序号进行确认，所以这个1000实际上是累计确认!!!**\n\n### 可靠传输协议rdt\n\n![image-20230626155514095](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626155514095.png)\n\n![image-20230611131502756](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611131502756.png)\n\n* FSM：有限状态机\n  * 来表示发送方和接收方\n\n#### rdt1.0 完全可靠信道上的可靠数据传输\n\n![image-20230610104840840](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610104840840.png)\n\n#### rdt2.0 具有bit错误的信道\n\n![image-20230610105031837](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610105031837.png)\n\n* 提供了差错检测和接收方反馈(ACK,NAK)\n\n* ![image-20230610105600242](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610105600242.png)\n\n* 当没有错误时：![image-20230610105629761](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610105629761.png)\n\n* 当发生错误时：![image-20230610105640978](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610105640978.png)\n\n* 停-等协议\n\n  * 发送方发送一个报文，然后等待接受方的响应\n\n* Rdt2.0的致命缺陷\n\n  * **如果ACK/NAK混淆了会发生什么？**\n\n    * 发送方并不知道接收方发生了什么!\n\n      万能做法：**重发**\n\n      不能正确重发: 可能重复\n\n* **处理重复**: \n\n  发送方给每个分组加一个序号\n\n  在 ACK/NAK 混淆时发送方重发当前分组\n\n  接收方丢弃重复的分组（并不向上传递）\n\n  ——停等协议数据包需要多少序号？\n\n  * ==两个序号 (0,1) 就可以满足==\n\n#### rdt2.1发送方处理•两个序号 (0,1) 就可以满足混乱的ACK/NAKs\n\n![image-20230610110625349](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610110625349.png)\n\nrdt2.1接收方处理混乱的ACK/NAKs\n\n![image-20230610110928220](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610110928220.png)\n\n* ![image-20230610111910920](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610111910920.png)\n\n#### rdt2.2一个NAK不要的协议\n\n![image-20230610112013611](https://cdn.davidingplus.cn/images/2025/02/02/image-20230610112013611.png)\n\n![image-20230611101310353](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611101310353.png)\n\n#### rdt3.0 具有出错和丢失的信道\n\n![image-20230611102248943](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611102248943.png)\n\n![image-20230611102257034](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611102257034.png)\n\n![image-20230611102544124](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611102544124.png)\n\n![image-20230611102731005](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611102731005.png)\n\n性能\n\n![image-20230611102940505](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611102940505.png)\n\n![image-20230611102951612](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611102951612.png)\n\n ![image-20230611103359901](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611103359901.png)\n\n* 算出来的是发送方的利用率\n\n流水线技术 go-back-N\n\n* 流水线: 发送方允许发送多个 “在路上的”, 还没有确认的报文\n  * 序号数目的范围必须增加\n  * 在发送方/接收方**必须有缓冲区**\n\n* 增加了利用率![image-20230611103729317](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611103729317.png)\n\n\n\n滑动窗口\n\n* ![image-20230611103736771](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611103736771.png)\n\n* 发送方:\n\n  * 在分组头中规定一个k位的序号\n\n  * **窗口：允许的连续未确认的报文**\n\n* 接收方：\n\n  * ACK-only: 总是为**正确接收的最高序号的分组发送ACK**\n\n  * 可能生成重复的ACKs\n\n  * **只需要记住被期待接收的序号**expectedseqnum\n\n  * 接收到失序分组: \n\n    丢弃(不缓冲) -> 没有接收缓冲区!\n\n    重发最高序号分组的ACK![image-20230611105642815](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611105642815.png)\n\n选择性重传 **Selective Repeat, SR**\n\n* 接收方**分别确认已经收到的分组**\n\n  * 必要时，缓冲报文, 最后按序提交给上层\n\n* 发送者**只重发没有收到确认的分组**\n\n  * 对每个没有确认的报文发送者都要启动一个定时器(每个**未被确认的报文都有一个定时器**)\n\n* **发送窗口**\n\n      N 个连续序号\n        \n      **限制被发送的未确认的分组数量**\n\n* ![image-20230611110149363](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611110149363.png)\n\n* ![image-20230611110459865](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611110459865.png)\n\n  * 接收方收到窗口第一个ACK之后，向后移动一位\n    * 收到非首位的ACK，窗口不移动\n  * 接收方收到窗口第一个报文之后，向后移动一位\n    * 当失序接收时，窗口不移动，记下已接收的报文序号，当窗口中的序号全部接收时，**整体移动**\n\n窗口大小和序号大小的关系\n\n![image-20230611111352285](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611111352285.png)\n\n* 窗口≤序号空间大小的一半\n\n* 重发场景![image-20230611132911101](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611132911101.png)\n\n快速重传\n\n* 超时触发重传存在问题:超时周期往往太长——重传丢失报文之前要**等待很长时间**,因此**增加了网络的时延**\n\n  * 发送方可以在超时之前通过重复的ACK检测丢失报文段\n\n  * 发送方常常一个接一个地发送很多报文段\n\n  * 如果报文段丢失,则**发送方**将可能接收到**很多重复的 ACKs**\n\n  * 如果发送方收到一个确认后再收到**3个对同样报文段的确认**，发送方应意识到不对劲——生成三个重复ACK，是因为接收方存在缺失报文段\n\n    **启动快速重传**: 在定时器超时之前重发丢失的报文段\n\n![image-20230611133139299](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611133139299.png)\n\n### 流量控制\n\n运输层的流量控制和数据链路层的流量控制的区别是：\n\n**传输层**定义**端到端用户之间的流量控制**，\n\n**数据链路**层定义两个中间的**相邻结点**的流量控制。\n\n另外，数据链路层的**滑动窗口协议的窗口大小**不能动态变化，**传输层**的则可以**动态变化**\n\n![image-20230611143731217](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611143731217.png)\n\n* TCP连接的接收方有一个接收缓冲区\n* 发送速率和接收应用程序的提取速率匹配\n* 流量控制：**发送方不能发送的太多太快，让接收缓冲区溢出**\n  * **应用程序可能从这个缓冲区读出数据很慢**\n\n* 工作机制（假设 TCP **接收方丢弃失序的报文段**）\n  * 流量控制**使用接收窗口**:接收缓冲区的剩余空间\n  * 接收方在**报文段**中宣告接收窗口的**剩余空间**\n  * 发送方限制没有确认的数据**不超过接收窗口**\n\n#### 举例\n\n前面的过程不再赘述\n\n![image-20230624162643615](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624162643615.png)\n\n后续打破死锁\n\n**发送窗口为0之后启动持续计时器，为什么要引入持续计时器呢？**\n\n**如果等待接收方通知，如果这个报文丢失了那么两方就陷入了互相等待的死锁状态；**\n\n**当持续计时器超时，那么发送零窗口探测报文，如果为0返回确认，然后再启动一个持续计时器；**\n\n**值得一提的是，零窗口探测报文也是具有计时器的，当超时就重发**\n\n**那么接收窗口满了还能接受报文吗？TCP规定，像零窗口探测报文，确认报文，带有紧急事务的报文是必须被接受的!!!**\n\n![image-20230624163134819](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624163134819.png)\n\n### TCP建立连接：三次握手\n\n![image-20230624191349583](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624191349583.png)\n\n**第一步，设置SYN=1,给定一个初始序号seq=x，发送给Tcp服务器；**\n\n**第二步，服务器收到之后发送针对TCP连接请求的确认报文，SYN=1，ACK=1，seq=y，ack=x+1；TCP服务器进入同步已接收状态，TCP客户进入连接已建立状态**\n\n**TCP规定，SYN=1的请求连接的报文不能携带数据，但是需要消耗一个序号**\n\n**第三步，客户端发送针对TCP服务器确认的确认，ACK=1，seq=x+1，ack=y+1，这是一个普通的报文段，如果不携带数据不消耗序号，下一个序号从x+1开始!!!这时TCP服务器才进入连接已建立阶段**\n\n**为什么不用两次握手？**(面试常考)\n\n![image-20230624192151599](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624192151599.png)\n\n浪费资源，同时\n\n![image-20230625173604484](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625173604484.png)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622150704074.png\" alt=\"image-20230622150704074\" style=\"zoom:80%;\" />\n\n* 用户发送TCP **SYN 报文段到服务器**\n\n  * **客户机TCP向服务器的TCP发送请求连接的报文段**\n\n    **这个报文段置同步位SYN为1，同时指定一个初始的序号 seq = x**\n\n    **TCP规定，SYN不能携带数据，并且要消耗掉一个序号**\n\n  * 指定初始的序号\n\n  * 没有数据\n\n* 服务器接收SYN，**回复SYN/ACK报文段**\n\n  * 如同意建立连接，则向客户机发回确认，并为该TCP连接分配**缓存和变量**。\n\n    在确认报文段中，把**SYN位和ACK位都置1** ， **确认号是 ack=x +1** ，\n\n    同时也为自己选择一个**初始序号 scq=y** 。 注 意 ， **确认报文段不能携带数据，但也要消耗掉一个序号**\n\n  * 服务器分配缓冲区和变量\n\n  * 指定服务器的初始序号\n\n* 客户接收SYN/ACK，回复ACK报文段\n\n  * 当客户机收到确认报文段后，还要向服务器给出确 认，并为该TCP连接**分配缓存和变量** 。\n\n    确认报文段的**ACK位置1**，**确认号 ack=y+1** ，**序号seq=x+1**。\n\n    **该报文段可以携带数据， 若不携带数据则不消耗序号**\n\n  * 可能包含数据\n\n  ![image-20230611144616017](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611144616017.png)\n\n\n### TCP释放连接：四次挥手\n\n![image-20230624192947356](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624192947356.png)\n\n**第一步，TCP客户端向服务器发送终止报文，FIN=1，ACK=1,seq=u,ack=v，seq和ack针对上一次发送和接受的数据进行设置**\n\n**TCP规定FIN=1的终止报文段即使不携带数据也要消耗一个序号**\n\n**第二步，TCP服务器向客户端发送普通确认报文，ACK=1，seq=v，ack=u+1，seq和ack由上一条得出**\n\n**这样TCP客户到服务器单方向的传送就关闭了**\n\n**第三步，TCP服务器还可能进行一些数据传输，最后发送终止报文，FIN=1,ACK=1，seq=w，ack=u+1,w是根据自己这边数据传输得出的，u+1是因为客户端没有发送报文了，这是对u前面的重复确认**\n\n**第四步，TCP客户端发送普通的确认报文，ACK=1,seq=u+1,ack=w+1**\n\n注意一点：Tcp发送确认报文之后还要经过2MSL才会完全关闭，下面探讨为什么\n\n**如果最后一个报文段丢失了那么会导致服务器一直重发这条报文，所以需要设置一段等待时间**\n\n![image-20230624193652490](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624193652490.png)\n\n#### 保活计时器\n\n![image-20230624194027145](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624194027145.png)\n\n**TCP服务器为了避免TCP客户端出现问题而无法及时发送报文段，设置了一个保活计时器，每收到一个报文就重置一下该计时器**\n\n**如果到了规定时间还未收到数据，那么TCP服务器进程会像TCP客户进程发送探测保温段，如果发送了很多(10)个仍无响应，则关闭连接**\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622151317052.png\" alt=\"image-20230622151317052\" style=\"zoom:80%;\" />\n\n* **客户关闭套接字: **clientSocket.close()\n\n  Step 1: 客户发送 TCP **FIN 控制报文段到服务器**\n\n  \t该报文段的终止位 **FIN 置 1 ， 序 号 seq=u** ，它等于**前面已传送过的数据的最后一个字节的序号加1**，\n  \t\n  \tFIN报文段即使**不携带数据，也消耗掉一个序号**\n\n  Step 2: 服务器接收 FIN, **回复 ACK. 进入半关闭连接状态**\n\n  \t**确认号ack=u+1 ， 序 号 seq=w** ， 等于它**前面已传送过的数据的最后一个字节的序号加1**\n  \t\n  \t此时，从客户机到服务器这个方向的连接就释放了\n\n  Step 3: **服务器发送FIN**到客户，**客户接收 FIN, 回复 ACK**\n\n  进入 “time wait”状态等待结束时释放连接资源\n\n  Step 4: **服务器接收 ACK. 连接关闭**.\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230611144918305.png\" alt=\"image-20230611144918305\" style=\"zoom:80%;\" />\n\n![image-20230611145144608](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611145144608.png)\n\n### 拥塞控制\n\n![image-20230624164440408](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624164440408.png)\n\n拥塞控制是指**防止过多的数据注入网络**，**保证网络中的路由器或链路不至于过载**\n\n拥塞控制和流量控制的区别：\n\n拥塞控制是让**网络能够承受现有的网络负荷**，是一个全局性的过程，涉及所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。强调全局\n\n相反，流量控制往往是指点对点的通信量的控制，是个端到端的问题（接收端控制发送端），它所要做的是**抑制发送端发送数据的速率**，**以便使接收端来得及接收**。强调点对点\n\n* 术语\n\n  * **MSS：最大报文段**\n  * rwnd：拥塞控制窗口\n  * **ssthresh：满开始门限**\n\n* 拥塞：\n\n  * 从信息系角度：**太多源主机发送太多的数据**，速度太快以至于网络来不及处理\n\n  * 与流量控制不同\n\n  * 表现:\n\n    **丢失分组** (路由器的缓冲区溢出)\n\n    **长延迟** (在路由器的缓冲区排队)\n\n控制方法\n\n* 端到端拥塞控制\n  * **没有从网络中得到明确的反馈**\n  * 从**端系统观察到的丢失和延迟推断出拥塞**\n  * TCP采用的方法\n* 网络辅助的拥塞控制\n  * 路由器给端系统提供反馈\n  * 单bit指示拥塞 (SNA, DECnet, TCP/IP ECN, ATM)\n  * 指明发送者应该发送的速率\n\n#### TCP拥塞控制\n\n![image-20230611150227235](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611150227235.png)\n\n* 三个机制\n  * 慢启动\n  * AIMD\n  * 对拥塞事件做出反应\n\n归纳\n\n**只要网络没有出现拥塞，拥塞窗口就可以再大一些；只要出现拥塞，就减少一些**\n\n**判断是否出现网络拥塞：没有及时收到按时到达的确认报文(发生超时重传)**\n\n**发送方将拥塞窗口作为发送窗口**\n\n![image-20230624164700775](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624164700775.png)\n\n##### 慢启动\n\n**提前设置一个慢开始门限值，这里是16，然后采用指数的形式上涨，每次增加一倍；初值为1**\n\n![image-20230624165034674](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624165034674.png)\n\n* **连接开始时，CongWin=1MSS**\n  * **以2的指数方式增加速率**![image-20230611150506930](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611150506930.png)\n* ![image-20230611150944446](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611150944446.png)\n\n##### 拥塞避免算法\n\n**如果慢启动加倍后超过了门限值，那么发送窗口去门限值!!!**\n\n**超过慢开始门限之后每次增加一倍了，而是固定的增加1**\n\n![image-20230624165146364](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624165146364.png)\n\n**如果过程中丢失了几个报文，导致重传计时器超时，那么判断网络很可能出现了拥塞，那么如下操作：**\n\n**更新门限值为当前拥塞窗口的一半，设置拥塞窗口为1，重新开始慢启动**\n\n![image-20230624165440842](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624165440842.png)\n\n**每经过一个往返时延 RTT 就把发送方的拥塞窗口cwnd加1，而不是加倍**\n\n使拥塞窗口cwnd按线性规律缓慢增长（即加法增大），这比慢开始算法的拥塞窗口增长速率要缓慢得多\n\n##### 慢开始门限ssthresh\n\n- **防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置慢开始门限ssthresh状态变量**\n- **当cwnd < ssthresh时，使用慢开始算法**\n- **当cwnd == ssthresh时，可以使用慢开始算法，也可以使用拥塞避免算法**\n- **当cwnd > ssthresh时，使用拥塞避免算法**\n- **无论使用哪种算法，只要发送方判断网络出现拥塞，就把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半，把拥塞窗口cwnd设置为1，执行慢开始算法**\n- ![image-20230622154851864](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622154851864.png)\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230611151642399.png\" alt=\"image-20230611151642399\" style=\"zoom: 67%;\" />\n\n##### 快速重传和快速恢复\n\n![image-20230622160059642](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622160059642.png)\n\n上面的意思简单来说就是：当发送方连续收到**三个重复的 ACK 报文**时，直接重传对方尚未收到的报文段，而不必等待那个报文段设置的重传计时器超时\n\n![image-20230622155932347](https://cdn.davidingplus.cn/images/2025/02/02/image-20230622155932347.png)\n\n快速重传\n\n![image-20230624165850413](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624165850413.png)\n\n注意细节(大题考)\n\n**确认M2的意思是：我现在确认了M2，我想要的是M3!!!**\n\n**收到三个重复确认的时候就对相应的报文段立即重传，而不是等待计时器超时，超时了就可能认为网络拥塞，导致网络传输效率减慢**\n\n![image-20230624170425939](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624170425939.png)\n\n快恢复算法\n\n**针对只是个别报文段进行丢失的情况，在收到三个重复确认的时候启动快恢复算法而不是慢启动算法**\n\n**将慢开始门限和拥塞窗口都调为当前窗口的一半，开始拥塞避免算法；也有的把拥塞窗口调整为新的门限加3**\n\n**做题时记得加上3!!!**\n\n![image-20230624170813869](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624170813869.png)\n\n##### 注意(快速恢复阶段受到重复的ACK)\n\n![image-20230626211432664](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626211432664.png)\n\n**(在三个重复ACK之后)这个时候调成发送窗口为门限值大小!!!!!**\n\n![image-20230626163513696](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626163513696.png)\n\n![image-20230626163521386](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626163521386.png)\n\n#### 总结\n\n![image-20230611151806393](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611151806393.png)\n\n![image-20230611152335303](https://cdn.davidingplus.cn/images/2025/02/02/image-20230611152335303.png)\n\n* 当 CongWin 低于阀值, 发送方处于慢启动阶段, 窗口指数增长.\n* 当 CongWin 高于阀值, 发送方处于拥塞避免阶段, 窗口线性增长.\n* 当三个重复的ACK 出现时,阀值置为CongWin/2 并且CongWin 置为阀值加上3个MSS并进入**快速恢复阶段**，此时**每收到一个重复的ACK拥塞窗口增加1MSS**，**如果收到新的ACK则拥塞窗口置成阀值**）.\n* 当超时发生时 ，**阀值置为CongWin/2 并且CongWin 置为1 MSS.** \n\n# 第四章 网络层\n\n![image-20230626213312835](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626213312835.png)\n\n## 协议总览\n\n![image-20230626164519671](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626164519671.png)\n\n**可靠传输，面向连接(虚电路)；不可靠传输，无连接(数据报网络)**\n\n![image-20230624202157507](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624202157507.png)\n\n**通过TCP/IP协议栈的网际层来学习网络层的理论知识和技术**\n\n![image-20230624202306581](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624202306581.png)\n\n## 概念\n\n* 从发送方主机传输**报文段**到接收方主机\n* 发送方主机封装**报文段**(segments)为**数据报(datagrams)**\n* 接收方主机递交**报文段**给传输层\n* 在**每个**主机、路由器上都需要**运行网络层协议**\n* 路由器会检查通过它的所有**IP数据报头部字段**，然后根据目的的IP地址对数据报进行转发\n\n### 两个主要的网络层功能\n\n#### 转发**(forwarding)** (数据平面)(硬件实现)\n\n* **将分组从路由器的输入端口转移到正确的路由器输出端口**\n\n#### **路由**(routing)(控制平面)(软件实现)\n\n* **确定分组从发送方传输到接收方(目的主机)所经过的路径(或路由)**\n  * 路由算法\n  * ![image-20230612084523965](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612084523965.png)\n* 路由是端到端的路线。整体路线\n* 转发是局部具体怎么走\n* 两者的相互作用\n* 你要先路由确定路径我才能根据路径进行转发\n  * ![image-20230612084719972](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612084719972.png)\n  * **路由算法**确定通过网络的**端到端路径**\n  * 转发表确定**本路由器**上的**本地转发**\n\n## 数据平面和控制平面\n\n* **数据平面**\n\n  * 本地的，每个**路由器自身的功能**\n\n  * **决定抵达路由器输入端口的数据包如何转发到输出端口，进行路由器内部的数据报文从输入端口到输出端口的转发**\n\n* 控制平面\n\n  * **整个网络范围**\n  * 决定数据报在**端到端路径上的路由器之间**如何路由\n  * 两种控制平面的实现方式\n    * 传统的路由算法![image-20230612085204688](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612085204688.png)\n    * 软件定义网络 SDN![image-20230612085222116](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612085222116.png)\n\n## 虚电路和数据报网络\n\n虚电路\n\n**这个虚电路的建立是逻辑上的连接，和电路交换物理上的连接是不同的!!!**\n\n![image-20230624202545848](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624202545848.png)\n\n数据报网络\n\n**采用这种设计，把可靠数据传输的实现交给了上层的运输层来实现，而网络层是负责存储转发数据报就ok了**\n\n**网络的造价大大降低，运行方式灵活，能够适应多种应用**\n\n![image-20230624202734313](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624202734313.png)\n\n比较\n\n![image-20230624202931326](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624202931326.png)\n\n* **数据报网络提供网络层的无连接服务**\n* **虚电路网络提供网络层的连接服务**\n* 任何网络中的网络层只**提供两种服务之一，不会同时提供**\n* 传输层：**面向连接服务在网络边缘的端系统中实现**\n* 网络层：**面向连接服务在端系统及网络核心的路由器中实现**\n\n* 数据报网络特点![image-20230612090035382](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612090035382.png)\n\n### 数据报转发表\n\n* 采用地址范围建立表项![image-20230612090205350](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612090205350.png)\n* 对于给定的目的地址，使用**最长地址前缀匹配**来完成输出端口的查找\n  * ![image-20230612090312398](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612090312398.png)\n  * 路由器**转发表只维持转发状态信息**\n  * **转发表由选路算法修改；虚电路网络转发表随虚电路的建立和拆除更新**\n  * 一个端系统发送给另一个端系统的**一批分组可能在网络中选择不同的路径，到达的顺序可能不一致**\n* 数据报网络的特点\n  * **网络层服务模型简单**\n  * **端系统功能复杂**。**高层实现许多功能，如按序传送、可靠数据传输、拥塞控制和DNS名字解析等**\n  * 带来的结果\n    * 因特网**服务模型提供的服务保证最少**（可能没有！），对网络层的需求最小，使得互连使用各种不同**链路层技术的网络变得更加容易**\n    * 许多应用都是在位于网络边缘的主机(服务器)上实现\n\n## 路由器的工作原理\n\n![image-20230623104401684](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623104401684.png)\n\n### 结构及功能\n\n* 两个核心功能\n  * **运行路由算法/协议(OSPF,RIP,BGP)**\n  * 将分组从路由器的**输入端传送到正确的输出链路**\n* 路由器的体系结构\n  * ![image-20230612091315440](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612091315440.png)\n\n### 输入端功能\n\n* **线路端接**模块\n  * 将一条**物理链路端**接到**路由器的物理层**\n* **数据链路处理**模块\n  * 实现路由器的**数据链路层功能**\n* **查找与转发**模块\n  * 实现**查找与转发功能**，以便**分组通过路由器交换结构**转发到**适当的输出端口**\n  * 确定将一个到达的分组**通过交换结构转发给哪个输出端口**。通过**查找转发表**实现，这里的转发表是存储在**输入端口的内存中**\n  * 分布式交换\n    * 选路处理器计算转发表，给每个输入端口存放一份转发表拷贝\n    * 在每个输入端口本地作出交换决策，无需激活中央选路处理器\n    * 可避免在路由器中某个单点产生转发处理瓶颈\n    * 目的：**以线速完成输入端口的处理**\n    * 排队：如果数据报到达输入端口的速度快于输入端口将数据报转发到交换结构的速度，就会发生排队\n* ![image-20230612092020730](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612092020730.png)\n\n### 三种交换结构![image-20230612093013485](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612093013485.png)\n\n* 经内存的交换结构\n\n  * 输入端口与输出端口之间的交换**由CPU(选路处理器)控制完成**\n\n  * 输入端口与输出端口类似I/O设备：\n\n    * 当分组到达输入端口时，通过**中断**向选路处理器发出信号，将**分组拷贝到处理器内存**中；\n\n    * 选路处理器根据分组中的目的地址查表找出适当的输出端口，将**该分组拷贝到输出端口的缓存**中\n\n  * **交换速度受总线带宽的速度限制(每个分组穿过两次总线)**\n\n    * 若总线带宽为每秒写入或读出**B个**分组，则总的转发吞吐量 (分组从输入端口被传送到输出端口的总速率)**小于B/2**\n    * ![image-20230612093316557](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612093316557.png)\n\n* 经总线的交换结构\n\n  * 输入端口**通过一条共享总线将分组直接传送到输出端口**，不需要CPU选路处理器的干预\n    * 每次**只能有一个分组**通过总线传送\n    * 分组到达一个输入端口时，若总线正**忙**，会被暂时阻塞，在输入端口**排队**\n    * 路由器交换带宽**受总线速率控制**\n\n* 经交换矩阵的交换结构\n\n  * **纵横式交换机**：*由2*n条总线组成，*n* 个输入端口与*n* 个输出端口连接\n\n  * 到达输入端口的分组**沿水平总线**穿行，直至与所希望的输出端口的**垂直总线交叉点**\n\n    * 若该条**垂直总线空闲**，则分组被**传送到输出端口**\n    * 否则，该到达的分组被**阻塞**，必须在输入端口**排队**![image-20230612094206251](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612094206251.png)\n\n  * 输出端口：\n\n    * 取出存放在输出端口内存中的分组，并将其传输到输出链路上\n    * 当交换结构将分组交付给**输出端口的速率超过输出链路速率**，就需要排队与缓存管理功能。当输出端口的缓冲区溢出时，就会出现延时和丢包![image-20230612094508801](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612094508801.png)\n\n    ![image-20230612094520528](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612094520528.png)\n\n  * 输入端口排队![image-20230612094720975](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612094720975.png)\n\n### 网络层转发分组的流程\n\n相邻直接传，否则查表传，特定>到达>默认，否则出错\n\n1、从数据报的首部提取目的主机的IP地址D，得出目的网络地址N\n\n2、若网络N与此路由器直接相连，则把数据报直接交付给目的主机 D，这称为路由器的直接交付；否则是间接交付，执行步骤 3\n\n3、若路由表中有目的地址为D的特定主机路由（对特定的目的主机指明一个特定的路由，通常是为了控制或测试网络，或出于安全考虑才采用的），\n\n则把数据报传送给路由表中所指明的下一跳路由器；否则，执行步骤 4。\n\n4、若路由表中有到达网络N的路由，则把数据报传送给路由表指明的下一跳路由器∶ 否则，执行步骤 5\n\n5、路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器;否则， 执行步骤6\n\n6、报告转发分组出错\n\n## IP数据报\n\n### 发送过程\n\n**IP数据报发送可以直接发到本网络，也可以通过路由器转发到其他网络，如果发到本网络称作直接交付，发到其他网络称作间接交付；**\n\n**IP数据报中包含源IP地址和目的IP地址，IP数据报到达路由器的位置，先检查首部看是否出错，如果出错发送ICMP差错报告报文，路由器查路由表，把目的地址和子网掩码相与，如果得到的目的网络不匹配，则查下一项；查到匹配的则根据吓一跳进行转发，如果查不到则丢弃并且给发送方返回信息**\n\n**注意发送过程中源IP和目的IP地址是不变的，修改的是源MAC地址和目的MAC地址!!!**\n\n![image-20230625090650029](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625090650029.png)\n\n例题\n\n**中继器和集线器工作在物理层，既不隔离冲突域也不隔离广播域**\n\n**网桥和交换机(多端口网桥)工作在数据链路层，可以隔离冲突域，不能隔离广播域**\n\n**路由器工作在网络层，既隔离冲突域，也隔离广播域**\n\n![image-20230625091612689](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625091612689.png)\n\n例题\n\n注意要配置好默认网关\n\n![image-20230625091935015](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625091935015.png)\n\n### 首部\n\n![image-20230625104050465](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625104050465.png)\n\n#### 版本\n\n![image-20230625104131427](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625104131427.png)\n\n#### 首部长度\n\n![image-20230625104221458](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625104221458.png)\n\n#### 区分服务\n\n只有使用区分服务该字段才有作用，一般情况不使用\n\n![image-20230625104308971](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625104308971.png)\n\n#### 总长度\n\n表示总长度(首部+数据载荷)\n\n**IP数据报是16位，理论上的最大长度是2的16次方-1，65535**\n\n**首部长度以四字节为单位，总长度以字节为单位!!!**\n\n![image-20230625104431604](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625104431604.png)\n\n#### 标识，标志，片偏移(用于IP数据报分片)\n\n![image-20230625104601025](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625104601025.png)\n\n**标识：标识各个分片数据报同一个数据报分片下来的**\n\n**标志：DF 1表示不允许分片，0表示允许**\n\n**MF 1表示后面还有分片 0表示最后一个分片**\n\t\n**保留位 必须置0**\n\n**片偏移：指出分片数据包的数据载荷部分在原来的数据报上偏移了多少的位置，以8字节为单位(写的时候注意要除以8)，并且片偏移量必须为整数!!!**\n\n![image-20230625104729522](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625104729522.png)\n\n##### IP分片举例\n\n![image-20230625110152268](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625110152268.png)\n\n![image-20230625110210150](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625110210150.png)\n\n#### 生存时间TTL(与路由环路相关)\n\n![image-20230625111000783](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625111000783.png)\n\n举例：防止路由环路\n\n![image-20230625111025162](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625111025162.png)\n\n#### 协议(熟悉)\n\n![image-20230625111137796](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625111137796.png)\n\n#### 首部检验和(如何计算)\n\n**IP只计算首部，tcp,udp需要包含首部和数据**\n\n![image-20230626173204731](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626173204731.png)\n\n![image-20230625111418457](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625111418457.png)\n\n#### IP地址\n\n![image-20230625111509445](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625111509445.png)\n\n### 例题\n\n注意：\n\n**1.首部+数据载荷 对应MTU，记得要加上首部!!!也就是数据链路层的数据部分最大值!!!**\n\n**2.片偏移量是以8字节为单位，并且一定是整数，所以数据载荷部分记得取8的整数倍数!!!**\n\n![image-20230625112306082](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625112306082.png)\n\n#### 学校PPT所讲\n\n![image-20230612094758546](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612094758546.png)\n\n* 各功能\n  * 版本号：4位。表示该IP数据报使用的IP协议版本。目前Internet中使用的主要是TCP/IP协议族中版本号为4的IP协议\n  * 首部长度：4位。此域指出**整个报头的长度**（包括选项）\n    * 该长度是以**32位二进制数为一个计数单位**的\n    * **接收端**通过此域可以**计算出报头在何处结束及从何处开始读数据**\n    * 普通IP数据报（没有任何选项）该字段的值是**5（即20个字节的长度）**\n  * 服务类型（TOS、type of service）：8位。服务类型字段的8位分成了5个子域![image-20230612095340972](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612095340972.png)\n  * 长度：16位。总长度字段是指**整个IP数据报的长度（报头区+数据区）**，以字节位单位\n    * 利用头部长度字段和总长度字段就可以计算出IP数据报中**数据内容的起始位置和长度**\n  * 生存时间(寿命 TTL，time to live)：占用8位二进制位\n    * 指定了数据报可以在网络中传输的最长时间\n    * TTL的初始值由源主机设置（通常为32、64、128或256），一旦经过一个处理它的路由器，它的值就减1。当该字段为0时，数据报就丢弃，并发送**ICMP**报文通知源主机，因此可以防止进入一个循环回路时，数据报无休止地传输下去\n  * 高层：占用8位二进制位\n    * IP协议可以承载各种上层协议，目标端根据协议标识就可以把收到的IP数据报送到**TCP或UDP**等处理此报文的上层协议了\n  * 首部检查和\n    * 占用16位二进制数\n      * 用于协议**头数据有效性**的校验\n      * 保证IP**报头区在传输时的正确性和完整性**。头部检验和字段是根据IP协议头计算出的检验和，它**不对头部后面的数据进行计算**\n      * 原理：发送端首先将**检验和字段置0**，然后对头部中每16位二进制数进行**反码求和**的运算，并将结果存在校验和字段中。 由于接收方在计算过程中包含了发送方放在头部的校验和，因此，如果头部在传输过程中没有发生任何差错，那么**接收方计算的结果应该是全1**。\n  * 源IP地址：占用32位二进制数，表示发送端IP地址\n  * 目的地址：占用32位二进制数，表述目的端IP地址\n\n##### 分片和重组\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230622164525685.png\" alt=\"image-20230622164525685\" style=\"zoom:80%;\" />\n\n* 分片：\n  * 把**一个数据报**为了适合网络传输而分**成多个数据报**的过程称为分片，被分片后的各个IP数据报可能**经过不同的路径**到达目标主机\n  * 一个IP数据报在传输过程中可能被分片，也可能不被分片。如果被分片，分片后的IP数据报和原来没有分片的IP数据报结构是相同的，即**也是由IP头部和IP数据区两个部分组成**![image-20230612103347388](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612103347388.png)\n  * 分片后的IP数据报，**数据区是原IP数据报数据区的一个连续部分**，头部是原IP数据报**头部的复制**，但与原来未分片的IP数据报头部有两点主要不同：**标志和片偏移 **\n    * 标志：在IP数据报头部有一个叫标志的字段，用3位二进制数表示![image-20230612103822809](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612103822809.png)\n  * —片偏移：IP数据报被分片后，各片数据区在原来IP数据区中的位置用**13位片偏移来表示**。上图中分片1的偏移为0；分片2的偏移为600；分片3的偏移为1200实际在IP地址中,由于偏移是以**8个字节为单位**进行计算的,因而在IP数据报中分片1的偏移是0；分片2的偏移是75；分片3的偏移是150\n* 重组\n  * 当分了片的IP数据报到达最终目标主机时，目标主机对各分片进行组装，恢复成源主机发送时的IP数据报，这个过程叫做IP数据报的重组。\n  * IP数据报头部中，**标识**用16位二进制数表示，它**唯一地标识主机发送的每一份数据报**\n    * 在一个数据报被分片时，每个**分片仅把数据报“标识”字段的值原样复制一份**，所以一个数据报的所有分片具有相同的标识\n  * 目标端主机重组数据报的原理:\n    * 根据“**标识**”字段可以确定收到的分片属于原来哪个IP数据报\n    * 根据“**标志**”字段的“**片未完MF**”子字段可以确定分片是不是最后一个分片\n    * 根据“**偏移量**”字段可以确定分片在原数据报中的位置\n\n![image-20230612110021542](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110021542.png)\n\n### ip地址\n\n#### 概述\n\n**IPV4地址就是给因特网上的每一台主机或者路由器的每一个接口分配一个全世界范围内唯一的32位bit的标识符**\n\n![image-20230624203130971](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624203130971.png)\n\n#### 分类编制的IPV4\n\n![image-20230624203408369](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624203408369.png)\n\n##### D类多播地址\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230624211609006.png\" alt=\"image-20230624211609006\" style=\"zoom: 80%;\" />\n\n![image-20230624211240221](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624211240221.png)\n\n##### A类\n\n![image-20230624203621544](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624203621544.png)\n\n##### B类\n\n![image-20230624203836527](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624203836527.png)\n\n##### C类\n\n![image-20230624203952543](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624203952543.png)\n\n##### 特殊IP地址\n\n![image-20230624204059658](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624204059658.png)\n\n![image-20230612110124002](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110124002.png)\n\n* IPV4编址\n\n  * ![image-20230612110205717](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110205717.png)\n\n  * ![image-20230612110226430](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110226430.png)\n\n    * 分为主机号和网络号\n\n  * 传统的IP地址分类![image-20230612110306612](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110306612.png)\n\n    * A类地址：第一个字节作为网络地址，**最高位为0**，其余的三个字节作为主机地址。![image-20230612110425765](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110425765.png)\n\n    * B类地址：l两个字节作为网络地址，**最高位为10**，其余的两个字节作为主机地址![image-20230612110524582](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110524582.png)\n\n    * C类地址：利用IP地址的前三个字节作为网络地址，最高位为110，最后一个字节作为主机地址![image-20230612110540514](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110540514.png)\n\n    * 特殊IP地址段![image-20230612110614270](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110614270.png)\n\n      ![image-20230612110744135](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612110744135.png)\n\n    * 同一局域网上的主机或路由器的IP地址中的网络号必须相同\n\n    * **交换机互连的网络仍然是一个局域网**，只能有一个网络号\n\n    * 路由器总是具有两个或两个以上IP地址\n\n    * 当两个路由器直接相连时，在连线两端的接口处，可以指明IP地址也可以不指明IP地址\n\n#### 划分子网的IPV4\n\n**为什么要划分子网呢？**\n\n**如果不划分子网，那么对于新的主机网络，就需要构建新的网络，申请新的网络号，如下弊端：**\n\n![image-20230624204819614](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624204819614.png)\n\n**用子网掩码可以表示借用了多少位主机号来充当子网号**\n\n![image-20230624204712748](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624204712748.png)\n\n##### 例题\n\n![image-20230624205143265](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624205143265.png)\n\n![image-20230624205227085](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624205227085.png)\n\n##### 子网号能否为全0或者全1\n\n**在 ABC类 划分子网时，子网号不能为全0或全1\n在 CIDR 划分子网时，子网号可以为全0或全1**\n\n![image-20230624205428971](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624205428971.png)\n\n![image-20230624205436720](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624205436720.png)\n\n##### 默认子网掩码\n\n主机号不管划不划分，讲子网号和主机号全取0\n\n![image-20230624205935497](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624205935497.png)\n\n#### 无分类编制的IPV4(CIDR)\n\n##### 表示方法\n\n![image-20230624210214522](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624210214522.png)\n\n举例\n\n**聚合C类网的数量是指这个地址块相当于多少个C类网络的数量**\n\n**C类网络主机号8位，因此12-8，留出4位当子网号，就是2的4次方**\n\n![image-20230624210645096](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624210645096.png)\n\n##### 路由聚合(构造超网)\n\n**减少路由表的占用，对R1的5条路由信息合成一条！**\n\n**寻找共同的前缀，作为新的IP地址的网络前缀，然后主机号取0就得到了这个目的网络号**\n\n**值得主要注意的是，如果出现了多个匹配项，选择网络前缀最长的那个，称为最长前缀匹配。这样的路由更加具体**\n\n![image-20230624211713812](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624211713812.png)\n\n##### 例题\n\n![image-20230624212025339](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624212025339.png)\n\n![image-20230624212055969](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624212055969.png)\n\n#### IP地址的应用规划\n\n##### 定长的子网掩码\n\n![image-20230625084304792](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625084304792.png)\n\n**注意看题目给出的是主机还是总的IP地址需求个数，记得根据情况是否加上网络地址，广播地址和路由器接口地址!!!!**\n\n**注意，这些合计的IP地址数都是主机号决定的，而对于分类编址的IPV4的子网号不能取同0和同1，这个和这些没关系**\n\n**注意，分类编址子网号不能全0和全1，CIDR是可以全0和全1的**\n\n![image-20230625084912251](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625084912251.png)\n\n##### 变长的子网掩码(CIDR重点)\n\n![image-20230625085219751](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625085219751.png)\n\n**注意分配原则：每个子块的起点位置不能随意选取，只能选取块大小整数倍的地址作为起点，建议从大的子块开始分配!!!**\n\n**注意这里的子网所需地址数量普通情况下是大于主机数量+网络地址+广播地址+路由器接口地址，但是我们划分子网主机号位数得出的子网地址数是2的n次方倍，这样虽然划分的子网中有地址浪费，但是大大减小了；并且也能选取块大小整数倍的地址为起点**\n\n![image-20230625085535320](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625085535320.png)\n\n#### 子网划分老师所讲\n\n##### 划分子网\n\n![image-20230612111124320](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612111124320.png)\n\n* 划分子网的方法是**从主机号借用若干个比特作为子网号**，剩下的主机位为主机号\n* 子网特点：\n  * 设备接口的**IP地址具有同样的网络部分**\n  * 没有路由器的介入，**物理上能够相互到达**\n* 子网掩码\n  * l子网号字段长度是可变的，因此，为了确定子网地址，IP协议提供了子网掩码的概念 。\n  * l子网掩码用来**确定网络地址（包括网络号和子网号）**和**主机地址的长度**。子网掩码长为**32位比特**，其中的**1对应于IP地址中的网络号和子网号**，而子网掩码中的**0对应于主机号**。![image-20230612111333291](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612111333291.png)\n\n##### 子网划分技术\n\n* 主机号**全0的地址不能用**，它被用做表示该子网的**子网号**；主机号**全1的也不能用**，它用于**本子网的广播**。因此每个子网所能容纳的主机数是**2^N-2**，N是主机号位数![image-20230612111717314](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612111717314.png)\n\n##### 无分类域间路由CIDR\n\n* Classless Inter-Domain Routing，CIDR\n\n* lCIDR消除了传统的A类、B类和C类地址的概念。\n\n* 使用**斜线记法，**又称为CIDR记法来**区分网络前缀和主机号**，即在IP地址后面加上一个斜线“/”，**斜线后面用一个数字指定网络前缀的长度**。\n\n* 构造超网![image-20230612113204774](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612113204774.png)\n\n* ![image-20230612112136182](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612112136182.png)\n\n* 层次寻址，路由聚合![image-20230612112424214](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612112424214.png)\n\n* 练习：![image-20230612112459665](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612112459665.png)\n\n  > （1）\n  >\n  > 以最多台数的部门（60台）为准，需要的最接近数为2^6=64，故要从最后个字节借8-6=2位，\n  >\n  > 子网分别为 202.1.1.0, 202.1.1.64, 202.1.1.128, 202.1.1.192，在这4个其中任选3个即可。掩码均为255.255.255.192。\n  >\n  > （2）\n  >\n  > 若以最多台数的部门（120台）为准，仅能分两个子网，无法满足。故应采用CIDR法：\n  >\n  > 首先以最小需求台数部门为准（60台），此时主机号位数需要6位（因为60=<2^6-2），则子网号位数为8-6=2位，然后将子网划分出来。此时和（1）一样；\n  >\n  > 接下来，部门2、3可以直接在4个子网中任选两个，部门1选剩下2个以满足120台的要求（但这两个子网要连续，以便用CIDR法合并之，做超网）。比如202.1.1.128、202.1.1.192分别给部门2、3，部门1用202.1.1.0、202.1.1.64。\n  >\n  > （3）最后将各部门IP段用CIDR超网形式描述，以便对外发布：\n  >\n  > 部门1：202.1.1.0/25; (注意含义：表示前25位是网络号，且最后一个字节最高位为0，后面7位是主机号)\n  >\n  > 部门2：202.1.1.128/26; (最后一个字节最高两位为10，后面6位是主机号)\n  >\n  > 部门3：202.1.1.192/26; (最后一个字节最高两位为11，后面6位是主机号)\n  >\n  > \n  >\n  > 说明：将202.1.1.128、202.1.1.192给部门1，202.1.1.0、202.1.1.64分别给部门2、3亦可。此时答案为：\n  >\n  > 部门1：202.1.1.0/26; \n  >\n  > 部门2：202.1.1.64/26;\n  >\n  > 部门3：202.1.1.128/25\n\n## 静态路由配置\n\n**静态路由是指网络管理员使用命令给路由器配置路由表**\n\n**简单，开销小，但是不能适应网络拓扑的变化，一般只在小规模网络中使用**\n\n![image-20230625092159370](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625092159370.png)\n\n静态路由配置：人为配置好\n\n![image-20230625092419554](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625092419554.png)\n\n**默认路由：0.0.0.0(或者0.0.0.0/0)，在其他的路由查不到的时候，就是默认走这里；网络前缀最短，路由最模糊**\n\n**特定主机路由：给网络中的某个主机特定配置的一个路由，网络前缀最长，路由最具体**\n\n**当有多个路由可选的时候，找最长前缀匹配的!!!**\n\n![image-20230625092551946](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625092551946.png)\n\n### 路由环路\n\n**静态路由配置错误导致路由环路**\n\n配置错误后，R2吓一跳给R3，R3查表又给R2，死循环\n\n**IP首部设有生存时间TTL的字段，进入路由器后-1，若不为0则转发，否则丢弃，这样就很好的缓解了路由环路问题**\n\n![image-20230625093020162](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625093020162.png)\n\n**聚合路由中有不存在的网络导致路由环路**\n\n**为了节省空间，R2的路由表将R1 0和2 接口连接的网络聚合成了一个聚合路由存在了R2的路由表中，R2发出目的网络地址192.168.2.0/24，查R2的路由表发现192.168.0.0/22前缀匹配，则转发到R1，R1则正确接受并且转发给目的网络；**\n\n**好，但是实际上24位的网络前缀在22位的基础上可以衍生出4个网络，其中两个网络是图中的网络拓扑没有的，所以就容易出现下列问题**\n\n**发送192.168.3.0/24，按照前缀匹配会发给R1，然后R1找不到，就会找默认路由，然后又回到R2了,形成环路**\n\n**解决方法：针对这两个不存在的路由存储黑洞路由，下一跳设置为NULL**\n\n![image-20230625093743207](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625093743207.png)\n\n**网络故障导致路由环路**\n\n最开始正常，然后出故障，R2不知道，仍发送到R1，然后这个时候出故障之后从路由表中删除这个信息，然后就找到了默认路由，导致环路\n\n解决：在消除之后设置黑洞路由，网络恢复之后将路由表恢复或者禁用黑洞路由\n\n![image-20230625095651756](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625095651756.png)\n\n##  动态主机配置协议DHCP(应用层协议)\n\n### DHCP发现(客户发)\n\n**源IP：0.0.0.0，目的：255.255.255.255，因为不知道服务器地址所以广播**\n\n**帧当中带有事务ID和客户的MAC地址**\n\n![image-20230625145702923](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625145702923.png)\n\n### DHCP提供(服务器发)\n\n**服务器收到后发送DHCP提供报文，源IP：自己服务器IP，目的IP：广播**\n\n**帧当中带有事务ID，用来标识这个是刚才客户发送的DHCP报文的回复**\n\n**还带有IP的配置信息，包括IP地址，子网源码，地址租期，默认网关，DNS服务器等等**\n\n**注意使用该IP的时候需要用ARP协议保证该IP地址未被其他主机使用**\n\n![image-20230625145800985](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625145800985.png)\n\n### DHCP请求(客户发)\n\n**客户收到DHCP提供报文后，选择一个服务器的报文，想用它为自己提供的IP，发送DHCP请求报文，目的地址仍为0.0.0.0，因为还未正式使用这个IP地址，目的地址为广播，这样就不用单独给每一个DHCP服务器发送我是否同意用你的IP地址了**\n\n**帧当中包含事务ID，DHCP客户的MAC，DHCP给分配的IP地址和DHCP服务器的IP地址**\n\n![image-20230625150053892](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625150053892.png)\n\n### DHCP确认(服务器发)\n\n**这时候服务器1收到请求，如果同意则返回确认报文**\n\n**注意客户收到后，IP地址仍需要用ARP协议检测是否被占用，如果在这个过程中有人捷足先登占用了，那么发送DHCP取消报文取消租约，并重新来过**\n\n![image-20230625150431016](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625150431016.png)\n\n### 关于租用期和补充\n\n![image-20230625150649095](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625150649095.png)\n\n### 关于DHCP中继代理\n\n**我们不愿意给每个网络都设置一个DHCP服务器，这样会导致DHCP服务器太多了**\n\n**所以例如DHCP的发现报文，由于目的地址为全1，为广播地址，这样的地址一般情况下是不会被路由器转发的，但是就是要通过路由器转发才能被DHCP服务器接受**\n\n**那么只需要在路由器中配置DHCP服务器的IP地址就好了，这个路由器也就成为了DHCP中继代理**\n\n**这个时候广播到达路由器的DHCP发现报文就会被路由器存储并且单播转发给DHCP服务器了**\n\n![image-20230625150823199](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625150823199.png)\n\n### 老师PPT所讲\n\n用于给主机动态的分配IP地址，它提供了**即插即用的联网机制**，这种机制允许一台计算机加入新的网络和获取IP 地址，而不用手工参与\n\n**DHCP是应用层协议，是基于UDP的**\n\n* DHCP: Dynamic Host Configuration Protocol\n\n  * 自动从一个DHCP服务器得到IP地址\n\n* 工作过程\n\n![image-20230612114056091](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612114056091.png)\n\n  > * 1：DHCP **服务器被动打开 UDP 端口 67**，等待客户端发来的报文\n  >\n  > * 2：DHCP **客户从 UDP 端口 68**发送 DHCP **发现报文**，以便从DHCP服务器获得一个IP地址\n  >\n  > * 3：凡收到 DHCP 发现报文的 DHCP 服务器\n  >\n  >       **都发出 DHCP 提供报文**，因此 DHCP 客户\n  >                   \n  >       可能**收到多个 DHCP 提供报文**。\n  >\n  > * 4：DHCP 客户从几个 DHCP 服务器中**选择**\n  >\n  >       **其中的一个，并向所选择的 DHCP 服务**\n  >                   \n  >       **器发送 DHCP 请求报文**。\n  >\n  > * 5：被选择的 DHCP 服务器发送**确认报文**\n  >\n  >       DHCPACK，客户进入已绑定状态，并可\n  >                         \n  >       开始使用得到的**临时 IP 地址**了。\n  >\n  > DHCP 客户现在要根据服务器提供的**租用期 T 设置两个计时器 T1 和 T2**，它们的超时时间分别是 **0.5T 和 0.875T**。当超时时间到就要请求更新租用期。\n  >\n  > * 6：租用期过了一半（T1 时间到），DHCP客户 发送\n  >\n  >       **请求报文 DHCPREQUEST** 要求**更新租用期**。\n  >\n  > * 7： DHCP 服务器若不同意，则发回否认报文DHCPNACK。这时 DHCP 客户必须**立即停止使用原来的 IP 地址，而必须重新申请 IP 地址**（回到步骤2）\n  >\n  > * 8： DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP 客户得到了**新的租用期，重新设置计时器。** \n  >\n  > * 若DHCP服务器不响应步骤6的请求报文DHCPREQUEST，则在租用期**过了 87.5%** 时，DHCP 客户必须**重新发送请求报文 DHCPREQUEST**（重复步骤6），然后又继续后面的步骤。\n\n* 服务场景\n\n![image-20230612125040776](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612125040776.png)\n\n* DHCP分配的不仅仅是IP地址，还可以分配\n\n  * 客户的第一跳路由器的地址(**网关**)\n  * DNS服务器的IP地址或域名\n  * 子网掩码\n\n* **DHCP是应用层协议，基于UDP**\n\n## NAT网络地址转换\n\n### 私有IP地址\n\n![image-20230625142918846](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625142918846.png)\n\n本地网络只能用于局域网内部通信而不能被路由器进行转发，进入到公网当中\n\n![image-20230625142809627](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625142809627.png)\n\n### NAT过程\n\n![image-20230625143139594](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625143139594.png)\n\n![image-20230625143252508](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625143252508.png)\n\n**存在的问题：一个内网地址对应一个路由器上接口的外网地址，那么如果外网地址的数量不够的话会出问题**\n\n![image-20230625143422526](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625143422526.png)\n\n### NAPT\n\n**把多个公网IP的问题用运输层的端口号来解决了，公网IP地址是相同的，但是端口号不同，所代表的进程服务就不同**\n\n![image-20230625143550830](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625143550830.png)\n\n### 补充\n\n**使用NAT不能让外网主机优先向内网主机发送请求，因为这会导致在NAT表里面找不到记录而失败**\n\n![image-20230625143744475](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625143744475.png)\n\n**NAT对外网屏蔽了内网的IP地址**\n\n![image-20230625144001558](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625144001558.png)\n\n* 使本地网络分组离开时具有同样的IP地址\n\n![image-20230612231154780](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612231154780.png)\n\n* 执行NAT时路由器要求：\n  * 外出的分组: **替换每个外出的分组的 (源IP 地址, 端口号) 为 (NAT IP 地址, 新端口号)** \n  * 远程客户/服务器用**(NAT IP地址, 新端口号)****作为目的**地来响应。\n  * (在NAT转换表中)记录每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 转换配对\n  * 进来的分组: **对每个进来的分组，用保存在NAT表中的对应的(源IP 地址, 端口号) 替换分组中的目的域 (NAT IP 地址, 新端口号）**\n* 地址转换过程\n\n![image-20230612231710190](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612231710190.png)\n\n## 因特网控制报文协议ICMP\n\n![image-20230625113527570](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625113527570.png)\n\n分为两种：**ICMP差错报文和ICMP询问报文**\n\n### ICMP差错报文\n\n分为五种\n\n#### 终点不可达\n\n![image-20230625113859562](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625113859562.png)\n\n#### 源点抑制\n\n因为拥塞而丢弃\n\n![image-20230625114026661](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625114026661.png)\n\n#### 时间超过\n\n![image-20230625114153412](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625114153412.png)\n\n**当在规定时间内无法收取全部的数据报的时候也会发送ICMP差错报文(时间超过)来提醒发送方重发剩余的分片**\n\n![image-20230625114253198](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625114253198.png)\n\n#### 参数问题\n\n检测到误码\n\n![image-20230625114429240](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625114429240.png)\n\n#### 改变路由(重定向)\n\n**H1默认网关是R1，但是H1发送给N2的报文最佳路径是经过R4，R1收到这个报文后发现不是最佳路径，于是发送ICMP差错报告(改变路由)，H1添加路由项，发送报文给N2不经过默认网关R1而是R4**\n\n![image-20230625114527220](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625114527220.png)\n\n#### 不应发送差错报文的情况\n\n![image-20230625114719621](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625114719621.png)\n\n### ICMP询问报文\n\n**回送请求和回答**\n\n**时间戳请求和回答**\n\n![image-20230625141910573](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625141910573.png)\n\n#### 应用\n\n分组网间探测PING\n\n![image-20230625142139330](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625142139330.png)\n\n跟踪路由\n\n![image-20230625142241615](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625142241615.png)\n\n![image-20230625142315919](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625142315919.png)\n\n### 学校PPT所讲\n\n**ICMP 差错报告报文：向源主机报告差错：包括终点不可达、拥塞丢弃、时间超过**\n\n用于目标主机或到目标主机路径上的路由器向源主机报告差错和异常情况\n\n- 终点不可达。当路由器或主机不能交付数据报时，就向源点发送终点不可达报文\n- 源点抑制。当路由器或主机由于拥塞而丢弃数据报时，就向源点发送源点抑制报文\n- 时间超过。当路由器收到生存时间为零的数据报时，除丢弃该数据报外还要向源点发送时间超过报文\n\n**不应发送 ICMP差错报告报文的几种情况如下**\n\n- 对ICMP差错报告报文不再发送 ICMP 差错报告报文\n- 第一个分片的数据报片的所有后续数据报片都不发送ICMP 差错报告报文\n- 对具有组播地址的数据报都不发送 ICMP 差错报告报文\n\n* Internet Control Message Protocol\n* 用于**主机路由器之间**彼此**交流网络层信息**\n  * 差错报告: 不可到达的主机, 网络,端口,协议\n  * 请求/应答\n* 位于IP之上\n  * 因为ICMP消息是**装载在IP分组里的**\n\n![image-20230612232317788](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612232317788.png)\n\n## IPV6\n\n**更大的IP地址空间，从32位升到了128位**\n\n**支持即插即用(自动配置IP地址)**\n\n**IPv6 首部长度必须是 8B的整数倍，而IPv4 首部是 4B 的整数倍，tcp首部也是4B的整数倍!!!**\n\n**从根本上解决了IP 地址的耗尽问题**\n\n* IPv6 数据报格式\n  * **固定长度的 40 字节首部**\n  * 不允许分片：**IPv6 只有在包的源结点才能分片，是端到端的，传输路径中的路由器不能分片**\n\n### IPV6地址表示\n\n* 冒号十六进制表示法\n* ![image-20230612232811674](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612232811674.png)\n\n## ==选路算法==\n\n* 路由算法确定了通过网络的**端到端路径**\n* 转发表确定了在路由器上的本地转发\n\n* 默认路由器：\n  * 与**主机直接相连的路由器**，又叫**第一跳路由器**\n  * 每当主机发送一个分组时，都先传送给它的默认路由器\n    * *源路由器：*源主机的默认路由器\n    * *目的路由器：*目的主机的默认路由器\n    * 从源主机到目的主机的选路归结为从源路由器到目的路由器的选路\n  * **路由算法**：是确定一个分组**从源路由器到目的路由器所经路径的算法**\n  * ![image-20230612233433762](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612233433762.png)\n\n### 网络的抽象图模型：费用(cost)\n\n![image-20230612233807967](https://cdn.davidingplus.cn/images/2025/02/02/image-20230612233807967.png)\n\n### 路由算法分类：\n\n#### 全局路由算法\n\n* **所有路由器拥有完整的网络拓扑信息和链路费用信息。**\n\n  **链路状态路由算法LS**：**必须知道网络中每条链路的费用**\n\n#### 分布式路由算法\n\n* 以迭代的、分布式的方式计算最低费用路径\n  * 节点只有**与其直接相连链路的费用信息**：**不需拥有**所有网络链路费用的完整信息\n  * 通过迭代计算，并与相邻节点(邻居节点)交换信息\n  * 逐步计算出到达某目的节点或一组目的节点的最低费用路径\n* **距离向量路由算法DV**：每个节点维护到**网络中所有其他节点的费用**（距离）的估计向量\n\n#### **静态路由算法**\n\n* 路由确定后基本不再变化。只有人工干预调整时，可能有一些变化\n\n#### 动态路由算法\n\n* 网络的流量负载或拓扑发生变化时，**路径可能发生改变**\n* 可以周期性地或直接地响应拓扑或链路费用的变化\n* 易受选路循环、路由振荡之类问题的影响\n\n![image-20230623103438337](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623103438337.png)\n\n### 链路状态路由算法LS\n\n#### Dijkstra最低费用路径算法\n\n所有节点都知道网络拓扑，以及每条线路的信息\n\n- 通过链路状态广播来实现\n- 所有节点拥有相同的信息\n\n- 计算**任意一个节点**（源节点）到**所有其他节点的最低费用路径**\n\n* 给出该节点的转发表\n\n* 迭代：通过k次迭代后可以知道到达k个目的节点的最低费用路径\n\n* 基本思想：以源节点为起点，**每次找出一个到源节点的费用最低的节点**，直到把所有的目的节点都找到为止\n  \n\n![image-20230613190712563](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613190712563.png)\n\n* 算法描述：\n\n![image-20230613191020488](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613191020488.png)\n\n  * 1、初始化\n  * 2、找出一个到源节点的费用最低的节点w，并以此**更新其它点**D(v) 值\n  * 3、重复步骤2\n    * 直到所有的网络结点都在N'中为止\n\n##### 例题\n\neg：\n\n* 计算从*u*到所有可能目的节点的最低费用路径。\n\n* 计算过程如表，表中的每一行表示一次迭代结束时的算法变量值。![image-20230613192048469](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613192048469.png)\n\n* ==构建从源节点到所有目的节点的路径==\n  * 对于每个节点，都得到**从源节点沿着它的最低费用路径的前驱节点**\n  * 每个前驱节点，又可得到它的前驱节点；以此继续，可以得到到所有目的节点的完整路径![image-20230613192253768](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613192253768.png)\n* ==构建最低费用路径树==\n  * 根据**目的节点找出顺序和其费用以及前驱节点**，可以画出源节点u到所有目的节点的最低费用路径树\n  * 根据得到的所有目的节点的**完整路径**，或最低费用路径树，可以生成源节点的**转发表**\n  * 转发表\n    * 存放从源节点到每个目的节点的最低费用**路径上的下一跳节点**\n    * 即指出对于发往某个目的节点的分组，**从该节点发出后的下一个节点**\n\n![image-20230613193259127](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613193259127.png)\n\n##### 转发表\n\n* 构建转发表\n\n![image-20230613193624053](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613193624053.png)\n\n##### dijkstra复杂度\n\n![image-20230613193847066](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613193847066.png)\n\n### 距离向量路由算法DV\n\n* 距离向量路由算法是一种迭代的、异步的和分布式的算法\n  * 分布式：每个节点都**从其直接相连邻居接收信息**，进行计算，再将计算结果**分发给邻居**\n  * 迭代：计算过程**一直持续**到**邻居之间无更多信息交换为止**\n  * 异步：不要求所有节点相互之间步伐一致地操作\n  * 自我终结：算法能自行停止\n\n#### 最低费用表示\n\n![image-20230613194719897](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613194719897.png)\n\n* dx(y)：**节点x到节点y的最低费用路径的费用**\n* v: 节点**x的邻居**节点\n* c(x,v)+ dv(y)：x与某个邻居v之间的直接链路费用c(x,v)加上邻居v到y的最小费用。即**x经v到节点y的最小的路径费用**\n* minv ：从所有经直接相连邻居节点到节点y的费用中选取的**最小路径费用**\n\n* B-F方程举例![image-20230613194906607](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613194906607.png)\n* 对每个结点x\n  * 初始化\n  * 更新自己的距离向量\n  * 重复执行（2），直到没有更新的距离向量发出\n  * ![image-20230613195434833](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613195434833.png)\n\n#### 距离向量表\n\n* 行：该节点的距离向量Dx和其邻居的距离向量Dv\n\n* 列：所有目的节点\n\n* 节点x的距离向量Dx ，即节点x到每个目的节点y的估计费用； Dx = [Dx(y)：y在N中]\n\n* 节点x每个邻居的距离向量Dv ，即x的邻居v到每个目的节点y的估计费用，Dv = [Dv(y)：y在N中]\n\n* ![image-20230613195656072](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613195656072.png)\n\n* 更新其距离向量\n\n  * ![image-20230613200022864](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613200022864.png)\n\n    ![image-20230613200539753](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613200539753.png)\n\n#### 链路费用改变与链路故障\n\n* 当一个节点检测到从它到邻居的链路费用发生变化时，就更新其距离向量，如果最低费用路径的费用发生变化，通知其邻居\n\n* **某链路费用减少时情况**\n  * ![image-20230613200702033](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613200702033.png)\n  * ![image-20230613200755966](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613200755966.png)\n  * 好消息在链路中能迅速传播\n\n* **某链路费用增加时情况**\n\n  * ![image-20230613200830906](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613200830906.png)\n  * ![image-20230613201428985](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613201428985.png)\n  * ![image-20230613201514443](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613201514443.png)\n  * 链路费用增加的“坏消息”传播很慢\n\n  * ![image-20230613212521754](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613212521754.png)\n\n  * 不知道坏消息已经影响他了，局部形成环路\n\n### LS算法与DV算法的比较\n\n![image-20230613201606964](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613201606964.png)\n\n* LS算法：\n\n  * 知道网络**每条链路的费用**，需发送O(nE)个报文；**当一条链路的费用变化时，必须通知所有节点**\n  * 需要O(nE)个报文和O(n**2**)的搜寻，可能会振荡\n  * \n\n* DV算法：\n\n  * 迭代时，仅在**两个直接相连邻居之间交换报文**\n  * 当链路费用改变时，只有**该链路相连的节点的最低费用路径发生改变时**，**才传播已改变的链路费用**\n  * 收敛较慢。可能会遇到选路回环，或计数到无穷的问题。\n\n* 健壮性\n\n  * LS：\n    * 路由器向其连接的一条链路广播不正确费用，路由计算基本独立（仅计算自己的转发表），**有一定健壮性**\n  * DV：\n    * 个节点可向任意或所有目的节点发布其不正确的最低费用路径，一个节点的计算值会传递给它的邻居，并间接地传递给邻居的邻居。**一个不正确的计算值会扩散到整个网络**\n    * 无健壮性\n\n## 分层次的路由选择协议\n\n### 域内路由协议IGP\n\n![image-20230623104007207](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623104007207.png)\n\n* 域（自治系统）内路由选择\n* 内部网关协议 IGP ：AS(**自治系统**)内使用的 \n  * RIP，OSPF\n* 外部网关协议EGP：AS之间使用的\n  * BGP \n\n#### 路由信息协议RIP(自治系统内部)\n\n* 基于**距离向量**的路由选择协议\n\n* 距离：**定义为路径中经过的路由器个数**\n\n  * 通常为跳数，即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1\n  * **特别的，从一路由器到直接的网络距离为1**\n\n* **RIP允许路由最多包含15个路由器**\n\n  * **距离16表示不可达，而且就是用16来表示距离不可达到!!!!**\n  * **RIP适用于小的互联网**\n\n  等价负载平衡\n\n  <img src=\"https://cdn.davidingplus.cn/images/2025/02/02/image-20230623142700261.png\" alt=\"image-20230623142700261\" style=\"zoom:67%;\" />\n\n三个要点\n\n- **和谁交换信息 和相邻的路由器**\n- **交换什么信息 自己的路由表**\n- **何时交换 周期性的交换**\n\n##### 交换信息(路由表更新问题)\n\n![image-20230623142336168](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623142336168.png)\n\n注意这里有的资料认为距离相等但是下一跳不相等的时候不进行路由表更新，也就是图中的 N8 4 C 没有，这个看情况来定\n\n* 仅和**相邻的路由器**交换信息\n* 路由器交换的信息是**自己的路由表**\n* ![image-20230613205209017](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613205209017.png)\n* eg\n  * 修改发来的路由更新信息，距离+1，下一跳路由器改为发送来的路由器\n  * **更新距离**\n  \n  ![image-20230613205506045](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613205506045.png)\n\n* eg2：![image-20230613210112278](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613210112278.png)\n\n##### RIP存在“坏消息传的慢”的问题\n\n**假如某一时刻R1收到N1故障，将自己的路由表修改为 N1 16 直连，然后到达周期时刻准备发给R2，然后R2这时候不知道，也发送给R1，但是R2的消息先到了，这个时候R1的消息尚未发出，收到R2的更新报文之后修改自己的路由表然后发出，这时候变为了 N1 3 R2，传过去R2变成了 N1 4 R1，以此类推，知道都更新为16的时候才知道不可到达，那么这个中间的过程就浪费了很长的时间，长达数分钟，形成了路由环路**\n\n![image-20230623143244527](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623143244527.png)\n\n这些措施并不能彻底解决这个问题，根本上是距离向量算法决定的\n\n#### 开放最短路径优先OSPF(自治系统内部)\n\n**OSPF 信息直接通过 IP 传输 （不是 TCP 或 UDP），因此必须自己实现可靠报文传输、链路状态广播等功能。**\n\n**为了克服RIP协议的缺点开发出来的，开放表示不是受某一家厂商控制而是公开发表的**\n\n**OSPF基于链路状态，RIP基于距离向量**\n\n* **使用了dijkstra最短路径算法**\n* ![image-20230623144107129](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623144107129.png)\n\n##### 交换信息\n\n**OSPF相邻路由器之间通过Hello分组来建立和维护邻居关系**\n\n![image-20230623144615721](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623144615721.png)\n\n**每个路由器都有链路状态公告LSA**\n\n![image-20230623144826717](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623144826717.png)\n\n每个路由器都有一个链路状态数据库LSDB，用来存储每个数据库的LSA\n\n![image-20230623144923675](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623144923675.png)\n\n工作过程\n\n![image-20230623144947654](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623144947654.png)\n\n五种分组类型\n\n![image-20230623145048982](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623145048982.png)\n\n工作过程\n\n![image-20230625103430164](https://cdn.davidingplus.cn/images/2025/02/02/image-20230625103430164.png)\n\n**建立关系(指定路由器)**\n\n**由于当链路状态更新的时候路由器需要通过广播的形式向系统中其他的路由器发送链路状态请求分组，所以在网络中就会存在大量的广播分组的传递，为了减少这个问题，引入了指定路由器DR和备用指定路由器BDR，规定其他的路由器只能和他们交换信息，减少了路由器之间相连的个数，但是增加了这两个路由器的负担**\n\n![image-20230623145416672](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623145416672.png)\n\n关于区域\n\n将自治系统AS划分为若干个区域，为了减少区域内部的通信量，使得能用于大规模的网络系统\n\n![image-20230623150007804](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623150007804.png)\n\n* 通过洪泛法(广播)向自制系统内所有的路由器发送信息\n  * **广播**\n* 交换本路由器**相邻的所有路由器的链路状态**\n* 当**链路状态发生变化时**交换信息\n\n![image-20230613210945337](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613210945337.png)\n\n### 边界网关协议BGP(自治系统之间)\n\n不同的自治系统之间所使用的代价度量可能不相同，**这使得在自治系统之间没有一个相对统一的标准**\n\n**自治系统之间的路由选择必须考虑相关的策略，例如：政治，经济，安全等等**(比如有的自治系统不让我们的TCP报文通过)\n\n**BGP协议为了找到一条尽可能快的路径(避免兜圈圈)，而不是找到最佳路径**\n\n#### 工作原理\n\n**BGP发言人之间通信需要建立TCP连接，端口号为179**\n\n![image-20230623151542954](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623151542954.png)\n\n![image-20230623151716299](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623151716299.png)\n\n![image-20230613213119975](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613213119975.png)\n\n* 从相邻AS获取子网可达信息\n* 向该AS内部的所有路由器传播这些可达性信息\n* 域间寻路任务：\n\n![image-20230613213247279](https://cdn.davidingplus.cn/images/2025/02/02/image-20230613213247279.png)\n\n* 基于距离矢量算法\n\n### 三个封装关系\n\n![image-20230623151144777](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623151144777.png)\n\n# 第五章 链路层\n\n## 关于可靠数据传输\n\n![image-20230626173103214](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626173103214.png)\n\n地位\n\n![image-20230623152241085](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623152241085.png)\n\n**链路加上通信协议就称为数据链路**\n\n![image-20230623152339948](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623152339948.png)\n\n## 三个重要问题(点对点传输)\n\n**封装成帧；差错检测；可靠传输**\n\n封装成帧\n\n**应用层封装好应用层协议数据单元，然后交付给运输层添加运输层协议首部，然后交给网络层添加网络层协议首部，然后交给数据链路层添加帧头帧尾，最后交给物理层把这一段帧视作比特流进行传输，到达接收方后进行一层一层的解包得到数据**\n\n![image-20230623162156552](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623162156552.png)\n\n差错检测\n\n![image-20230623162355842](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623162355842.png)\n\n需要有一定的措施来判断传输过程的数据是否发生错误\n\n可靠传输\n\n![image-20230623162430886](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623162430886.png)\n\n尽管可能发生差错，但发送方发送什么，接收方都能相应的接受到什么，这个就叫做可靠传输\n\n## 其他的\n\n![image-20230623162729781](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623162729781.png)\n\n### 概述\n\n* 主要术语\n\n  * 链路层的节点包括了主机和路由器；\n\n  * 我们将沿通信路径，将相邻节点连接起来的通信信道称为链路，这里的链路可以将主机与路由器，或者路由器与路由器连接起来。\n\n  * 为了将一个数据报从源主机传输到目的主机，数据报必须通过沿端到端路径上的各段链路传输。\n\n  * 链路主要包括：**有线链路和无线链路**。在实际链路上传输时，传输节点需要**将数据报封装成数据帧**进行传输。\n\n  * 数据链路层的职责是将数据报从一个节点传送到与该节点**直接有物理链路相连**的另一个节点。\n\n* 类比\n\n![image-20230614144243344](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614144243344.png)\n\n* 链路层提供的服务\n\n  * 封装成**帧**，链路接入\n    * 封装数据报为数据帧，**增加头部尾部信息**\n    * 若是共享链路，接入链路\n    * 在**数据帧头部**中，用MAC地址来表示源目的MAC地址\n      * 不同于IP地址\n  * 在相邻节点之间**可靠传输数据帧**\n  * 流量控制**(flow control):**\n    * 用于控制发送节点向**直接相连的接收节点**发送**数据帧的频率**\n  * 差错检测**(error detection):** \n    * 差错可能由信号衰减、噪声引入\n    * 接收方检测是否出现错误\n      * 通知发送方重传或丢弃数据帧\n  * 错误纠正**(error correction):**\n    * **接收方标识和纠正比特错误**，而不需要请求重传\n  * **半双工和全双工(half-duplex and full-duplex):**\n    * •在半双工模式，链路的两个节点都可以发送数据，但是不能同时发送\n\n* 链路层实现的位置\n\n  * 在主机和网络设备(路由器)上实现\n  * 在主机上，链路层的主体部分是在**网络适配器**上实现的(称为**网卡**)\n\n![image-20230614145625597](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614145625597.png)\n\n## 封装成帧\n\n![image-20230626213952332](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626213952332.png)\n\n**添加帧头和帧尾使之成为帧；包含重要的控制信息；帧头帧尾重要的作用之一就是帧定界**\n\n![image-20230623163138611](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623163138611.png)\n\n### 透明传输\n\n透明传输是指数据链路层对上层交付的数据没有任何限制，就好像数据链路层不存在一样\n\n**理解下来就是说：我的帧头帧尾里面的定界符是一串01，在数据当中很可能也存在一样的01，那么不加处理的话就会导致接收方把数据里面的01认为是定界符而导致数据出错。**怎么解决呢？\n\n**面向字节的物理链路**，可以在数据当中的flag前面加上一个转义字符，表示这是数据不是定界符，接受方接收到之后把转义字符剔除就好了\n\n![image-20230623163706309](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623163706309.png)\n\n如果数据中也包含转义字符形式的数据那么在前面也加上转义字符，接收方接受并且剔除就好了\n\n![image-20230623164020644](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623164020644.png)\n\n那么面向比特的物理链路呢？\n\n**帧定界码：01111110**\n\n**在数据当中的没五个连续的1后面加一个0，接收方接受识别并剔除就好了**\n\n![image-20230623164150736](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623164150736.png)\n\n### 补充\n\n帧数据部分尽可能大，提高利用率\n\n**最大传送单元MTU**\n\n![image-20230623164258204](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623164258204.png)\n\n## 差错检测和纠错\n\n![image-20230614145803630](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614145803630.png)\n\n* 发送节点\n\n![image-20230614145900470](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614145900470.png)\n\n* 接收节点\n\n![image-20230614145955026](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614145955026.png)\n\n* 差错检测和纠正技术不能保证接收方检测到所有的比特差错，即**可能出现未检测到的比特差错**，而接收方并未发现\n\n  * 选择一个合适的差错检测方案使未检测到的情况发生的概率很小即可。\n\n    差错检测和纠错技术越好，越复杂，开销更大\n\n### 奇偶校验\n\n**奇校验添加1保证1个数为奇数，如果1数量变为偶数就发生差错，但是如果1的奇性不变那么就无法检测出来，例如发生两位的误码**\n\n![image-20230623164750694](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623164750694.png)\n\n![image-20230614150416870](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614150416870.png)\n\n* 二维奇偶校验![image-20230614150630833](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614150630833.png)\n\n  ![image-20230614150919693](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614150919693.png)\n\n  > 第一行有3个1，因此第一行的校验位为1，\n  >\n  > 第二行有4个1，因此第二行的校验位为0，\n  >\n  > 第三行有3个1，因此第三行的校验位为1，\n  >\n  > 最终得到得到左边这个图。\n  >\n  > 假设在传输过程中，有一个比特错误，例如第二行第二列的1发生了翻转，变为了0，\n  >\n  > 在接收方进行检验时，会发现第二行的校验位不对，以及第二列的校验位不对，这样一交叉就会发现，第二行第二列的比特发生错误。\n  >\n  > 因此二维奇偶校验可以检测并纠正单个比特差错；能够检测分组中任意两个比特的差错。\n\n### Internet校验和\n\n![image-20230614151210888](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614151210888.png)\n\n> 在**发送方：**\n>\n> 首先，将数据的每两个字节当作一个16位的整数，可分成若干整数；\n>\n> 其次，将所有16 位的整数求和；\n>\n> 最后，对得到的和逐位取反，作为检查和，放在报文段首部，一起发送。\n>\n> \n>\n> 在接收方：对接收到的信息 (包括检查和项)按与发送方相同的方法求和。\n>\n> 如果结果为全“1”：则收到的数据无差错；\n>\n> 如果结果中有“0”：则收到的数据出现差错。\n\n* 特点：\n  * 分组开销小，检查和位数比较少\n  * 差错检测能力弱\n  * 适用于**运输层**\n  * 链路层的差错检测由适配器中专用的硬件实现，采用更强的CRC方法\n\n### 循环冗余(CRC)检测\n\n**算法要求多项式必须包含最低此项!!!**\n\n![image-20230623165224195](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623165224195.png)\n\n* 即**多项式编码**，把要发送的比特串看作为**系数是0或1**的一个多项式，对比特串的操作看作为多项式运算\n\n* 基本思想\n  * 设发送节点要把数据*D*（*d* 比特）发送给接收节点\n  * 发送方和接收方先共**同选定一个生成多项式G**（r+1比特），**最高有效位 (最左边)是1**。\n\n> 把要发送的比特串看作为系数是0或1的一个多项式，对比特串的操作看作为多项式运算。\n>\n> 这里我们来看这样一个例子，10111这个比特序列，如果用多项式表示，每个比特作为多项式的系数，因此10111等价于x的4次方+x的2次方+x的1次方+1\n\n* 基本思想\n\n![image-20230614151622292](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614151622292.png)\n\n  * 模2运算\n\n    * 加法不进位，减法不借位\n    \n    ![image-20230614152005675](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614152005675.png)\n\n    * 乘以2*r*，即比特模式左移*r* 个位置。\n\n          *D*×2*r* XOR *R* = *D* 00…00 XOR *R*\n            \n                       = *DR* (*d+r* 比特)·\n\n  * > 如何计算CRC码。\n    >\n    > 首先将**数据D称为2的r次方**，这里r表示CRC编码的位数，\n    >\n    > 然后将其除以给定的生成多项式G，\n    >\n    > 所得的余数为CRC编码\n\n\n\n* ![image-20230614152349294](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614152349294.png)\n\n  > 我们通过一个具体的例子来说明，CRC编码的计算过程。\n  >\n  > 假设数据D为101110，生成多项式G为1001，CRC编码为3比特，是生成多项式的位数减1.\n  >\n  > 这里用模2运输，计算CRC编码。\n  >\n  > 首先将D乘以2的3次方，即可得101110000；\n  >\n  > 然后将101110000除以生成多项式1001，最后可得余数为0011，因为CRC编码只取3比特，因此为011。\n  >\n  > 因此发送方最终发送的数据为101110011。\n\n* 例题\n\n![image-20230614153203464](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614153203464.png)\n\n* CRC特点\n\n  * 生成多项式G的选择：常见的有8、12、16和32 比特生成多项式G\n  * 能检测**小于 r+1 位的突发差错、任何奇数个差错**。\n\n![image-20230614153249181](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614153249181.png)\n\n补充\n\n![image-20230623165609117](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623165609117.png)\n\n**注意：CRC具有纠错能力，但是数据链路层一般只用他的检错能力，关于纠错看第四条**\n\n### 三种方法的比较\n\n![image-20230614153536058](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614153536058.png)\n\n## 多路访问链路和协议\n\n![image-20230626213714390](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626213714390.png)\n\n![image-20230626192839443](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626192839443.png)\n\n### 两种网络链路\n\n* **点对点链路**\n  * 链路两端各一个节点。一个发送和一个接收\n  * 如点对点协议ppp\n* **广播链路**\n  * 多个节点连接到**一个共享的广播信道**\n  * 广播：\n    * **任何一个节点传输一帧**时，信号在信道上广播，**其他节点都可以收到一个拷贝**\n\n### PPP(point to point protocol)协议（了解)\n\n封装成帧，链路控制协议LCP，网络控制协议NCPs\n\n![image-20230623170531731](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623170531731.png)\n\n#### 帧格式\n\n![image-20230623171139140](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623171139140.png)\n\n![image-20230626191818698](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626191818698.png)\n\n#### 关于封装帧的透明传输\n\n**面对字节：**\n\n三种数据，定界符7E，转义字符7D和ASCII码控制符的处理\n\n![image-20230623171454880](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623171454880.png)\n\n**面对比特：**\n\n![image-20230623171554940](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623171554940.png)\n\n#### 差错检测\n\n计算范围如下，计算完之后填入FCS\n\n![image-20230623171706985](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623171706985.png)\n\n### 广播信道存在问题\n\n![image-20230614153847137](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614153847137.png)\n\n## 多路访问协议\n\n* 目的：\n  * 避免多个节点同时使用信道，发生冲突，产生互相干扰\n* 冲突（collide）：\n  * **两个以上的节点同时传输帧**，使接收方收不到正确的帧(所有冲突的帧都受损失)\n    * 造成广播信道时间的浪费\n    * 多路访问协议可用于许多不同的网络环境，如有线和无线局域网、卫星网等\n\n* 理想的多地址访问协议\n\n![image-20230614154953535](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614154953535.png)\n\n![image-20230614155005837](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614155005837.png)\n\n### 信道划分(静态划分信道)协议\n\n* 把信道划分为小片(时隙)\n* 给节点分配专用的小片\n* 主要有**TDMA、FDMA**、**CDMA**三种\n\n#### TDMA时分复用\n\n![image-20230623185937536](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623185937536.png)\n\n* 设信道支持 *N* 个节点，传输速率是 *R* b/s\n\n  * **时分多路访问**TDMA **(time division multiple access)**\n\n    * 将时间划分为***时间帧***，每个时间帧再划分为***N个时隙***（长度保证发送一个分组），分别分配给*N*个节点。**每个节点只在固定分配的时隙中传输**。\n\n          例：6个站点的LAN, 时隙1、3、4 有分组, 时隙2、5、6 空闲 \n\n![image-20230614155414982](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614155414982.png)\n\n* 频率相同，每个用户占用不同时隙\n\n* TDMA特点：\n\n  * 避免冲突、公平\n    * 每个节点专用速率R/N b/s\n  * 节点速率有限：R/N b/s\n  * 效率不高：节点必须等待它的传输时隙\n\n![image-20230614191733115](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614191733115.png)\n\n#### FDMA频分复用\n\n**不同用户的数据使用不用的频率段**\n\n![image-20230623185812721](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623185812721.png)\n\n* **频分多路访问** FDMA **(frequency division multiple access)**\n* ![image-20230614155848923](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614155848923.png)\n* 每个用户占一个频段\n\n![image-20230614191544047](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614191544047.png)\n\n#### CDMA码分复用\n\n与前面两个不同，**码分复用允许用户在同样的时间使用同样的频带进行通信**\n\n**由于各用户使用经过特殊挑选的不同码型，各用户之间不会造成干扰**\n\n**每一个用户有标识性的唯一的编码，可以用这个编码对自己的数据进行编码然后进行发送**\n\n* **码分多路访问**CDMA (code division multiple access)\n\n![image-20230614155922455](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614155922455.png)\n\n### 随机访问协议\n\n* 基本思想\n  * 发送节点**以信道全部速率（*R* b/s）发送**\n  * 发生冲突时，**冲突的每个节点分别等待一个随机时间**，再重发，**直到帧(分组)发送成功**\n  * 节点间没有协调者\n* 典型随机访问协议：\n  * ALOHA协议(纯ALOHA，时隙ALOHA)\n  * 载波监听多路访问CSMA协议\n  * 带冲突检测的载波监听多路访问CSMA/CD\n  * 带冲突避免的载波监听多路访问CSMA/CA\n\n#### ALOHA\n\n* ![image-20230614160323469](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614160323469.png)\n\n> 首先介绍ALOHA协议。\n>\n> ALOHA是夏威夷大学研制的一个无线电广播通信网，采用星型拓扑结构，使**地理上分散的用户通过无线电来使用中心主机**。\n>\n> 中心主机通过下行信道向二级主机广播分组；\n>\n> 二级主机通过上行信道向中心主机发送分组（可能会冲突，无线电信道是一个公用信道）。如图所示。\n>\n> ALOHA有两种形式：时隙ALOHA和纯ALOHA。我们将分别进行介绍。\n\n#### 纯ALOHA\n\n* 非时隙ALOHA：简单，不需同步\n* **帧一到达，立即传输**\n* 如果与其他帧产生冲突，在该冲突帧传完之后：\n  * **以概率p**立即重传该帧\n  * **或等待一个帧的传输时间**，**再以概率p传输该帧**，或者**以概率1-p 等待另一个帧的时间**\n\n![image-20230614160542156](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614160542156.png)\n\n* 纯ALOHA效率\n\n![image-20230614160701801](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614160701801.png)\n\n![image-20230614161434578](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614161434578.png)\n\n#### 时隙ALOHA\n\n* ![image-20230614190132600](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614190132600.png)\n* 控制发送的时间\n* 比纯ALOHA效率更高\n* 效率\n  * 当有很多节点，每个节点有很多帧要发送时，成功时隙所占的百分比\n  * ![image-20230614192321295](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614192321295.png)\n\n### CSMA（载波侦听多路访问）\n\n动态接入控制\n\n协调总线上各个主机的工作，尽量避免产生碰撞，是我们要研究的问题\n\n* 载波侦听\n\n  * 某个节点在发送之前，先监听信道\n  * 信道忙：有其他节点正往信道发送帧，该节点随机等待（回退）一段时间，然后再侦听信道\n  * 信道空：该节点开始传输整个数据帧\n\n* CSMA特点：\n\n  * 发前监听，可减少冲突\n  * 由于传播时延的存在，仍有可能出现冲突，并造成信道浪费\n\n* CSMA发送冲突的例子\n\n  * ![image-20230614192826190](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614192826190.png)\n  * ![image-20230614193028622](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614193028622.png)\n\n  > 在时间t0：节点B侦听到信道空，开始传输帧，沿着媒体传播比特。\n  >\n  > 在时间t1：节点D有帧要发送。B的传输信号未到达D，因此D检测到信道空，开始传输数据帧。很快，B的传输开始在D节点干扰D的传输（冲突）\n  >\n  > 我们可以看到传播时延越长，节点不能侦听到另一个节点已经开始传输的可能性越大。\n\n* 带来的问题：信道浪费\n\n  * **节点没有进行冲突检测**，既使发生了冲突，节点仍继续传输它们的帧。但**该帧已经被破坏、是无用的帧，信道传输时间被浪费**\n\n\n\n#### 总线局域网协议 CSMA/CD\n\n![image-20230626190818430](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626190818430.png)\n\n多址接入MA：多个主机连在一条总线上，竞争使用总线\n\n载波监听CS：发送前检测是否有其他站点正在发送，有则等待(**96比特时间**)\n\n碰撞检测CD：**发送的过程**中检测是否出现碰撞，有则停止发送，退避一段时间再次发送**（这个和发送完帧的传播不一样！发送完很有可能帧仍在传播）**\n\n![image-20230623194111678](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623194111678.png)\n\n**载波监听多址接入/碰撞检测**\n\nCS:载波侦听/监听，每一个站在发送数据之前以及发送数据时都要检查总线上是否有其他计算机在发送数据\n\nMA：多点接入，表示许多计算机以多点接入的方式连接在一根总线上\n\nCD：碰撞检测(冲突检测)，**边发送边监听**，判断自己在发送数据时其他站是否也在发送数据\n\n* 基本原理：传送前侦听\n\n  * 信道忙：延迟传送\n  * 信道闲：传送整个帧\n\n* 发送同时进行冲突检测：一旦检测到冲突就立即停止传输， 尽快重发\n\n* 目的：缩短无效传送时间，提高信道的利用率\n\n* CSMA/CD举例\n\n![image-20230614193518854](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614193518854.png)\n\n  > 可以看到CSMA/CD中虽然也会发生碰撞，但是两个节点B、D在检测到冲突之后很短的时间内都放弃传输。\n  >\n  > （备注）\n  >\n  > 黄色表示B节点的传播物理范围，红色表示D节点的物理传播范围\n  >\n  > 怎么看时空图，横轴表示四个节点在空间中的位置，纵轴表示时间\n  >\n  > 在时刻t0，节点B侦听到信道是空闲的，因为当前没有其他节点在传输，于是节点B开始传输\n  >\n  > 在t1时刻，由于B节点的电磁波还没有传播到D能检测的范围，因此D节点发现信道空闲，开始传输，这个时候就会产生相互干扰\n  >\n  > D节点检测到干扰后，会**立即放弃**传输，B节点也会放弃\n\n* 以太网CSMA/CD的运行机制\n\n  > 我们说以太网也是采用CSMA/CD机制来访问共享信道。\n  >\n  > 其基本思想如下：\n  >\n  > 首先，适配器从网络层获得一个数据报，封装成帧，准备发送；\n  >\n  > 第二，如果适配器侦听到信道空闲，开始传输帧；如果检测到信道繁忙，将等待一段时间，直到侦听到信道空闲，开始传输帧；\n  >\n  > 第三，在传输过程中，适配器会同时监听是否有其他适配器的信号能量；\n  >\n  > 如果适配器在整个帧的传输过程中，没有监听到其他信号，则完成该帧的传输；如果监听到来自其他适配器的信号，则中止传输帧；\n  >\n  > 中止传输后，**适配器会等待一个随机时间**，重新执行步骤2\n\n![image-20230614193752692](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614193752692.png)\n\n关于碰撞\n\n![image-20230623194508839](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623194508839.png)\n\n##### 以太网CSMA/CD的运行机制讨论\n\n* 拥塞信号\n\n  * 48比特，确保所有传送者知道冲突发生\n\n* 比特时间\n\n  * •对于10 Mbps Ethernet 为0.1微秒，\n    当K=1023，等待时间大约50毫秒\n\n* 二进制指数回退算法\n\n  * •目标：适配器依据当前负载情况重传，重负载时等待时间变长\n\n    •第一次冲突： 在{0,1}中选k值；延迟Kx512比特时间传送\n\n    •第二次冲突：在{0,1,2,3}中选k值…\n\n    •10次以后，在 {0,1,2,3,4,…,1023}中选k值。\n\n    •K是等概率选择\n\n##### 争用期\n\n* 最迟要多久才能检测到碰撞？\n\n![image-20230614200805416](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614200805416.png)\n\n引入**争用期**的概念\n\n**我们需要尽量做到的就是在数据发送完成之前，就是最后一个比特发送出去之前，我们的第一个比特已经到达目的主机了，如果帧太短没到达的话，这段信号就没有人监听了，意思是发生了碰撞也没人管**\n\n![image-20230623194834497](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623194834497.png)\n\n##### 最小帧长\n\n**如果发送的帧太短，那么发送帧的时间就很短，完了之后可能帧还没传到地方，这个时候并没有进行碰撞检测，所以这个时候发生碰撞就没有办法处理了**\n\n![image-20230623195552335](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623195552335.png)\n\n**如果接收方接收到的帧长度小于64字节，那么一定是发生了碰撞，这个数据为垃圾数据，应该直接丢弃**\n\n**最小帧长 = 争用期 * 数据传输速率**\n\n**这个是在传播时延和发送时延相同的极限情况下得出的，也就是第一个bit刚好传到然后最后一个bit刚好发送完的极限情况，保证了刚好在发送过程中能一直监听是否发生碰撞，免得发送完毕之后第一个字节还在传播就可能碰撞**\n\n![image-20230623202304075](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623202304075.png)\n\n##### 最大帧长\n\n![image-20230623200424898](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623200424898.png)\n\n##### 截断二进制指数规避算法\n\n**用来计算发生碰撞之后的与下一次重传的退避(间隔时间)**\n\n![image-20230623201225148](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623201225148.png)\n\n![image-20230614201158767](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614201158767.png)\n\n##### 信道利用率\n\n![image-20230623201513042](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623201513042.png)\n\n提高利用率：**以太网端到端的距离受到限制，以太网帧的长度应该尽可能长一些**\n\n接受方的流程\n\n需要通过三个检查：最短帧长；地址正确；CRC检测出现误码\n\n![image-20230623201745152](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623201745152.png)\n\n#### 无线局域网协议 CSMA/CA\n\nCA：避免碰撞\n\n**在无线局域网当中不能使用碰撞检测CD，应该使用碰撞避免CA！！！**\n\n原因：\n\n![image-20230623202908992](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623202908992.png)\n\n* **可以适用于无线局域网**\n  * 这是CSMA/CD无法实现的\n* 工作原理\n  * 预约信道\n  * ACK帧\n  * RTS/CTS帧\n\n* 两者区别\n\n![image-20230614202226981](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614202226981.png)\n\n### 介质访问控制协议\n\n* MAC协议\n\n![image-20230614203131214](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614203131214.png)\n\n#### 轮询协议\n\n* 轮询开销\n* 等待延迟\n* 单点故障\n\n![image-20230614203303160](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614203303160.png)\n\n#### 令牌传递协议\n\n* 令牌：\n  * 一个特殊格式的MAC控制帧，不含任何信息\n  * 确保同一时刻只有一个节点独占信道\n* ![image-20230614203552549](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614203552549.png)\n\n## MAC地址，IP地址和ARP协议\n\n![image-20230623203359379](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623203359379.png)\n\n### Mac地址介绍\n\n**Mac地址又称为物理地址，用来全球性唯一标识网络接口，属于数据链路层，不属于物理层**\n\n![image-20230623203746399](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623203746399.png)\n\n#### 单播，广播，多播MAC地址举例\n\n![image-20230623204425170](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623204425170.png)\n\n![image-20230623204449724](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623204449724.png)\n\n**多播和广播的区别：多播是一对多，不一定是全部；而广播就是一对全部**\n\n**判断是否为多播地址，多播地址的第一个字节的第一个bit是1，也就是图中的第二个数字是奇数，这里就是7**\n\n![image-20230623204941223](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623204941223.png)\n\n**给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址**\n\n### IP地址\n\n![image-20230623205811799](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623205811799.png)\n\n数据的封装过程\n\n![image-20230623210002716](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623210002716.png)\n\n我看不懂也不需要看懂，加上首部(尾部)交给下一层\n\n**在网络层首部中应该封装有源IP地址和目的IP地址；链路层首部中应该封装有源MAC地址和目的MAC地址**\n\n#### 数据包转发过程中的IP和MAC\n\n**在数据包的转发过程中，源IP地址和目的IP地址始终保持不变，而源MAC地址和目的MAC地址逐段链路(或逐个网络)改变！！**\n\n![image-20230623210353555](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623210353555.png)\n\n### ARP协议\n\n**通过IP地址找到其对应的MAC地址**\n\n**发送广播帧，目的MAC地址是全1(FF-FF-FF-FF-FF-FF)**\n\n**对应的主机收到并且将发送方的IP和MAC存到自己的ARP缓存表中记录**\n\n![image-20230623211704130](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623211704130.png)\n\n**返回的帧源IP和MAC是自己的，目的是发送方的；发送方收到返回帧之后解析，得到MAC地址并且存到ARP缓存表中**\n\n![image-20230623211851788](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623211851788.png)\n\n**注意：ARP协议只能用于一个链路或者网络当中；跨网路需要逐个网络使用**\n\n![image-20230623212137813](https://cdn.davidingplus.cn/images/2025/02/02/image-20230623212137813.png)\n\n## 交换局域网\n\n###  概述\n\n* 局域网：Local Area Network ( LAN )\n* 多址访问协议广泛应用于局域网\n* 基于随机访问的CSMA/CD广泛应用于局域网\n* 局域网**按拓扑结构**进行分类：\n  * 星形网、环形网、总线网、树形网和网状网\n\n* 计算机与局域网通过**网络接口板进行连接**\n  * 网络接口板又称**通信适配器**（Adapter）或**网络接口卡NIC**（Network Interface Card），通常我们称为“**网卡**”\n\n### 链路层寻址和ARP\n\n* 每个节点有网络层地址和链路层地址\n  * 网络层地址\n    * 节点在**网络中**分配的一个**唯一地址（IP地址）**。用于把分组送到目的IP网络。长度为32比特（IPv4）\n  * 链路层地址\n    * 又叫做**MAC地址**或物理地址、局域网地址\n* MAC地址\n  * LAN地址、物理地址\n  * 节点“**网卡”本身所带的地址（唯一**）\n  * MAC地址长度通常为**6字节(48比特**)，共**248**个\n  * 6字节地址用16进制表示，每个字节表示为一对16进制数\n    * 1A-2F-BB-76-09-AD\n  * **网卡的MAC地址是永久的**（生产时固化在其ROM里）\n\n#### MAC地址分配\n\n* ![image-20230614205610876](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614205610876.png)\n* MAC 地址是**平面结构**\n  * 带有同一网卡的节点，在任何网络中都有同样的MAC地址\n\n#### AMC地址识别\n\n* 广播信道的局域网中，一个节点发送的帧，在信道上**广播传输，其他节点都可能收到该帧**\n* 大多数情况，一个节点只向某个特定的节点发送\n* 由“**网卡**”负责MAC地址的封装和识别\n* **发送适配器**：\n  * 将目的MAC地址封装到帧中，并发送。**所有其他适配器都会收到这个帧**。\n* **接收适配器**：\n  * 检查**帧的目的MAC地址是否与自己MAC**地址相匹配：\n  * 匹配：**接收该帧，取出数据报，并传递给上层。不匹配：丢弃该帧**\n* 广播帧：发送给所有节点的帧     全1地址：FF-FF-FF-FF-FF-FF\n\n#### 回顾：节点的三种不同地址\n\n![image-20230614210610683](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614210610683.png)\n\n> 刚刚我们讲到在单条链路上，数据帧的接收是根据目的MAC地址。\n>\n> 这里我们简单回顾下，一个节点的三种不同的地址表示。\n>\n> 第一种表示是：**应用层的主机名，例如域名**；\n>\n> 第二种表示是：**网络层的IP地址**，用于**在网络层寻址**，即路由器根据目的IP地址来进行转发；主机也根据目的IP地址是否是本机地址来判断是否接收。\n>\n> 第三章表示是：**链路层的MAC地址**，用于在链路层寻址，即实际链路传输时，每个主机**网卡根据目的MAC地址是否是本机的MAC地址来判断是否接收**。\n>\n> 在本页的例子中，标出了每个主机的IP地址和每个网卡的MAC地址。\n\n#### 回顾：地址之间的转换\n\n![image-20230614210729898](https://cdn.davidingplus.cn/images/2025/02/02/image-20230614210729898.png)\n\n> 那么，我们说实际的**数据帧发送**，**需要目的主机的IP地址和MAC地址**，这就需要提供地址之间的转化服务。\n>\n> 例如已知主机名，怎么查找该**主机名对应的IP地址**呢？这就需要用到**DNS域名解析服务**；\n>\n> 那么如果已知目的主机的IP地址，怎么查找它在同一个局域网中的MAC地址呢？这就需要用到**ARP协议**。ip->MAC\n>\n> 我们说ARP协议的主要作用是**将IP地址解析为其对应的MAC地址。**\n>\n> 需要说明的是ARP协议**只为在同一个局域网内部的节点进行IP地址解析**。\n\n### ARP地址地址解析协议\n\n![image-20230615205225915](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615205225915.png)\n\n* *ARP**表**:* 局域网上的每个节点(主机、路由器)都有这个表\n\n  •为某些局域网节点进行IP/MAC地址映射：\n\n     **< IP address; MAC address; TTL>**\n\n  •TTL (存活时间): **地址映射将被删除的时间**（通常为20分钟）\n\n#### 两个主机位于同一个LAN\n\n* 1.主机A希望发送数据报给主机B\n  * B的MAC地址**不在A的ARP映射表中**\n* 2.主机A **广播 ARP查询分组, 其中包含B的IP地址** \n  * 目的MAC地址 = FF-FF-FF-FF-FF-FF\n  * 局域网中**所有节点收到ARP查询分组**\n* 3.主机B收到ARP查询分组，**返回B的MAC地址给主机A**\n  * 包含有B的MAC地址的帧发送给主机A(单播)\n* 4.主机A在它的ARP表中缓存 **IP-to-MAC** **地址对，**直到信息\n  * 软状态：信息超时会被删除，除非有新的更新消息\n  * ARP是即插即用的：\n    * 节点创建ARP表不需要网络管理员的干预\n\n#### 发送数据报到子网以外\n\n![image-20230615205645829](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615205645829.png)\n\n* 主机A构建IP数据报，**源地址是A的IP地址，目的地址是B的IP地址**\n\n* 主机A构建链路层数据帧，**目的MAC地址是路由器左边端口的MAC地址**\n\n* 1.![image-20230615205732121](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615205732121.png)\n\n  > 首先主机A构建IP数据报，数据报的源IP地址是自己的111.111.111.111，目的IP地址是主机B的IP地址222.222.222.222。\n  >\n  > 那么该数据报封装成数据帧的源MAC地址是自己的MAC地址，74-29-9C-E8-FF-55，目的MAC地址是谁的呢？是B主机的MAC地址，还是路由器左边端口的MAC地址呢？\n  >\n  > 我们首先分析这个数据帧的发送路径。我们说当主机A判断该数据报的接收主机与自己不在同一个局域网时，它会首先将数据报发送到自己的第一跳路由器，即这里的路由器R，\n  >\n  > 因此该数据帧的目的MAC地址应该是R的左边端口的MAC地址，E6-E9-00-17-BB-4B。\n\n* 2.![image-20230615210113780](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615210113780.png)\n\n  > 该数据帧到达路由器R后，路由器R接收数据帧，然后抽取出数据报递交给网络层，网络层根据目的IP地址，判断该数据报要往右边的端口转发，且接收主机B与自己右边端口属于同一个局域网。\n\n* 3.![image-20230615211104130](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615211104130.png)\n\n  > 因此向右边端口输出数据帧时，数据帧的源MAC地址是路由器右边端口的MAC地址1A-23-F9-CD-06-9B，\n  >\n  > 数据帧的目的MAC地址是主机B的MAC地址49-BD-D2-C7-56-2A。\n\n* 这里需要强调的是，在整个传输过程中，**数据报的源IP地址和目的IP地址是不会发生改变的，改变的只是数据帧的源和目的MAC地址。**\n\n### 以太网\n\n#### 以太网的帧结构\n\n* 发送方：\n  * 发送适配器**将IP数据报封装成以太网帧**，并传递到物理层\n* 接收方：\n  * 接收适配器**从物理层收到该帧，取出IP数据报**，并传递给网络层\n* ![image-20230615212904236](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615212904236.png)\n\n> 接着，我们再介绍以太网的帧结构，如图所示，包括了前同步码、目的MAC地址、源MAC地址、类型、数据和CRC校验码。\n>\n> 注意这里CRC检验的数据只包含目的MAC地址、源MAC地址、类型、数据四部分。\n>\n> 首先发送方的发送适配器将IP数据报封装成以太网帧，并传递到物理层。\n>\n> *接收方的*接收适配器从物理层收到该数据帧，抽取出IP数据报，并传递给网络层。\n>\n> Ref : https://blog.csdn.net/eliot_shao/article/details/123473548\n\n* 前同步码(8 字节)\n\n![image-20230615212923620](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615212923620.png)\n\n  * > 前同步码有8个字节，其中前7字节是“10101010”，最后一个字节是“10101011”。\n    >\n    > 前同步码的作用是使接收方和发送方的时钟同步，接收方一旦**收到连续的8字节**前同步码，可确定有帧传过来。\n    >\n    > 注意：前同步码是“无效信号”，接收方收到后删除，不向上层传。CRC的校验范围不包括前同步码。\n\n* 源、目的MAC地址(各6字节)\n\n![image-20230615213135997](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615213135997.png)\n\n  >然后是各6个字节的源、目的MAC地址。\n  >\n  >如果主机A向主机B发送一个IP数据报，**主机B只接收目的MAC地址与自己MAC地址匹配的数据帧或广播地址的数据帧**，并将数据字段的内容传递给网络层。否则，丢弃该帧。\n\n* 类型字段(2 字节)\n\n  * ![image-20230615213210068](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615213210068.png)\n\n  * > 帧结构中类型字段主要是支持以太网中的多种网络层协议的**复用的**，绝大多数这里的类型是指IP协议。\n\n* 数据字段(46-1500字节)\n\n![image-20230615213434405](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615213434405.png)\n\n  * 然后是数据字段，*以太网的最大传输单元**MTU**是**1500**字节，最小长度是**46**字节。*\n\n* 循环冗余检测CRC(4字节)\n\n![image-20230615213459966](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615213459966.png)\n\n  帧结构的尾部**是CRC循环冗余校验码**。它主要是用于帮助接收主机检测数据帧中是否出现比特差错。\n\n#### 不可靠的无连接服务\n\n* 以太网向网络层提供的服务：\n  * 无连接服务：\n    * 通信时，**发送方适配器不需要先和接收方适配器\"握手\"**\n  * 不可靠服务：\n    * 接收到的帧可能含有比特差错\n      * 收到正确帧，不发确认帧\n      * 收到出错帧，丢弃该帧，**不发否定帧**\n      * 发送适配器不会重发出错帧\n      * 丢弃数据的恢复是通过终端**传输层的可靠数据传输机制**来实现的\n\n### 交换机SWITCH\n\n#### 集线器HUB\n\n**集线器连接下的网络虽然物理上看起来不是总线型的，但是逻辑上仍然是总线型的**\n\n**使用CSMA/CD协议**\n\n**集线器只工作在物理层，他的每个接口只是简单的转发比特流，碰撞检测的事情交给各站的网卡进行检测**\n\n![image-20230624101402969](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624101402969.png)\n\n使用集线器HUB在物理层扩展以太网\n\n![image-20230624101639421](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624101639421.png)\n\n**使用集线器连接的以太网就相当于是把总线型的给画的好看了点，其实没什么区别，用的还是CSMA/CD协议调节各个主机使用总线，还要进行碰撞检测，只能工作在半双工模式，收发帧不能同时进行**\n\n#### 交换机与集线器的对比\n\n##### 比较\n\n![image-20230626192052973](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626192052973.png)\n\n![image-20230626192105334](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626192105334.png)\n\n**某站的信号经过集线器会转发给广播域中的所有其他主机，但是经过交换机之后，由于内部的设置会只转发给目的主机**\n\n![image-20230624101832631](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624101832631.png)\n\n**以太网交换机有多个接口，一般工作在全双工模式，不用考虑碰撞检测(不适用CSMA/CD协议)，能同时连通多个接口!**\n\n![image-20230624102447140](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624102447140.png)\n\n**关于碰撞的问题，集线器收到帧之后就会直接向其他所有主机进行传递，这里必然就会涉及到碰撞的问题**\n\n**而交换机，当交换机收到多个帧的时候，为了避免碰撞会将这些帧进行缓存，之后再进行逐一转发，避免了碰撞的问题**\n\n##### 交换机和集线器扩展以太网\n\n单播帧\n\n![image-20230624103048893](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624103048893.png)\n\n广播帧\n\n![image-20230624103106429](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624103106429.png)\n\n可能发生碰撞的时候\n\n![image-20230624103214629](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624103214629.png)\n\n**因此，集线器扩大了广播域，也扩大了碰撞域；而交换机扩大了广播域，但是隔离了碰撞域!!!**\n\n![image-20230624103312938](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624103312938.png)\n\n* **链路层设备**\n  * **存储转发数据帧**\n  * **检查**到达的数据帧的MAC地址，有选择的转发数据帧到一个或多个输出链路，当数据帧被转发到一个共享网段时，使用CSMA/CD来访问共享链路\n* **透明**\n  * 主机不关心是否存在交换机\n* **即插即用和自学习**\n  * 交换机不需要手工配置\n* ![image-20230615214505580](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615214505580.png)\n\n> 本次课将详细讲解链路层交换机的工作原理。\n>\n> 首先交换机是属于链路层的设备，其主要作用是**存储转发数据帧。**\n>\n> 对于到达交换机的数据帧，交换机首先**检查其目的MAC地址**，然后根据MAC地址，有选择的将数据帧转发到一个或多个输出链路；\n>\n> 如果输出链路是一个共享网段，将使用CSMA/CD来访问共享链路。我们这里给出了一幅图来帮助大家理解后面这句话。\n>\n> 在这幅图中A、B、C主机和交换机的端口1由集线器设备互连，因此这里**，A、B、C主机和交换机的端口1构成了一个共享网段**，在共享链路发送数据帧，需要用到我们前面学习到的以太网链路访问协议CSMA/CD。\n>\n> 链路层交换机的第二个特点是透明，这里的透明是指的当一个主机向另一个主机发送数据帧时，它并不会知道某个交换机会收到这个数据帧，并将其转发到另一个节点。\n>\n> 交换机的第三个特点是即插即用和自学习，也就是说交换机是不需要手工配置的，插上就可以用。\n\n#### 支持多节点同时传输\n\n![image-20230615214659240](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615214659240.png)\n\n> 在组网时加入交换机后，可以支持多个节点同时传输数据帧。\n>\n> 可以看上边这幅图，每个主机由单独的链路与交换机端口相连，因此交换机每个端口对应的链路和主机是一个**独立的碰撞域。**\n>\n> 又因为交换机对于收到的数据帧可进行缓存，因此在上边这幅图中，A主机和B主机同时发送数据帧，将不会发生冲突。\n>\n> 因此交换机具有较高的转发率。\n\n#### 以太网自学习和转发帧的过程(自学习算法)\n\n##### 考虑以下过程\n\n![image-20230624103924717](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624103924717.png)\n\nA给B发送帧，进入交换机1中，先进行登记，记录A的MAC地址和接口1，然后找B的MAC地址，找不到，进行广播，接口3的B收到发现正确，接受；C则丢弃；到4号接口转发到交换机2中，帧进入交换机2中先进行登记，登记A的MAC地址和接口2，然后进行广播，都不匹配，则都丢弃，这就是一个完整的过程\n\n后面还有两个过程\n\n![image-20230624104855273](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624104855273.png)\n\n丢弃帧的例子\n\n![image-20230624105132560](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624105132560.png)\n\n**G发送帧到A，这个帧在分岔口两边传播，给A并接受，到交换机的时候先进行登记，然后查找，发现A 1，意思是从哪里来回哪里去，这显然是没必要转发的，于是丢弃**\n\n每条记录的持续时间不是永久的，会定期删除!!!\n\n![image-20230624105419966](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624105419966.png)\n\n##### 转发表\n\n![image-20230615215151514](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615215151514.png)\n\n> 在右边这幅图中，我们有这样一个疑问：交换机是怎么知道A’可通过端口4达到， B’ 可通过端口5到达呢？\n>\n> **这是因为每个交换机都有一个转发表，其中的条目如下：**(主机的MAC地址，到达主机的端口，时戳)；\n>\n> 因此当数据帧的目的MAC地址为A’主机时，我们通过查找相应的转发表项，就可获知该主机对应的端口。\n>\n> 那么转发表中的条目是怎么建立的呢？我们说是通过自学习机制。\n\n* 自学习![image-20230615215317577](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615215317577.png)\n\n> 下面我们就来介绍交换机的自学习机制。非常简单。\n>\n> 每当交换机收到一个数据帧时，交换机会学习发送主机的位置：**及进入的局域网段和到达端口，并在转发表中进行记录**。\n>\n> 如这里的例子所示，主机A发送数据帧给主机A’，数据帧到达交换机时，交换机会在转发表中记录这样一个表项：\n>\n> A主机的MAC地址和可达端口号1，生存时间60秒，这就表示通过端口1可达到A主机。\n\n##### 数据帧的过滤/转发\n\n* ![image-20230615220318143](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615220318143.png)\n\n> 下面我们来学习交换机收到数据帧后，是如何进行查表转发的。我们说根据如下规则：\n>\n> 首先，**记录**到达链路和发送主机的MAC地址；\n>\n> 第二步，使用数据帧的目的MAC地址，在转**发表中进行检索：**\n>\n> 如果在转发表条目中找到对应的MAC地址，则执行：\n>\n> 如果**目的MAC地址对应的端口**与**数据帧的到达端口相同**，说明接收主机属于同一个共享网段，则**直接将该数据帧丢弃**。**因为接收主机也会收到该数据帧**；\n>\n> 否则，转发端口与达到端口不一致，则将该数据帧转发到指定端口\n>\n> 如果数据帧的目的MAC地址在转发表中没有找到，则交换机将该数据帧向除到达端口之外的所有端口转发，也就是**泛洪**。\n\n##### 自学习/转发例子\n\n![image-20230615220549451](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615220549451.png)\n\n> 我们来看一下自学习和转发的例子。\n>\n> 这里初始时转发表是空的，当主机A发送数据帧给主机A’时，该数据帧到达交换机，\n>\n> 交换机首先根据收到数据帧的端口和该数据帧的源MAC地址，建立表项1，说明通过端口1可达到主机A，这就是自学习。\n>\n> 然后交换机根据数据帧的目的MAC地址（A’）在转发表中查找，由于没有找到A’的MAC地址，则交换机将该数据帧向除1端口之外的所有端口转发，\n>\n> 只有A’主机会发现数据帧的目的MAC地址与自己的MAC地址一致，接收该数据帧。\n>\n> 注意，这里主机A’发往主机A的数据帧，在到达交换机后，由于转发表中已经有目的MAC地址对应的表项，因此交换机将只向1端口转发数据帧。\n\n#### 交换机互连\n\n* ![image-20230615221022380](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615221022380.png)\n\n> 交换机也可以进行**互连，以组成更大的局域网**。如本页的图所示。\n>\n> 那么请大家思考，这样一个问题，如果主机A发送数据帧给主机G,那么交换机S1是怎么知道需要先把数据转发到S4和S3的？\n>\n> 我们说仍然是通过自学习。当数据帧到达S1时，可能S1的转发表中没有G主机的MAC地址的表项，于是S1将该数据帧泛洪，那么S4的端口也会收到这个泛洪的数据帧，\n>\n> 如果S4的转发表也没有G主机的MAC地址对应的表项，则S4会继续泛洪，于是S3也会收到数据帧，如果S3的转发表仍然没有G主机的MAC地址，则S3会继续向它的端口泛洪，直到数据帧到达G主机。\n\n* 多个交换机自学习的例子\n\n![image-20230615221124088](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615221124088.png)\n\n#### 交换机交换特点和方式\n\n* 特点\n\n  * 识别目的MAC地址，根据交换表进行端口选择\n  * 识别源MAC地址更新交换表\n\n* 在识别目的MAC地址和源MAC地址的过程中是否需要接收并缓存完整的帧呢？\n\n  * 在识别目的MAC地址和源MAC地址的过程中，**需要接收并缓存完整的帧**。这是因为MAC地址是位于数据链路层的帧的**头部**中，用于标识帧的源和目的设备。\n\n    当一个设备接收到一个帧时，它需要读取帧头部中的目的MAC地址和源MAC地址字段来确定该帧是否是针对自己的，或者是从哪个设备发送过来的。因此，设备需要接收并缓存完整的帧，以便能够从帧头部提取MAC地址信息进行判断和处理\n\n* 交换方式\n\n  * **存储转发**(缓存整个帧后再转发)\n  * **快速分组**(直通交换)\n    * 识别出目的地址直接转发\n\n存储转发交换方式\n\n![image-20230615221909190](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615221909190.png)\n\n快速分组交换方式\n\n![image-20230615221938880](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615221938880.png)\n\n> 存储转发：具有**差错检测**功能，**转发时延较大**，适用于**出错率高的链路**。\n>\n> 快速分组又称直通交换：**不具有差错检测功能，转发时延较小**，适用于时延要求高，**出错率低的链路**。\n\n#### 路由器和交换机的区别\n\n![image-20230615222230911](https://cdn.davidingplus.cn/images/2025/02/02/image-20230615222230911.png)\n\n> 最后我们将交换机和路由器进行简单的对比。\n>\n> 首先，路由器和交换机都是存储转发设备（中转设备），其中路由器是**网络层设备**，交换机是**链路层设备**。\n>\n> 第二，路由器和交换机**都需要维护转发表**，其中路由器使用**路由算法**来计算转发表，**基于IP地址转发**；而交换机是通过泛**洪和自学习**来建立转发表，**基于MAC地址**进行数据帧转发。\n\n### 虚拟局域网VLAN\n\n以太网的规模变大之后，随之而来的就是广播域不断增大，广播会导致很大的弊端!!!\n\n![image-20230624110432468](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624110432468.png)\n\n如何缓解这个问题呢？\n\n可以使用路由器，**路由器默认情况下不对广播数据包进行转发，**所以可以隔绝广播域\n\n![image-20230624110602013](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624110602013.png)\n\n但是路由器成本太高了，在局域网内部尽量少的使用路由器，所以这个时候可以用虚拟局域网VLAN技术\n\n![image-20230624110819408](https://cdn.davidingplus.cn/images/2025/02/02/image-20230624110819408.png)\n\n**同一个VLAN内部可以广播通信，不同的不可以广播通信；VLAN的划分与物理位置无关，只与人为的设置相关!!!**\n\n# 第六章 网络编程\n\n考试只会考写步骤，代码在实验里就写过了\n\n## 步骤\n\n![image-20230626192916119](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626192916119.png)\n\n![image-20230626194828716](https://cdn.davidingplus.cn/images/2025/02/02/image-20230626194828716.png)\n\n","categories":["校内课程","计算机网络"]},{"title":"数据库 期末复习","url":"/posts/27483ebb.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 前言\n\n**数据库期末重点：**\n\n**SQL编程--难度类似实验测评**\n\n**关系模型---概念、关系运算**\n\n**CDM设计---根据题目给出的需求，画出PD格式的CDM图**\n\n**PDM设计---课件4-4数据库规范化设计**\n\n**ODBC---概念、分级、方法**\n\n**JDBC----概念、分级、编程**\n\n**存储过程、触发器----难度类似实验**\n\n**第七章考核点：5v，cap，base，四种nosql数据库类型和分类比较**\n\n<!-- more -->\n\n2023年，学院对各课程考核题型形式提出了统一要求，取消单选题、判断题的测试形式，更多采用综合考核能力的题型形式\n\n此文档作为数据库系统的最新复习资料,部分截图来自授课PPT，严格按照教科书目录结构编写，方便结合教材查缺补漏，精华浓缩阐述清楚，看完的话应该有85分，部分概念(规范化、并发..)比较抽象需要看书可能才能理解清楚。\n\n建议复习步骤：此文档-->教科书-->此文档。\n\n# 数据库及其系统概念\n\n> - 了解数据库、数据库管理系统、数据库系统等基本概念\n> - 理解数据模型与数据库类型关系 \n> - 熟悉数据库系统组成及其各部分作用\n\n数据库：按特定数据模型组织存储管理数据的文件集合\n\n特点\n\n- 数据不重复 \n- 支持并发 \n- 数据结构独立于应用程序 \n- 数据的增删改查由数据库系统管理软件管理\n\n数据模型：事物对象数据特征结构的形式化表示，包括数据结构、数据操作、数据约束\n\n数据结构：对象静态特征\n\n数据操作：对象动态特征\n\n数据约束：数据结构中数据之间的联系制约关系，数据动态变化的规则\n\n数据模型-关系数据模型：采用“二维表”结构组织、存储和管理数据，并以关联列实现表之间的联系。\n\n![image-20230603193803070](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603193803070.png)\n\n数据库系统（DS）\n\n数据库应用程序：在DBMS支持下对数据库中数据进行访问处理\n\n关系数据库数据内容：用户表（用户数据），系统表（元数据、索引数据、运行数据）\n\n关系数据库对象组织：\n\n- 用户表：存储用户的应用数据\n- 系统表：存储数据库系统自身数据\n- 视图：通过虚拟表实现数据查询处理\n- 索引：通过目录数据结构支持快速的数据查询\n- 约束：对关系表及其数据施加规则\n- 存储过程：在数据库内部实现特定功能程序的数据处理\n- 触发器：在数据库内部实现数据操作事件触发自动执行的过程程序\n\n# 关系模型\n\n## 关系相关概念\n\n键：关系中可以唯一标识元组的属性列，其他的为非键列\n\n候选键：多个列都可以作为键时，它们每一个均为候选键\n\n主键：候选键中最具代表性的，唯一\n\n复合键：关系中必须用多列才能唯一标识元组时，为复合主键\n\n代理键：DBMS自动生成的数字序列主键，可替代复合主键\n\n外键：关系中的关键字为另一个关系的主键，此时称该关系为另一个关系的从表\n\n关系模式：关系名（<u>主键属性</u>，属性2，…，属性x）\n\n## 关系模型原理\n\n数据模型-关系模型：基于二维表结构存储数据实体及实体间联系\n\n关系模型数据操作\n\n集合：选择（select）、投影（project）、连接（join）、交（intersection）、并（union）、差（difference）\n\n元组：行插入（Insert）、 修改（Update）、删除（Delete）\n\n交并差：关系R与关系S需有相同属性组成（简单不赘述）\n\n笛卡尔积×：R的属性列+S的属性列=新表属性列，元组进行排列组合\n\n选择：σF(R)：在关系R中选出满足条件F的元组形成新的关系。(F：条件表达式)；对应where子句\n\n投影：πA（R）：在R中选出若干属性列组成一个新关系。(A:属性组)；对应select子句\n\n连接：从两个关系的笛卡尔积中选取属性间满足条件AθB的元组组成新的关系\n\n条件连接\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20250201003952106.png\" alt=\"image-20250201003952106\" style=\"zoom:60%;\" />\n\n等值连接-条件连接的特例：选取指定属性列的值相等的行，可以选择多个条件\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20250201004007703.png\" alt=\"image-20250201004007703\" style=\"zoom:65%;\" />\n\n```sql\nSELECT 列表\nFROM 表1\nJOIN 表2 ON 表1.列 = 表2.列;\n```\n\n自然连接-等值连接的特例：根据两个表中的所有相同属性列进行连接，连接后多个的相同属性列只保留一个\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20250201004025422.png\" alt=\"image-20250201004025422\" style=\"zoom:75%;\" />\n\n```sql\nSELECT 列表\nFROM 表1\nNATURAL JOIN 表2;\n```\n\n外连接-自然连接的特例：自然连接只有相同属性列的值相同才返回，外连接中若有一方的行的共同属性列没有找到与之匹配的行，则也保留该行，以NULL填充。左外连接、右外连接、全外连接\n\n除（了解；t代表元组、XY代表属性）\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20250201004048581.png\" alt=\"image-20250201004048581\" style=\"zoom:65%;\" />\n\n关系模型完整性约束：实体完整性约束（主键非空且不唯一）、参照完整性约束（主从表的外键主键一致）、用户自定义完整性约束\n\n# SQL语句\n\n## sql概述\n\n数据定义语言（DDL）：创建修改删除数据库对象；create/drop/alter database/table/index\n\n数据操纵语言（DML）：增删改数据；insert/update/delete\n\n数据查询语言（DQL）：数据查询；\n\n数据控制语言（DCL）：数据库对象访问控制；grant/deny/revoke\n\n事物处理语言（TPL）：事物处理；begin transaction/commit/rollback\n\n游标控制语言（CCL）：游标操作；declare cursor/fetch into/close cursor\n\n## 数据定义语句\n\n### 数据库\n\n```sql\nCREATE DATABASE CourseDB;\n\nALTER DATABASE CourseDB RENAME TO CourseManageDB;\n\nDROP DATABASE CourseManageDB；\n```\n\n### 数据库表\n\n格式：列名+数据类型+列完整性约束\n\n列完整行约束\n\nPRIMARY KEY——单列主键\n\nNOT NULL——非空值\n\nNULL——空值\n\nUNIQUE——值唯一\n\nCHECK——有效性检查\n\nDEFAULT——缺省值\n\n\n\n表约束：可定义复合主键、代理键、外键，可以命名约束\n\n```sql\nCREATE  TABLE  Student\n(StudentID      char(13)    PRIMARY  KEY,\n StudentName    varchar(10)\tNOT NULL UNIQUE,\n StudentGender  char(2)     NULL     CHECK(StudentGender IN('男','女')),\n BirthDay       date        NULL,\n Major          varchar(30) NULL     DEFAULT '本科生',\n StudentPhone\tchar(11)    NULL\n --或者\n CONSTRAINT Student_PK PRIMARY Key(StudentID,StudentName)\n);\n \nALTER TABLE STUDENT ADD <.><.>[..];\nALTER TABLE STUDENT DROP COLUMN<.>;\nALTER TABLE STUDENT DROP CONSTRAINT<.>;\nALTER TABLE STUDENT RENAME TO<>;\nALTER TABLE STUDENT RENAME <> TO <>;\nALTER TABLE STUDENT ALTER COLUMN<> TYPE<>;\n \nDROP TABLE <>;\n```\n\n表约束定义代理键：有时为了方便数据处理，可以使用代理键去替代复合主键\n\n```sql\nCREATE  TABLE  Plan\n( CoursePlanID\tserial\t\t    NOT  NULL,\n  CourseID  \tchar(4)  \t\tNOT  NULL,\n  TeacherID  \tchar(4)  \t\tNOT  NULL,\n  CourseRoom  \tvarchar(30),\n  CourseTime  \tvarchar(30),\n  Note  \t\tvarchar(50),\n  CONSTRAINT\tCoursePlan_PK\tPRIMARY Key(CoursePlanID)\n);\n\n\n```\n\n表约束定义外键\n\n```sql\nCREATE  TABLE  Register\n( CourseRegID  \tserial\t    NOT  NULL,\n  CoursePlanID  Int  \t\tNOT  NULL,\n  StudentID  \tchar(13),\n  Note  \t\tvarchar(30),\n  CONSTRAINT\tCourseRegID_PK\tPRIMARY Key(CourseRegID),\n  CONSTRAINT\tCoursePlanID_FK\tFOREIGN Key(CoursePlanID)\n\tREFERENCES  Plan(CoursePlanID)\n    ON DELETE CASCADE,\n  CONSTRAINT\tStudentID_FK\tFOREIGN KEY(StudentID)\n\tREFERENCES  Student(StudentID)\n    ON DELETE CASCADE\n);\n\n```\n\n### 数据库索引\n\n索引（index）：将关系表按照指定列的取值顺序组织元组数据的数据结构，加快查询，占用额外存储空间、开销较大\n\n```sql\nCREATE INDEX Birthday_Idx ON  STUDENT(Birthday);\n\nALTER INDEX Birthday_Idx RENAME TO Bday_Idx;\n\nDROP INDEX bday_idx;\n```\n\n## 数据操纵语句\n\n### 数据插入\n\n```sql\nINSERT INTO Student VALUES('2017220101105','柳因','女','1999-04-23','软件工程', 'liuyin@163.com');\n```\n\n### 数据修改\n\n```sql\nUPDATE  Student\nSET  Email='zhaodong@163.com'\nWHERE   StudentName='赵东';\n```\n\n### 数据删除\n\n```sql\nDELETE \nFROM  STUDENT\nWHERE   StudentName='张亮';\n```\n\n## 数据查询语句\n\n### 单表查询\n\n```sql\n-- 通用结构\nSELECT  [ALL|DISTINCT]  <目标列>[，<目标列>…]\n[ INTO <新表> ]\nFROM  <表名|视图名>[，<表名|视图名>…]\n[ WHERE  <条件表达式> ]\n[ GROUP BY  <列名> [HAVING <条件表达式> ]]\n[ ORDER BY  <列名> [ ASC | DESC ] ];\n\n-- BETWEEN AND 限制列值范围\nSELECT  *\nFROM  STUDENT\nWHERE BirthDay BETWEEN ‘2000-01-01’ AND ‘2000-12-30’;\n\n-- LIKE 通配符'_'代表一个字符'%'代表一个或多个字符 \nSELECT  *\nFROM  STUDENT\nWHERE  Email  LIKE  ’%@163.com’;\n\n-- AND\\OR\\NOT 逻辑运算符\nSELECT  StudentID, StudentName, StudentGender, Major\nFROM  STUDENT\nWHERE  Major=’软件工程’  AND  StudentGender=’男’;\n\n-- IN 限定范围\nSELECT  StudentID, StudentName, StudentGender, Major\nFROM  STUDENT\nWHERE  Major IN  ('计算机应用');\n\n-- ORDER BY <> ASC/DESC 默认升序ASC\n-- 多个列排序时，写在前面排序的基础上满足后面的\nSELECT  *\nFROM  STUDENT\nORDER  BY  Birthday DESC ,  StudentName  ASC;\n\n-- 内置函数\nSELECT  COUNT（*） AS  学生人数\nFROM  Student;\nSELECT  Min（Birthday） AS 最大年龄，Max（Birthday） AS 最小年龄\nFROM  Student;\n\n-- GROUP BY <> HAVING \n-- 专业统计STUDENT表中男生人数，但限定只显示人数大于2的人数\nSELECT  Major  AS 专业,  COUNT（StudentID） AS 学生人数\nFROM  Student\nWHERE  StudentGender=’男’\nGROUP  BY  Major\nHAVING  COUNT(*)>2;\n```\n\n### 多表关联查询\n\n子查询\n\n```sql\nSELECT  TeacherID, TeacherName, TeacherTitle\nFROM  Teacher\nWHERE  CollegeID  IN\n        (SELECT  CollegeID  \n     FROM  College\n     WHERE  CollegeName='计算机学院');\n\n```\n\n连接查询\n\n```sql\nSELECT  B.CollegeName AS 学院名称,  A.TeacherID  AS 编号, A.TeacherName  AS 姓名,  A.TeacherGender  AS 性别,  A. TeacherTitle  AS 职称\nFROM  Teacher  AS  A，College  AS  B\nWHERE  A.CollegeID=B.CollegeID \nORDER  BY  B.CollegeName, A.TeacherID;\n\n-- JOIN ON 内连接\nSELECT  B.CollegeName AS 学院名称,  A.TeacherID  AS 编号, A.TeacherName  AS 姓名,  A.TeacherGender  AS 性别,  A. TeacherTitle  AS 职称\nFROM  TEACHER  AS  A  JOIN  COLLEGE  AS  B\nON  A.CollegeID=B.CollegeID \nORDER  BY  B.CollegeName, A.TeacherID;\n\n-- LEFT JOIN/RIGHT JOIN/FULL JOIN 外连接\nSELECT C.CourseName AS 课程名称, T.TeacherName AS 教师, \nCOUNT  (R.CoursePlanID)  AS 选课人数\nFROM  COURSE  AS  C  JOIN  PLAN  AS  P  \nON  C.CourseID=P.CourseID \nJOIN  TEACHER  AS  T  ON  P.TeacherID=T.TeacherID\nLEFT  JOIN  REGISTER  AS  R  ON  P.CoursePlanID=R.CoursePlanID\nGROUP  BY C.CourseName, T.TeacherName;\n```\n\n# 数据库设计\n\n## 概述\n\n### 数据库开发过程\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603193850316.png\" alt=\"image-20230603193850316\" style=\"zoom:67%;\" />\n\n### 数据库结构模型设计-数据库结构模型\n\n| 概念数据模型  Conceptual  Data Model (CDM) | 从用户角度所建模的系统数据对象及其关系，它帮助用户分析信息系统的数据结构关系。 |\n| ------------------------------------------ | :----------------------------------------------------------- |\n| 逻辑数据模型  Logic  Data Mode(LDM)        | 从**系统分析员**角度所建模的系统数据对象逻辑结构关系，它帮助开发人员分析信息系统的逻辑数据结构。 |\n| 物理数据模型  Physical  Data Model (PDM)   | 从系统设计人员角度所建模的系统数据物理存储及结构关系，它针对设计者具体定义信息系统的数据库表结构。 |\n\n## E-R模型方法\n\n> “实体-联系模型”（Entity-Relationship Model）的简称。它是一种描述现实世界**概念数据模型**、**逻辑数据模型**的有效方法，基本元素有实体、属性、标识符和联系\n\n联系度数：联系中关联的实体数目\n\n二元联系-基数：实体的实例与另一实体实例存在的数量对应关系，1/n，表示最大基数\n\n实体参与关系：可选/强制，表示最小基数 p;\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603193923231.png\" alt=\"image-20230603193923231\" style=\"zoom:67%;\" />\n\n实体继承联系：表示实体的相似性，有公共属性的是父实体，有特殊性的是子实体\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603193933407.png\" alt=\"image-20230603193933407\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603193945024.png\" alt=\"image-20230603193945024\" style=\"zoom:67%;\" />\n\n强弱实体联系：弱实体的存在必须以强实体的存在为前提，这是一个相对的概念\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603193954175.png\" alt=\"image-20230603193954175\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194004354.png\" alt=\"image-20230603194004354\" style=\"zoom:67%;\" />\n\n扩展建模实例o\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194028029.png\" alt=\"image-20230603194028029\" style=\"zoom:67%;\" />\n\n### 概念数据模型\n\n概念数据模型设计一般是采用E-R模型方法进行建模设计\n\n### CDM/LDM/PDM模型转换设计\n\n当使用关系数据库时，物理数据模型（PDM）即为关系模型。CDM/LDM到PDM的转换其实就是E-R模型到关系模型的转换。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194202048.png\" alt=\"image-20230603194202048\" style=\"zoom:67%;\" />\n\nCDM/LDM转换\n\n1. LDM将CDM的多对多实体联系转化为易于关系数据库实现的一对多实体联系\n2. LDm将CDM中的标识符依赖实体进一步细化，并区分主键标识符< pi >和外键标识符< fi >，以便数据模型规范化处理\n\nE-R模型到关系模型转换原理：\n\n1. 将每一个实体转换成一个关系表，实体属性转换为关系表的列，实体标识符转换为关系表的主键或外键。\n2. 将实体之间的联系转化为关系表之间的参照完整性约束。\n\n弱实体转换为关系表\n\n![image-20230603194222701](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194222701.png)\n\n![image-20230603194229345](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194229345.png)\n\n实体联系转换\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194242124.png\" alt=\"image-20230603194242124\" style=\"zoom:67%;\" />\n\n![image-20230603194250887](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194250887.png)\n\n![image-20230603194259344](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194259344.png)\n\n实体继承联系转换\n\n将父表中的主键放置到子表中，既做主键又做外键。\n\n实体递归联系转换\n\n![image-20230603194328262](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194328262.png)\n\n![image-20230603194334061](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194334061.png)\n\n## 数据库规范化设计\n\n通常在LDM时期进行规范化设计完善，减少冗余数据，设计合理依赖约束关系，降低维护数据完整性一致性的工作量，访问更高效\n\n问题：一个表中存在多个主题的数据，且大量重复出现\n\n### 函数依赖理论\n\n> 在关系模式R（U）中， U 为关系R的属性集合，X和Y为属性U的子集。设t，s是关系R中的任意两个元组，如果t[X] = s[X]，则t[Y] = s[Y]。那么称Y函数依赖于X，表示为X→Y。此时**函数依赖的左部称为决定因子**，**右部称为依赖函数**。决定因子和依赖函数都是属性的集合。函数依赖反映属性或属性组之间相互依存、互相制约的关系，即关系表中属性之间的依赖关系。\n\n完全函数依赖\n\n> 设X、Y是某关系的不同属性集，如X→Y，且不存在X中的子集 X’使X’→Y，则Y称完全函数依赖，否则称Y部分函数依赖。\n\n对于关系R（<u>X</u>, <u>Y</u>, N, O, P），其中（X，Y）为复合主键，若其它属性N,O,P都完整依赖于该复合主键，则称关系R为完全函数依赖。反之，其它属性N,O,P仅依赖于X，或仅依赖于Y，则称R为部分函数依赖。\n\n函数传递依赖\n\n对于关系R（<u>X</u>, N, O, P），其中X为主键，若属性N依赖于X，**而X不依赖于N**，属性O依赖于N。则属性O函数传递依赖于X。\n\n多值函数依赖\n\n对于教学关系R（课程, 教师, 课程参考书），一门课程可以有多个任课教师，也可以有多本参考书；每个任课教师可以任意选择他的参考书。该关系存在多值函数依赖。\n\n### 关系规范化范式\n\n1NF：关系表中的属性不可再细分，否则该表不是关系表\n\n2NF：1NF基础上，消除关系中的属性部分函数依赖(多在复合主键里面)\n\n> 有一个关系（<u>A</u>,<u>B</u>,N,O,P）,其复合主键为（A,B）,那么N,O,P这三个非键属性都不存在只依赖A或只依赖B情况，则该关系满足第2范式,反之,不满足第2范式。\n\n3NF：2NF基础上，切断属性传递函数依赖\n\n> 若有一个关系（A,N,O,P）,主键为（A）,那么非键属性N,O或P都不能由单个的N,O或P或它们的组合所确定。该关系满足第3范式。\n\n**BCNF：所有函数依赖的决定因子都是候选键**\n\n**4NF：BCNF基础上，消除了多值函数依赖**\n\n### 逆规范化处理\n\n规范化过高也会导致数据库性能降低，因此要适当降低规范化范式约束，允许适当的数据冗余性，以获取数据访问性能。可以通过增加冗余列或派生列，多个表合并为一个表进行处理。\n\n# 数据库管理\n\n## 概述\n\n包括性能索引查询并发管理、角色用户对象权限管理、安全备份恢复等。\n\npgadmin4-Postgresql的数据库管理工具\n\n## 事务管理\n\n防止业务处理单元的一组操作中某一步出现错误导致混乱，事务是DBMS执行的最小任务单元、故障恢复单元、并发控制任务单元\n\n生命周期状态变迁图\n\n![image-20230603194419185](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194419185.png)\n\n事务ACID特性\n\n- 原子性（Atomicity）：事务所有操作在数据库中要么全部执行，要么全部不执行。\n- 一致性（Consistency）：事务多次执行，其结果应一致。\n- 隔离性（Isolation）：事务与事务之间隔离，并发执行透明。\n- 持续性（Durability ）：事务完成后，数据改变必须是永久的。\n\n```sql\nSTART TRANSACTION;\nINSERT  INTO college( collegeID, collegename)VALUES ('004', '外语学院');\nINSERT  INTO college( collegeID, collegename)VALUES ('005', '数学学院');\nINSERT  INTO college( collegeID, collegename)VALUES ('006', '临床医学院');\nCOMMIT;\n```\n\n## 并发控制\n\n### 事务调度\n\n多个事务在DBMS同时运行可能对共享数据同时访问，需要加以约束控制按照恰当顺序访问，否则导致数据不一致和死锁。在DBMS中，为使并发事务调度实现的处理结果与串行化调度处理结果一致，事务管理器将并发执行事务的SQL数据操作请求提交给并发控制调度器。由并发控制调度器将各个事务的SQL数据操作请求按照一定顺序进行调度执行，并完成对数据库缓冲区的读写操作。\n\n#### 数据不一致问题\n\n丢失更新\n\nT1、T2两个事务并发执行，它们均对数据库共享数据A进行了非锁定资源的读写操作。当事务T1和T2均读入该共享数据A并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改被丢失。\n\n不可重复读\n\n![image-20230603194431807](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194431807.png)\n\n幻象读\n\n事务T1按一定条件从数据库中读取某些数据记录后，事务T2在其中插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。称为幻象读取。与不可重复读类似。\n\n脏数据读取\n\n![image-20230603194438438](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194438438.png)\n\n### 锁机制\n\n事务对共享数据加锁访问，锁的粒度由数据库到表页面行\n\n- 排它锁定(Lock-X)——锁定后，不允许其它事务对共享数据再加锁\n- 共享锁定(Lock-S)——锁定后，只允许其它事务对共享数据添加读取锁\n\n锁的相容性：排他锁与其他锁均不相容，共享锁之间相容\n\n#### 加锁协议\n\n一级加锁协议：对共享数据修改时执行排它锁定指令，直到该事务处理完成才解锁。只能避免丢失更新问题。\n\n二级加锁协议：一级协议基础上，对共享数据读操作进行共享锁定指令，读完数据立刻释放共享锁。避免丢失更新问题，脏读。\n\n三级加锁协议：一级协议基础之上，对共享数据读操作进行共享锁定指令，直到事务处理结束才释放。避免丢失更新、脏读、不可重复读问题。\n\n#### 两阶段锁定协议\n\n**二阶段锁定协议可以保证可串行化调度**\n\n每个事务必须分两个阶段提出加锁和解锁申请:\n\n- 增长阶段，事务只能获得锁，但不能释放锁。\n- 缩减阶段，事务只能释放锁，但不能获得新锁。\n\n### 死锁\n\n事务同时锁定两个及以上资源可能出现彼此不能继续执行的状态\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194449699.png\" alt=\"image-20230603194449699\" style=\"zoom:67%;\" />\n\n### 事务隔离\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194501880.png\" alt=\"image-20230603194501880\" style=\"zoom:67%;\" />\n\n## 安全管理\n\n### 存取安全模型\n\n![image-20230603194516267](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194516267.png)\n\n### 系统安全模型\n\n![image-20230603194526082](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194526082.png)\n\n![image-20230603194531339](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194531339.png)\n\n### 用户管理\n\n在DBMS中对每个用户进行管理\n\n```sql\n--创建用户\nCREATE USER \"USERA\" WITH\n LOGIN\n INHERIT\n NOSUPERUSER\n NOCREATEDB\n NOCREATEROLE\n NOREPLICATION\n CONNECTION LIMIT -1\n PASSWORD '123456';\n \n--修改用户\nALTER USER \"USERA\"\n  CONNECTION LIMIT 10\n  PASSWORD 'GRES123';\nALTER USER  <用户名>  [ [ WITH ] option [ ... ] ];              \t--修改用户的属性\nALTER USER  <用户名>  RENAME TO <新用户名>;                          --修改用户的名称\nALTER USER  <用户名>  SET <参数项> { TO | = } { value | DEFAULT };  --修改用户的参数值  \nALTER USER  <用户名>  RESET <参数项>;\t\t\t                      --重置用户参数值\n\n--删除用户\nDROP USER \"USERA\";\n```\n\n### 权限管理\n\nDBA对用户进行数据库系统/数据库对象访问操作/数据库对象定义操作的授予/收回/拒绝权限\n\n```sql\nGRANT  SELECT  ON  Department  TO  userA;\nGRANT  SELECT  ON  Employee    TO  userA;\nGRANT  SELECT  ON  Project     TO  userA;\nGRANT  SELECT  ON  Assignment  TO  userA;\n\nGRANT  <权限名> ON  <对象名>  TO {数据库用户名|用户角色名}；\nREVOKE  <权限名> ON  <对象名>  FROM {数据库用户名|用户角色名}；--撤回权限\nDENY  <权限名> ON  <对象名> TO {数据库用户名|用户角色名}；--拒绝权限\n```\n\n### 角色管理\n\n将一组相同权限的用户定义为角色\n\n```sql\nCREATE  ROLE  <角色名> [ [ WITH ] option [ ... ] ]; \t               --创建角色\nALTER  ROLE  <角色名>  [ [ WITH ] option [ ... ] ]; \t               --修改角色属性\nALTER  ROLE  <角色名>  RENAME TO <新角色名>; \t\t                    --修改角色名称 \nALTER  ROLE  <角色名>  SET <参数项> { TO | = } { value | DEFAULT };\t --修改角色参数值\nALTER  ROLE  <角色名>  RESET <参数项>;\t                    \t\t --复位角色参数值\nDROP  ROLE  <角色名>;\t\t\t\t\t                           \t   --删除指定角色\n\nCREATE  ROLE  \"Role_Manager\"  WITH\n LOGIN\n NOSUPERUSER\n NOCREATEDB\n NOCREATEROLE\n INHERIT\n NOREPLICATION\n CONNECTION LIMIT -1;\n\nGRANT  SELECT,INSERT,UPDATE,DELETE  ON  Department  TO  \"Role_Manager\";\nGRANT  SELECT,INSERT,UPDATE,DELETE  ON  Employee  TO  \"Role_Manager\";\nGRANT  SELECT,INSERT,UPDATE,DELETE  ON  Project  TO  \"Role_Manager\";\nGRANT  SELECT,INSERT,UPDATE,DELETE  ON  Assignment  TO  \"Role_Manager\";\n```\n\n为用户赋予角色\n\n```sql\nCREATE USER  \"StudentUser\"  WITH\n  LOGIN\n  CONNECTION LIMIT -1\n  IN ROLE \"R_Student\"\n  PASSWORD '123456';\nCREATE USER  \"TeacherUser\"  WITH\n  LOGIN\n  CONNECTION LIMIT -1\n  IN ROLE \"R_Teacher\"\n  PASSWORD '123456';\n```\n\n## 数据库备份与恢复\n\n数据库备份：对数据和状态（日志）进行副本复制\n\n数据库恢复：从备份副本将数据库从错误状态恢复到某一正确状态\n\n备份SAMPLE数据库到一个G磁盘的根目录文件Sample.bak中。 \n\n```sql\nBACKUP DATABASE SAMPLE   \nTO DISK = ‘G:\\Sample.bak'; \n```\n\n从存储备份文件中恢复SAMPLE数据库。 \n\n```sql\nRESTORE DATABASE SAMPLE\nFROM DISK = ‘G:\\Sample.bak'; \n```\n\n也可利用事务日志前滚或回滚方式进行数据库恢复\n\n# 数据库应用编程\n\n## 数据库连接技术ODBC\n\n### 概念\n\n传统应用开发通常选用特定DBMS管理系统，Microsoft推出开放式数据库互连（Open DataBase Connectivity，简写为ODBC）技术。ODBC定义了一套基于SQL的、公共的、与数据库无关的API，实现了应用程序对多种不同DBMS的数据库的访问，实现了数据库连接方式的变革。 ODBC使应用程序利用相同源码就可以访问不同数据库系统。\n\n### ODBC层次结构\n\n![image-20230603194547936](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194547936.png)\n\n### ODBC使用步骤\n\n1. 使用ODBC管理器注册一个数据源\n2. 管理器根据数据源提供的信息（数据库位置类型及ODBC驱动程序）建立ODBC与具体数据库的联系\n3. 应用程序将数据源名提供给ODBC，让ODBC建立起连接\n4. 应用程序通过驱动程序管理器与数据库交换信息\n5. 驱动程序管理器负责将应用程序对ODBC API的调用传递给正确的驱动程序\n6. 驱动程序执行玩相应的sql操作后，通过驱动程序管理器将结果返回给应用程序\n\n## 数据库连接技术（JDBC）\n\n### 概念\n\n**JDBC**（Java DataBase Connectivity，Java数据库连接）技术的简称 ，是一种用于执行SQL语句的Java API。它由一组用Java编程语言编写的类和接口组成。这个API由**java.sql.*包中**的一些类和接口组成，它为数据库开发人员提供了一个标准的API，使他们能够用纯Java API 来编写数据库应用程序。使用JDBC访问数据库需要相应数据库的JDBC驱动程序\n\n```java\n// 加载驱动\nClass.forName(\"org.postgresql.Driver\");\n// 建立连接\nString UrL = \"jdbc:postgresql://localhost:5432/testdb\";\nString username = \"myuser\";\nString password = \"sa\";\nConnection conn = DriverManager.getConnection(URL,username,password);\n// 创建Statement对象\nStatement stmt = conn.createStatement();\n// 执行sql语句\nString sql = \"INSERT INTO public.student (sid, sname, gender, birthday, major, phone)\" + \" VALUES ('2017001', '张山', '男', '1998-10-10','软件工程','13602810001')\";\nstmt.executeUpdate(sql);\n```\n\n创建了Statement对象 ,就可以向Statement对象发送SQL语句。主要掌握两种执行SQL语句的方法：executeQuery()、executeUpdate()\n\n1. executeQuery()：返回语句执行后的单个结果集的，所以通常用于select语句\n2. executeUpdate()返回值是一个整数，指示受影响的行数（可以用于update、insert、delete语句）\n\n```java\n// 保存结果集\nStatement stmt = conn.createStatement();\nString sql = \"SELECT id, name, age FROM company\";\nResultSet rs = stmt.executeQuery(sql);\nwhile(rs.next()){\n    System.out.println(rs.getString(\"name\"));\n}\n// 关闭连接\nrs.close();\nstmt.close();\nconn.close();\n```\n\n## 数据库存储过程\n\n存储过程，一种数据库对象，由一组能完成特定功能的SQL语句集构成，编译后存储在数据库服务端接受调用。能够减少网络通信量加快执行速度，不过开发调试复杂可移植性差。\n\n```sql\nCREATE [ OR REPLACE ] FUNCTION/PROCEDURE  name\n    ( [ [ argmode ] [ argname ] argtype [ { DEFAULT | = } default_expr ] [, ...] ] )\n    [ RETURNS retype | RETURNS TABLE ( column_name  column_type [, ...] ) ]\nAS $$         //$$用于声明存储过程的实际代码的开始\nDECLARE\n        -- 声明段\nBEGIN\n        --函数体语句\nEND;\n$$ LANGUAGE lang_name;  //$$ 表明代码的结束, LANGUAGE后面指明所用的编程语言\n\n-- 创建一个名为countRecords()的存储过程统计STUDENT表的记录数。\nCREATE OR REPLACE FUNCTION countRecords ()  \nRETURNS integer AS $count$  \ndeclare  \n    count integer;  \nBEGIN  \n   SELECT count(*) into count FROM STUDENT;  \n   RETURN count;  \nEND;  \n$count$ LANGUAGE plpgsql;\n\n-- 执行存储过程\nSELECT * FROM countRecords();\n\n-- 存储过程调用其他存储过程:select  into 自定义变量  from 存储过程名（参数）；\nCREATE OR REPLACE FUNCTION testExec()  \nreturns integer AS $$ \ndeclare\n   rec integer;  \nBEGIN  \n   select  into rec countRecords();  \n     //如果不关心countRecords()的返回值，则可用 PERFORM countRecords() 代替; \n   return  rec;  \nEND;  \n$$ LANGUAGE plpgsql;\n\n-- 删除存储过程\nDROP FUNCTION [ IF EXISTS ] name ( [ [ argmode ] [ argname ] argtype [, ...] ] ) [ CASCADE | RESTRICT ]\n\nDROP FUNCTION IF EXISTS testExec();\n\n```\n\n## 数据库触发器\n\n触发器是一个定义在表或视图上的特殊类型的存储过程（不传递接受参数）、一个特殊的事务单位，由操作事件触发自动执行，可以实现比约束更复杂的数据完整性，用于加强数据完整性约束和业务规则\n\n语句级触发器只执行一次（默认触发器）；行级触发器每有数据变化一行就执行一次\n\nINSTEAD OF触发器：事件发生时只执行触发器不执行原本的sql语句，一个表或视图只能有一个INSTEAD OF触发器\n\n### 触发器相关特殊变量\n\nNEW：RECORD类型，对于行级触发器其存有INSERT或UPDATE操作产生的新数据行。对于语句级触发器其值为NULL\n\nOLD：RECORD类型，对于行级触发器其存有DELETE或UPDATE操作修改或删除的旧数据行。对于语句级触发器其值为NULL\n\nTG_OP:text类型，值为INSERT/UPDATE/DELETE，说明引发触发器的操作\n\n创建触发器步骤：\n\n1. 检查所依附的表或视图是否存在\n2. 创建触发器执行的触发器函数，返回类型为TRIGGER\n3. 创建触发器\n\n```sql\nCREATE  TRIGGER  触发器名   \n    { BEFORE | AFTER | INSTEAD OF }\n     ON 表名\n     [ FOR [ EACH ] { ROW | STATEMENT } ]\n     EXECUTE PROCEDURE 存储过程名 ( 参数列表 )\n```\n\n实例 为了防止非法修改stu_score表的课程成绩，创建audit_score表记录stu_score表的成绩变化\n\n```sql\n-- 创建表\nCREATE TABLE stu_score\n( \n    sid character(10) NOT NULL,\n    cid character(10) NOT NULL,\n    score numeric(5,1),\n    CONSTRAINT stu_score_pkey PRIMARY KEY (sid, cid)\n)\nCREATE TABLE audit_score\n(    username character(20) ,  --用户名\n    sid character(10) ,\n    cid character(10) ,\n    updatetime text ,            --修改的时间\n    oldscore numeric(5,1),   --修改前的成绩\n    newscore numeric(5,1)  --修改后的成绩\n)\n-- 创建函数\nCREATE OR REPLACE FUNCTION score_audit() RETURNS TRIGGER \nAS $score_sudits$\nBEGIN\n\tIF (TG_OP = 'DELETE') THEN\n\t\tINSERT INTO audit_score SELECT user,old.sid,old.cid,OLD.score ;\n\t\tRETURN OLD;\n\tELSIF (TG_OP = 'UPDATE') THEN\n\t\tINSERT INTO audit_score\n\t\tSELECT user,old.sid,old.cid,now(),OLD.score,new.score\n\t\tWHERE old.sid=new.sid and old.cid=new.cid;\n\t\tRETURN NEW\n\tELSIF (TG_OP = 'INSERT') THEN\n\t\tINSERT INTO audit_score SELECT user,new.sid,new.cid,now(),null,new.score;\n\t\tRETURN NEW;\n\tEND IF;\n\tRETURN NULL;\nEND;\n$score_audits$ LANGUAGE plpgsql;\n-- 创建触发器\nCREATE TRIGGER score_audit_triger\nAFTER INSERT OR UPDATE OR DELETE ON stu_score\nFOR EACH ROW EXECUTE PROCEDURE score_audit();\n-- 修改触发器\nALTER TRIGGER score_audit_trigger ON stu_score  RENAME TO score_audit_trig;\n-- 删除触发器\nDROP TRIGGER [ IF EXISTS ] name ON table_name [ CASCADE | RESTRICT ]\n\nDROP TRIGGER IF EXISTS score_audit_trig ON stu_score CASCADE;\n```\n\n## 数据库游标\n\n游标是一种存放了查询数据库表返回的数据记录的临时的数据库对象，包含查询结果和指针，提供了处理结果集中每一条记录的机制，它总是与一条查询SQL语句相关联\n\n声明游标\n\n![image-20230603194659342](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194659342.png)\n\n```sql\n-- 声明游标\ncurStudent CURSOR FOR SELECT * FROM student;\ncurStudentOne CURSOR (key integer)7y IS SELECT * FROM student WHERE SID = key;\n\n```\n\n打开游标\n\n![image-20230603194708438](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194708438.png)\n\n使用游标\n\n![image-20230603194714433](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194714433.png)\n\n关闭游标\n\n![image-20230603194737413](https://cdn.davidingplus.cn/images/2025/02/01/image-20230603194737413.png)\n\n## 嵌入式sql编程\n\nsql与宿主语言，混合编程\n\n# NoSQL数据库技术\n\n## 大数据5V特征：大量，高速性，多样性，真实性，价值性\n\n- 超量Volume\n- 高速Velocity\n- 异构Variety\n- 真实Veracity\n- 价值Value\n\n## CAP理论\n\n在分布式的环境下设计和部署系统时，有3个核心的需求：**CAP对应一致性（Consistency），可用性（Availability）和分区容忍性（Partition Tolerance）**\n\nCAP理论的核心：\n\n**一个分布式系统不可能同时很好的满足一致性、可用性和分区容错性这三个需求，最多只能同时较好的满足两个。**\n\n- CA - 单点集群，满足一致性，可用性的系统，\n- CP - 满足一致性，分区容忍性的系统，\n- AP - 满足可用性，分区容忍性的系统，\n\nCAP目的：\n\n- CAP是为了探索不同应用的一致性C与可用性A之间的平衡，\n- 在网络或其他原因，通过牺牲一定的一致性C来获得更好的性能与扩展性\n- 在有分隔发生，选择可用性A，集中关注分隔的恢复，需要分隔前、中、后期的处理策略， 及合适的补偿处理机制。\n- 选择什么样的方式： 放弃Ｐ？放弃Ａ？放弃Ｃ？BASE\n\n## BASE\n\n- **Basically Available --基本可用**；系统能够基本运行，一直提供服务。\n- **Soft-state --软状态/柔性事务**。\"Soft state\" 可以理解为\"无连接\"的, 而 \"Hard state\" 是\"面向连接\"的；系统不要求一直保持强一致状态。 \n- **Eventual Consistency --最终一致性** 系统在某个时刻达到最终一致性。\n- BASE定义为CAP中AP的衍生，在分布式环境下， BASE是数据的属性，BASE强调基本的可用性，按照功能划分数据库\n\nbase特点\n\n- **ACID是事物的特征**， A（原子性）C（一致性）I（隔离性）D（持久性），ACID的特点是强一致性、隔离性、采用悲观保守方法、难以变化；\n- BASE的特点是弱一致性、可用性优先、采用乐观方法、适应变化并且简单快捷。\n- 对数据不断增长的系统， 大数据环境下系统的可用性及分隔容忍性的要求要高于强一致性，很难满足事务要求的ACID特性。\n\n## 最终一致性\n\n- 强一致性：要求无论更新操作实在哪一个副本执行，之后所有的读操作都要能获得最新的数据。\n- 弱一致性：用户读到某一操作对系统特定数据的更新需要一段时间，称这段时间为“不一致性窗口”。\n- 最终一致性： 弱一致性的一种特例，保证用户最终能够读取到某操作对系统特定数据的更新。\n\n## 存储模型\n\n- 列存储数据库，将同一列的数据存储在一起，可以存储结构化和半结构化数据\n- 键值存储数据库，存储的数据是有键（key）和值（value）两部分组成，通过key快速查询到其value，value的格式可以根据具体应用来确定\n- 文档存储数据库，存储的内容是文档型的，可以用格式化文件（类似json、XML等）的格式存储\n- 图存储数据库，数据以有向加权图方式进行存储\n\n|       **分类**        |                  **Examples**举例                   |                       **典型应用场景**                       |                    **数据模型**                     |                           **优点**                           |                           **缺点**                           |\n| :-------------------: | :-------------------------------------------------: | :----------------------------------------------------------: | :-------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n| 键值    （key-value） | Tokyo  Cabinet/Tyrant, Redis, Voldemort,  Oracle DB | 内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等等 | Key  指向  Value  的键值对，通常用hash  table来实现 |                          查找速度快                          |        数据无结构化，通常只被当作字符串或者二进制数据        |\n|     列存储数据库      |               Cassandra,  HBase, Riak               |                       分布式的文件系统                       |         以列簇式存储，将同一列数据存在一起          |         查找速度快，可扩展性强，更容易进行分布式扩展         |                         功能相对局限                         |\n|     文档型数据库      |                  CouchDB, MongoDb                   | 与Key-Value类似，Value是结构化的，不同的是数据库能够了解Value的内容 |      Key-Value对应的键值对，Value为结构化数据       | 数据结构要求不严格，表结构可变，不需要像关系型数据库一样需要预先定义表结构 |            查询性能不高，而且缺乏统一的查询语法。            |\n|   图形(Graph)数据库   |          Neo4J,  InfoGrid,  Infinite Graph          |           社交网络，推荐系统等。专注于构建关系图谱           |                       图结构                        |     利用图结构相关算法。比如最短路径寻址，N度关系查找等      | 很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案 |\n\n","categories":["校内课程","数据库"]},{"title":"本科 实验室工作记录","url":"/posts/a73bc3b6.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n这部分是对我`实验室工作`的`记录和总结`。\n\n# 总览\n\n我是大二下四月份进入的实验室，跟随学长负责的是网络模块的部分，我自己完成了对于`IP`地址的封装，完成了`LHostAddress`类(虽然他们两个最后没用我的代码，可能是懒得做修改和适配吧)，供他们两个调用，在这个过程我学到了大型项目的编译方法，我们的项目`sdk`部分采用的是`cmake`编译链接的方式，非常好用，使用第三方软件`conan`进行第三方包的管理，在`Linux`平台下(也是我想要就业的平台方向)进行构建编译。暑假学长走后，针对代码过程出现的`bug`进行了修复，9月初结束了`sdk`部分的开发，现在转向了安全代码扫描部分的开发。\n\n<!-- more -->\n\n安全代码扫描部分，我们需要用开源项目`llvm`编译生成的`clang-tidy`可执行文件去扫描代码中的规范问题并提出警告，首先这涉及到的是`clang`编译器，我没用过，但是这个问题倒不是很大；第二是这个东西涉及到编译原理中的抽象语法树，这个东西我没学过，所以有点难，还好老师给我分配的任务是中低优先级，到目前为止还好。关于工作中的细节问题我放在下面了。\n\n注意：下面由于我配置了`ccache`(这玩意用起来是真爽我操)，编译器版本写`\"g++\"`和`\"gcc\"`，不能让他直接调用我们安装的`gcc`，`g++`，要走`ccache`这一步哈，并且对于公司这边，记得`gcc`和`g++`一定要切为`gcc-9`(当然我没事也不会切)...\n\n# Larksdk工作内容\n\n我主要负责的是网络模块后续的处理，目前我一个人感觉能够处理，基本到收尾阶段了。\n\n## cmake构建\n\n第一次按照下面的`cmake`操作，后面就只用 `cmake ..` 就可以了\n\n~~~bash\nconan install ..\ncmake -DCMAKE_C_COMPILER=\"gcc\" -DCMAKE_CXX_COMPILER=\"g++\" ..\nmake # 构建 LarkSDK 本体和 snippet 下面的测试代码片段\n~~~\n\n现在需要激活`GoogleTest`单元测试，激活构建目标`tests`，可以用如下：\n\n~~~bash\ncmake -DCMAKE_C_COMPILER=\"gcc\" -DCMAKE_CXX_COMPILER=\"g++\" -DENABLE_GTEST=ON ..\n\n# 这两个根据需要进行操作\nmake # 构建 LarkSDK 本体和 snippet 下面的测试代码片段\nmake tests # 构建单元测试\n~~~\n\n如果显示`doxygen`相关的错误，那么记得安装；可能也需要安装一下`graphviz`\n\n~~~bash\nsudo apt install doxygen graphviz\n~~~\n\n### 2024/1/22 更新\n\n在公司我的办公电脑上我安装的是`Ubuntu`虚拟机，上述在`Wsl`上的步骤可能不太适应原生的`Ubuntu`系统，所以可能编译会报错\n\n我总结了一下，使用如下流程，前提是配置好了`ccache`，总结好下面的原因就是为了兼容`ccache`和`vscode`当中的`CMake tools`，注意`cmake`后面是**两个点**\n\n~~~bash\nconan install ..\ncmake -DENABLE_GTEST=ON ..\ncmake ..\nmake\nmake tests\n~~~\n\n第一次`cmake`的时候，选择的编译器如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240122174307585.png\" alt=\"image-20240122174307585\" style=\"zoom:70%;\" />\n\n第二次的时候如下：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20240122174342963.png\" alt=\"image-20240122174342963\" style=\"zoom:67%;\" />\n\n如果是这样，就表明配置成功了，在`vscode`的`CMake Tools`插件当中只能找到`gcc`和`g++`，虽然我们在配置`ccache`的时候做了软链接的映射，但是还是会出现各种问题，这样的流程可以有效的做到避免\n\n然后进行`make`即可\n\n## 单元测试和覆盖率检测\n\n- `googletest`版本使用`1.12.1`，去`github`下载源码进行编译安装\n\n- `gcovr`版本使用`5.1`，使用`pip`安装\n\n本地运行单元测试，并且生成覆盖率报告，按照上面进行单元测试，在测试过程中，覆盖率数据将会被自动收集，然后我们通过`gcovr`工具生成这份报告，如下：\n\n~~~bash\n# 安装gcovr\nsudo apt install pip\npip install gcovr\n\n# 建议回到项目根目录执行 gcovr\n\n# gcovr 可以一步直接生成测试率报告\n# 注：若不是在项目根目录执行 gcovr， 需用 -r 参数指定项目根目录，即 build 的上一级目录，以同时找到源码文件和 gcov 中间数据文件（*.gcno、*.gcda）\n# -e 参数用于排除无需覆盖率报告的源码文件，接受正则表达式。\n\n# 生成单页 html 覆盖率简报\ngcovr -e \".*3rdparty.*\" --exclude-throw-branches --exclude-unreachable-branches --html build/gcovr.html\n\n# 生成多页面 html 详细覆盖率报告到 gcovr 目录中\nmkdir build/gcovr\ngcovr -e \".*3rdparty.*\" --exclude-throw-branches --exclude-unreachable-branches --html-details build/gcovr/gcovr.html\n\n# 浏览器打开 build/gcovr.html 或 build/gcovr/gcovr.html即可查看单元测试覆盖率报告\n~~~\n\n## 后续\n\n网络模块测试完毕啦，问题也全部解决，剩下的`12`月就在实验室复习，然后考完试就去上班！啦啦啦啦啦啦！~~~\n\n# 安全代码扫描工作内容\n\n## LarkScanner\n\n`LarkScanner`是已经写好的脚本，执行这个脚本可以执行国军标的检测文件`clang-tidy`\n\n- `clang-tidy/src/gjb8114`目录下的规则文件的编写：一个头文件.h，一个源文件`.cpp`，以表格中的序号命名\n\n- 编写完成之后，需要在`gjb/samples`目录下编写对应的两个源文件，一个是遵守规则的，一个是不遵守规则的，还是以序号命名，如果扫描出来之后遵守规则没有扫到然后不遵守规则的扫到了，那么就算成功\n\n- 编译命令\n\n  ~~~bash\n  conan install .. //只用拉一次\n  cmake -DPACKAGE_VERSION=1.0.1 -DCMAKE_C_COMPILER=\"gcc\" -DCMAKE_CXX_COMPILER=\"g++\" ..\n  make\n  ~~~\n\n  `make`完毕之后在`build/bin`目录下生成可执行文件`larkscan`\n\n  然后我们需要跑程序来检测`samples`目录下的各个程序\n\n  ~~~bash\n  ctest -VV\n  ~~~\n\n  或者我们直接调用可执行程序`larkscan`来扫描样本目录的程序(我的第一个不行，只能用第二个目前)\n\n  ~~~bash\n  // 现在我们在build目录\n  ./bin/larkscan ../gjb/\n  ~~~\n\n- 我们需要把自己编译的规则拿到`llvm`工程当中去编译，见第二条，这样生成的新文件就包含了我们写的规则了，然后把生成的`clang-tidy`在我们的项目中`clang-tidy/bin`目录下替换掉，然后再把`clang-tidy/bin`和`clang-tidy/lib`目录再次拷贝到`/opt/LarkStudio5/LarkScanner`\n\n~~~bash\ncd /opt/LarkStudio5/LarkScanner\n\nsudo cp /home/lzx0626/DavidingPlus/Lark5/larkscanner/clang-tidy/bin . -r\nsudo cp /home/lzx0626/DavidingPlus/Lark5/larkscanner/clang-tidy/lib . -r\n~~~\n\n## 国军标规则编写\n\n- 国军标规则编写的流程\n\n  注意，用官方的`llvm`工程它本身是不包含我们自己的模块的，想要编译我们自己的模块需要添加一些东西，见`gitlab`:\n\n  [点这里，注意挂梯子](http://192.168.1.248/larkstudio/larkscanner/-/tree/feature-chenb-gjb-rules)\n\n  包含完之后就可以编译，然后注意每次加入新的规则都要将对应的先加入到`Gjb8114TidyModule.cpp`中和`CMakeLists.txt`\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230911151056393.png\" alt=\"image-20230911151056393\" style=\"zoom:80%;\" />\n\n- (现在不需要)需要编写新的规则的时候，是有样本文件供我们参考的，现在工程中已经把所有的模板文件创建好了，所以不需要\n\n  ~~~bash\n  sudo apt install python-is-python2 #只安装一次python2，用python3会出问题\n  \n  cd llvm-project/clang-tools-extra/clang-tidy #进入到这个目录\n  \n  python2 add_new_check.py gjb8114 r_x_y_z #对应规则R-x-y-z，尽量一次写对，不然不好删除\n  ~~~\n\n  然后进行规则编写，然后进行自测\n\n- 拉取代码覆盖`llvm`工程下的文件\n\n  ~~~bash\n  # 注意自己写的部分需要提前备份，否则给你替换掉了，这一点要尤其注意！！！\n  cp /home/lzx0626/DavidingPlus/Lark5/larkscanner/clang-tidy/src/gjb8114 /home/lzx0626/DavidingPlus/Lark5/llvm-project/clang-tools-extra/clang-tidy/ -r\n  ~~~\n\n- `llvm`工程的编译\n\n  记得使用`gcc-9`，不要乱切`gcc`版本，因为这样很容易导致代码的重新编译!!!\n\n  编译完成后`build/bin/clang-tidy`目录下的文件就是我们需要的，按照前面说的进行拷贝\n\n  ~~~bash\n  # 跑之前gcc版本最好切为gcc-9，虽然我下面也设置了!!!!!\n  \n  cd llvm-project\n  mkdir build #如果不存在\n  cd build\n  \n  cmake -DCMAKE_C_COMPILER=/usr/bin/gcc-9 -DCMAKE_CXX_COMPILER=/usr/bin/g++-9 -DLLVM_ENABLE_PROJECTS=\"clang;clang-tools-extra\" -DLLVM_TARGETS_TO_BUILD=X86 -DCMAKE_BUILD_TYPE=Release -G \"Unix Makefiles\" ../llvm\n  \n  # 我的电脑是6核，量力而为\n  make -j 4\n  ~~~\n\n  \n\n- 上传\n\n  ![image-20230911155204282](https://cdn.davidingplus.cn/images/2025/02/01/image-20230911155204282.png)\n\n## 使用clang-tidy\n\n其中修复功能我们不需要管，注意有两个`clang-tidy`，一个是通过apt管理下载的官方的`clang-tidy`，另外一个是我们通过`llvm`工程添加了测试模块之后的自己的`clang-tidy`，这两个需要注意，我们自己的就在目录下`./clang-tidy`就好了，注意两个不要搞混了\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230912102946085.png\" alt=\"image-20230912102946085\" style=\"zoom:80%;\" />\n\n## 抽象语法树\n\n查看抽象语法树\n\n~~~bash\nclang -c -Xclang -ast-dump test.cpp # test.cpp就是需要查看的cpp文件\n~~~\n\n结果示例：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230914145403241.png\" alt=\"image-20230914145403241\" style=\"zoom: 67%;\" />\n\n### 对象树匹配网站\n\n[AST Matcher Reference (llvm.org)](https://clang.llvm.org/docs/LibASTMatchersReference.html)\n\n### clang-query\n\n使用示例\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230914150823694.png\" alt=\"image-20230914150823694\" style=\"zoom:67%;\" />\n\n## 目前写了的条数记录\n\n~~~bash\n# A_1_5_1 R_1_6_12 R_1_5_2 R_1_6_5 R_1_7_8 R-1-6-8\n\n# 拉取git代码，然后把别人更新的代码拷贝到llvm对应的目录\n\n# 自己先把代码拉取了\n\n# 首先需要把我自己的代码拷贝出去\ncd /home/lark5/Lark5/llvm-project/clang-tools-extra/clang-tidy/gjb8114\n\n# 后续自己添加\ncp A_1_5_1* /home/lark5/Lark5/llvm-project\ncp R_1_6_12* /home/lark5/Lark5/llvm-project\ncp R_1_5_2* /home/lark5/Lark5/llvm-project\ncp R_1_6_5* /home/lark5/Lark5/llvm-project\ncp R_1_7_8* /home/lark5/Lark5/llvm-project\ncp R_1_6_8* /home/lark5/Lark5/llvm-project\n\n# 拷贝git拉取的代码修改的部分到llvm目录\ncp /home/lark5/Lark5/larkscanner/clang-tidy/src/gjb8114/* . -r\n\n# 移动回去\ncd /home/lark5/Lark5/llvm-project/\nmv *.cpp *.h /home/lark5/Lark5/llvm-project/clang-tools-extra/clang-tidy/gjb8114\n~~~\n\n## 进程记录\n\n~~~bash\nA-1-5-1：自测完成(已上传，等待反馈)\nR-1-6-12：测试提的bug存在问题，已经解决(等待反馈)\nR-1-5-2：自测完成(已上传，等待反馈)\nR-1-6-5：自测完成(已上传，等待反馈)\nR-1-7-8：自测完成(已上传，等待反馈)\nR-1-6-8：自测完成(已上传，等待反馈)\nR-1-6-19：交给学长处理了(我免费啦！)...\n~~~\n\n## 后续\n\n马上就期末复习了，这部分交给一位研究生学长做了，所以后续内容不再更新...\n\n","categories":["实验室"]},{"title":"操作系统 PV 程序题","url":"/posts/cc15ddd9.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n注意：所有的互斥信号量的使用都是配对的!!!有wait操作就必然有signal操作!!!\n\n类型定义 用 **semaphore** 就行\n\n# 经典的消费者生产者问题\n\n```c++\nint full=0;\nint empty=n;\nint mutex=1;\nCobegin\nProducer();Consumer();\nCoend\nProducer(){\n    while(true){\n        生产者生产物品\n        wait(empty)\n        wait(mutex)\n        放入物品\n        signal(mutex)\n       \tsignal(full)\n    } \n}\nConsumer(){\n    while(true){\n       \twait(full)\n        wait(mutex)\n        消费物品\n        signal(mutex)\n        signal(empty)\n    }\n}\n```\n\n<!-- more -->\n\n# 读者写者问题\n\n允许多个进程同时读取一个共享对象；但是不允许一个写进程和其他读进程或者写进程同时访问一个共享对象\n\n即保证 write 进程与其他进程互斥访问共享对象\n\n```c++\nsemaphore rmutex=1,wmutex=1;\n//这个rmutex是给 readcount 临界资源设置的互斥信号量，同时只能有一个读进程去操作\nstatic int readcount=0;\nCobegin\nreader();writer();\nCoend\nreader(){\n    while(true){\n        //可能有写进程\n        if(readcount==0)\n            wait(rmutex);\n        \n        //准备开始读，修改readcount\n        wait(rmutex);\n        readcount++;\n        signal(rmutex);\n        \n       \t读操作;\n        \n       \t//读完了，修改readcount\n        wait(rmutex);\n        readcount--;\n        signal(rmutex);\n        \n        //当读进程为0，写进程可以进入\n        if(readcount==0)\n           signal(wmutex);\n    }\n}\nwriter(){\n    while(true){\n        wait(wmutex);\n        写;\n        signal(rmutex);\n    }\n}\n```\n\n# 哲学家进餐问题\n\n```c++\nsemaphore chopsticks[5]={1,1,1,1,1};//定义每根筷子的互斥信号量\nCobegin\nEat();\nCoend\nEat(){\n    while(true){\n        wait(chopsticks[i]);\n        wait(chopstick[(i+1)%5]);\n        吃;\n      \tsignal(chopstick[(i+1)%5]);\n       \tsignal(chopsticks[i]);\n    }\n}\n```\n\n# 1、\n\nn个并发进程共用一个公共变量Q，写出用信号灯的PV操作实现n个进程互斥的程序描述。\n\n```c++\nint mutex=1;//互斥\nCobegin\nP1();P2();...;Pn();\nCoend\nPi(){\n    while(true){\n        wait(mutex)\n        访问Q\n        signal(mutex)\n    }\n}\n```\n\n# 2、\n\n如图1所示的进程流程图中，有8个进程合作完成某一任务，试说明这八个进程之间的同步关系，用PV操作实现之，并要求写出程序描述。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/e96de0527e103c0fe045c6317cca4990.png\" alt=\"e96de0527e103c0fe045c6317cca4990\" style=\"zoom:67%;\" />\n\n```cpp\nint s2=s3=s4=s35=s36=s37=s45=s46=s47=s28=s58=s68=0;\nCobegin\nP1();P2()……P8();\nCoend\nP1(){\n\twhile(1){\n\t\t执行P1;\n\t\tV(s2);\n\t\tV(s3);\n\t\tV(s4);\n\t}\n}\nP2(){\n\twhile(1){\n\t\tP(s2);\n\t\t执行P2;\n\t\tV(s28);\n\t}\n}\nP3(){\n\twhile(1){\n\t\tP(s3);\n\t\t执行P3;\n\t\tV(s35);\n\t\tV(s36);\n\t\tV(s37);\n\t}\n}\nP4(){\n\twhile(1){\n\t\tP(s4);\n\t\t执行P4;\n\t\tV(s45);\n\t\tV(s46);\n\t\tV(s47);\n\t}\n}\nP5(){\n\twhile(1){\n\t\tP(s35);\n\t\tP(s45);\n\t\t执行P5;\n\t\tV(s58);\n\t}\n}\nP6(){\n\twhile(1){\n\t\tP(s36);\n\t\tP(s46);\n\t\t执行P6;\n\t\tV(s68);\n\t}\n}\nP7(){\n\twhile(1){\n\t\tP(s37);\n\t\tP(s47);\n\t\t执行P7;\n\t}\n}\nP8(){\n\twhile(1){\n\t\tP(s28);\n\t\tP(s58);\n\t\tP(s68);\n\t\t执行P8;\n\t}\n}\n```\n\n# 3、\n\n如图2所示，get/copy/put三进程共用两个缓冲区s、t（其大小为每次存放一个记录）。get进程负责不断把输入记录送入缓冲区s中，copy进程负责从缓冲区s中取出记录复制到缓冲区t中，而put进程负责把记录从缓冲区t中取出打印。试用PV操作实现这3个进程之间的同步。\n\n![ef4647bd2c5eb8c55fe42945237c0a3c](https://cdn.davidingplus.cn/images/2025/02/01/ef4647bd2c5eb8c55fe42945237c0a3c.png)\n\n```c++\nint fullS=0;\nint emptyS=1;\nint fullT=0;\nint emptyT=1;\nsemaphore mutexS=1;\nsemaphore mutexT=1;\nCobegin\nget();copy();put();\nCoend\nget(){\n    while(true){\n        wait(emptyS);\n        wait(mutexS);\n        放入缓冲区s;\n        signal(mutexS);\n        signal(fullS);\n    }\n}\ncopy(){\n    while(true){\n        wait(fullS);\n        wait(mutexS);\n        从s中取出记录;\n        signal(mutexS);\n        signal(emptyS);\n        wait(emptyT);\n        wait(mutexT);\n        放入缓冲区t;\n        signal(mutexT);\n        signal(fullT);\n    }\n}\nput(){\n    while(true){\n        wait(fullT);\n        wait(mutexT);\n        拿出数据打印;\n        signal(mutexT);\n        signal(emptyT);\n    }\n}\n```\n\n# 4、\n\n有一个阅览室，读者进入阅览室必须先在一张登记表TB上登记，该表为每一个座位设一个表目，读者离开时要消掉其登记信息，阅览室共有100个座位。请用PV操作写出进程间的同步算法。\n\n```c++\nint count=100;//座位数量\nsemaphore mutex=1;//登记表使用互斥\nCobegin\nread();\nCoend\nread(){\n    while(true){\n        进入阅览室;\n        wait(count);\n        wait(mutex);\n        登记;\n        signal(mutex);\n        读书;\n        wait(mutex);\n        撤销登记;\n        signal(mutex);\n        signal(count);\n        离开;\n    }\n}\n```\n\n# 5、\n\n设公共汽车上，司机和售票员的活动分别是：\n\n司机的活动：启动车辆、正常行车、到站停车\n售票员的活动：开车门、售票、关车门\n在汽车不断到站、停站、行驶过程中，这两个活动有什么同步关系？请用信号量的PV操作实现。\n\n```c++\nint s1=0;//是否到站\nint s2=0;//是否可以离站\nCobegin\ndriver();seller();\nCoend\ndriver(){\n    while(true){\n        wait(s2);\n        启动车辆;\n        正常行车;\n        到站停车;\n        signal(s1);\n    }\n}\nseller(){\n    while(true){\n        wait(s1);\n        开车门;\n        售票;\n        关车门;\n        signal(s2);\n    }\n}\n```\n\n# 6、\n\n医生为某病员诊病，认为需要做些化验，于是，就为病员开出化验单，病员取样送到化验室，等待化验完毕交回化验结果，然后继续诊病。医生为病员诊病和化验分别是两个协作的进程。试用信号灯的PV操作描述这两个进程之间的同步。\n\n```cpp\nint s1=0;//是否有化验单\nint s2=0;//是否有化验结果\n医生诊病(){\n\twhile(1){\n\t诊病;\n\tV(S1);\n\tP(S2);\n\t诊病;\n\t}\n}\n化验(){\n\twhile(1){\n\tP(S1);\n\t化验;\n\tV(S2);\n\t}\n}\n```\n\n# 7、\n\n有个仓库，可以放A和B两种产品，仓库的存储空间足够大，但要求：\n\n（1）一次只能放入一种产品（A或B）\n（2）-N<A产品数量-B产品数量<M\n其中，M和N是正整数，试用PV操作描述产品A和产品B的入库过程。\n\n```cpp\nint Sa=M-1;\nint Sb=N-1;\nint mutex=1;\nCobegin\n存放A();存放B();\nCoend\n存放A(){\n\twhile(1){\n\tP(Sa);\n\tP(mutex);\n\t放入A;\n\tV(mutex);\n\tV(Sb);\n\t}\n}\n存放B(){\n\twhile(1){\n\tP(Sb);\n\tP(mutex);\n\t放入B;\n\tV(Sa);\n\tV(mutex);\n\t}\n}\n```\n\n# 8、\n\n![image-20230418190835692](https://cdn.davidingplus.cn/images/2025/02/01/image-20230418190835692.png)\n\n```c++\nint capacity=500;//能容纳的最大人数\nint mutex=1;//出入口互斥锁\nCobegin\nVisit();\nCoend\nVisit(){\n    while(true){\n        wait(capacity);\n        wait(mutex);\n        进门\n        signal(mutex);\n        参观;\n        wait(mutex);\n        出门;\n        signal(mutex);\n        signal(capacity);\n    }\n}\n```\n\n# 9、\n\n![image-20230418191212388](https://cdn.davidingplus.cn/images/2025/02/01/image-20230418191212388.png)\n\n```c++\nint A1=x;//A信箱装的邮件数量\nint A2=M-x;//A信箱还可以装的邮件数量\nint B1=y;//B邮箱装的邮件数量\nint B2=N-y;//B邮箱还以装的邮件数量\nint mutexA=1;\nint mutexB=1;//访问互斥锁\nCobegin\nA();B();\nCoend\nA(){\n    while(true){\n        wait(A1);\n        wait(mutexA);\n        从A的信箱中取出一个信件;\n        signal(mutexA);\n        signal(A2);\n        回答问题并提出一个新问题;\n        wait(B2);\n        wait(mutexB);\n        将新邮件装入B邮箱;\n        signal(mutexB);\n        signal(B1);\n    }\n}\nB(){\n\twhile(true){\n        wait(B1);\n        wait(mutexB);\n        从B的信箱中取出一个信件;\n        signal(mutexB);\n        signal(B2);\n        回答问题并提出一个新问题;\n        wait(A2);\n        wait(mutexA);\n        将新邮件装入A邮箱;\n        signal(mutexA);\n        signal(A1);\n    }\n}\n```\n\n# 10、\n\n三个进程 P1、P2、P3 互斥使用一个包含 N（N>0）个单元的缓冲区。P1 每次用 produce() 生成一个正整数并用put()送入缓冲区某一个空单元中；P2 每次用 getodd()从该缓冲区中取出一个奇数并用 countodd()统计奇数个数；P3 每次用 geteven()从该缓冲区中取出一个偶数并用 counteven()统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活动， 并说明所定义的信号量的含义。\n\n```c++\nsemaphore mutex=1;//缓冲区使用互斥锁\nint empty=N;//缓冲区空闲的个数\nint odd=0;//奇数区个数\nint even=0;//偶数区个数\nCobegin\nP1();P2();P3()\nCoend\nP1(){\n    while(true){\n        wait(empty);\n        wait(mutex);\n        produce();\n        put();\n        signal(mutex);\n        if(num&1)//奇数\n            signal(odd);\n       \telse\n            signal(even);\n    }\n}\nP2(){\n    while(true){\n        wait(odd);\n        wait(mutex);\n        getodd();\n        countodd()++;\n        signal(mutex);\n        signal(empty);\n    }\n}\nP3(){\n    while(true){\n\t    wait(even);\n       \twait(mutex);\n        geteven();\n        counteven()++;\n        signal(mutex);\n        signal(empty);\n    }\n}\n```\n\n# 11、\n\n一个野人部落从一个大锅中一起吃炖肉，这个大锅一次可以存放 M 人份的炖肉。当野人们想吃的时候，如果锅中不空，他们就自助着从大锅中吃肉。如果大锅空了，他们就叫 醒厨师，等待厨师再做一锅肉。 野人线程未同步的代码如下： while (true){ getServingFromPot() } 厨师线程未同步的代码如下： while (true) { putServingsInPot(M) } 同步的要求是： 当大锅空的时候，野人不能够调用 getServingFromPot() 仅当大锅为空的时候，大厨才能够调用 putServingsInPot() 问题：请写出使用 PV 满足同步要求的完整程序。\n\n野人互斥着吃，厨师互斥着做\n\n```c++\nsemaphore mutex=1;//使用锅的互斥信号量\nsemaphore full=0;//锅满了\nsemaphore empty=0;//锅空了\nstatic int servings=0;//肉的数量\nCobegin\ncook();eat();\nCoend\ncook(){\n    while(true){\n        wait(empty);\n        wait(mutex);\n        putServingsInPot(M);\n        servings += M;\n        signal(mutex);\n        signal(full);  \n    }\n}\n//这是一个野人的线程\neat(){\n    while(true){\n        wait(full);\n        wait(mutex);\n        getServingFromPot();\n        servings -= 1;\n        signal(mutex);\n        if(servings == 0)\n            signal(empty);\n    }\n}\n```\n\n# 12、\n\n机场中有些道路，航班和摆渡车都可以通行。当航班通行时，摆渡车必须等待，直到所有航班通过后才能通行。当摆渡车通行时，航班必须等待，直到所有摆渡车通过后才能通行。请用信号量描述摆渡车和航班通行的控制过程。\n\n```c++\nsemaphore mutex=1;//道路行驶的互斥锁\nsemaphore plane=1,car=1;//航班占据还是摆渡车占据\nint plane_count=0;,car_count=0;//某时刻在道上的航班或者摆渡车的个数\nCobegin \n    Car();Plane();\nCoend\nCar(){\n    while(true){\n        if(car_count==0)\n            wait(car);//如果没有车则表明可能有飞机，那么等待车的控制权\n        car_count++;\n        wait(mutex);\n        开车！\n        signal(mutex);\n        car_count--;\n        if(car_count==0)\n            signal(plane);//如果车清空了，那么通知飞机可以接管了\n    }\n} \t\nPlane(){\n    ...//同理\n}\n  \n```\n\n","categories":["校内课程","操作系统"]},{"title":"操作系统 简答题","url":"/posts/a53d022b.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 简答题总览\n\n## 设计现在OS的主要目标是是什么？\n\n**有效性，方便性，可扩充性，开放性**\n\n## 何为脱机I/O和联机I/O？\n\n脱机 I/O 是指事先将装有用户程序和数据的纸带或卡片装入纸带输入机或卡片机，在**外围机**的控制下，把纸带或卡片上的数据或程序输入到**磁带**上。该方式下的输入输出**由外围机控制完成，是在脱离主机的情况下进行的**。\n\n而联机 I/O 方式是指程序和数据的输入输出都是**在主机的直接控制**下进行的。\n\n<!-- more -->\n\n## 试说明推动分时系统形成和发展的主要动力是什么？\n\n推动分时系统形成和发展的主要动力是更好地**满足用户的需要**。主要表现在：\n\n- CPU的分时使用**缩短了作业的平均周转时间**；\n- **人机交互能力**使用户能直接控制自己的作业；\n- **主机的共享**使多用户能同时使用同一台计算机，独立地处理自己的作业。\n\n## OS**的作用是什么**？\n\n1.操作系统作为用户与硬件系统之间的接口。\n2.操作系统作为计算机资源的管理者。\n3.操作系统实现了对计算机资源的抽象。\n\n## **单道批处理是什么概念**，**解决了什么问题**，是如何解决的？还存在什么问题？\n\n1.单道批处理是计算机系统对一批作业（但在内存中仅有一道作业）自动进行处理。\n2.解决了人机矛盾和CPU与I/O设备速度不匹配矛盾。\n3.通过提高系统资源的利用率和系统吞吐量。\n4.不能充分利用系统资源。\n\n## **多道批处理是什么概念**，**解决了什么问题**，**是如何解决的**？\n\n1.在内存中同时存放多道相互独立程序，按照一定的算法，共享CPU和系统中的各种资源。\n2.提高了资源的利用率和系统吞吐量。\n3.它能使多道程序交替运行，使得CPU和其他资源保持忙碌状态\n\n## **实现多道程序设计应解决那些问题**？\n\n1.处理机管理问题\n2.内存管理问题\n3.I/O设备管理问题\n4.文件管理问题\n5.作业管理问题\n\n## **对比分时系统和实时系统的特征，它们的含义有何异同？**\n\n两者同时具有多路性 交互性 独立性 及时性四个特征 但实时系统额外具有可靠性\n分时系统没有实时系统具有的容错机制可靠\n\n## **为什么引入进程的概念**？它会产生什么样的影响？\n\n这是因为并发执行的程序（即进程）是“停停走走”地执行，只有在为它创建进程后，在它停下时，方能将其现场信息保存在它的PCB中，待下次被调度执行时，再从PCB中恢复CPU现场并继续执行，而传统的程序却无法满足上述要求。为了使程序在多道程序环境下能并发执行，并对并发执行的程序加以控制和描述，在操作系统中引入了进程概念。\n\n影响 : 使程序的并发执行得以实行。\n\n## 试从动态性，并发性和独立性上比较进程和程序。\n\n- **动态性是进程最基本的特性**，表现为由创建而产生，由调度而执行，因得不到资源而暂停执行，由撤销而消亡。进程有一定的生命期，而程序只是一组有序的指令集合，是静态实体。\n- **并发性是进程的重要特征**，同时也是OS的重要特征。引入进程的目的正是为了使其程序能和其它进程的程序并发执行，而程序是不能并发执行的。\n- **独立性是指进程实体是一个能独立运行的基本单位，也是系统中独立获得资源和独立调度的基本单位**。对于未建立任何进程的程序，不能作为独立单位参加运行。 \n\n## 试说明PCB的作用具体表现在哪几个方面，为什么说PCB是进程存在的唯一标识？\n\nPCB是进程实体的一部分，是操作系统中最重要的**记录型数据结构**。作用是**使一个在多道程序环境下不能独立运行的程序，成为一个能独立运行的基本单位**，成为能与其它进程并发执行的进程。OS是根据PCB对并发执行的进程进行控制和管理的。\n\n每个进程都有一个独立的PID号，操作系统通过PID号映射之后使用PCB来管理进程的资源和状态，可以了解到该进程的所有信息和状态，继而对其进行调控。\n\n## 画出进程在三个基本状态及转换图，说明状态转换的典型原因。\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230418164932525.png\" alt=\"image-20230418164932525\" style=\"zoom:67%;\" />\n\n就绪->执行：进程调度，进程分配到CPU资源\n\n执行->就绪：时间片完\n\n执行->阻塞：I/O请求\n\n阻塞->就绪：I/O请求完成\n\n## 为什么要引入挂起状态？该状态有哪些性质？\n\n引入挂起状态处于五种不同的需要：**终端用户需要，父进程需要，操作系统需要，对换需要和负荷调节需要**。处于挂起状态的进程**不能接收处理机调度**。\n\n## 在进程切换的时候需要保存的处理机状态信息有哪些？\n\n进行进程切换时,所要保存的处理机状态信息有:\n\n- **进程当前暂存信息**\n- **下一指令地址信息** \n- **进程状态信息**\n- **过程和系统调用参数及调用地址信息**\n\n## 试说明引起进程创建的主要事件\n\n用户登录、作业调度、提供服务、应用请求\n\n## 试说明引起进程被撤销的主要事件\n\n正常结束、异常结束（越界错误、保护错、非法指令、特权指令错、运行超时、等待超时、算术运算错、I/0故障）、外界干预（操作员或操作系统干预、父进程请求、父进程终止)\n\n## 在创建一个进程时所要完成的主要工作是什么？\n\n- OS发现请求创建新进程事件后，调用进程创建原语 Creat()；\n- 申请空白PCB；\n- 为新进程分配资源；\n- 初始化**进程控制块**；\n- 将新进程插入就绪队列。\n\n## 在撤销一个进程时所要完成的主要工作是什么？\n\n- 从PCB中读取该进程的状态；\n- 若被终止进程处于执行状态，立即终止该进程的执行，置调度标志真，指示该进程被终止后重新调度。\n- 若该进程还有子进程，应将所有子孙进程终止；\n- 将进程的所有资源归还给父进程，或归还给系统；\n- 将进程从所在队列或列表中移出，等待其它程序搜集信息。\n\n\n\n## **如何理解并发性和共享性的联系**？\n\n并发性和共享性互为存在条件，是操作系统最基本的特征。一方面资源共享是以程序（进程）的并发性执行为条件的，若系统不允许程序并发执行，自然不存在资源共享问题。另一方面若系统不能对资源共享实施有效管理，则也必将影响到程序并发执行。如果自己用的操作系统，不能并发执行，你每次只能打开一个程序，要打开另外一个就得关闭前一个，会十分痛苦。而你打开多个程序的时候不可避免会用到同一个资源。\n\n## **什么是同步和异步的概念**？**如何理解操作系统的异步性**？\n\n异步：在多批道处理系统中，由于并发进行的进程中，存在调度的随机性和执行速度的独立性，即间接制约，导致各个进程走走停停 同步：多个进程之间存在直接制约关系，而为了提高执行速度，让各个进程之间互相发送消息，确定执行顺序，而不会出现走走停停的情况，达到同步。同步不是指多个进程同时执行，而是指多个进程之间互相发送消息，不会出现走走停停的混乱情况，将无序变为有序。\n\n## **为什么说操作系统是对裸机的首次虚拟**？\n\n计算机的硬件、软件以及软件的各部分之间是一种层次结构的关系。硬件在最底层，操作系统是裸机上的第一层软件，是对硬件功能的首次扩充。\n\n## 为什么说处理机管理体现为进程管理？\n\n因为处理机是计算机中宝贵的资源，有效地将处理机分配和回收给各个进程体现才能系统性能。\n\n## 处理机管理有哪些主要功能？他们的主要任务是什么？\n\n处理机管理的主要功能是：**进程管理、进程同步、进程通信和处理机调度**；\n\n- 进程管理：为作业创建进程，撤销已结束进程，控制进程在运行过程中的状态转换。\n\n- 进程同步：为多个进程（含线程）的运行进行协调。\n\n- 进程通信：用来实现在相互合作的进程之间的信息交换。\n\n- 处理机调度：\n\n  1)作业调度。从后备队里按照一定的算法 ，选出若干个作业，为他们分配运行所需\n\n  的资源（首选是分配内存）。\n\n​\t   2)进程调度：从进程的就绪队列中，按照一定算法选出一个进程，把处理机分配给它，并设置运行现场，使进程投入执行。\n\n## 存储器管理有哪些功能？他们的主要任务是什么？\n\n**内存分配和回收，内存保护，地址映射和内存扩充**；\n\n- 内存分配与回收：为每道程序分配内存，并在程序结束的时候回收内存。\n- 内存保护：确保每道用户程序都只在自己的内存空间运行，彼此互不干扰。\n- 地址映射：将地址空间的逻辑地址转换为内存空间与对应的物理地址。\n- 内存扩充：用于实现**请求调用功能，置换功能**等。\n\n## **设备管理有哪些功能**？他们的主要任务是什么？\n\n主要功能有: **缓冲管理、设备分配和设备处理以及虚拟设备等**。\n\n主要任务 :  完成用户提出的 I/O 请求，为用户分配 I/O 设备；提高 CPU 和 I/O 设备的利用率；提高 I/O 速度；以及方便用户使用 I/O 设备 \n\n## 文件管理有哪些功能？他们的主要任务是什么？\n\n文件管理主要功能：**文件存储空间的管理、目录管理、文件的读/写管理和保护**。\n\n文件管理的主要任务：管理用户文件和系统文件，方便用户使用，保证文件安全性。\n\n\n\n## 如何划分程序模块**？**对模块有什么要求？\n\n划分：功能相对独立的一段代码\n要求：高内聚，低耦合\n\n## **简述冯**.**诺依曼计算机的工作原理**\n\n存程序加程序控制\n\n## 什么是中断**？**为什么要引入中断机制？\n\n中断是系统运行期间发生任何紧急事件，使得CPU暂停正在执行的程序，保留现场后自动转去执行相应事件的处理程序。\n引入中断机制的目的有：\n1、使实时处理紧急事件成为可能\n2、可增加处理机的执行效率\n3、可简化OS的程序设计\n\n## CPU**如何感知中断请求**，**又如何响应中断请求**？\n\n中断源向CPU发出中断请求，CPU收到中断请求后保留现场信息转相应的事件处理程序去处理中断源，处理完后返回现场信息，继续处理之前没有完成的任务。\n中断处理过程是怎样的？\n1、保留现场到各个寄存器内\n2、处理触发中断源的中断事件，即真正执行具体的为某个中断源服务的中断服务程序\n3、关闭中断，以防止在恢复现场过程中被新的中断请求打断，接着恢复现场，然后开放中断，以便返回原来的程序后可响应其他的中断请求\n\n## **CPU的现场信息主要包括哪些内容**？\n\nCPU各个寄存器（通用寄存器和指令寄存器）、程序状态字PSW以及用户栈指针\n\n## **什么是程序执行结果的不可再现性**？**如何确保执行结果的可再现**？\n\n不可再现性：**由于程序的并发执行，打破了由另一程序独占系统资源的封闭性，因而破坏了可再现性**\n解决：必须通过**Berstein条件**的限制，保证程序在异步环境下的执行结果是确定的\n\n## **为什么要引入进程的概念**？**进程有哪些特征**？\n\n为了实现多道程序并发执行，而进程是进程实体的运行过程，资源分配和调度的独立单位。\n特征：**动态性，并发性，独立性，异步性, 结构性**\n\n## **进程图与前趋图的作用分别是什么**？\n\n进程图：描述进程家族关系，一个结点代表一个进程，一条孤代表进程间的父子关系。\n前趋图：表示语句或者进程间的执行顺序。\n\n## **引起进程阻塞和唤醒的典型原因有哪些**？\n\n1、**请求系统服务**\n＊无法获得服务，进程主动阻塞\n＊服务完成，由服务释放进程唤醒阻塞进程\n2、**启动某种操作**\n＊进程主动阻塞，等待操作完成\n＊操作完成，由中断处理程序唤醒阻塞进程\n3、**合作数据尚未到达**\n＊合作进程的数据尚未到达，等待进程阻塞\n＊新数据到达，由合作进程唤醒阻塞进程。\n4、**无新工作可做**\n＊系统进程无新工作可作，主动阻塞\n＊新工作到达时，系统进程被唤醒\n\n## **创建进程需要执行哪些操作**？\n\n1.申请空白PCB\n2.为新进程分配资源\n3.初始化PCB\n4.将PCB插入队列\n\n## **进程的同步机制解决什么问题**？\n\n解决进程在并发执行时产生结果的不可再现性（不确定性），也可以说进程的异步性。\n其实现了多个相关进程在执行次序上的协调。\n\n## **什么是临界区**，**引入临界区的目的是什么**？\n\n临界区：在进程中涉及到临界资源的程序段\n目的：为了让诸进程互斥，实现对临界资源的互斥访问\n\n## **利用信号量机制如何实现资源的互斥使用**？\n\n进入临界区前，进程通过锁变量判断临界资源是否被占用\n占用：进程反复测试W的状态\n否则：为临界资源加锁，然后进入临界区，为临界资源开锁\n\n## **互斥信号量机制如何体现资源的互斥准则**？\n\n空闲让进，忙则等待，有限等待，让权等待\n\n## **信号机机制在有合作关系的进程中如何描述进程同步**？\n\n先操作的进程执行后设置V原语，在后操作的进程执行前设置P原语，这一对原语同时存在\n\n## **讨论生产者**-**消费者问题中互斥信号量设置的必要性**。\n\n从生产者角度看，如果多个生产者进入缓冲区进行各自的操作，可能会出现覆盖等错误；从消费者角度看，同样可能出现错误；单纯从生产者消费者的角度来看，一个生产者和一个消费者进入缓冲区，修改的是各自的缓冲区，没有冲突，可以不必设置互斥信号量。\n\n## **哲学家就餐问题可以有哪些方法避免死锁**\n\n1最多允许4个哲学家同时坐在桌子旁边\n2仅当一个哲学家左右两边的筷子都可以用时才允许拿筷子\n3给所有哲学家编号，奇数号的哲学家必须首先拿左边的筷子，偶数号的哲学家则反之，最后总有一个哲学家能获得两只筷子而进餐\n\n## **读者**-**写者问题是如何实现读者优先或写者优先的**？\n\n读者优先：第一个读者可以读，只有第一个读者阻塞写者，只有最后一个读者才能唤醒写者。\n写者优先：第一个写者可以读，只有第一个写者阻塞读者，只有最后一个写者才能唤醒读者。\n\n## **直接消息通信机制中**，**接收进程的**PCB**需要保存哪些与通信有关的数据**？\n\n1、 mq (消息队列队首指针)\n2、mutex (消息队列互斥信号量)\n3、sm (消息队列资源信号量)\n\n## **管道通信的工作原理和基本要求是什么**？\n\n工作原理：\n＊管道是连接发送进程和接收进程的共享文件（Pipe 文件）\n＊发送进程以字符流的形式将消息写入管道\n＊接收进程按先进先出的顺序从管道读出数据\n基本要求：\n＊对管道的互斥使用\n＊发送进程与接收进程的同步\n＊确定通信对方的存在\n\n## **讨论管道通信的代码描述**\n\n创建管道文件\n建立通信然后实现连接\n信息交换后由任意一方断开连接\n\n## **引入线程的目的是什么**？\n\n**增加并发程度和减少并发开销**\n\n## **线程与进程有什么区别与联系**？\n\n**(1)调度的基本单位:线程是调度和分派的基本单位，而在未设置线程时，进程也是进行资源分配和调度执行的独立单位**\n**(2)并发性:进程之间、线程之间均可并发执行**\n**(3)拥有资源:进程拥有资源,线程继承资源**\n**(4)独立性:同一进程中的线程的独立性低于不同进程的线程独立性**\n**(5)系统开销:线程的系统开销小于进程**\n**(6)支持多处理机系统:可将一个进程中的多个线程分配到多个处理机中**\n\n## 调度有哪几个层次，分别作用于什么范围？\n\n作业调度、内存调度(中级调度)、进程调度\n\n## **引起进程调度的时机和原因有哪些**？\n\n1、当前运行进程运行结束。因任务完成而正常结束，或者因出现错误而异常结束。\n2、当前运行进程因某种原因，比如 I/O 请求、 P 操作、阻塞原语等，从运行状态进入阻塞状态。\n3、执行完系统调用等系统程序后返回用户进程，这时可以看作系统进程执行完毕，从而可以调度一个新的用户进程。\n4、在采用抢占调度方式的系统中，一个具有更高优先级的进程要求使用处理器，则使当前运行进程进入就绪队列（与调度方式有关）。\n5、在分时系统中，分配给该进程的时间片已用完（与系统类型有关）。\n\n## **作业与进程有什么区别与联系**？\n\n区别：进程是一个程序的一次执行，而作业是任务。\n联系：一个作业通常包括多个进程，多个进程共同完成一个作业。一个是任务的静态描述，一个是任务的动态描述。互相补充\n\n## **作业有哪几种状态**？\n\n**后备状态、 提交状态 、执行状态和完成状态**\n\n## 高级调度和低级调度的主要任务是什么？为什么要引入中级调度？\n\n- 高级调度(作业调度)的主要任务是根据某种算法，把外存上处于后备队列中的那些作业调入内存。\n- 低级调度(进程调度)是**保存处理机的现场信息**，**按某种算法选取进程**，**再把处理器分配给进程进行运行**。\n- 引入中级调度(内存调度)的主要目的是为了**提高内存利用率和系统吞吐量**。使那些暂时不能运行的进程不再占用内存资源，将它们调至外存等待，把进程状态改为挂起状态。\n\n## 在作业调度中如何确定接纳多少个作业和接纳哪些作业？\n\n- 接纳多少个作业取决于**多道程序度**。\n- 接纳哪些作业取决于**调度算法**。\n\n## **作业调度的时机与任务是什么**？\n\n- 时机：**内存中的进程数小于多道程序度**。\n- 任务：从后备队列中选取多少个作业调入内存，**取决于多道程序度**，而接纳哪些作业取决于调度算法。\n\n## **进程调度有哪两种调度方式**？**各自的调度时机是什么**？\n\n1.非抢占式：\n发生调度的时机：正在运行的进程运行正常/异常结束；进程发生阻塞；\n2.抢占式\n发生调度的时机：有优先权更高的进程到达；有更短的进程到达；时间片用完了。\n\n## 在选择调度方式和调度算法时，应遵循的准则是什么？\n\n- 面向**用户**的准则：周转时间短、响应时间快、截止时间的保证、优先权准则。\n- 面向**系统**的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用。\n\n## 为什么说多级反馈队列调度算法是综合性能比较好的？\n\n- 对于终端型用户，作业比较小，可在第一队列即可完成，响应时间很短。\n- 对于短批处理作业用户，这类作业属于稍长的短作业，可在第二或第三队列即可完成，周转时间也比较短。\n- 对于长批处理作业用户，它总会被运行的，不用担心它长期得不到处理。\n\n## 何为死锁？死锁产生的原因和必要条件是什么？\n\n- 死锁是指多个进程因竞争资源而造成的一种僵局，若无外力作用，这些进程都将永远不能再向前推进；\n- 产生死锁的原因有二，一是**竞争资源**，二是**进程推进顺序非法**；\n- 必要条件是：**互斥条件，请求和保持条件，非剥夺条件和环路等待条件**。\n\n\n\n## 进程的优先权有静态优先权和动态优先权两种形式，试分析基于这两种优先权的非抢占式调度和抢占式调度的调度时机和调度原则。\n\n非抢占式调度方式的调度时机：CPU空闲\n抢占式调度方式的调度时机：CPU空闲或新进程到达\n基于优先权的抢占式调度：\n新进程到达时：\n静态优先权：新老进程比较优先级\n动态优先权：重新计算新老进程、就绪进程优先级\nCPU 空闲时：\n静态优先权：选择就绪队列优先权最高者\n动态优先权：重新计算新进程、就绪进程优先级\n\n## **那种调度方式既考虑等待时间又兼顾服务时间**？\n\n高响应比优先调度算法\n\n## **讨论教材图**3.9**最低松弛度优先算法的正确性**。\n\n我认为，3.9基于 抢占会发生于实时任务队列中存在松弛度为0的任务 的前提。故，在t=10时，A1已完成，由于B1松弛度小于A2，故执行B1；而当t=30时，A2松弛度为0，调度程序抢占B1的处理机而调度A2。同理可得后面的调度顺序，故3.9是自洽的。\n\n## **什么是死锁**？**引起死锁的原因是什么**？\n\n死锁是指多个进程因竞争共享资源而造成的一种僵局，若无外力作用，这些进程都将无法向前推进。引起死锁的原因有：竞争不可抢占性资源，竞争可消耗性资源，进程推进顺序不当。\n\n## **产生死锁的必要条件是什么**？\n\n1、互斥条件：进程对占有的资源进行排他性使用\n2、请求和保持条件：动态分配策略中，进程占有资源却又申请新的资源\n3、不可抢占条件：对己经分配给进程的资源不可抢占使用\n4、环路等待条件：发生死锁时，系统的RAG必然出现环路\n\n## **预防死锁的策略有哪几个**，**分别破坏什么条件**？\n\n1.破坏“请求和保持条件”\n2.破坏“不可抢占”条件\n3.破坏“环路等待”条件\n\n## **简述银行家算法的工作流程**\n\n1、检测请求资源数量是否合理：不合理拒绝请求并报错，合理继续；\n2、检测系统是否有足够可用资源分配；没有等待，有继续；\n3、利用相应的数据结构进行试探性分配；\n4、利用安全性算法，检测此次分配后系统是否处于安全状态；是则分配资源，否则恢复数据结构。\n\n## **如何检测申请不同类资源的进程是否存在死锁**？\n\n1.在RAG中找一个非孤立，非阻塞的进程结点，去掉所有边将其变成孤立结点\n2.把等待该资源的请求边变成分配边\n3.如果所有进程结点均成为孤立结点，则资源分配图是可以完全化简的\n4.若可以完全化简资源分配图，则不存在死锁，否则，系统中存在死锁\n\n## **程序要运行必须经过哪几个步骤**，**各自完成什么任务**？\n\n1.编译：由编译程序对源程序编译得到0,1代码的目标模块\n2.链接：由链接程序将编译后形成的一组目标模块以及库函数链接形成可执行的装入模块\n3.装入：由装入程序将装入模块装入内存\n\n## **地址映射有静态映射和动态映射**，**试比较两者的优劣**\n\n静态映射灵活性低，但对硬件要求也低；动态映射灵活性高，速度快，但是对硬件要求高\n\n## **用界限寄存器如何实现内存保护**？\n\n每当CPU要访问内存时，硬件自动将被访问的内存地址与界限寄存器的内容进行比较，以判断是否越界，如果没有越界，则按此地址访问内存，否则将产生越界中断。\n\n## **固定分区和动态分区分配初始的分区是如何得到的？**\n\n固定分区：分区说明表。\n动态分区：空闲分区表，空闲链。\n\n## **引入对换技术的目的是什么**？**对换有哪两种类型**？\n\n使进程在内存和外存之间能够动态调度。\n有整体对换和页面对换两种类型。\n\n## **分页存储管理方式是如何实现的**？\n\n系统将一个进程的逻辑地址空间分成若干个大小相等的页面，相应地，将内存空间分成若干个与页面同样大小的物理块，内存的分配以块为单位，并允许将一个进程的若干页分别装入到多个可以不相邻接的物理块中。逻辑地址分为两部分：页号和页内地址。在程序运行时，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立了一张页表。进程的每个页占页表的一个表项，其中记录了相应页对应的内存块的块号，以及用于分页保护的存取控制信息。页式存储管理系统中，逻辑地址到物理地址的转换是在进程执行的过程中，由硬件地址变换机构借助页表自动进行的。\n\n## **分页存储管理方式中的数据结构有哪些**，**分别有什么作用**？\n\n面向进程：页面请求表，整个系统统一一张页面请求表，记录所有进程使用内存的请况。\n面向内存：内存块表（空闲块表，空闲块链，位示图）。\n进程和内存的对应：页表，记录每个页面在内存所对应的物理块。\n\n## **分页方式中如何将逻辑地址转换为物理地址**？\n\n当进程要访问某个逻辑地址中的数据时，分页地址变换机构会自动地将有效地址（相对地址）分为页号和页内地址两部分再以页号为索引去检索页表。查找操作由硬件执行。在执行检索前，先将页号与页表进行比较，如果页号大于或等于页表长度，则表示本次所访问的地址已超越进程的地址空间。于是，这一错误将被系统发现，并产生一地址越界中断。若未出现越界错误，则将页表始址与页号和页表项长度的乘积相加，变得到该表项在页表的位置，于是可从得到该页的物理块号，将之装入物理地址寄存器中，与此同时，在将有效地址寄存器中的页内地址送入物理地址寄存器的块内地址字段中。\n\n## **引入分段存储管理方式有什么好处**？\n\n1.方便编程，\n2.分段便于实现信息共享，信息保护\n3.而且分段可以动态增长，动态链接\n\n## **段页式存储管理方式的地址变换中**，**三次访问内存的目的分别是什么**？\n\n第一次：获取页表地址\n第二次：获取指令或数据的物理地址\n第三次：从所得地址中取出指令或数据\n\n## **什么是虚拟存储器**？**虚存的容量如何衡量**？\n\n虚拟存储器是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定。\n\n## **阐述实现虚拟存储器的理论依据**。\n\n（1）基于局部性原理，应用程序在运行之前并不必全部装入内存，仅须将当前要运行的那部分程序和数据装入内存便可启动程序的运行，其余部分仍驻留在外存上；当要执行的指令或访问的数据不在内存时，再由OS请求调入；如果内存已满，则通过置换功能进行程序或数据之间的置换。\n（2）虚拟存储器还必须建立在离散分配的基础上，其实现方式可分成请求分页、请求分段和请求分段分页等方式。\n.\n\n## **虚拟存储器具有哪些特征**？\n\n多次性 对换性 虚拟性\n\n## **请求分页存储管理方式的页表中各字段有什么作用**？\n\n1）页号和内存块号：当页面在内存时，用于地址变换\n（2）中断位：表示该页是在内存还是在外存\n（3）外存地址：如果页面在外存，记录磁盘块号\n（4）访问位：记录该页最近被访问的次数或多久未被访问，根据访问位来决定淘汰哪页\n（5）修改位：查看此页是否在内存中被修改过\n\n## **缺页率与哪些因素有关**？\n\n1.页面大小\n2.进程所分配物理块的数目\n3.页面置换算法\n4.程序固有特性\n\n## **为什么**FIFO**置换算法存在**Belady**异常现象**？\n\n因为驻留在内存最久的页面不代表它的访问频率最小，可能是经常访问或者是刚刚访问过，如果把这样的页面换出去，在未来可能会频繁地换进来，导致命中率低下。\n\n## LRU**置换算法的思想是什么**，**如何实现页面的**“**计时**”？\n\nLRU算法是选择最近最久未使用的页面予以淘汰。利用寄存器实现页面的“计时”。为每个在内存中的页面配置一个移位寄存器。当进程访问某物理块时，将相应寄存器的Rn-1位置成1.此时，定时信号将每隔一定时间将寄存器右移一位。如果我们把n位寄存器的数看作是一个整数，那么，具有最小数值的寄存器所对应的页面，就是最近最久未使用的页面。\n\n## **简述改进的**Clock**算法的执行过程**。\n\n先为每一个页面设置一个访问位，再将所有的页面通过指针链接起来形成一个循环队列，当页面没有被访问时，访问位为1，当需要换出页面时，替换指针从原来的位置开始，每次判断所指的页面的访问位是否为0，若为0则换出，若为1,则设置为0，寻找下一个页面，若到队尾则重新从对首开始寻找\n\n## **产生抖动的原因是什么**？\n\n多道度太高的清况下，页面在内存与外存之间频繁调度，以至于CPU难以有效工作，导致系统效率急剧下降甚至系统崩溃，即产生抖动。\n\n## **为什么引入工作集机制可以预防抖动**？\n\n在进程初始分配内存块时，分配大于等于工作集的内存块数，使其在比较低的缺页率下开始工作。\n\n## **请求分段存储管理方式的地址越界中断如何处理**？\n\n处理地址越界中断时，首先判断该段的扩充位，如果可扩充，则增加段长，否则发生越界中断，进行出错处理\n\n## **如何实现分段共享**？\n\n配置一张共享段表，所有各共享段表中记录共享分段的进程数，表中包括该段的各种信息，以及各进程利用该共享段的信息。\n\n## I/O**系统的软件有哪几个层次**？\n\n用户层I/O软件\n设备独立性软件\n设备驱动程序\n中断处理程序\n\n## **简述字符设备控制器的组成和原理**。\n\n组成：寄存器、I/O逻辑、借口。\n\n## **引入通道的目的是什么**？\n\n为了建立独立的I/O操作，不仅使数据的传送能独立于CPU，而且也希望有关对I/O操作的组织、管理及其结束处理尽量独立，以保证CPU有更多的时间去进行数据处理\n\n## **操作系统是如何识别中断请求**，**如何调用中断处理程序的**？\n\n每个中断源用一固定触发器寄存中断信号，称为中断位——值为1表示有中断信号，为0则无。当某一中断源需要CPU为其进行中断服务时，就输出中断请求信号，使中断请求触发器置位，向CPU请求中断。每一种中断都有一个与之相联系的中断号，并有一个与之相联系的中断处理程序，而每种中断的中断处理程序按中断号的顺序存放在一张中断向量表中。在中断响应时，系统会根据中断号去查找中断向量表，从中获得相应的中断处理程序的入口地址，这样便可以转入中断处理程序执行。\n\n## **中断和陷阱有什么区别**？\n\n1、陷阱由处理机正在执行的指令引起，而中断由与现行指令无关的中断源引起\n2、陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务不是为当前进程\n3、CPU可以在指令执行中响应陷阱，而必须在指令执行后响应中断\n设备驱动程序的主要功能是什么？\n1、接收由与设备无关的软件发来的命令和参数，并将命令中的抽象要求转换为与设备相关的低层操作序列\n2、检查用户I/O请求的合法性，了解I/O设备的工作状态，传递与I/O设备操作有关的参数，设置设备的工作方式\n3、发出I/O命令，如果设备空闲，便立即启动I/O设备，完成指定的I/O操作；如果设备忙碌，则将请求者的请求块挂在设备队列上等待\n4、及时响应由设备控制器发来的中断请求，并根据其中断类型，调用相应的中断处理程序进行处理\n\n## **中断驱动的**I/O**控制方式与**DMA的I/O**控制方式有什么区别**？\n\n1、中断方式是以字符为单位传送数据，而DMA方式是以块为单位传送数据\n2、中断方式是在DR满后发中断信号，而DMA方式是在数据块传送完成后发中断信号\n3、中断方式的数据传送是在CPU的控制下由中断处理程序完成的，而DMA方式的数据传送是在控制器的控制下盗用CPU周期完成的\n\n## DMA**控制方式中**，**进入控制器**DR**中的数据如何传送到内存**？\n\n不断挪用CPU周期，将DR中的数据写入内存指定单元，直至DC=0\n\n## **通道控制方式中什么情况下需要盗取**CPU周期\n\n1.通道获取下一条通道指令\n2.数据控制器将数据传到内存\n\n## **操作系统如何实现逻辑设备名向物理设备名的映射**？\n\n在系统中配置一张逻辑设备表，每个表目包含三项——逻辑设备名、物理设备名和设备驱动程序的入口地址。当进程用逻辑设备名请求分配I/O设备时，系统根据当时的具体情况，为它分配一台相应的物理设备。与此同时，在逻辑设备表上建立一个表目，填上应用程序中使用的逻辑设备名和系统分配的物理设备名，以及该设备驱动程序的入口地址。当以后进程再利用该逻辑设备名请求I/O操作时，系统通过查找LUT，便可找到该逻辑设备所对应的物理设备和该设备的驱动程序\n\n## **独占设备的分配流程是怎样的**？\n\n1.分配设备\n2.分配控制器\n3.分配通道\n\n## **用户层实现的\\**\\*\\*SPOOLing\\*\\**\\*技术其原理和目的是什么**？\n\n目的是实现虚拟设备功能\n\n## **引入缓冲区的目的是什么**？\n\n1.缓和CPU与I/O设备间速度不匹配的矛盾\n2.减少对CPU的中断频率，放宽对CPU中断响应时间的限制\n3.解决数据粒度不匹配的问题\n4.提高CPU和I/O设备间的并行性\n\n## **简述缓冲池的基本组成和工作过程**。\n\n1、组成\n三个缓冲队列\n\n- 空闲缓冲队列 emq: 由空缓冲区所链成的队列\n- 输入队列 inq:由装满输入数据的缓冲区所链成的队列\n- 输出队列 outq:由装满输出数据的缓冲区所链成的队列\n  四个工作缓冲区\n- 输入收容hin\n- 输出收容hout\n- 输入提取sin\n- 输出提取sout\n  简述磁盘的格式和物理扇区号的结构\n  1）硬盘有数个盘片，每盘片两个面，每个面一个磁头\n  （2）盘片被划分为多个扇形区域即扇区\n  （3）同一盘片不同半径的同心圆为磁道\n  （4）不同盘片相同半径构成的圆柱面即柱面\n\n## **逻辑扇区号与物理扇区号如何相互转换**？\n\n通过逻辑扇区号计算 柱面号->磁道号->扇区号\n\n## **磁盘访问时间如何计算**\n\n巡道时间+平均旋转延迟时间+传输时间\n\n## **对比**FCFS、SSTF、SCAN**磁盘调度算法的优劣**。\n\n先来先服务算法（FCFS）\n这是一种比较简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。此算法由于未对寻道进行优化，在对磁盘的访问请求比较多的情况下，此算法将降低设备服务的吞吐量，致使平均寻道时间可能较长，但各进程得到服务的响应时间的变化幅度较小。\n最短寻道时间优先算法（SSTF）\n该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，该算法可以得到比较好的吞吐量，但却不能保证平均寻道时间最短。其缺点是对用户的服务请求的响应机会不是均等的，因而导致响应时间的变化幅度很大。在服务请求很多的情况下，对内外边缘磁道的请求将会无限期的被延迟，有些请求的响应时间将不可预期。\n扫描算法（SCAN）\n扫描算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。此算法基本上克服了最短寻道时间优先算法的服务集中于中间磁道和响应时间变化比较大的缺点，而具有最短寻道时间优先算法的优点即吞吐量较大，平均响应时间较小，但由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道\n\n## **文件系统的管理对象是什么**？\n\n文件、目录、磁盘（磁带）存储空间\n\n## **文件的逻辑结构类型如何划分**\n\n1、按文件是否有结构分类\n\n2、按文件的组织方式分类\n\n## **有结构的顺序文件和索引文件分别如何存取**\n\n对于定长的顺序文件，读文件：设置一个读指针Rptr，令它指向下一个记录的首地址，每当读完一个记录时，便执行Rptr=Rptr+1操作，L为记录长度；写文件：设置一个写指针Wptr，使之指向要写的记录的首地址，每写完一个记录，执行Wptr=Wptr+1操作。\n对于变长记录的文件，同样设置读写指针，每次读或写完一个记录后，将读或写指针加上刚读或刚写完的记录的长度。\n对于索引文件，使用关键字建立索引表，根据用户（程序）提供的关键字用折半查找法去检索索引表，从中找到相应的表项。再利用该表项中给出的指向记录的指针值去访问所需的记录。而每当要向索引文件中增加一个新记录时，便须对索引表进行修改。\n\n## **文件目录的基本功能有哪些**\n\n（1）实现按名存取\n（2）提高对目录的检索速度\n（3）文件共享\n（4）允许文件重名\n\n## **引入索引结点的目的是什么**？\n\n为了减少索引文件时启动磁盘的次数\n\n## **文件有哪两种共享方式**\n\n1.利用索引节点实现文件共享\n2.利用符号链接实现文件共享\n文件的访问矩阵保护方式如何实现\n1.访问控制表\n2.访问权限表\n\n## **什么是事务**？**设置事务的目的是什么**？\n\n(1)事务是用于访问和修改各种数据项的-一个程序单位\n(2)事务也可以被看作是一系列相关读和写操作\n(3)事务的执行具有原子性\n\n","categories":["校内课程","操作系统"]},{"title":"操作系统 期末复习","url":"/posts/4e49f4fa.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 分值分布\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230617151449822.png\" alt=\"image-20230617151449822\" style=\"zoom:150%;\" />\n\n<!-- more -->\n\n# 第一章 操作系统引论\n\n## 操作系统介绍\n\n### 定义：是一种软件\n\n**操作系统是**一组用于控制和管理计算机系统硬件和软件资源、合理地对各类作业进行调度，以及方便用户使用的**程序集合**。\n\n### 地位：软件管理硬件和软件\n\n操作系统是裸机之上的第一层**软件**，是建立其他所有软件的基础。它是整个系统的控制管理中心，**既管硬件，又管软件**，它为其它软件提供运行环境。\n\n### 设计现代操作系统的目的：\n\n**有效性，方便性，可扩充性，开放性**\n\n## OS的作用是什么？\n\n1.操作系统作为用户与硬件系统之间的接口。\n2.操作系统作为计算机资源的管理者。\n3.操作系统实现了对计算机资源的抽象。\n\n### **基本特征：并发、共享、异步、虚拟**\n\n- 并发：是指两个或多个活动在同一给定的时间间隔中进行。注意**并行**：两个或多个活动在在**同一时刻**发生\n- 共享：是指计算机系统中的资源被**多个进程所共用**。\n- 异步：进程以**不可预知**的速度向前推进\n- 虚拟：把一个物理上的实体变为若干个**逻辑上的对应物**。\n- **最基本特征：并发、共享（两者互为存在条件） ** 其中**并发**是最基本的特征!!!\n\n### 主要功能：处理机管理、存储器管理、文件管理、设备管理\n\n- 处理机管理：主要功能包括**进程控制、进程同步、进程通信、死锁处理、处理器调度**等\n- 存储器管理：主要包括**内存分配与回收、地址映射、内存保护与共享、内存扩充**等功能\n- 文件管理：包括**文件存储空间管理、目录管理、文件读写管理和保护等**\n- 设备管理：主要包括**缓存管理、设备分配、设备处理、虚拟设备**等功能\n\n### 发展：辨析各个阶段的优缺点\n\n### **手工操作阶段（此阶段无操作系统）**\n\n缺点：人机速度矛盾\n\n### **批处理阶段（操作系统开始出现）**\n\n### 1.单道批处理阶段：一个CPU运行一个程序\n\n优点：缓解人机速度矛盾\n\n缺点：**系统资源利用率依然低**\n\n### 2.多道批处理阶段（操作系统正式诞生）：一个CPU运行多个程序\n\n推动多道批处理形成的主要动力是：**提高资源利用率和系统吞吐量**\n\n优点：多道程序并发进行，**资源利用率高**\n\n缺点：**不提供人机交互能力**（缺少交互性）\n\n### **分时操作系统（不可以插队，有了人机交互） **\n\n推动分时系统形成的主要动力：**满足用户需求：人机交互和共享主机**\n\n特点：多路性，独立性，及时性，交互性\n\n优点：**提供人机交互**\n\n缺点：**不能优先处理紧急事务**\n\n**典型系统**：Multics (MIT)；UNIX；Linux\n\n关于windows系统：是分时系统和实时系统的组合，根据不同的情况来进行分时系统的操作和实时系统的操作\n\n### **实时操作系统（可以插队）**\n\n特点：多路性，独立性，及时性，交互性，可靠性\n\n1.硬实时系统：必须在被控制对象规定时间内完成（火箭发射）\n\n2.软实时系统：可以松一些（订票）\n\n优点：**可以优先处理紧急事务**\n\n**从可靠性看实时操作系统更强，从交互性看分时操作系统更强**\n\n## 不得不知的概念\n\n### 两种指令：特权指令、非特权指令\n\n**特权指令：不允许用户程序使用**（只允许操作系统使用）如IO指令、置中断指令\n\n**非特权指令：普通的运算指令**\n\n### 两种程序：内核程序、应用程序\n\n**内核程序**：系统的管理者，可执行一切指令、运行在**核心态**\n\n**应用程序**：普通用户程序只能执行非特权指令，运行在**用户态**\n\n### 处理机状态\n\n用户态（目态）：CPU只能执行非特权指令\n\n核心态（管态、内核态）：可以执行所有指令\n\n用户态到核心态：通过**中断**（是**硬件**完成的）\n\n核心态到用户态：**特权指令psw的标志位：0用户态  1核心态**\n\n常考谁在用户态执行，谁在核心态执行\n\n### 原语\n\n1.处于操作系统的**最底层**，是**最接近硬件**的部分\n\n2.这些程序的运行具有**原子性**，其操作只能**一气呵成**\n\n3.这些程序的运行时间都较**短**，而且**调用频繁**\n\n### 中断和异常\n\n内中断（异常，信号来自内部）\n\n- 自愿中断---指令中断\n- 强迫中断：硬件中断、软件中断\n\n外中断（中断，信号来自外部）\n\n- 外设请求\n- 人工干预\n\n### 系统调用\n\n系统给程序员（应用程序）提供的唯一接口，可获得OS的服务，在用户态发生，在核心态处理\n\n### 体系结构\n\n大内核\n\n微内核\n\n# 第二，三章 进程，处理机调度和死锁\n\n## 进程管理\n\n### 引入进程的目的\n\n为了更好地描述和控制程序并发执行，实现操作系统的并发性和共享性（**进程是动态的，程序是静态的**）\n\n### 进程的特点\n\n**动态性，并发性，独立性**\n\n### 定义\n\n是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位\n\n> **在引入线程的操作系统中，线程是调度和分配的基本单位 ，进程是资源拥有的基本单位**\n>\n> **在未引入线程的操作系统中，进程是系统进行资源分配和调度的基本单位**\n\n### 组成：PCB+程序段+数据段\n\nPCB：**保存进程运行期间相关数据，是进程存在的唯一标志，常驻内存**\n\n程序段：能被进程调度到的CPU代码\n\n数据段\n\n### 进程的状态\n\n状态种类\n\n![image-20230416210528891](https://cdn.davidingplus.cn/images/2025/02/01/image-20230416210528891.png)\n\n- 运行态：进程正在占用CPU\n- 就绪态：进程已处于准备运行的状态，即进程获得了除处理机外地一切所需资源，一旦得到处理机即可运行\n- 阻塞态：进程由于**等待某一事件**不能享用CPU\n- 创建状态：进程正在被创建\n- 结束状态：进程正在从系统消失\n\n状态变化\n\n就绪态->运行态：处于就绪态的进程被调度后，获得处理机资源（分派处理机时间片）\n\n运行态->就绪态：系时间片用完或在可剥夺统中有更高级的进程进入\n\n运行态->阻塞态：进程需要的某一资源还没有准备好\n\n阻塞态->就绪态：进程等待的时间到来时\n\n进程状态转化图：\n\n![7478da23a11b1a44f156f204c07c4c67](https://cdn.davidingplus.cn/images/2025/02/01/7478da23a11b1a44f156f204c07c4c67.png)\n\n### 线程\n\n引入目的：为了更好的使用多道程序并发执行，提高资源利用率和系统吞吐量\n\n特点：是**程序执行的最小单位**，基本**不拥有任何系统资源**（**调度的基本单位**）\n\n## 处理器调度\n\n### 概念：多个进程选一个给处理机\n\n是对处理机进行分配，即从就绪队列中按照定的算法（公平、高效）选择一个进程并将处理机分配给他运行，以实现进程并发进行\n\n### 分类\n\n- **高级调度（作业调度，长程调度）**（次数少）将作业从外存调入内存，创建进程，分配资源，并放入就绪队列。**主要用于多道批处理系统中，分时和实时一般不用**\n- **中级调度（内存调度）**（次数中）**提高内存利用率和系统吞吐量**。把暂时不能运行的进程调至外存等待(挂起状态)；把具备条件的又调入内存，放入就绪队列(注意是调回)，这种情况下和高级调度(调入)有些相似，但是又有不同，发生的频率要比高级调度要高一些。\n- **低级调度（进程调度，短程调度）**（次数多）根据算法，决定就绪队列哪个进程能获得处理机，并分配**。在多道批处理，分时和实时都必须配置**\n\n### 调度方式\n\n- 剥夺式：进程1正在运行，进程2权限高，所以进程2挤掉进程1位置\n- 非剥夺式：进程1运行到底，或者因为自身原因(I/O请求，Block())不能继续运行，不会被其他进程抢占CPU；**适用于大部分批处理系统，不适用于分时和实时系统**\n\n### 调度准则\n\n- CPU利用率\n- 系统吞吐量：单位时间内CPU完成的作业数\n- **周转时间：作业完成时间-作业提交时间**\n- **带权周转时间W=T/Ts   其中T为周转时间，Ts为服务时间**\n- 等待时间：进程等待处理的时间，有可能时间片用完了 就继续等待\n- 响应时间：提交到第一次运行的时间\n\n### 算法\n\n- 先来先服务 FCFS : first come first service\n- 短作业优先 SJF：哪个作业短，哪个先\n- 优先级调度算法 PSA:外部赋予优先级\n- **高响应比优先调度算法 HRRN：高响应比= 1 + 等待时间 / 运行时间** (**计算结果越大优先级越高!!!**)\n\n> ![c7555bea163feeb1af4837bb152d0323](https://cdn.davidingplus.cn/images/2025/02/01/c7555bea163feeb1af4837bb152d0323.png)\n\n- **时间片轮转 RR：剥夺** 时间片的大小q很重要\n\n- 按照顺序来进行就绪队列的排序，**注意一点的是如果在某一时刻作业B到达，然后作业A时间片执行完毕(但是没有执行完)，需要把作业A排到就绪队列队尾!!!**\n\n  如果q很大，能使得每个进程都能在q时间片之内运行完，那么就退化为FCFS算法；其他情况需要画甘特图分析!!!\n\n  两个公式：\n\n  **周转时间 = 结束时间 - 到达时间**\n\n  **带权周转时间 = 周转时间 / 运行时间** \n\n  ![image-20230418180455682](https://cdn.davidingplus.cn/images/2025/02/01/image-20230418180455682.png)\n\n> ![97d8dcb9ee60302f3b35c29c27d6ed41](https://cdn.davidingplus.cn/images/2025/02/01/97d8dcb9ee60302f3b35c29c27d6ed41.png)\n\n**一个例题：**\n\n![image-20230614163048468](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614163048468.png)\n\n注意两道作业的意思：**内存里最多只能同时存在两道作业，在内存里有两道作业时，此时在到达的作业只能在后备队列里储存。作业调度和进程调度好理解**\n\n![image-20230614163105994](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614163105994.png)\n\n- **多级反馈队列调度算法**\n\n> 算法思想：对其他调度算法的折中权衡\n>\n> 算法规则\n>\n> 1．**设置多级就绪队列，各级队列优先级从高到低，时间片从小到大**\n> 2．新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾\n> 3．只有第k级队列为空时，才会为k+1级队头的进程分配时间片\n>\n> 用于进程调度：用于作业/进程调度\n> 是否可抢占?：**抢占式的算法**。在 k级队列的进程运行过程中，若更上级的队列(1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，**原来运行的进程放回k级队列队尾**。(因为没运行完，所以放到k级队尾就绪等待)\n>\n> \n>\n> 优缺点：\n>\n> 对各类型进程相对公平（FCFS的优点）﹔每个新到达的进程都可以\n>\n> 很快就得到响应（RR的优点)﹔\n>\n> 短进程只用较少的时间就可完成(SJF的优点）﹔\n>\n> 不必实现估计进程的运行时间（避免用户作假);\n>\n> 可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/o密集型进程\n>\n> （拓展:可以将因I/o而阻塞的进程重新放回原队列，这样I/o型进程就可以保持较高优先级）\n>\n>\n> 是否会导致饥饿：**会**\n\n\n\n> 例题:各进程到达就绪队列的时间、需要的运行时间如下表所示。\n>\n> 使用多级反馈队列调度算法，分析进程运行的过程。\n> ![f5a50770e2b86bfcce55a1779cd0b682](https://cdn.davidingplus.cn/images/2025/02/01/f5a50770e2b86bfcce55a1779cd0b682.png)\n>\n> ![e27a7f0b21a03b61fa0162bed932eaaf](https://cdn.davidingplus.cn/images/2025/02/01/e27a7f0b21a03b61fa0162bed932eaaf.png)\n>\n> \n>\n> P1(1)->P2(1)->P1(2)->P2(1)->P3(1)->P2(2)->P1(5)\n>\n> 时间0：P1进入第一队列，运行1，后进入第二队列队尾\n>\n> 时间1：P2到达第一队列，运行1，后进入第二队列队尾\n>\n> 时间2：P1运行2，后进入第三队列队尾\n>\n> 时间4：P2运行1s后，P3进入第一队列，**P2被抢占，进入第二队列队尾**\n>\n> 时间5：P3进入第一队列，P3运行1\n>\n> 时间6：P2运行2\n>\n> 时间8：P1运行5\n\n\n\n## 进程同步\n\n### 引入原因\n\n协调进程之间的相互制约关系\n\n### 制约关系\n\n**两种：直接制约和间接制约。**\n\n**引起制约的原因：这种制约可分为直接制约和间接制约，进程间的直接制约是被制约进程和制约进程之间，存在着使用对方资源的需求。**\n\n- **同步：亦称直接制约关系，是因合作进程之间协调彼此的工作而控制自己的执行速度，即因相互合作，相互等待而产生的制约关系**\n- **互斥：也称间接制约关系，是进程之间竞争临界资源而禁止两个以上的进程同时进入临界区所发生的制约关系**\n\n### 临界资源\n\n一次**仅允许一个进程**使用的资源**（打印机、共享缓冲区、共享变量、公共队列）**\n\n### 临界区\n\n在每个进程中访问临界资源的**那段程序**\n\n### 临界区互斥\n\n原则\n\n- **空闲让进**：如果有若干进程要求进入空闲的临界区，**一次仅允许一个进程进入**\n- **忙则等待**：任何时候，**处于临界区内的进程不可多于一个**。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待\n- **有限等待**：进入临界区的**进程要在有限的时间内退出**，以便其它进程能及时进入自己的临界区\n- **让权等待**：如果进程不能进入自己的临界区，则应该**让出CPU**，避免进程出现“忙等”的现象\n\n基本方法\n\n- 信号量：**利用PV操作实现互斥**\n\n## 信号量(信号量机制是一种有效实现进程同步和互斥的工具)\n\n**信号量是被看做具有原子操作的计数器**\n\n信号量的物理意义∶\n\n(1)信号量的值大于0︰**表示当前资源可用数量【S=5    有5个可用资源】**\n\n小于0:其绝对值表示**等待使用该资源的进程个数【S=-5    有5个进程在等待资源】**\n\n(2)信号量初值为非负的整数变量，代表资源数。\n\n(3)信号量值可变，但仅能由P、V操作来改变。\n\n## P/V操作原语\n\n### 1）P操作原语P(S)\n\n相当于wait操作\n\n(1)P操作一次，S值减1，即S=s-1(请求分配一资源）【P(s)=S-1    消耗一个资源】【S=5    P（s）；     S=4】\n\n(2)如果S≥0，则该进程继续执行;\n\n**如果S<0表示无资源则该进程的状态置为阻塞态**，【相当于阻塞队列】 **s=0表示最后一个资源恰好被分配出去!!!!**\n\n把相应的PCB连入该信号量队列的末尾,并放弃处理机，进行等待(直至另一个进程执行V (S）操作)\n\n\n\n### 2)V操作原语(荷兰语的等待)V(S)\n\n相当于signal操作\n\n(1)v操作一次，s值加1，即S=S+1(释放一单位量资源)\n\n(2)如果S>0，表示有资源，则该进程继续执行;**如果S≤0，则释放信号量队列上的第一个PCB所对应的进程(阻塞态改为就绪态)**，执行v操作的进程继续执行。**s=0表示阻塞队列里最后一个进程刚好被唤醒!!!!**\n\n\n\n### 2)用P、V原语操作实现简单同步的例子\n\nS1缓冲区是否空(0表示不空，1表示空)，初值S1=0;\n\nS2缓冲区是否满(0表示不满，1表示满)，初值S2=0;\n\n\n\n### 3)生产者——消费者问题(Os典型例子):找到同步和互斥的关系\n\nmutex互斥信号量，初值为1;\n\nfull满缓冲区数，初值为0;\n\nempty空缓冲区数，初值为N;\n\n\n一组生产者和一组消费者共享一个初始为空，大小为n的缓冲区，【生产者生产->消费者取 同步关系】\n\n只有当缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待，\n\n只有当缓冲区不空时，消费者才能从中取出消息，否则必须等待，\n\n只允许一个生产者放入消息，或者一个消费者取出消息。【生产者的放 和 消费者的取 互斥关系】\n\n```cpp\n伪代码\n//这里的P代表wait(),V代表signal()\n\nSemaphore mutex=1;//临界区信号量（互斥） 互斥信号量初始化为1!   \n\n【信号量Semaphore，实现互斥的时候mutex=1，当一个进程使用资源的时候P（mutex），mutex=0，则资源数为0，其它进程无法使用资源】\n\nSemaphore empty=n;//空闲缓冲区为n个\n\nSemaphore full=0;//满缓冲区数(有资源)【full=0代表没有缓冲区被充满】\n\nproducer(){\n    \n    while(1){\n        \n    produce an item in nextp;//生产一个东西\n\n    P(empty);    //空缓冲区-1\n\n    P(mutex);    //互斥的访问缓冲区，mutex=0，生产者进入了缓冲区\n\n【这里两个P操作不能交换：若交换，则生产者占用缓冲区mutex=0，若此时缓冲区全满empty=0，则发生阻塞，生产者等待消费者消费，但消费者无法进入临界区，则死锁】\n\n    add nextp to buff;    //行为 in=(in+1)%n;\n\n    V(mutex);    //离开缓冲区\n\n    V(full);    //提供了资源\n\n    }\n\n}\n\nconsumer(){\n    \n    while(1){\n\n    P(full);    //看看缓冲区是不是有资源的，有则-1\n\n    P(mutex);    //进入临界区\n\n【不能对调，对调死锁】\n\n    remove an item from buffer; // out=(out+1)%n;\n\n    V(mutex);    //释放临界区\n\n    V(empty);    //空缓冲区+1\n\n    }\n}\n```\n\n## 死锁\n\n### 关于死锁的一个计算题\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230617195118808.png\" alt=\"image-20230617195118808\" style=\"zoom:80%;\" />\n\n### 产生的原因\n\n**非剥夺资源的竞争**和进程的**不恰当推进顺序**（与饥饿的区别：**饥饿为缺乏某些资源的进程**）\n\n### 1)系统资源的竞争\n\n通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。\n\n只有对**不可剥夺资源的竞争才可能产生死锁**，对**可剥夺资源的竞争是不会引起死锁的**。\n\n【P1有资源A，需要资源B，且不会释放资源A；     P2有资源B，需要资源A，且不会释放资源B；    死锁】\n\n【P1需要A资源4个    P2需要A资源4个    A资源只有6个，且A资源为不可剥夺资源    P1申请了3个，P2申请了3个，P1P2都在申请，但没有了】\n\n\n\n### 2)进程推进顺序非法\n\n进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。\n\n例如,并发进程P1、P2分别保持了资源R1、R2，而进程P1申请资源R2，进程P2申请资源R1时，两者都会因为所需资源被占用而阻塞。\n\n【P1申请R1，R2，后结束释放资源，P2再申请R1、R2，则无阻塞】\n\n### 3)死锁产生的**必要条件：死锁产生一定是因为4个条件，但4个条件不一定产生死锁**\n\n**互斥条件**:进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。(**这个是一定要有的，不管会不会产生死锁，这个条件都必须存在**)\n\n**非剥夺条件**:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放(只能是**主动释放**）\n\n**请求和保持条件**︰进程已经保持了至少一个资源，但又提出了新的资源请求,而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。(请求别的资源但是保持自己的资源不放手)\n\n**循环等待条件**:存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。\n\n【P1->P2->P3->P4->P1：P1等P2的资源，2等3，3等4，4等1】\n\n当死锁产生的时候一定会有这四个条件，有一个条件不成立都不会造成死锁。其中**互斥使用资源是无法破坏**的\n\n\n\n### 定义\n\n多个进程因**竞争资源**而造成的一种**僵局**，如果**没有外力，这些进程将无法推进**\n\n## 解决方法\n\n解决死锁的三种方法:**死锁的预防、避免、检测与恢复**。\n\n### 1.死锁预防的基本思想和可行的解决办法\n\n1.**死锁预防**的基本思想:打破产生死锁的四个必要条件的一个或几个。【主动出击】\n\n2**.避免死锁**的策略︰在资源的动态分配过程中，用某种方法防止系统进入不安全状态，从而避免死锁。【躲着它】\n\n3.**死锁的检测及解除**【一开始不作为，然后一步到位：不预防避免死锁，有死锁再解除】\n\n无需采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。\n\n\n\n## 预防死锁\n\n- 破坏**互斥**条件\n- 破坏**不剥夺**条件\n- 破坏**请求和保持**条件\n- 破坏**循环等待**条件\n\n### 1)破坏互斥条件(不行)\n\n如果允许系统资源都能共享使用，则系统不会进入死锁状态。\n\n但**有些资源根本不能同时访问**，如打印机等临界资源只能互斥使用。\n\n所以，破坏互斥条件而预防死锁的方法**不太可行**，而且在有的场合应该保护这种互斥性。\n\n\n\n### 2)破坏不剥夺条件\n\n当一个已保持了某些不可剥夺资源的进程，请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。\n\n这意味着，**一个进程已占有的资源会被暂时释放，或者说是被剥夺了，或从而破坏了不可剥夺条件。**\n\n【P1有3个A资源，请求3个B资源，B资源没有，则释放3个A资源】\n\n\n\n### 3)破坏请求和保持条件\n\n#### 第一种协议\n\n**采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。**\n\n**一旦投入运行后，这些资源就一直归它所有，也不再提出其他资源请求，这样就可以保证系统不会发生死锁。**\n\n【P1 需要A3 B4 C5    ，现在P1有A2 B3 C0    ，申请A1 申请B1 申请C5，全部申请完就允许】\n\n这种方式实现简单，但缺点也显而易见，**系统资源被严重浪费**，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。\n\n而且还会导致**“饥饿”**现象，当由于**个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。**\n\n【P1过程    T1只需要A资源    T2 需要B    T3需要C    后结束，但在T1时刻有ABC资源，造成浪费】\n\n#### 第二种协议\n\n对第一种协议的改进，**允许一个进程只获得运行初期所需要的资源后，便开始运行。在运行过程中逐步释放自己的，且已经用毕的全部资源，然后再请求新的所需资源。**\n\n**可以使进程更快的完成任务，提高设备的利用率，还可以减少进程发生饥饿的概率。**\n\n### 4)破坏循环等待条件\n\n为了破坏循环等待条件，可采用**顺序资源分配法**。首先给系统中的资源编号规定每个进程，**规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。**\n\n也就是说，只要进程提出申请分配资源Ri，就必须把Ri以下的编号全部申请到才能运行(导致资源的浪费)，则该进程在以后的资源申请中，**只能申请编号大于Ri的资源。**\n\n## 避免死锁\n\n- **安全状态**\n- **银行家算法(注意理解例题)**\n\n银行家算法是最著名的**死锁避免算法**。\n\n它提出的思想是:把操作系统看做是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。\n\n操作系统按照银行家制定的规则为进程分配资源，\n\n当进程**首次申请**资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。\n\n【max>available，申请量大于可申请，则推迟】\n\n当进程在**执行中**继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量\n\n【max>available，申请量之和大于可申请，则推迟】\n\n若超过则拒绝分配资源，\n\n若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，\n\n若能满足则按当前的申请量分配资源，\n\n否则也要推迟分配。\n\n\n\n### 1)数据结构描述\n\n**可利用资源矢量Available**:含有m个元素的歉组，其中的每一个元素代表一类可用的资源数目。Available[j]=K，则表示系统中现有Rj类资源K\n\n**最大需求矩阵Max**:为n*m矩阵，定义了系统中n个进程中的每一个进程对m类资源的最大需求。Max[i,j]=K，则表示进程i需要Rj类资源的最大数目为K。\n\n**分配矩阵Allocation**:为n*m矩阵，定义了系统中每一类资源当前已分配给每一进程的资源数。AlloCation[i,j]=K，则表示进程i当前已分得Rj类资源的数目为K。\n\n**需求矩阵Need**:为n*m矩阵，表示每个进程尚需的各类资源数Need[i,j]=K，则表示进程i还需要Rj类资源的数目为K。\n\nNeed[i,j]=Max[i,j]-Allocation[i,j]\n\n\n\n### 2)银行家算法描述\n\n设Requesti是进程Pi的请求矢量，如果Requesti[j]K，表示进程Pi需要Rj类资源K个。当Pi发出资源请求后，系统按下述步骤进行检查:\n\n①如果Requesti[j]<=Need[i,j]，便转向步骤②;否则认为出错\n\n因为它所需要的资源数已超过它所宣布的最大值。\n\n②如果Requesti[ij]<=Available[i]，便转向步骤③;否则，表示尚无足够资源，Pi须等待。\n\n③系统试探着把资源分配给进程Pi，并修改下面数据结构中的数值:\n\n1.Available[j]=Available[i]- Requesti[j];\n\n2.Allocation[i,j]= Allocation[i,j]+ Requesti[ j];\n\n3.Need[i,j] = Need[i,j] - Requesti[j];\n\n④系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。\n\n若安全，才正式将资源分配给进程Pi，以完成本次分配;否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程Pi等待。\n\n\n\n## 检测死锁：利用死锁定理\n\n## 解除死锁\n\n- 资源剥夺法\n- 撤销进程法\n- 进程回退法\n\n## 进程管理习题讲解\n\n## 题1\n\n一个四道作业的操作系统中，设在一段时间内先后到达6个作业，它们的提交时间和运行时间见表\n\n![622a3226d0302fc334c0d8bd3a3b69b4](https://cdn.davidingplus.cn/images/2025/02/01/622a3226d0302fc334c0d8bd3a3b69b4.png)\n\n系统采用**短作业优先**的调度算法，作业**被调度进运行后不再退出【非抢占式】**，但当一作业进入运行时，可以调整运行的优先次序。\n\n1按照所选择的调度算法，请分别给出上述6个作业的执行时间次序\n\n> 次序156342\n>\n> JOB1提交到完成为9:00，JOB2-6已经全部提交，**短作业优先：**则选择时间短到长的进行排序56342\n\n> 标准答案\n>\n> 标准的运行流程如下\n>\n> ![fbe7f7c9acd8743e692a02b03c127927](https://cdn.davidingplus.cn/images/2025/02/01/fbe7f7c9acd8743e692a02b03c127927.png)\n\n2计算在上述调度算法下作业的平均周转时间\n\n> **周转时间T=作业完成时间-作业的提交时间**\n>\n> 平均周转时间=1/n(T1+T2+....Tn)    \n>\n> n为作业进程数，本题为6\n\n> 标准答案\n>\n> T1=60\n>\n> T2=135\n>\n> ...\n>\n> T6=35\n>\n> 平均周转时间=1/6*（60+135+70+90+30+35）=70\n\n\n\n## 题2\n\n一个具有两道作业的批处理系统【进程只允许在内存中存在两个】，\n\n作业调度【从外存向内存里面调度】采用短作业优先的调度算法，\n\n进程调度【分配处理机cpu】采用以**优先数**为基础的**抢占式**调度算法，如下表的作业序列\n\n(表中所有作业优先数即为进程优先数，**数值越小优先级越高**)。\n\n![651d93c2caf4c64682109da6d992704e](https://cdn.davidingplus.cn/images/2025/02/01/651d93c2caf4c64682109da6d992704e.png)\n\n1.列出所有作业进入内存时间及结束时间\n\n> 作业ABCD都在外存，可以向内存中调入两个作业，按优先数进入CPU\n>\n> 到达时间\n>\n> 10:00    A到达 进入内存    CPU运行\n>\n> 10:20    B到达 进入内存    内存中有AB A运行20min，剩余20min    B优先数高，B开始运行\n>\n> 10:30    C到达，A剩余20min，B运行10min，剩余20min    由于采用短作业优先算法，50>20=20，所以C不被调入内存\n>\n> 10:50    D到达，B作业完，下处理机，下内存    由于采用短作业优先算法，C50min，D20min，D进入内存    内存有AD，进程调度A优先数高，A进CPU\n>\n> 11:10    A结束    C进内存，内存有CD，C优先数高，先进处理器\n>\n> 12:00    C结束，D进处理器\n>\n> 12:20    D结束\n\n> 标准答案\n>\n> 1、10:00，A作业到达，进入系统开始运行。\n>\n> 2、10∶20，B作业到达，系统内存中只有一道作业A，B作业进入内存，此时A运行20min，还剩20min,由于B作业的优先数小，即优先级高，则作业A进入就绪状态，作业B开始运行。\n>\n> 3、10∶30，C作业到达，内存中已有两道作业，则在后备队列中等待被作业调度程序调度，A等待10min,剩20min,继续等待，B运行10min,还剩20min,继续运行。\n>\n> 4、10∶50，D作业到达，B作业完成，内存中只剩下作业A,剩20min，作业D与作业C相比，作业D的运行所需时间少被调到进内存，内存中的A和D相比，A的优先级高，A继续运行。\n>\n> 5、11∶10，作业A运行完成，作业C被调度进内存，内存中有作业D和作业C，C的优先级比D高，C先运行。\n>\n> 6、12: 00，作业C完成，D运行。\n>\n> 7、12∶20，作业D完成\n>\n> ![a2be6f71ff92d4b6cee980875b026ad5](https://cdn.davidingplus.cn/images/2025/02/01/a2be6f71ff92d4b6cee980875b026ad5.png)\n\n2.计算平均周转时间\n\n>  各作业执行时间的周转时间为\n>\n>  作业A 70分钟\n>\n>  作业B30分钟\n>\n>  作业C 90分钟\n>\n>  作业D 90分钟\n>\n>  作业的平均周转时间为T=70 (min)\n\n\n\n## 题3.有5个批处理作业(A、B、C、D、E)几乎同时到达一个计算中心，估计的运行时间分别为2，4，6，8，10分钟，\n\n它们的优先数分别为1，2，3，4，5(1为最低优先级)，\n\n对下面的每种调度算法，分别计算作业的平均周转时间。\n\n1最高优先级先\n\n2时间片轮转(时间片为2分钟)\n\n3 FIFO( FCFS ) (作业到达顺序为C、D、B、E、A)\n\n4短作业优先\n\n【题目没提：默认为非剥夺式】\n\n> 1对最高优先级优先算法\n>\n> ![d83d86f2bfe347dc357aa83b3d76068e](https://cdn.davidingplus.cn/images/2025/02/01/d83d86f2bfe347dc357aa83b3d76068e.png)\n>\n> 平均周转时间=（10+18+24+28+30）/5=22分钟\n\n> 2对时间片轮转算法\n>\n> ![ca18bcaccd42c2e34787159674132ab4](https://cdn.davidingplus.cn/images/2025/02/01/ca18bcaccd42c2e34787159674132ab4.png)\n>\n> 平均周转时间=(2+12+20+26+30)/5=18\n\n> 3 FIFO (作业到达顺序为C、D、B、E、A)\n>\n> ![c747a0c9e3f8a0336399242d737f00c8](https://cdn.davidingplus.cn/images/2025/02/01/c747a0c9e3f8a0336399242d737f00c8.png)\n>\n> 平均周转时间=(6+14+18+28+30)/5=19.2\n\n> 4短作业优先\n>\n> A:2 B:4 C:6 D:8 E:10\n>\n> 平均周转时间=(2+6+12+20+30)/5=14\n\n## 题9.银行家算法中，若出现下述的资源分配情况:\n\n![1e93cc965771ae3d7697f3fc6f048be7](https://cdn.davidingplus.cn/images/2025/02/01/1e93cc965771ae3d7697f3fc6f048be7.png)\n\n【已分配Allocation    尚需need    未分配available    Max=已分配+尚需=Allocation+Need    后available=原available+Allocation】\n\n⑴该状态是安全的吗?【假设P0->P1->P2->P3->P4可以执行结束，我能够找到一个安全序列，则该状态是安全的】\n\n> 未分配2431，可以给P0用，P1不行，P2不行，P3不行，P4不行，所以先运行P0，运行结束未分配为2441\n>\n> 未分配2441，P1不行，P2不行，P3行，P4不行，运行P3，结束未分配为2572\n>\n> 未分配2572，P1不行，P2不行，P4行，运行P4，结束未分配为2586\n>\n> 未分配2586，P1不行，P2行，运行P2，结束未分配为3 8 13 10\n>\n> 未分配3 8 13 10，P1行，运行P1\n>\n> 所以安全序列为P0->P3->P4->P2->P1\n\n> 标准答案\n>\n> P0(2 4 4 1)->P3(2572)->P4(2 5 8 6)->P2(3 8 13 10)->P1(4 8 13 10)为其中一个安全序列，所以该状态安全。\n\n⑵如果P1再提出资源请求Request (0 3 2 1)，系统能否将资源分配给它?【找不到安全序列，系统处于危险状态，不能分配】\n\n> 标准答案\n>\n> 因为一旦分配，P1还需P1(0 4 3 0),系统的可用资源数为(2 1 1 1)，\n>\n> 在所有进程中只有P0(2 0 1 0)，为其分配，作上完成标志，可用资源为(2 1 2 1);\n>\n> 而P1/P2/P3/P4均不能作上完成标志\n\n# 第四章 内存管理\n\n## 引入目的\n\n更好的支持多道程序的**并发执行**，提高系统性能\n\n## 主要功能\n\n### 内存空间的分配与回收\n\n### 存储的保护和共享：\n\n保证各道作业在各自的存储空间内运行，互不干扰。\n\n### 地址转换：\n\n在多道程序环境下，程序中的**逻辑地址**与内存中的**物理地址**不可能一致，因此存储管理必须提供地址变换功能，把**逻辑地址转换成相应的物理地址**\n\n### 内存扩充：\n\n利用**虚拟存储技术或自动覆盖技术**，从**逻辑上**扩充内存。\n\n## 用户程序的主要处理阶段\n\n![image-20230611101715397](https://cdn.davidingplus.cn/images/2025/02/01/image-20230611101715397.png)\n\n### 1). 编辑阶段\n\n创建源文件\n\n### 2). 编译阶段(形成目标模块)\n\n由编译程序将用户源代码编译成若干**目标模块**，生成**目标文件**\n\n### 3). 链接阶段(形成装入模块)\n\n由链接程序将编译后形成的一组目标模块**及所需的库函数**链接在一起， 形成一个完整的**装入模块**。**生成可执行文件(形成逻辑地址)**\n\n### 4). 装入阶段\n\n由装入程序将装入模块**装入内存**运行。\n\n### 5). 运行阶段\n\n得到结果\n\n## 相关概念\n\n### 程序的装入\n\n- 绝对装入（**逻辑地址必须和实际的内存地址完全一样**)：所以不允许对程序和数据的地址进行修改\n\n**重定位：装入内存时，相对地址（数据、指令地址）要作出相应的修改以得到正确的物理地址，这个修改的过程称为重定位。**\n\n- 静态重定位（**地址变换在装入时一次完成，并且之后不能移动**）：**装入内存的时候地址变换**\n- 动态重定位（**地址变换在执行程序的时候再完成**）：**运行的时候地址变换，更加灵活高效**\n\n### 程序的链接\n\n- 静态链接：在程序运行之前，先将各目标模块及它们所需的库函数，链接成一个完整的装入模块（又称执行模块），以后不再拆开。要解决两个问题，一是**将相对地址进行修改**，二是**变换外部调用符号**(例如将 Call B 变换为 JSR \"L\")\n- 装入时链接：用户源程序经编译后所得到的目标模块，**是在装入内存时，边装入边链接的。**就是在装在内存的时候，如果发生一个外部模块调用，就调用装入程序去找出相应的外部模块然后把他装入内存\n- 运行时链接：在执行过程中，若发现一个被调用模块尚未装入内存时，由OS去找到该模块，将它装入内存，并链接到调用模块上。\n\n### 地址空间\n\n- 逻辑地址空间（地址空间从0开始）\n- 物理地址空间（内存中物理单元的集合）\n\n## 管理方式\n\n## 连续分配管理方式：物理地址连续，逻辑地址连续\n\n### 1.单一连续分配\n\n系统分为**系统区和用户区**，应用程序装载到用户区，内存中仅驻留一道用户程序，整个用户区为用户一个人所占，使用用户区的全部空间\n\n分配到内存固定的区域（有内部碎片）：**分配给进程的内存有一部分没有用上**\n\n> 例如：30mb分30mb\n\n### 2.固定分区分配\n\n将内存用户空间划**分为若干个固定大小(每块的大小不一定相同)**的区域，每个区域称为一个分区，在每个分区中只装入一道作业 ，从而支持多道程序并发设计\n\n分配到内存不同的固定区域，分区可以相等可以不等（**内部碎片，内零头**）\n\n> 例如：30mb分为10mb和20mb\n\n#### 补充：内零头和外零头\n\n![image-20230611110754152](https://cdn.davidingplus.cn/images/2025/02/01/image-20230611110754152.png)\n\n### 3.动态分区分配\n\n#### 可变分区存储管理：\n\n按照**程序的需要**进行**动态的划分**\n\n#### 动态分区的分配策略算法\n\n#### 首次适应（***\\*最好\\****）\n\n空闲分区以**地址递增的次序**链接。分配内存时顺序查找，**找到大小能满足要求的第一个空闲分区**。（**增加查找开销**）\n\n![image-20230611110653354](https://cdn.davidingplus.cn/images/2025/02/01/image-20230611110653354.png)\n\n> 例如：从0x0001到0xFFFF顺序查找，30mb小了，20mb小了，40mb合适就你了\n\n#### 最佳适应\n\n空闲分区按容量递增的方式形成分区链，找到一个最接近目标大小的满足要求的空闲分区。（**外部碎片过多**）\n\n![image-20230611110554522](https://cdn.davidingplus.cn/images/2025/02/01/image-20230611110554522.png)\n\n> 例如：从1mb到9999mb查找，1mb小了，2mb小了，3mb合适\n>\n> **外部碎片:因为碎片过小而无法利用，例如30mb的**空闲分区，进程需要29.999mb，剩下的0.001mb为外部碎片\n\n#### 最坏适应\n\n空闲分区以**容量递减**的次序链接。找到第一个能满足要求的空闲分区，即挑选出最大的分区。（**对大进程不利**）\n\n![image-20230611110613282](https://cdn.davidingplus.cn/images/2025/02/01/image-20230611110613282.png)\n\n> 例如：空闲分区有100mb，70mb，........，1mb\n>\n> 70mb进程来了进100mb的空闲分区，然后100mb进程来了就要等等等\n\n#### 邻近适应\n\n由首次适应算法演变而成。不同之处是，**分配内存时从上次查找结束的位置开始继续查找**。\n![image-20230611110844074](https://cdn.davidingplus.cn/images/2025/02/01/image-20230611110844074.png)\n\n> 例如：第一次找到了0xFF00，第二次从0xFF00开始找\n\n### 4.可重定位分配(解决外零头)\n\n**将内存中的所有作业进行移动，使它们全都相邻接，把原来分散的多个小分区合成一个大分区**\n\n## 非连续分配管理方式（大题）：物理地址不连续，逻辑地址连续\n\n离散分配：程序在内存中的存放不一定是连续的\n\n### 1.基本分页式存储管理\n\n离散的基础：\n\n- 分页(Pages)：将程序地址空间分页\n- 分块(Frames)：将内存空间分块\n\n**内存可以装入程序一页；连续的多个页不一定装入连续的多个块当中；系统的页块大小是不变的**\n\n优点：**没有外零头，但是存在内零头**\n\n![image-20230612102324296](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612102324296.png)\n\n**逻辑地址到物理地址的转换：由地址变换机构完成**\n\n**逻辑地址：由页号和页内偏移量组成**\n\n**页号到物理块号的转换：由页表完成**\n\n**每个存储块的大小和页面的大小相同**\n\n![image-20230612102754955](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612102754955.png)\n\n有两种地址变换结构：\n\n- 基本的：就是查页表\n- 具有快表：**设置一个快表TLB，也叫联想存储器；根据逻辑地址的页号，优先查询快表查看是否存在对应的页表项，若存在则成为命中，取出物理块号计算出物理地址，如果不存在查找页表更新快表**\n\n![image-20230612103635755](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612103635755.png)\n\n两级和多级页表\n\n![image-20230612104109474](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612104109474.png)\n\n对换操作\n\n![image-20230612110205390](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612110205390.png)\n\n外存可以分为文件区和对换区：**文件区存放文件，侧重于提高存储空间利用率，应用离散分配方式；对换区存放从内存中进进出出的文件，交换较频繁，侧重于对换这个操作，应用连续分配方式**\n\n换出换入：\n\n![image-20230612110650932](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612110650932.png)\n\n**分页系统地址变换机构图：(牢记!!!)**\n\n![image-20230617153605037](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617153605037.png)\n\n具有快表的情况\n\n![image-20230617153551945](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617153551945.png)\n\n### 2.基本分段式存储管理\n\n**引入分段式的原因：**\n\n- 通常的程序都可以分为若干个段，**每个段大多都是一个相对独立的逻辑单位**。\n- **实现和满足信息共享，信息保护，动态链接以及信息的动态增长等需求，也都是以段为基本单位的。**\n\n**分段制造了二维空间，而内存是一维的**\n\n段表\n\n![image-20230612111402650](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612111402650.png)\n\n地址变换机构：\n\n![image-20230612111614439](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612111614439.png)\n\n分页和分段的联系(信息共享)\n\n![image-20230612111709825](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612111709825.png)\n\n### 补充：比较分页和分段存储？\n\n1.相同点：\n\n- 分页机制和分段机制都是为了提高内存利用率，产生较少的内存碎片。\n- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个页和段中的内存是连续的。\n\n2.不同点：\n\n- 页的大小是固定的，由操作系统决定，而段的大小不固定，取决于我们当前运行的程序。\n- 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，**它含有一组其意义相对完整的信息，在程序中可以体现为代码段，数据段，是为了满足用户的需要。**\n- 分页的作业地址空间是维一的，即单一的线性空间，**程序员只须利用一个记忆符(这一个地址可以拆解为页号和页内偏移量)，即可表示一地址**。分段的作业地址空间是二维的，程序员在标识一个地址时，**既需给出段名，又需给出段内地址。**\n- 段一般比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n\n### 3.段页式\n\n**段式存储在内存保护和共享方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。**\n\n![image-20230612111824929](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612111824929.png)\n\n![image-20230612112011176](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612112011176.png)\n\n该图中仍然存在未写满的页，说明仍然存在内零头的问题\n\n如下管理：\n\n![image-20230612112118688](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612112118688.png)\n\n访问：**第一次段表，第二次页表，第三次数据，一共访问三次内存**\n\n![image-20230612112244935](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612112244935.png)\n\n## 内存扩充\n\n可以从物理和逻辑上增加\n\n**一次性和驻留性严重降低内存利用率，减少系统吞吐量。**\n\n- 一次性：要求将一个作业全部装入内存才能运行，这导致 大作业无法运行 和 限制作业并发执行的程度。\n- 驻留性：作业装入后一直驻留内存直到作业完成。 内存中存在一些已无用的、或暂时不用的程序或数据，浪费内存空间。\n\n### 1覆盖（同一程序或进程中）\n\n**针对同一程序，当一个程序的大小超过内存的大小的时候，不能一次性把作业全部装入内存运行，这个时候将程序分段，分为必须一直在内存的段和不是必须的段，当非必须的段用不到的时候将其调出内存，把需要的段覆盖进来，这样就可以实现这个程序的运行了。解决了一次性问题**\n\n### 2交换（不同进程/作业之间进行）\n\n**操作系统自动把暂时不能执行的程序保存到外存中；解决了驻留性问题**\n\n例如：在打大型游戏时候，将QQ微信放到外存\n\n### 3.虚拟存储\n\n**在有限容量的内存当中，自动装入更多更大的内存**\n\n## 虚拟内存\n\n![image-20230612112601533](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612112601533.png)\n\n特征(**多次性和对换性就是一次性和驻留性 反过来**)\n\n![image-20230612140330263](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612140330263.png)\n\n**实现虚拟存储的关键技术**\n\n- 请求分页技术\n\n- 请求分段技术\n\n抖动\n\n**选择的页面不恰当可能导致频繁的内存频繁的换进换出，吞吐量很低**\n\n![image-20230612140655714](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612140655714.png)\n\n### 引入原因\n\n在逻辑上扩充内存\n\n### 组成部分\n\n- 页表机制\n- 中断机制\n- 地址变换机制\n- 内存与外存\n\n引入算法：\n\n![image-20230612141104980](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612141104980.png)\n\n页表\n\n- 页框号Q：代表物理块号\n- 状态位D：**该页是否已经调入内存**，=0没有调入，=1已经调入\n- 访问位A：**用于记录本页在一段时间内被访问的次数，或最近已有多长时间未被访问**，提供给置换算法选择换出页面时参考。 A=0，该页未被访问；A=1，该页被访问 \n- 修改位M：**用于表示该页在调入内存后是否被修改过，也是提供给置换算法在换出页面时是否将该页面写回外存作参考**。 M=0，该页在内存中未被修改；M=1，该页在内存中已经被修改 \n- 外存地址：**用于指出该页在外存上的地址，供调入该页时使用**。\n\n![image-20230612141221434](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612141221434.png)\n\n最小物理块：\n\n![image-20230612141841257](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612141841257.png)\n\n**一般来说，增加物理块的个数应该是可以减少缺页中断的次数的，但是这种说法不能绝对化了，比如FIFO就有可能出现问题，异常现象!**\n\n## 页面淘汰（置换）算法：\n\n注意：页面淘汰是由缺页中断引起的，但缺页中断不见得一定引起页面淘汰\n\n### 先进先出页面淘汰（置换）算法（FIFO）\n\n总是选择作业中驻留时间最长(即最老)的一页淘汰。即：先进入主存的页面先退出主存。淘汰最先进入内存的页面（3个内存块都为空，3次缺页中断）\n\n注：**对于FIFO页面淘汰算法，有时增加分配给作业的可用 内存块数，它的缺页次数反而上升，通常称为异常现象**\n\n![image-20230612142748135](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612142748135.png)\n\n### 最近最久未用页面淘汰（置换）算法（LRU）\n\n总是把最长时间未被访问过的页面淘汰出去（**需要寄存器和栈**）。认为过去一段时间里不曾被访问过的页面，在最近的将来可能也不会再被访问。\n\n![image-20230612142843142](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612142843142.png)\n\n### 最近最少未被使用置换算法（LFU）\n\n**淘汰到目前为止访问次数最少的页面**\n\n![image-20230612143255819](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612143255819.png)\n\n### 最优（最佳）页面淘汰（置换）算法（OPT）\n\n把以后**不再使用**的或**最长时间内不会用到**的页面淘汰出去（理论上，不会实现，因为我们不知道未来页面的访问顺序是什么）\n\n![image-20230612142327562](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612142327562.png)\n\n### 时钟置换算法（clock），也叫NRU算法(最近未访问算法)\n\n**给每个页面设置一个访问位(比如R)，在最近一段时间内中在未访问也就是访问位为0的页面上任选一页进行淘汰**\n\n![image-20230617200334152](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617200334152.png)\n\n![image-20230617200346827](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617200346827.png)\n\n### 改进型的时钟置换算法\n\n**除了考虑一个页面最近有没有被访问过之外，操作系统还应考虑页面有没有被修改过。在其他条件都相同时，应优先淘汰没有修改过的页面，避免I/O操作。这就是改进型的时钟置换算法的思想。**\n\n为方便讨论，用**（访问位，修改位）**的形式表示各页面状态。如（1，1）表示一个页面近期被访问过，且被修改过。\n\n![image-20230617200554681](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617200554681.png)\n\n![image-20230617200559528](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617200559528.png)\n\n![image-20230617200657053](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617200657053.png)\n\n![208f4ffb18d7caa2a03b401b2775687f](https://cdn.davidingplus.cn/images/2025/02/01/208f4ffb18d7caa2a03b401b2775687f.png)\n\n### 抖动\n\n页面频繁的换进换出\n\n原因：分配给进程的进程块不足 ； 选择的页和段不合适\n\n### 页面分配的策略\n\n![image-20230612142206449](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612142206449.png)\n\n固定分区局部置换（物理块不变）\n\n> 给进程分配3个物理块，不变\n\n可变分配局部置换  (动态增加物理块)\n\n> 给进程分配3个物理块，缺页，加一块\n\n可变分配全局置换(只允许从该进程的内存页面中挑选一页)\n\n\n\n## 例题\n\n### 一个请求页式存储系统中，\n\n### 一个程序的页面走向为2，3，1，2，4，3，5 , 7，2，3，4，3，6，2，1，3，4，1\n\n### 假设分配给程序的存储块数为3块【三个物理块中有三个页，第四个来了，要挑一个页出来换】，\n\n### 请给出OPT、FIFO、LRU每种页面置换算法的页面走向，并计算缺页率。\n\n解:OPT最佳置换算法︰淘汰最远将来才使用的页。\n\n> 2，3，1，2，**4【引起缺页，要换123之中的一个】**，3【3最近要使用】，5 , 7，2【2最近要使用】，3，4，3，6，2，1【1最远使用，所以淘汰1】，3，4，1\n\nFIFO先进先出置换算法:淘汰最先进来的页。\n\n> 2【最先进来，最先淘汰2】，3，1，2，**4【引起缺页，要换123之中的一个】**，3，5 , 7，2，3，4，3，6，2，1，3，4，1\n\nLRU最近最久未使用置换算法:最近最久未使用的页。\n\n> 2，3【因为2更新，所以3为最久未使用，所以淘汰3】，1，2【2更新】，**4【引起缺页，要换123之中的一个】**，3，5 , 7，2，3，4，3，6，2，1，3，4，1\n\n![cd13e146c1f7e382c94c497a1f936950](https://cdn.davidingplus.cn/images/2025/02/01/cd13e146c1f7e382c94c497a1f936950.png)\n\n# 第五章 设备管理\n\n## 设备管理的目标\n\n**总体目标是高效性和通用性**，也就是为了使用方便、与设备无关、效率高、管理统一。\n\n## I/O设备\n\n**I/O系统：用于实现数据输入、输出及数据存储的系统**\n\n### I/O系统层次\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230617172623421.png\" alt=\"image-20230617172623421\" style=\"zoom:80%;\" />\n\n#### 分类\n\n- 存储设备(磁带，磁盘，光盘等)或输入输出设备(键盘、鼠标、扫描仪、视频摄像、传感器等)\n- 块设备或字符设备\n- 低速中速高速设备\n\n#### 设备控制器\n\n功能：**接受CPU命令，控制I/O设备工作，解放CPU**\n\n可分为控制块设备的控制器和控制字符设备的控制器\n\n## I/O控制方式(逐级向上提高优化CPU利用率)\n\n### ①程序直接控制方式(程序查询或者轮询方式)\n\nCPU需不惜花代价查询I/O状态\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230612170439639.png\" alt=\"image-20230612170439639\" style=\"zoom:80%;\" />\n\n这种方式也可以称为查询方式，cpu不断地去查询设备控制器是否将数据放到了数据存储器中，或者从数据存储器存到设备中，当完成IO时cpu才能去干别的事。CPU浪费资源的情况非常大\n\n### ②中断方式\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230612170544610.png\" alt=\"image-20230612170544610\" style=\"zoom:80%;\" />\n\n这种方式当cpu发出指令后就可以去干别的事，当设备控制器把数据存在数据存储器后，向cpu发出中断请求，然后cpu再来处理这部分数据。**但是即使如此，还是一个一个字或者字节传输，效率太低了**\n\n### ③DMA方式\n\n![image-20230612170653993](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612170653993.png)\n\n虽然中断方式提高了cpu的利用率，但是数据寄存器有限，**中断是以字节单位进行中断**，也就是说读取或存储一个字节后就需要进行中断，那么其实cpu的利用率还是很低的，**所以就诞生了DMA方式，这种方式由DMA控制器直接将设备中的数据以数据块为单位直接传输到内存中，当传输结束后才向cpu发起中断。**\n\n### ④IO通道控制方式\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230612170739575.png\" alt=\"image-20230612170739575\" style=\"zoom:80%;\" />\n\nDMA虽然大大地提升了cpu的利用率，**但是DMA只能传输一个连续的数据块**。所以引入了IO通道的控制方式，**IO通道控制方式可以传输不连续的数据块**，减少了cpu干预。**cpu通过对IO通道发出指令，然后让IO通道自己工作，等数据传输完才向cpu发起中断。**\n\n## 与设备无关的I/O软件\n\n- 应用程序独立于具体使用的物理设备。\n- **为了实现设备独立性而引入了逻辑设备和物理设备这两个概念**。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统在实际执行时，还必须使用物理设备名称。\n- 因此，系统须具有将逻辑设备名称转换为某物理设备名称的功能\n\n设备独立性软件的功能\n\n![image-20230612171254228](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612171254228.png)\n\n**设备的固有属性：独占性；(临界资源)共享性；可虚拟性；所以因此也有三种属性的设备：独占设备，共享设备和虚拟设备**\n\n\n\n## 引入缓冲的目的和缓冲区的设置方式\n\n![image-20230618194849339](https://cdn.davidingplus.cn/images/2025/02/01/image-20230618194849339.png)\n\n### 什么是缓冲区？有什么作用？\n\n- **缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。**\n- **使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）**\n- **一般情况下，更多的是利用内存作为缓冲区，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区**\n\n### 1. 引入缓冲区的目的\n\n-  **缓和CPU与外设间速度不匹配的矛盾**\n-  **提高CPU与外设之间的并行性**\n-  **减少对CPU的中断次数**\n-  **缓和CPU和外设之间数据粒度不匹配的矛盾**\n\n### 2. 缓冲区的设置方式\n\n\\1) 单缓冲：**当数据到达率与离去率相差很大时**，可采用单缓冲方式。\n\n![image-20230618194319508](https://cdn.davidingplus.cn/images/2025/02/01/image-20230618194319508.png)\n\n![image-20230612171905141](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612171905141.png)\n\n\\2) 双缓冲：**当信息输入和输出率相同（或相差 不大）**时，可利用双缓冲区，实现两者的并行。【**非空不能放东西，非满不能取东西**】\n\n![image-20230618194620971](https://cdn.davidingplus.cn/images/2025/02/01/image-20230618194620971.png)\n\n![image-20230612172033944](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612172033944.png)\n\n\\3) 多缓冲：**对于阵发性的输入、输出，为了解决速度不匹配问题，可以设立多个缓冲区。**\n\n> 循环缓冲区：分为三个队列：空缓冲队列，输入队列：装满输入数据的缓冲队列，输出队列：装满输出数据的缓冲队列\n>\n> ![image-20230612172143980](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612172143980.png)\n>\n> 四个缓冲区：收容输入数据的工作缓冲区，提取输入数据的工作缓冲区，收容输出数据的工作缓冲区，提取输出数据的工作缓冲区\n\n## 常用设备分配技术\n\n### 1. 根据设备的使用性质\n\n\\1) 独占设备：\n\n不能共享的设备，即：在一段时间内，该设备只允许一个进程独占。如打印机。\n\n\\2) 共享设备：\n\n可由若干个进程同时共享的设备。如磁盘机。\n\n\\3) 虚拟设备：\n\n是利用某种技术**把独占设备改造成可由多个进程共享的设备**。\n\n### 2. 针对三种设备采用三种分配技术\n\n\\1) 独占分配技术：\n\n是把独占设备固定地分配给一个进程，直至该进程完成I/O操作并释放它为止。\n\n\\2) 共享分配技术：\n\n通常适用于高速、大容量的直接存取存储设备。由多个进程共享一台设备，每个进程只用其中的一部分。\n\n\\3) 虚拟分配技术：\n\n利用共享设备去模拟独占设备，从而使独占设备成为可共享的、快速I/O的设备。**实现虚拟分配的最有名的技术是SPOOLing技术，也称作假脱机操作。***(虚拟化技术到处都是欺骗)\n\n【分配技术应该考虑：固有性质、分配算法、安全性、独立性【应用程序独立于具体使用的物理设备】\n\n## 虚拟设备\n\n![image-20230618195437491](https://cdn.davidingplus.cn/images/2025/02/01/image-20230618195437491.png)\n\n![image-20230618195653340](https://cdn.davidingplus.cn/images/2025/02/01/image-20230618195653340.png)\n\n![image-20230618195815412](https://cdn.davidingplus.cn/images/2025/02/01/image-20230618195815412.png)\n\n![image-20230618195822075](https://cdn.davidingplus.cn/images/2025/02/01/image-20230618195822075.png)\n\n## 什么是设备独立性？ 为什么要引入设备独立性？如何实现设备独立性\n\n**什么是设备独立性**\n**设备独立性是指操作系统把所有外部设备统一当作成文件来看待，只要安装它们的驱动程序，任何用户都可以象使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式。**\n\n**为什么要引入设备独立性**\n**引入设备独立性后可以调高设备的利用率和分配时的灵活性；提高系统的可适应性和可扩展性；可以方便用户操作，易于实现IO重定向**\n\n**如何实现设备独立性**\n**为了实现设备的独立性，应引入逻辑设备和物理设备两个概念。在应用程序中，使用逻辑设备名称来请求使用某类设备；而系统执行时，是使用物理设备名称。鉴于驱动程序是一个与硬件（或设备）紧密相关的软件，必须在驱动程序上设置一层软件，称为设备独立性软件，以执行所有设备的公有操作、完成逻辑设备名到物理设备名的转换（为此应设置一张逻辑设备表）并向用户层（或文件层）软件提供统一接口，从而实现设备的独立性**\n\n## 磁盘管理\n\n### 磁盘地址结构\n\n柱面号、盘面号、扇面号\n\n### 磁盘访问的时间(大题)\n\n通常磁盘数据访问时间计算分为三个部分（实际上是四个，但是启动时间不加说明时忽略不计）：\n\n- **寻道时间，也称寻找时间：磁头移动到指定磁道需要的时间**，寻道时间题目一般会给\n- **延迟时间：磁头定位到某一磁道的扇区所需要的时间**\n- **传输时间：从磁盘读出或者写入经历的时间**\n\n![image-20230617173146579](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617173146579.png)\n\n![image-20230617173203297](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617173203297.png)\n\n![image-20230617172747211](https://cdn.davidingplus.cn/images/2025/02/01/image-20230617172747211.png)\n\n### 磁盘调度算法（必考大题）\n\n- 先到先服务算法（FCFS）\n- 最短查找时间优先算法（SSTF）\n- **扫描算法和LOOK算法（SCAN）**：类似电梯\n\n​       当设备无访问请求时，磁头不动；当有访问请求时，**磁头按一个方向移动**，在移动过程中对遇到的访问请求进行服务，**然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复**\n\n- **循环扫描算法和循环LOOK算法**：单项循环电梯\n\n​       **总是向一个方向移动，例如自里向外移动。移动臂到达最后个一个柱面后，立即带动读写磁头快速返回到最里的欲访问磁道。返回时不为任何的等待访问者服务。返回后可再次进行扫描**\n\n## 例题\n\n题11.假设系统中磁头当前的位置在110号磁道上，\n\n设有若干个进程先后提出磁盘I/O请求序列为65，68，49，28，100，170，160，48和194。\n\n(1)按FCFS算法进行调度的平均寻道距离;\n\n解:(1)平均寻道距离55.3条磁道\n\n110->65->68->49->28->100->170->160->48->194\n\n![8242a708d9f0802c242c68160109515c](https://cdn.davidingplus.cn/images/2025/02/01/8242a708d9f0802c242c68160109515c.png)\n\n (2)按SSTF算法进行调度的平均寻道距离;\n\n 110->100->68->65->49->48->28->160->170->194\n\n (3)按SCAN算法进行调度的平均寻道距离;【题目没给最外侧磁道数目，则扫描到题目给出的最大数目194，若给了例如200，则要扫描到200】\n\n110->160->170->194->100->68->65->49->48->28\n\n (4)按循环SCAN算法进行调度的平均寻道距离;    \n\n110->160->170->194->28->48->49->65->68->100\n\n# 第六章 文件系统\n\n## 文件、文件系统\n\n### 概念\n\n文件是以计算机**硬盘**为载体的存储在计算机上的信息集合\n\n文件系统：就是操作系统中负责操纵和管理文件的一整套设施，它实现文件的共享和保护，方便用户**按名存取（\\**基本目标\\**），提高文件的存取速度（\\**最重要目标\\**）**。\n\n### 功能\n\n文件管理、目录管理、文件空间管理、文件共享和保护、提供方便的接口。\n\n**从逻辑组织的角度看，文件由若干记录构成**\n\n**从物理组织的角度看，文件由若干数据块组成**\n\n## 文件的逻辑结构\n\n![image-20230612145242736](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612145242736.png)\n\n### 无结构文件（即流式文件）\n\n> 例如文本框中打字\n\n### 有结构文件（记录式文件）\n\n- 顺序文件\n\n> **磁带**上的文件一定是顺序文件\n\n- 索引文件\n- 索引顺序文件\n- 哈希文件\n\n## 目录和目录结构\n\n### 文件控制块FCB\n\n![image-20230612155332828](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612155332828.png)\n\n**在文件系统内部给每个文件唯一地设置一个文件控制块，它用于描述和控制文件的数据结构，与文件一一对应**\n\n> 类似进程的PCB\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230612155613892.png\" alt=\"image-20230612155613892\" style=\"zoom:80%;\" />\n\n### 目录结构\n\n- 单级目录（不允许重名）：**整个系统中只建立这一张目录表，为每个文件分配一个目录项**\n- 二级目录（解决了重名问题）：**主文件目录MFD和用户文件目录UFD**\n\n![image-20230612155950643](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612155950643.png)\n\n**在不同的 UFD 中，可以使用相同的文件名**\n\n**不同用户可以使用不同的文件名访问系统中的同一个共享文件**\n\n- 树形目录（优点：方便，缺点：**不方便共享**）：绝对路径（从根目录出发）和相对路径（从当前目录出发）\n\n三级或者三级以上的称作树形目录\n\n![image-20230612160225737](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612160225737.png)\n\n- 图形目录（实现了共享）\n\n多层目录的优缺点\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230612160425102.png\" alt=\"image-20230612160425102\" style=\"zoom: 80%;\" />\n\n### 目录查询技术\n\n线性查询和哈希查询\n\n![image-20230612160815873](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612160815873.png)\n\n## 文件实现\n\n### 文件分配方式\n\n**在一个系统中仅采用一种方法来为文件分配外存空间**；在采用不同的分配方式的时候，将形成不同的文件物理结构\n\n1.连续分配（**有外部碎片**）：为每一个文件分配一组相邻接的盘块\n\n2.链接分配（**解决了外部碎片，但是不支持直接访问，数据易丢失**）：可以将文件装到多个离散的盘块中采用链接分配方式时，可通过在每个盘块上的链接指针，将同属于一个文件的多个离散的盘块链接成一个链表，把这样形成的物理文件称为链接文件\n\n3.索引分配（**加入 文件分配表FAT 可直接访问，减少了访问磁盘的次数**）：不支持高效的直接存取，**FAT需要占用较大的内存空间**\n\nFAT表例题：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230617201045462.png\" alt=\"image-20230617201045462\" style=\"zoom:67%;\" />\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230617201056810.png\" alt=\"image-20230617201056810\" style=\"zoom:67%;\" />\n\n单级索引分配\n\n![image-20230612153228543](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612153228543.png)\n\n两级索引分配\n\n![image-20230612153516809](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612153516809.png)\n\n混合索引分配\n\n![image-20230612153600495](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612153600495.png)\n\n4.成组链接：**成组链接法是结合了空闲表和空闲[链表](https://so.csdn.net/so/search?q=链表&spm=1001.2101.3001.7020)法的，UNIX系统采用的就是成组链接法。成组链接法中保存的是当前可用的存储盘块的地址。**\n\n### 文件存储空间管理（大题）\n\n**1）空闲表法（连续分配方式）**\n\n![image-20230612151507544](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612151507544.png)\n\n**2）空闲链表法**\n\n分为空闲盘块和空闲盘区\n\n**注意盘区在盘块的基础上是几个连续的空白盘块合并在一起**\n\n![image-20230612151904858](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612151904858.png)\n\n![image-20230612152036134](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612152036134.png)\n\n**3）位示图法**\n\n![image-20230612152256573](https://cdn.davidingplus.cn/images/2025/02/01/image-20230612152256573.png)\n\n**盘块号 = 字号 * n(代表字长) + 位号；里面1代表已分配，0代表未分配**\n\n主要能根据题目给的图推导出盘块号，字号，位号和字长的关系，因为有时候不一定位号是从0开始的\n\n**4）成组链接法**\n\n![image-20230614202621941](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614202621941.png)\n\n图中的例子：空间1-4存储的是可用的一个盘块的地址，然后这些盘块就是单级索引，指向的位置就是存储位置；空间0的盘块1地址指向的是盘块1，但是盘块1页是存储索引的，这就是二级索引，如果再往下走就是更高级的索引了\n\n![image-20230614202913155](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614202913155.png)\n\n现在有5个数据要存储，前四个很容易可以找到单级索引进行存储，每存储一个就需要把free盘块进行修改，空间置空和空闲盘块进行修改\n\n**存到第五个的时候由于1号盘块往下走还有高级索引，所以不能直接存储**\n\n![image-20230614203108830](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614203108830.png)\n\n![image-20230614203116631](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614203116631.png)\n\n**这时候需要把盘块1指向的内容填进盘块0中，就是现在这样，然后再继续按照刚才的样子分配就可以了**\n\n至于回收\n\n![image-20230614203502205](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614203502205.png)\n\n**系统释放data_5数据段，释放盘块1，将盘块1放到可用表中，但是这时候盘块0满了，怎么办呢？**\n\n**把盘块0现在的内容复制到盘块1中，然后把盘块1写入空白的盘块0中**\n\n![image-20230614203612272](https://cdn.davidingplus.cn/images/2025/02/01/image-20230614203612272.png)\n\n![image-20230619151816335](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619151816335.png)\n\n# 补充：shell编程\n\n## echo命令\n\n```sh\necho \"helloworld\" //在屏幕上输出 helloworld\n```\n\n## shell注释\n\n单行注释以 # 开头\n\n```sh\n# 这是一个注释\n# author：ohuohuoo\n# date：`date`\n```\n\n## 变量定义\n\nshell编程中，定义变量是直接定义的，没有明确的数据类型，shell允许用户建立变量存储数据，**但是认为赋给变量的值都解释为一串字符**\n\n```sh\ncout=1\t\t\t# 定义变量\t\t\nname=\"ohuohuo\"\t # 定义变量\necho $cout\t\t # 取变量值\necho $name\t     # 取变量值\n```\n\n**shell中，英文符号`\"$\"`用于取变量值!!**\n\n注意：\n\n<img src=\"https://cdn.davidingplus.cn/images/2025/02/01/image-20230614215645853.png\" alt=\"image-20230614215645853\" style=\"zoom:80%;\" />\n\n如果在变量中使用系统命令，**需要加上 \" `\"符号（ESC键下方）**，如下所示\n\n```sh\nDATE1=`date`\t\nDATE2=$(date)\n```\n\n## 使用变量\n\n使用变量的时，**用英文符号`\"$\"`取变量值，对于较长的变量名，建议加上`{ }`花括号，帮助解释器识别变量的边界**，如下\n\n```sh\nname=\"test_name\"\necho \"My name is ${name}and you\"\n```\n\n## 变量操作\n\nshell中的变量，默认为可读可写类型，如果想要其只可读，如同url一样，需要将其声明为**只读类型变量（**如同`const`），使用`readonly`命令，如下脚本\n\n```sh\nUrl=\"http://www.baidu.com\"\nreadonly Url\nUrl=\"http://www.csnd.net\"\n```\n\n如果想要**删除变量**，使用`unset`命令解除命令赋值，但是`unset`**不能删除可读变量**，如下所示\n\n```sh\nname=\"ohuohuo\"\nUrl=\"http://www.baidu.com\"\nreadonly Url\t# 设置可读变量\nunset name\t\t# 可以被删除\nunset Url\t\t# 不可被删除\necho $name\t\t# 不被打印出\necho $Url\t\t# 打印出\n```\n\n## Shell字符串\n\n**最好使用双引号**\n\n**shell规定单引号禁止变量替换, 元字符$和*等保持其符号本身; 而双引号允许元字符变量替换.**\n\n![image-20230619154559544](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619154559544.png)\n\n**反撇号中的字符串代表命令名**\n\n![image-20230619154726280](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619154726280.png)\n\n```\nname=\"ohouhuoo\"\nstr=\"please input your \\\"$name\"\\\"\necho -e $str\n```\n\n**花括号将变量名和后面的字符串区分开**\n\n![image-20230619155136048](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619155136048.png)\n\n## 字符串操作\n\n**获取字符串长度**：在对变量进行取值时，使用**\" # \"**符号对字符串进行取值\n\n```sh\nstring=\"abcd\"\necho ${#string} # 输出 4\n```\n\n**提取子字符串**：使用字符串的截取命令，用于提取部分字符串\n\n```sh\nstring=\"this is a test\"\necho ${string:2:6} # 表示从下标为2开始截取，到下标为6截止，两端包含!!!\n```\n\n**查找字符串**：用于查找字符的位置，输出结果为字符在字符串中所占的数据位置，如果查找多个字符，那哪个字母先出现就计算哪个，如下查找`it`中`i`和`t`两个字符，`t`先出现，输出为1\n\n```sh\nstring=\"this is a test\"\necho `expr index \"$string\" it`  # 输出 1\n```\n\n## Shell数组\n\nshell数组只支持**一维数组**!!!\n\n### 定义数组\n\n在 Shell 中，用括号`()`来定义表示数组，数组中元素**用\"空格\"符号分割开**。定义数组的一般形式为：\n\n```bash\n# 一般定义\narray_name=(value1 value2 value3 value4)\n\n# 多级定义\narray_test=(\nvalue1 \nvalue2 \nvalue3 \nvalue4\n)\n\n# \narray_text[0]=value0\narray_text[1]=value1\narray_text[3]=value3\n... \n...\n```\n\n### 读取数组\n\n和读取变量名相同，使用`$`符号，需要加上下标名\n\n```bash\nvaluen=${array_name[n]}\necho ${array_name[@]} # 读取所有\n```\n\n### 获取数组长度\n\n**这里获得长度注意对于数字而言，在shell中认为是一个字符串!!!**\n\n```bash\n# 取得数组元素的个数\nlength=${#array_name[@]}\t# 从头到尾取\n# 或者\nlength=${#array_name[*]}\t# 取所有\n# 取得数组单个元素的长度\nlengthn=${#array_name[n]}\t# 取特定\n```\n\n## Shell参数传递\n\n```sh\necho \"传递参数实例！\";\necho \"执行的文件名：$0\";\necho \"第一个参数为：$1\";\necho \"第二个参数为：$2\";\necho \"第三个参数为：$3\";\n```\n\n可以这么执行，注意可能需要赋予权限\n\n```bash\nchmod +x test.sh\n./test.sh 1 2 3\n```\n\n![image-20230615101419436](https://cdn.davidingplus.cn/images/2025/02/01/image-20230615101419436.png)\n\n举例如下：\n\n```sh\necho \"传递参数实例！\";\necho \"第一个参数为：$1\";\n\necho \"参数个数为：$#\";\necho \"传递的参数作为一个字符串显示：$*\";\n```\n\n## Shell运算符\n\n与其他编程语言相同的是，shell同样支持多种运算符：\n\n- 算数运算符\n- 关系运算符\n- 布尔运算符\n- 逻辑运算符\n- 字符串运算符\n- 文件测试运算符\n\nshell想要使用这些运算符，需要结合其他命令和工具来使用（因为shell中不支持简单的数学运算），如使用算符运算符就需要搭配的常用的工具有两种\n\n- awk\n- **expr（使用频繁）**\n\n**运算规则注意点**：\n\n- **表达式和运算符之间必须要有空格**，例如 3+2 是不对的，必须写成 3 + 2\n- **完整的表达式要被 两个\" ` \"包含**（**在 Esc 键下边那个键**）\n\n### 算数运算符\n\n![image-20230615102246921](https://cdn.davidingplus.cn/images/2025/02/01/image-20230615102246921.png)\n\n```bash\na=10\nb=20\n\nsum=`expr $a + $b`\necho \"两数之和为：$sum\"\n\nmul=`expr $a \\* $b`\necho \"两数之和为：$mul\"\n```\n\n注意：\n\n**在windows系统中乘号(*)前边必须加反斜杠( \\ )才能实现乘法运算；**\n\n### 关系运算符\n\n![image-20230615105751669](https://cdn.davidingplus.cn/images/2025/02/01/image-20230615105751669.png)\n\n```bash\na=10\nb=20\n\nif [ $a -eq $b ]\nthen\n   echo \"$a -eq $b : a 等于 b\"\nelse\n   echo \"$a -eq $b: a 不等于 b\"\nfi\nif [ $a -ne $b ]\nthen\n   echo \"$a -ne $b: a 不等于 b\"\nelse\n   echo \"$a -ne $b : a 等于 b\"\nfi \n```\n\n注意：**运算符和数之间必须要用空格隔开**\n\n### bool运算符\n\n![image-20230615105957759](https://cdn.davidingplus.cn/images/2025/02/01/image-20230615105957759.png)\n\n```sh\na=10\nb=20\n\nif [ $a != $b ]\nthen\n   echo \"$a != $b : a 不等于 b\"\nelse\n   echo \"$a == $b: a 等于 b\"\nfi \n```\n\n### 逻辑运算符\n\n![image-20230615110259573](https://cdn.davidingplus.cn/images/2025/02/01/image-20230615110259573.png)\n\n```bash\na=10\nb=20\n\nif [[ $a -lt 100 && $b -gt 100 ]]\nthen\n   echo \"返回 true\"\nelse\n   echo \"返回 false\"\nfi \n```\n\n### 字符串运算符\n\n![image-20230615110640052](https://cdn.davidingplus.cn/images/2025/02/01/image-20230615110640052.png)\n\n```bash\na=\"abc\"\nb=\"efg\"\n\nif [ $a != $b ]\nthen\n   echo \"$a != $b : a 等于 b\"\nelse\n   echo \"$a != $b: a 不等于 b\"\nfi \n```\n\n### 文件测试运算符\n\n![image-20230615111051580](https://cdn.davidingplus.cn/images/2025/02/01/image-20230615111051580.png)\n\n```bash\nfile=\"operator.sh\"\nif [ -r $file ]\nthen\n   echo \"文件可读\"\nelse\n   echo \"文件不可读\"\nfi\n```\n\n## shell编程中的命令\n\n### echo命令\n\necho命令在shell中用于字符串的输出，调用的格式：\n\n```bash\necho string\n```\n\necho命令还可显示复杂的输出格式\n\n- 显示普通的字符串\n\n```bash\necho \"helloworld\"\n```\n\n- 显示转义字符\n\n```bash\necho \"\\this is a test\\\"\n```\n\n- 显示变量\n\n```bash\nname=\"ohuohuo\"\necho \"you name is $name\"\n```\n\n- 显示换行\n\n```bash\necho -e \"Right!\\n \" # -e 表示开启转义\necho \"this is other line\"\n```\n\n- 显示command命令结果\n\n```bash\necho `date`\n```\n\n### cat命令\n\n![image-20230619153542524](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619153542524.png)\n\n### read命令\n\n![image-20230619155424293](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619155424293.png)\n\n### expr命令\n\n![image-20230619160626507](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619160626507.png)\n\n## 系统变量\n\n![image-20230619154232055](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619154232055.png)\n\n## 条件语句\n\n![image-20230619160752779](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619160752779.png)\n\n## 测试语句\n\n![image-20230619161752668](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619161752668.png)\n\n![image-20230619162129424](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619162129424.png)\n\n### 循环语句\n\n![image-20230619162739135](https://cdn.davidingplus.cn/images/2025/02/01/image-20230619162739135.png)\n\n","categories":["校内课程","操作系统"]},{"title":"计算机组成原理 汇编部分","url":"/posts/9ef2b034.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n帮助快速上手汇编语言编程，虽然只限于编程。。。\n\n# VScode配置调试环境\n\n1. 安装插件TASM/MASM\n2. 右键扩展设置，选择Assembler：MASM\n3. 右键调试即可开始调试了！\n\n# Debug.exe\n\n> R命令：查看、改变CPU寄存器的内容 \n> D命令：查看内存中的内容\n> T命令：执行一条机器指令\n> G命令：从停顿的地方运行到底\n\n<!-- more -->\n\n# 第一段代码：Hello World\n\n```assembly\nDSEG SEGMENT\n        MESS DB 'Hello, World!',0DH,0AH,24H\nDSEG ENDS\n\nSSEG SEGMENT PARA STACK\n             DW 256 DUP(?)\nSSEG ENDS\n\nCSEG SEGMENT\n              ASSUME CS:CSEG, DS:DSEG\n        BEGIN:MOV    AX,DSEG\n              MOV    DS,AX\n              MOV    DX,OFFSET MESS\n              \n              MOV    AH,9\n              INT    21H\n              \n              MOV    AH,4CH\n              INT    21H\nCSEG ENDS\nEND BEGIN\n```\n\n# 基础指令\n\n用以下指令可以写一个基础的程序：\n\n1. 段定义+Assume\n\n```assembly\nXXX SEGMENT(XXX:DATA/STACK/CODE)\nXXX ENDS\n```\n\n```assembly\nASSUME CS:CSEG, DS:DSEG, SS:SSEG\nMOV AX,DSEG\nMOV DS,AX\nMOV AX,SSEG\nMOV SS,AX\n```\n\n2. 数据定义\n\n```assembly\n(ORG 1000)\n(NAME) DB ?/...\n(NAME) DB N DUP(?/...)\ndb:12H/dw:1234H\n```\n\n3. MOV\n\n```assembly\n MOV AX,Y\n MOV Y,AX\n MOV AX,BX\n```\n\n\n4. +-\n\n```assembly\nADD AX,X;AX+=X\nSUB AX,X;\nINC AX;AX++\nDEC AX;AX--\n\nNEG AX ;取负\n```\n\n\n\n5. 程序的终止\n\n```assembly\nMOV AH,4CH\nINT 21H\n```\n\n稍后会讲的进阶指令：\n\n1. Label和JUMP：跳转\n2. 分支和循环\n3. 堆栈的使用\n4. <函数>：PROC和MACRO\n5. INT 21H指令：输入/输出\n\n\n# 寄存器的使用\n\n在汇编语言中，我们不能对内存中的数据进行直接操作，如果要操作，需要把数据先`MOV`到寄存器中再进行处理。\n为了写代码的过程更顺滑，最好先简单了解一下这些寄存器的使用，当然，你也可以只了解通用寄存器的使用，别的等用到了再去查询。\n我会尽可能简单地表述。\n\n8086 CPU 中有14个16位寄存器 。16位的存储可以用16进制表示，BeLike：`123AH`（H表示16进制）在查看内存情况的时候，由于数据从高位到低位存储，BeLike：`3A 12`\n\n![image-20200512110737331](https://cdn.davidingplus.cn/images/2025/02/02/image-20200512110737331.jpeg)  \n\n## 通用寄存器：AX，BX，CX，DX\n\n\n```assembly\nDSEG ...\nX DB 12H\nY DB ?\n....\n\nCSEG...\n...\nMOV AH,X\nMOV Y,AH ;Y--12H\n```\n\n\n可以拆分为两个寄存器使用（AH和AL），不过各自有各自的独特作用，用到再提，这和它们的名字是关联的\n\n说到底为什么<通用>寄存器会有<独特的作用>？\n这是因为==一些内置的指令依靠**固定**的寄存器传递参数==，所以这些寄存器也有了独特的作用\n\n一般来说随便用就可以，反正里面的东西不久存，只是用来做==中转==\n\n### AX：Accumlator 累加器\n\n特殊功能和MUL/DIV有关，后面再说\n\n### BX：Base 基地址寄存器\n\n可以存储地址并访问\n说到地址，就得提一下汇编语言里地址的表示方法\n在汇编语言里，内存中的地址BeLike：`204B:1001` （以16进制表示）\n`204B`是**段地址**，`1001`是**偏移地址**，各需要一个Word进行存储\n有两个指令对应的获取内存单元的这两种地址\n\t`SEG`可以获取**段地址**（这个段就是指我们程序对应的段Segment），`OFFSET`可以获取**偏移地址**\n\t使用这两个词只需要在MOV时加在变量前即可，比如`MOV BX offset X`\n在“通过地址找内容”这件事方面，一般用BX存储偏移地址\n比如：\n\n```assembly\n\tX DW 1234H\n\tY DW ?\n\t...\n\tMOV BX, OFFSET X;BX中存储了X的偏移地址\n\tMOV Y, [BX];BX存储的偏移地址对应的内容被存放到y\n```\n\n一般来说，`[BX]`就是指 `DS:[BX]`，默认段地址为数据段，当然你也可以指定为CS和SS\n\n### CX：Count 计数器\n\n和循环指令`LOOP`有关\n\nLOOP指令类似于C语言中的For循环，`loop NAME`近似于`for(cx;;cx--)`\n关于LOOP的用法，具体到程序结构再说好了~。\n\n### DX：Data 数据寄存器\n\n特殊功能和MUL/DIV有关，后面再说\n也有与输入输出的暂存有关的功能（9.10号指令）\n\n## 指针变址寄存器：SP，BP，SI，DI\n\n都倾向于用来存地址\n\n### SP：Stack Pointer\n\n和堆栈段的使用有关，定义堆栈段要记得手动把SP放在栈顶\n\n### BP：Base Pointer\n\n和BX有类似的用法，只是一般更倾向于用在堆栈的数据里，`[BP]`默认为`SS:[BP]`\n\n### SI：Source Index\n\n### DI：Destination Index\n\n和BX有类似的用法，`[SI]`默认为`DS:[SI]`\n\n如果要转移数据，倾向于用SI存原地址，DI存新地址\n\n## 段寄存器：CS，DS，SS，ES，IP\n\n段的存在方便我们以==段地址+偏移地址==的方式定位内存单元\n刚刚在例子中看到，一般的程序我们定义三个段，Data、Stack和Code，它们的作用和名字是一致的\n\n这些寄存器都和程序段还有程序的运行有关。\n在程序启动的时候，操作系统会把IP（Instruction Pointer）指向程序的第一句开始运行，之后IP会一直指向每次要运行的下一条指令（显然我们可以用IP玩一些花活，但是对于简单的程序，我们没有必要操作IP）\n\n在代码段的开始，我们就用Assume语句声明CS、DS、SS的地址\n和CS不同，DS和SS寄存器的值需要我们手动指定，而与SS寄存器绑定的SP指针也需要我们手动设置（SS:SP指向的就是栈顶元素）\n\nES是Extra Segment，程序有附加段落的时候才用，用法和DS SS差不多\n\n## 标志寄存器 FLAG\n\n只是写代码的话不用管它\n16位分开使用，有各自不同的意思，结果会以下面的形式呈现在-R中\n\n![2bde529eba4348d213144f7fd4d4743c](https://cdn.davidingplus.cn/images/2025/02/02/2bde529eba4348d213144f7fd4d4743c.png)\n\n\n\n\n# 阶段练习\n\n有以上的知识已经能写很多代码。\n\n## 练习a: x+y\n\n> 1. 在数据段（data segment）中定义3个word，其中x=1234H，y=2345H, z=?\n> 2. 将x+y的结果保存在z中\n\n\n\n\n# 进阶指令\n\n这里开始会有一点复杂，建议一边写一边看\n\n## 1. Label和Jump：跳转\n\n一段代码可以拥有label，Jump NAME 即可跳转至label位置\n比如\n\n```assembly\nMAIN：MOV X,AX\nJUMP DONE\nMOV AX,Y\n...\nDONE:\n\tMOV AH, 4CH\n\tINT 21\n```\n\n在这段程序中，`MOV AX,Y`就会直接被跳过\n\n## 2. 分支和循环\n\n### 分支 CMP-JGE/...\n\nBeLike:(求abs(AX)保存在AX中)\n\n```assembly\nMAIN:\n...\nCMP AX,0\nJGE DONE; Jump if Greater or Equal\nNEG AX\nDONE:\n...\nEND MAIN\n```\n\n\n#### 练习b: 求最大值\n\n> 1. 在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?\n> 2. 求max(x,y,z)储存于w\n\n\n### 循环  LOOP\n\n一种简单的循环，类似于`for(cx;;cx--)`。（事实上，你可以用JUMP和分支结构来实现循环）\n\nLOOP NM过程中：\n\t0. CMP CX,0\n\t1. 如果CX>0，继续执行以下语句，否则跳出\n\t2. DEC CX(CX>0)\n\t3. JUMP NM\n\n```\nMOV CX,6\nNM: ...\nLOOP NM;这样写一共执行CX次（声明NM时执行1次，LOOP中执行CX-1次）\n```\n\n#### 练习c: 数组初始化\n\n> 在数据段（data segment）中分配100字节，并为每个字节依次赋值0-99。\n\n## 3. 堆栈的使用\n\n### 初始化\n\n两个好用的方法\n\n#### 比较直观的（堆栈段中做定义）\n\n1. 在堆栈段划分位置，保存栈顶位置\n2. 在程序段开始的时候把堆栈段的位置告诉堆栈寄存器SS，把栈顶的位置告诉指针寄存器SP\n\n```assembly\nSSEG SEGMENT\n      STACK DW  128 dup(?)\n      TOP   DW LENGTH STACK ;划定范围\nSSEG ENDS\n\nCSEG SEGMENT\n           ASSUME CS:CSEG,DS:DSEG,SS:SSEG\n      MAIN:\n           MOV    AX,DSEG\n           MOV    DS,AX\n           MOV    AX,SSEG\n           MOV    SS,AX\n           MOV    AX,TOP\n           MOV    SP,AX                        ;栈顶地址载入\n```\n\n#### 稍微没那么直观的（程序段中划空间）\n\n直接给SP赋值\n\n```assembly\nSSEG SEGMENT\nSSEG ENDS\n;ss:0000-ss:1000\nCSEG SEGMENT\n            ASSUME CS:CSEG, DS:DSEG,SS:SSEG\n      BEGIN:MOV    AX,DSEG\n            MOV    DS,AX\n            MOV    AX,SSEG\n            MOV    SS,AX\n            MOV    SP,1000H                      ;手动规定了1000H的空置空间(OFFSET 0H-1000H)\n```\n\n\n### PUSH和POP\n\n注意：==只能操作寄存器==，不能直接操作内存单元\n`PUSH AX`：将AX的值入栈（如果AX两个字节，就会入栈两个字节，SP也相应-2）\n`POP AX`：出栈，内容保存在AX（如果AX两个字节，就会入栈两个字节，SP也相应+2）\n\n### 用SP和BP操作堆栈\n\n在主程序只是暂存数据用的话，一般==不用==操作指针\n但是，由于PROC需要使用到堆栈段，所以这是操作指针就是必要的，接下来在PROC中解释\n\n## 4. <函数>：PROC和MACRO\n\n### PROC&CALL（子程序结构）\n\n#### 定义 PROC-RET-ENDP\n\n(Near 属性是默认值)\n\n```assembly\nMAIN:\nCALL NM\n\nNM PROC\n...\nRET\nNM ENDP\n...\nEND MAIN\n```\n\n完整的表达式：\n调用：`CALL FAR/NEAR PTR NM`\n定义：`NM PROC FAR/NEAR`\n\n#### 子程序属性和调用\n\n##### 段内调用\n\n只需要Main（主Label调用）的话空置即可（默认Near）\n\n```assembly\nA:...\n\tCALL B;调用B\n\t\n\tPROC B:...;默认为near属性子程序\n\tRET\n\tB ENDP\n...\nEND A\n```\n\n\n##### 段间调用\n\n```assembly\nPROC A:CALL FAR PTR B\nRET\nENDP\n\nPROC B FAR:...;写明属性\nRET ENDP\n```\n\n\n#### 小心堆栈！\n\nPROC的本质是：入栈程序出口指针，RET时从回到出口指针的位置\n所以：\n\n1. 第一个出栈元素会是一个偏移地址\n2. 如果最后SP的指针位置不对，就无法正确RET\n\n简单的方法：==用寄存器BP保护SP==，使用BP进行数据的读取\n\n##### 例子a(1): x+y子程序化\n\n> ...\n>\n> 1. 在堆栈段push任意两个长度为1word的数据\n> 2. 使用子程序，将这两个数据的和存储于AX\n>    ...\n\n```assembly\nSUM PROC ;取两个栈顶元素求和储存到AX中\n         MOV    BP,SP\n         MOV    AX,[BP+2]\n         ADD    AX,[BP+4]\n         RET\nSUM ENDP\n```\n\n##### 练习b(1) 求最大值 子程序化\n\n> 1. 在数据段（data segment）中定义4个word，其中x=1234H，y=2345H, z=-1234H，w=?\n> 2. 在堆栈段push x,y,z\n> 3. 求max(x,y,z)储存于w\n\n### Macro（宏定义）\n\nPROC的使用有调用开销（程序的中断 跳转 继续），而MACRO没有\nMACRO相当于写代码的人把重复写代码的过程交给了汇编器，相比子程序来说，是通过多占程序的内存来提高运行速度（对机器来说，每调用一次Macro，就是把这段指令重复了一次）\n\n```assembly\nNM MACRO R1,R2...(参数)\n...\nEND M\n\nNM MACRO AX,BX...(寄存器取值)\n```\n\n\n## 5. INT 21H指令：输入/输出\n\n其实查书就可以了\n\n到这里汇编语言编程的<大局>已经描述完全\n\n关于一些语句的细节可以通过搜索引擎和汇编相关的任何书籍进行确认~\n\n### 键盘输入\n\n#### 1号指令：单个字符输入\n\n```assembly\nMOV AH,1\nINT 21H\n```\n\n(内容会保存在AL)\n\n#### 10号指令：从键盘输入字符串\n\n内存里需要划分三个部分：\n\t1.一个字节存放最大长度（你写，溢出会被裁掉）\n\t2.一个字节存放实际长度（指令运行完CPU会写）\n\t3.一些字节用来存字符串\n\n```assembly\nDATA SEGMENT\n    MAXLENGTH    DB 100           ;一个字节，用它存最大的长度\n    ACTUALLENGTH DB ?             ;一个字节，用它存实际的长度，在指令执行后会被填写\n    STRING       DB 100 DUP(?)    ;用来存字符串\nDATA ENDS\n\nSTACK SEGMENT\nSTACK ENDS\n\nCODE SEGMENT\n         ASSUME DS:DATA,SS:STACK,CS:CODE\n    MAIN:\n         MOV    AX,DATA\n         MOV    DS,AX\n         MOV    DX,OFFSET MAXLENGTH         ;把需要用到的内存块（三个部分）的地址存入DX\n\n         MOV    AH,10\n         INT    21H\n\n         MOV    AH,4CH\n         INT    21H\nCODE ENDS\nEND MAIN\n```\n\n### 显示器输出\n\n#### 2号调用：单个字符输出\n\n```assembly\nMOV DL,'A'\nMOV AH,2\nINT 21H\n```\n\n#### 9号调用：字符串输出\n\n你的字符串必须要以'\\$'结尾！不然输出不会结束！（类似于'\\\\0'，'\\$'是一种字符串的终止符）\n程序会将DS:DX地址开始输出字符到'\\$'结尾\n\n```assembly\nMOV DX,OFFSET STRING\nMOV AH,9\nINT 21H\n```\n\n## 综合练习\n\n### 练习d. 大小写转换+输入输出\n\n> （分支/循环/子程序+输入输出）\n> 用户输入一个单词，程序将所有大写转换为小写并输出到显示器\n> (注：'a'='A'+20H)\n\n","categories":["校内课程","计算机组成原理"]},{"title":"计算机组成原理 期末复习","url":"/posts/46678564.html","content":"\n<meta name=\"referrer\" content=\"no-referrer\"/>\n\n# 计组期末复习\n\n## 期末题型\n\n一、简述题（30分）6题*5分=30\n二、分析题（24分）\n三、设计题（28分）\n四、编程题（18分）\n\n## 常见问题\n\n* **什么是总线**？\n\n> 一组能为多个部件分时共享的公共的信息传送线c  \n\n* 总线周期\n\n> CPU完成一个访存或访问IO端口所需时间\n\n<!-- more -->\n\n* 硬件中断\n\n> 由某个硬件中断请求信号印发的中断\n\n* 比较CPU内总线和系统总线在互连对象、信号组成、时序控制等方面的不同之处\n\n>  CPU内总线：连接CPU内部的寄存器、运算部件，通常为单组信号线，采用同步控制\n>\n>  系统总线：连接计算机系统各个功能部件，包含数据、地址、控制三种信号，同步、异步、扩展同步控制\n\n*  试举两例说明同步控制方式在实际应用中的变化\n\n> 1. 总线周期允许插入延长周期\n> 2. 同步方式中引入异步应答\n\n* 在系统总线中，什么情况下适合使用同步控制方式？什么情况下适宜使用异步控制方式？\n\n> 总线上挂接的部件速度差异不大、传送距离近、传送时间确定的情况下适宜用同步控制方式。反之使用异步控制方式。\n\n---\n\n* 高速Cache用来存放什么内容？设置它的主要目的是？\n\n> 主要存放当前活跃的数据或程序\n>\n> 目的：CPU和主存的速度匹配\n\n* **什么是随机存储方式**？**什么是直接存储方式？什么是顺序存储方式？**\n\n> 随机：可根据地址访问任一存储空间，访问时间与地址无关\n>\n> 直接：读写部件先指向一块区域，在区域中顺序查找，访问时间与地址有关\n>\n> 顺序：顺序查找存储空间，访问时间与地址有关\n\n* 访问堆栈能否使用随机存取方式？为什么？\n\n> 每次只能访问栈顶单元，不能访问任一单元\n\n* 动态存储器存储信息的原理与静态有何不同？集中、分散、异步三种刷新方式如何安排周期？\n\n> 动态利用电容电荷存储信息，静态利用稳态触发器存储信息。\n>\n> 集中刷新：在2ms内集中安排所有刷新周期\n>\n> 分散刷新：各刷新周期分散在存储周期中\n>\n> 异步刷新：刷新周期分散安排在2ms内\n\n---\n\n* **单级/多级中断方式下的中断服务程序处理流程**\n\n> **单级中断**：保护现场、中断服务程序处理、恢复现场、开中断、返回\n>\n> **多级中断：**保护现场、开中断送新屏蔽字、中断服务程序处理、关中断、恢复现场和屏蔽字、开中断、返回\n\n* **描述从接口提出中断请求到转入中断服务程序的过程**\n\n> 接口提出中断请求、CPU响应批准请求、关中断、保存断点、保护现场、接口送出中断号，CPU将中断号转换为中断地址查向量表，取出中断服务程序入口地址，转入中断服务程序\n\n* **试比较中断处理和子程序调用的区别**\n\n> * 子程序的调用是事先人为设置好的，中断处理具有随机性\n> * 子程序执行受主程序控制，而中断服务程序与被中断程序无关\n> * 一段程序中最多调用一次子程序，而中断处理同时可能有多个中断请求\n\n*  **什么是中断方式？**\n\n> CPU暂停执行现行程序，转而执行中断服务程序以处理随机时间，并在执行完成后返回原程序继续执行。\n\n* 与转子比较，中断方式的主要特点是什么？试举两例说明\n\n> 中断方式调用程序是随机的。如键盘、打印机中断\n\n* 中断和DMA方式有何异同点？各应用于什么场合？\n\n> DMA方式仅占用系统总线，不用切换程序，因而不存在保存断点、和现场的保护也不用恢复。\n>\n> 中断适合中、低速外存，DMA适合高速外存\n\n* **在DMA方式的初始化阶段，CPU通过程序分别向DMA控制器和IO接口传送了哪些初始化信息？**为什么要给这些初始化信息？\n\n> * 给DMA控制器传输：数据传输方向、数据传输量、主存缓存首址\n> * 给IO接口传输：外设寻址信息\n>\n> 因为将初始化信息传给DMA控制器后，CPU不再干预，由DMA控制器控制传送。\n\n* DMA操作包含哪三个阶段？每个阶段分别完成哪些操作？\n\n> 初始化阶段：CPU用程序传送初始化信息\n>\n> 传送阶段：DMA控制器掌控总线权，控制传送\n>\n> 善后处理阶段：CPU执行中断操作作结束处理\n\n* **在程序执行过程中，CPU合适响应中断请求？合适响应DMA请求？**\n\n> 中断请求在一条指令执行完后响应。因为中断程序本质上是程序切换过程，不能影响程序的完整性\n>\n> DMA请求在一次总线周期之后响应。因为DMA不是程序切换，在一条数据传送后可响应\n\n---\n\n* **简述微程序控制方式的基本思想**\n\n> 答案看到两种\n>\n> * 一条微指令对应一步操作所需要的微命令；一段微程序对应若干微指令，解释执行一条机器指令；微程序存储在控制存储器中\n> * 将CPU工作流程对应的每个微操作命令系列编写称微程序，所有微程序存放在一个只读存储器-控制存储器中。控制器自动按照微程序的逻辑顺序，逐条取出微指令并执行，以实现CPU工作流程的控制。\n\n* **组合逻辑控制器和微程序控制器在产生微命令的方式上有什么不同**？\n\n> 组合逻辑控制器通过组合逻辑电路产生微命令\n>\n> 微程序控制器通过微程序控制产生微命令（考试可答得更详细）\n\n* **什么是组合逻辑控制方式？什么是微程序控制方式？有哪些优缺点**\n\n> 组合：通过综合化简产生微命令的条件，形成逻辑式，利用组合逻辑电路产生微命令。\n>\n> 优点：速度快 缺点：设计不规整，不易拓展程序\n>\n> 微程序控制方式：用微指令产生微命令的方式/设计CPU时，根据指令系统事先编制微程序，存入控制存储器（用程序设计思想产生微命令序列）\n>\n> 优点:设计规整，易拓展程序 缺点：速度慢\n\n\n\n## 第一章 概论\n\n一、基本概念\n\n1. 冯•诺依曼体制？存储程序方式？\n\n> **冯诺依曼体制**：\n>\n> 一、采用二进制来表示信息  二、采用存储程序的工作方式 三、计算机硬件系统由运算器、控制器、存储器、输入输出设备组成\n>\n> **存储程序方式：**\n>\n> 1. 编制程序\n> 2. 存储程序\n> 3. 自动、连续的执行程序\n\n2. 控制流？数据流？\n\n> 数据流——描述程序运行过程中数据的流转方式及其行为状态\n>\n> 控制流——控制程序逻辑执行的先后顺序，控制流实际上是数据流融入控制层之后形成的逻辑处理和程序跳转的结果。\n\n1. 模拟信号？数字信号？数字信号有哪两种？\n\n> **模拟信号：** **幅度**连续随着时间变化的信号\n>\n> **数字信号：**幅度不随时间变化，而是跳跃变化\n>\n> 包括，**电平信号、脉冲信号**\n\n4. 总线及其组成？\n\n> 地址总线、数据总线、控制总线\n\n5. 接口的概念？\n\n>*接口是指系统的(硬件或软件)组件和其他组件的交互点*\n\n6. 基本字长？\n\n> **机器字长（基本字长）：**参加一次**定点运算**的操作数的位数，通常与CPU寄存器或内部数据总线的位数有关。\n\n7. CPU主频？时钟频率？\n\n> 外部频率或基频，**也叫做系统时钟频率**\n>\n> CPU**主频** = 外频 * 倍频系数\n>\n> **CPU的主频**\n>\n> ​    **CPU主频是指CPU内核的工作频率，即CPU的时钟频率，计算机的操作在时钟信号的控制下分步执行，每个时钟信号周期完成一步操作，时钟频率的高低在很大程度上反映了CPU速度的快慢。**\n\n8. 数据通路宽度？数据传输率？\n\n> （1）数据通络宽度\n>     数据通路宽度是指数据总线一次能并行传输的数据位数，它会直接影响计算机的性能。一般分为CPU内部和CPU外部两种情况。CPU的内部数据通路宽度一般与CPU的基本字节长相同，也等于CPU内部总线的位宽；CPU外部数据通路宽度则等于系统数据总线的位宽。\n>\n> （2）数据传输率（data transfer rate，DTR）\n>     数据传输率也叫比特率，是指单位时间内信道的数据传输量，它基本单位是bps。\n\n1. 主存容量\n\n> 指可编制的存储单元个数（**取决于地址码位数**）×存储单元的位数（**表明编址单位**）\n\n## 第二章 计算机中的信息表示\n\n一、基本概念\n\n1. 一个数值型数据的完整表示需三个方面？\n\n> * 数的组合规则--进位计数制\n> * 小数点的位置确定 -- 数的定点表示和浮点表示\n>   * 符号的选择 --带符号数的代码表示\n\n2. 权、基数？\n\n> **基数：在任一数制中，某一数位上可选用的数码个数**\n>\n> **权：每一数位所表示位置的值**\n\n3. 真值？机器数的定义？分类？\n\n> 真值：数据真实的值\n>\n> *机器数是将符号数字化的数，是数字在计算机中的二进制表示形式*\n>\n> **分类：原码补码反码**\n\n4. 数的定点表示与浮点表示？\n\n> 定点表示：分为定点整数、定点小数、不定点整数\n>\n> 浮点表示：IEEE754的标准，数符（S），阶码（E），尾数（M）\n\n5. 指令？指令系统？\n\n> 指令：**按某种规律有序排列的、能被CPU识别并执行的二进制代码**\n>\n> 指令系统：**一台计算机能执行的所有指令的集合**\n\n6. 地址码？寻址方式？地址结构？\n\n> **地址码包括指令中给出操作数或操作数的地址、存放运算结果的地址、下一条指令的地址**\n>\n> **将产生操作数有效地址的方式称为寻址方式**\n>\n> > 操作数可能存在于何处？\n> >\n> > * 指令直接给出或紧跟指令在下一个存储单元\n> > * 寄存器中\n> > * 主存的存储单元中\n> > * 堆栈中，隐含约定由堆栈指针SP提供地址\n> > * IO接口寄存器中\n>\n> **地址结构：**\n>\n> * **显地址**：在指令代码中明确给出了主存储器单元地址码或者寄存器号\n> * **隐地址**：如果地址是以隐含的方式约定，则在指令中并不给出地址码\n\n7. 寻址方式：\n\n大致可将众多的寻址方式归纳为以下四大类，其它的寻址方式则是它们的变型或组合。\n\n① 立即寻址。在读取指令时也就从指令之中获得了操作数，即操作数包含在指令中。\n\n② 直接寻址类。直接给出主存地址或寄存器编号，从CPU内或主存单元内读取操作数。\n\n③ 间接寻址类。先从某寄存器中或主存中读取地址，再按这个地址访问主存以读取操作数。\n\n④ 变址类。指令给出的是形式地址（不是最终地址），经过某种变换（例如相加、相减、高低位地址拼接等），才获得有效地址，据此访问主存储器以读取操作数。\n\n8. 何谓隐式I/O指令？其主要特点是什么？\n\n> 采用统一编制，IO端口占用CPU提供的地址空间的一部分，比如CPU提供的全部地址空间的低地址部分用于主存单元、高地址部分分配给IO端口以示区分。\n>\n> 统一编制时，设备接口中的寄存器视为一个存储单元，采用通用的数据传送指令实现IO操作，又称为隐式IO\n>\n> **特点：地址码本身可区分存储单元地址和IO端口地址，无需其他操作，采用通用的数据传送指令即可**\n\n9.主机调用外围设备，外设编址可采用那几种方式？\n\n> 单独编址：为每个寄存器（IO端口）分配独立的端口地址，IO指令中给出端口地址，在处理器的指令集中，**需要有专门的IO指令来读写端口**\n>\n> 统一编址：IO端口占用CPU提供的地址空间的一部分，比如CPU提供的全部地址空间的低地址部分用于主存单元、高地址部分分配给IO端口以示区分。**地址码本身即可区分存储单元和IO端口**\n\n**二、计算题**\t\n\n1.扩展操作码：根据条件计算指令条数？\n\n> 留出扩展标记。见题目\n\n2.根据寻址方式寻找操作数？\n\n3.IEEE754短浮点数格式表示？\n\n> 一位S（0为正数1为负数） 8位E （E采用e+127的移码表示）M（32位，实际为1.M)\n\n \n\n## 第三章 中央处理器\n\n一、基本概念\n\n1. CPU内部各寄存器的功能？\n\n> * **通用寄存器组**：可编程访问的寄存器组，可以提供操作数、运算结果、地址指针、计数器等多种功能\n>   * 模型机中：R0、R1、R2、R3\n>   * 8086微机中：AX、BX、CX、DX、SP、BP、SI、DI\n> * **程序计数器**：PC：用来只是指令在存储器中的存放位置\n> * **程序状态字寄存器：PSW：**记录现行程序的运行状态和指示程序的工作方式\n> * **堆栈指针：SP：**设置一个具有加减计数功能的寄存器作为堆栈指针，命名为SP，SP中的内容就是栈顶单元地址\n> * **暂存器： C、D**不能被编程访问，只能CPU内部专用。目的是暂存某些中间过程产生的信息\n>   * 模型机中需要从主存中读取源操作数地址或源操作数时，就使用暂存器C；读取目的操作数地址或目的操作数时使用D\n> * **指令寄存器：IR：存放正在执行的指令**，它的输出包括操作码信息、地址码信息等，是产生微命令（控制信号）的主要逻辑依据。\n> * **地址寄存器：MAR**：存放被访问单元的地址\n> * **数据缓存寄存器：MDR：**存放**CPU与主存之间交换的数据。**无论是从主存读出的数据还是写入的数据都要经过MBR（MDR）\n\n2. 数据通路结构？\n\n> 1. 单组内总线、分立寄存器结构\n> 2. 单组内总线、集成寄存器结构\n> 3. 多组内总线结构\n>\n> * **CPU总线和数据通路结构：**ALU为内部数据传送通路的中心、寄存器采用分立结构、内总线采用单向数据总线，与系统总线的连接通过MAR、MDR实现\n\n3.何谓同步控制方式，何谓异步控制？有何主要特征？应用场合？\n\n> **同步控制：**同步控制方式就是指各项操作由统一的时序信号进行同步控制。意味着每个微操作必须在规定的时间内或固定时刻完成。\n>\n> * 特点：时钟周期时间固定；各步操作的衔接、各部件之间的数据传送受严格同步时钟定时控制。\n> * 应用场合：用于CPU内部，设备内部、系统内部。\n>\n> **异步控制：**各项操作按不同需求安排时间，不受统一时序控制。\n>\n> * 特点：无统一时钟周期划分，各个操作间的衔接和部件之间的信息交换采用应答的方式\n> * 应用场合：用于异步总线操作（各挂接部件速度差异大,传送时间不确定，传送距离远）。\n\n4.何谓主从设备，试举例说明。\n\n> 主设备：申请并掌握总线权的设备。\n> 从设备： 相应主设备请求的设备。\n> 操作流程:\n> 主设备获得总线控制权\n> 主设备询问从设备\n> 从设备准备好–接收否则再次询问。\n> 主设备发送/接收数据。\n> 主设备释放总线控制权\n> 优缺点：时间安排紧凑、合理；\n>\n> **DMA?**\n\n5.同步控制中如何引入异步应答的，试举例说明.\n\n> 扩展同步控制：即同步方式中引入了应答机制。\n>\n> **以固定时钟周期作为时序基础**，引入应答思想\n> 例如： 8088最大模式，用一根总线请求/应答线实现总线权的转移。\n\n7.判断下面叙述是否正确，说明理由：串行加法器中的进位链是串行进位链，并行加法器中的进位链只有并行进位链。\n\n> 错，并行加法器中的进位链可以并行串行结合\n\n12.1位全加器的结构及关系表达式。\n\n> C~i~ = (ab) 与 (a异或b)C~i-1~\n>\n> 三个输入量一个输出量\n\n13.并行加法器中的串行进位链结构：Cn = Gn + PnCn-1\n\n并行进位链结构：Cn = Gn + PnGn-1+ … + Pn…P1C0\n\n8.常用的加法器进位链结构有哪几种？\n\n> 串行进位、并行进位\n\n**8.影响加法器运算速度的主要因素：**\n\n> 全加器的速度、进位传递速度（主要）\n\n9.组合逻辑控制器、微程序控制器有何区别？\n\n> 控制器：控制部件的主要功能是负责对指令进行译码，并且发出为完成每条指令所要执行的各种操作的控制信号（微命令）\n>\n> 组合逻辑控制方式：**综合化简产生微命令的方式，形成逻辑式**，由组合逻辑电路产生微命令；\n>\n> * 优缺点：产生微命令的速度较快、设计不规整，设计效率低、不易修改、扩展指令系统功能。\n> * 应用场合：用于高速计算机，或小规模计算机\n>\n> 微程序控制方式 ：设计CPU时，根据指令系统事先编制好微程序，并存入控制存储器（CM\n\n10.组合逻辑控制器、微程序控制器的时序系统是如何划分的？\n\n> 组合逻辑控制器时序系统：采用三级时序系统：工作周期、时钟周期、工作脉冲\n>\n> * 工作周期：FT、ST、DT、ET、DMAT、IT\n> * 时钟周期（节拍）：以访存时间作为一步操作时间\n> * 工作脉冲：同步定时脉冲控制定时操作，每个时钟周期结束时设置一个脉冲\n\n11.微命令、微操作、微指令、微指令周期、微程序？\n\n> **微命令：各项操作所需要的控制命令**/**控制各功能部件的电平和脉冲信号**\n>\n> 一条机器指令的执行对应一段微程序\n>\n> 一段微程序可包含多条微指令\n>\n> 一条微指令包含机器指令一步所需要的微命令\n\n6.微程序控制器思想的基本要点是什么？内部部件？\n\n> 微程序控制的基本思想是:\n>\n> * 一条机器指令对应一段微程序\n> * 一段微程序包含多条微指令\n> * 一条微指令包含机器指令一步操作所需要的微命令\n>\n> 将CPU工作流程**对应的每个微操作命令序列编写成微程序(**微程序由若干微指令组成、每条微指令对应一个或几个微操作命令),**所有的微程序存放一个只读存储器中**;控制器自动按照**微程序的逻辑顺序,逐条取出微指令并执行,以实现CPU工作流程的控制**\n>\n> ---\n>\n> **内部部件**\n>\n> * 控制存储器（CM）：存放微程序（在CPU内部）\n> * 微指令寄存器：μIR：存放现行微指令\n>   * 微命令字段：提供机器指令一步操作所需要的微命令\n>   * 顺序控制字段：指明微地址后续生成方式，用于控制微程序的连续执行\n> * 微地址形成电路\n>   * 形成依据：现行微指令地址、微程序转移地址、现行微指令顺序控制字段，决定形成方式、机器指令有关代码：操作码、寻址方式、机器运行状态\n> * 微地址寄存器μAR：存放下一条微指令在CM中的地址\n>\n> 微程序执行过程：初始化μAR->CM->取机器指令微命令序列\n\n14.时序信号？时序系统？\n\n> 时序信号：计算机操作的时间标志\n>\n> 时序系统：即时序信号与操作的关系，用于规定各项操作所需的时间和时机\n\n二、设计题：\n\nCPU的逻辑组成及工作机制\n\n> CPU的工作原理：\n>\n> CPU的工作过程就是从主存（缓存）中读取指令，将指令放入指令寄存器，然后对指令译码，把指令分解成一系列的微操作，在发出各种响应的控制命令，控制各功能部件执行相关的操作，从而完成一条指令的执行，实现对应的功能。\n\n1.CPU的逻辑组成（模型机框图）\n\n（1）CPU的逻辑组成→模型机框图；\n\n（2）CPU内每个寄存器的作用；\n\n（3）总线的分类及定义；\n\n（4）控制器的分类及区别；\n\n2.CPU的指令流程\n\n（1）指令类型：MOV指令、双操作数算数逻辑运算指令、单操作数算是逻辑运算指令、转移/返回指令、转子指令；\n\n（2）核心是寻址方式：立即寻址、R、(R)、—(R)、(R)+、@(R)+、X(R)；\n\n> 模型机指令系统：定长指令格式16位，采用寄存器型寻址，即指令给出寄存器号\n\n3.操作时间表的安排（微命令的安排）：\n\n（1）CPU数据通路操作：按照数据的流向分成四段\n\nALU输入选择→AUL功能选择→移位器功能选择→分配脉冲（打入到寄存器中的脉冲）；\n\n（2）与访问主存有关的微命令。\n\n \n\n \n\n## 第四章 存储子系统\n\n一、基本概念\n\n1.主存、缓存、外存？\n\n> 存储系统层次结构：典型结构：三级存储体系结构\n>\n> Cache:容量小、速度高\n>\n> 主存：容量较大、速度较高\n>\n> 外存：容量大、速度慢\t\n\n2.高速缓存Cache用来存放什么内容？设置它的主要目的是什么？\n\n> (1)用来存放当前活跃的数据与程序,作为主存活跃区的副本;(2)设置它,是为了解决cpu与主存的速度匹配;\n\n3.存储介质？\n\n> 按存储介质，分为半导体存储器，磁表面存储器、光盘存储器\n\n4.何谓随机存取？何谓顺序存取？何谓直接存取？请各试举一例。\n\n> 随机访问存储器（RAM）：**随机存取**：可按地址访问存储器中的任一单元，**访问时间与地址单元位置无关**\n>\n> 如SRAM、DRAM\n>\n> **顺序访问存储器（SAM）：顺序访问时，读/写部件按照顺序查找目标地址，因此，访问时间与数据位置有关（如磁带）**\n>\n> **直接访问存储器（DAM）：访问时，读/写部件先直接指向一个小区域，再在该区域顺序查找，访问时间与数据位置有关（如磁盘、光盘）**\n\n5.数据传输率\n\n> 单位时间内存取的信息数量，也叫带宽\n>\n> 数据传输率 = 存储器数据位宽 / 存取周期bps\n\n5.静态存储器SRAM、动态存储器DRAM存储原理？\n\n> 静态存储器：**利用双稳态触发器存储信息**\n>\n> 动态存储器：**利用电容存储的电荷存储信息**\n\n6.动态刷新分为哪几种情况，各有什么特点？\n\n> 动态MOS存储单元：\n>\n> **四管单元**：保持原状态需要定期向电容补充电荷。**读出是非破坏性读出，读出过程即实现刷新**\n>\n> **单管单元：** **单管单元是破坏性读出，读出后需重写**\n>\n> `注意刷新和重写的区别：`\n>\n> 刷新：动态存储器，需要定期补充电容以保持原来信息\n>\n> 重写：破坏性读出后需要重写，以恢复原来的信息\n>\n> * 最大刷新间隔：大多数DRAM要求：保持2ms-64ms期间一定对所有单元刷新\n> * 刷新方法：\n>   * 单管动态存储器，读出时能自动重写补充电荷\n>   * **各动态芯片可同时刷新，片内按行刷新**\n> * 刷新周期（存取周期）：刷新一行需要的时间\n> * 刷新周期数：刷新一片芯片所需的周期数由芯片矩阵的行数决定\n> * 对主存的访问：\n>   * CPU访存：由CPU提供行列地址随机访问\n>   * 芯片刷新：由刷新地址计数器提供地址定时刷新\n> * 刷新周期的安排方式：\n>   * 集中刷新：2ms内集中安排所有刷新周期。用于实时要求不高的场合\n>   * 分散刷新：各刷新周期分散安排在存取周期中。造成主存利用率降低，用在低速系统中\n>   * 异步刷新：刷新周期分散安排在2ms内。\n\n7.全地址译码方式？部分地址译码方式？\n\n> **全译码方式：将除了与芯片连接的地址以外的所有高位地址用于译码产生片选信号**\n>\n> **部分译码方式：**将除了与芯片连接的地址外的部分高位地址用于译码产生片选信号（易出现地址重叠）\n\n二、设计题：\n\n半导体存储器逻辑设计：(地址分配、片选逻辑、逻辑框图)，片选逻辑采用全/部分译码方式。\n\n **易错点：**\n\n> 1. 部分译码时，产生片选信号要用或门，且单个地址线的值取反\n> 2. 不能增加门电路时，需要保持选用芯片的大小相同，即都为2K\n\n## 第五章 I/O系统\n\n一、基本概念\n\n1. 总线是什么？有什么特点？\n\n> **总线：一组为多个部件分时共享的信息传送线路**\n>\n> 特点：**分时共享：特定时刻只允许一个部件送出数据到总线上**\n>\n> **总线周期：完成一次主存或IO端口访问的时间**\n>\n> 总线分类\n>\n> * 按传输信号的类型\n>   * 数据总线\n>   * 地址总线\n>   * 控制总线\n> * 数据传送格式\n>   * 并行总线\n>   * 串行总线\n> * 按时序控制方式\n>   * 同步总线：由统一时序信号控制总线完成传送操作，在固定时钟周期内完成数据传送，由同步脉冲打入\n>   * 异步总线：无固定时钟周期，以异步应答的形式控制传送\n>   * 扩展同步总线：以时钟周期为基础，允许总线周期（完成一次主存或IO端口访问的时间）中时钟数可变【既有统一时序同步时钟，又有异步应答】\n> * 按功能\n>   * 内总线：CPU内部线\n>   * 局部总线：主板各芯片之间互连的总线\n>   * 系统总线：主板与插件板之间互连总线\n>   * 外总线：计算机系统与外部设备之间互连的总线\n> * 按方向分：\n>   * 单向总线\n>   * 双向总线\n\n2. 总线的标准\n\n> 针对系统总线和外总线\n>\n> * 物理特型\n> * 功能特型\n> * 电器特型\n> * 时间特型\n>\n> **ISA、EISA、AGP、PCI、USB**\n\n3. 接口\n\n> 外设与系统总线之间的逻辑电路称为输入输出接口，IO接口\n>\n> **为什么需要IO接口**\n>\n> * 工作速度，不同速度外设与CPU连接\n> * 数据格式的转换，外设与CPU的数据格式可能不同\n> * 一次数据传送量的控制\n> * 其他因素（如电平转换\n>\n> **IO接口的主要功能：**\n>\n> * 寻址：接受CPU送来的地址码、选择接口中的寄存器供CPU访问\n> * 数据缓冲：实现主机和外设的速度匹配、缓冲深度与传送的数据量有关\n> * 预处理：串-并格式转换，数据通路宽度转换，电平转换\n> * 控制功能：传送控制命令与状态信息，实现IO传送控制\n\n3. 系统总线上一般包含哪三组信息？\n\n> 数据总线：传输数据信息，决定总线宽度\n>\n> 地址总线：传输地址信息，决定寻址能力\n>\n> 控制总线：传输控制信息和状态信息\n\n4. 主机和外设的信息交换控制方式\n\n> 直接程序传送：依靠CPU直接执行相关的IO程序来实现数据的输入和输出控制\n>\n> 中断方式：设备提出中断请求，主机响应后与设备交换信息，接口中包含中断控制请求\n>\n> DMA方式：支持**高速外设与主存之间进行DMA方式交换数据**\n\n2. 中断方式定义、实质、特点？\n\n> **中断含义**：CPU**暂时中止现行程序的执行**，转去执行为某个随机事件服务的中断处理程序。处理完毕后自动恢复原程序的执行。\n>\n> **实质：**\n>\n> * 程序切换\n>   * 方法：**保存断点、保护现场、恢复现场、返回断点**\n>   * 时间：**一条指令结束时切换，保证程序的完整性**\n>\n> **特点：**\n>\n> * 随机性\n>   * 随机发生的事态（按键、故障）\n>   * 有意调用，随即请求与处理的事态（调用打印机）\n>   * 随机插入的事态(软中断指令可插入程序任何位置)\n\n\\3. 中断向量、中断向量表、向量地址？\n\n> 中断类型码：每个中断源对应的编号\n>\n> 中断向量：中断服务程序入口地址\n>\n> 中断向量表：存放各中断服务程序的入口地址的单元\n>\n> 向量地址：访问中断向量表的地址码，可通过计算中断类型码得到\n>\n> **模型机中：向量地址=中断号+2**\n>\n> **IBM PC向量表：向量地址 = 中断号 * 4**\n\n\\4. 何谓向量中断？何谓非向量中断？各有何优点和缺点？\n\n> 都是根据中断源获取服务程序入口\n>\n> **非向量中断：由软件查询提供服务程序入口地址**\n>\n> **向量中断：由硬件直接提供服务程序入口地址**\n\n4. 中断响应响应条件\n\n> 外设有请求且未被屏蔽\n>\n> CPU开中断\n>\n> 中断源优先级高于当前程序优先级\n>\n> 一条指令（非停机）结束后，即ET过后\n\n\\5. 单级中断、多重中断？ \n\n> 中断处理：主要任务：CPU执行中断服务程序\n>\n> 单级中断流程：\n>\n> * 保护现场、中断服务处理、恢复现场、开中断、返回\n>\n> 多级中断流程：\n>\n> * 保护现场\n> * 送新屏蔽字、开中断（禁止同级别或更低级别的请求，开发更高级别的请求）\n> * 中断服务处理\n> * 关中断\n> * 恢复现场及原屏蔽字\n> * 开中断\n> * 返回\n\n\\6. 程序直传方式定义、实质、特点？\n\n> 依靠CPU直接执行相关的IO程序来实现数据的输入和输出的控制\n>\n> 优缺点：硬件开销小、并行程度低，实时性差\n\n\\6. DMA定义、实质、特点？\n\n> 直接依靠硬件系统来控制主存和设备之间的数据传送，传送期间无需CPU干预，传送结束后通常通过中断方式通知CPU\n>\n> 特点：\n>\n> * 响应随机请求\n> * 不影响CPU程序的执行，仅占用总线、无程序切换\n> * 大批量数据的简单传送\n>\n> 典型的应用：\n>\n> * 主存和高速IO设备之间的简单数据传送\n> * 大批量数据采集系统\n> * 动态存储器DRAM的自动刷新\n>\n> DMA传送过程:\n>\n> * 程序准备：主程序实现初始化（对DMA控制器和接口\n> * 传送请求\n> * DMA传送：存储器--直传--IO（硬件实现）\n> * 善后处理：执行中断处理程序\n\n\\7. 程序直传方式，中断方式，DMA方式之间的区别？\n\n> 直接程序传送：依靠CPU直接执行相关的IO程序来实现数据的输入和输出控制\n>\n> 中断方式：设备提出中断请求，主机响应后与设备交换信息，接口中包含中断控制请求\n>\n> DMA方式：直接依靠硬件系统来控制主存和设备之间的数据传送，传送期间无需CPU干预，传送结束后通常通过中断方式通知CPU,支持**高速外设与主存之间进行DMA方式交换数据**\n\n \n\n# 《微型计算机原理与接口技术》重要知识点\n\n## 第一章  微处理器与总线\n\n一、基本概念\n\n6.8088/8086 CPU的特点？\n\n> **指令流水线：8088/8085CPU并行完成程序的执行，假设不考虑存储器操作数**\n>\n> **内存分段管理：**\n>\n> * 8088/8086CPU的内部结构为16位【内部1M的存储单元，但寄存器只有16位】\n> * 作为地址时，则只能访问64k存储单元\n> * 采用分段管理的方法，将内存空间分为多个逻辑段，每个逻辑段最大64k存储单元，段内每个单元的相对地址码用16位表示\n> * 每个段设置段地址用16位寄存器存储，以区分不同的逻辑段\n>\n> **支持多处理器系统：**\n>\n> * 8086 8088 具有最小与最大两种工作模式：\n> * 最小模式，也称为单处理器模式，系统控制总线的信号由CPU直接产生\n> * 最大模式，也称为多处理器模式，由总线控制器8288提供所有总线信号\n\n7.8088/8086的差异\n\n> * 外部数据总线宽度不同：\n>   * 8088的外部宽度是8位，8086是16位\n> * 访问存储器和IO控制的信号不同\n>   * 8088 低电平访问内存\n>   * 8086 高电平访问内存\n\n1.微处理器主要由哪几部分构成？\n\n2.说明8088CPU中EU和BIU的主要功能。在执行指令时，EU能直接访问存储器吗？\n\n> CPU内部结构由两部分组成：执行单元（EU）、总线接口单元（BIU）\n>\n> **执行单元EU：包括ALU、8个通用寄存器、标志寄存器FLAGS和EU控制部件**\n>\n> **从指令队列不断取出指令代码，译码后产生执行指令的控制信号。**ALU完成算术和逻辑运算，通用寄存器存放操作数和运算结果，而运算结果的状态特征则保存到标志寄存器中\n>\n> **总线接口单元BIU：包括四个段寄存器、程序计数器、指令队列、地址加法器、总线控制逻辑**\n>\n> **负责CPU与存储器和IO接口之间的信息传送**。由于8086/8088CPU中的寄存器均为16位，而CPU外部地址线为20根，因此BIU中采用地址加法器得到20位的物理地址，可以寻址的存储单元为1M。\n\n3.8086/8088CPU中，有哪些通用寄存器和专用寄存器？说明他们的作用。\n\n> 内部由8个通用寄存器、4个段寄存器、2个控制寄存器\n>\n> * 通用寄存器包括\n>   * 数据类寄存器：AX、BX、CX、DX，常用于存放操作数或运算结果\n>   * 地址指针寄存器：包括堆栈指针寄存器SP和基址指针寄存器BP。处理可以存放操作数外，还可以作为地址指针，常用于在堆栈操作中存放偏移地址。\n>     * SP：在堆栈操作中用来存放栈顶单元的偏移地址，永远指向堆栈的栈顶\n>     * BP：默认用于存放当前堆栈内某个单元的偏移地址，即可以对堆栈内任意单元的数据进行操作。\n>   * 变址寄存器：包括源变址寄存器SI和目的变址寄存器DI，处理可以存放操作数和作为地址指针外，还分别固定应用于数据的串操作指令中，提供串操作数的索引地址。\n>     * SI：串操作指令中隐含作为源操作数偏移地址\n>     * DI：串操作指令中隐含作为目的操作数的偏移地址\n> * 段寄存器：\n>   * CS，代码段寄存器\n>     * DS：数据段寄存器\n>   * ES：附加段寄存器\n>   * SS：堆栈段寄存器\n> * 控制寄存器：\n>   * IP：指令指针寄存器，用以存放预取指令的偏移地址\n>   * FLAGS：标志寄存器或程序状态字\n>     * 算术或逻辑运算结果的特征位\n>     * 控制标志位\n\n4.8086/8088系统中，存储器为什么要分段？一个段最大为多少字节？最小为多少字节？\n\n> 8086/8088的地址总线宽度为20位,其最大寻址空间是1 MB.\n> 在16位字长的机器里怎么提供20位地址的问题,而解决的办法是采用存储器地址分段的方法.\n> 程序员在编制程序时要把存储器划分成段,在每个段内地址空间是线性增长的.每个段的大小可达64 KB,这样段内地址可以用16位表示.\n>\n> 每段最长64KB，最短16B\n\n5.8086/8088系统中，物理地址和逻辑地址是指什么？ \n\n> 物理地址：\n>\n> * 指每个内存单元在整个内存空间中具有的唯一的地址\n> * 8086/8088CPU有20根地址线，它可以产生20位的地址码，寻址范围为2^20^.同时存储器按字节进行编制，索引存储器最大容量为1MB\n>\n> 逻辑地址：\n>\n> * *是指由程序产生的与段相关的偏移地址部分*\n\n6.段地址，段基地址：\n\n> 段地址：段寄存器中保存的16位地址\n>\n> 段基地址：段地址*16\n\n二、计算题：\n\n8086/8088系统中，物理地址和逻辑地址的转换？\n\n> 段地址*16+偏移地址=物理地址\n\n \n\n## 第二章 8086/8088指令系统\n\n一、基本概念\n\n1.8086/8088指令系统的8种寻址方式\n\n二、六大类指令\n\n1.数据传送：\n\n1）**通用数据传送：MOV**、堆栈操作指令push/pop、\n\n交换指令XCHG：将源地址和，目标地址中的内容进行互换。\n\n**要求：操作数中至少有一个是通用寄存器；段寄存器不能为操作数**\n\n查表转换指令XLAT：[BX+AL]->AL\n\n\n\n、（字位扩展指令不要求）\n\n2）**输入输出IN、OUT**\n\n> IN AL/AX port\n>\n> OUT port AL/AX\n>\n> 根据端口地址码的长度，指令具有两种不同的寻址方式\n>\n> * 直接寻址\n>   * 端口地址为8位，指令中直接给\n> * 间接寻址\n>   * 端口地址为16位，**指令中的端口地址必须由DX指定**\n\n3）地址传送LEA：取偏移地址指令，将存储器操作数的16位偏移地址送到指定的通用寄存器\n\n> LEA Reg16 Mem\n\n、LDS、LES：装入地址指针指令\n\n> LDS Reg16 Mem32\n>\n> 作用：把Mem32存储单元开始的四个字节单元的内容送入通用寄存器和段寄存器DS（LDS指令）或ES（LES）\n>\n> **低字单元作为偏移量送通用寄存器，高字单元为段基值送DS或ES**\n\n4）标志位操作PUSHF、POPF、LAHF、SAHF\n\nLAHF、SAHF:隐含操作数AH和FLAGS\n\nPUSHF、POPF：隐含操作数FLAGS和堆栈单元\n\n> LAHF：将FLAGS的低八位内容装入AH\n>\n> SAHF：将AH的内容送入到FLAGS的低八位\n>\n> PUSHF，将FLAGS的内容压栈保存\n>\n> POPF：将当前栈顶的内容送到FLAGS\n\n2.算术运算类指令：\n\n1）加法运算指令ADD、ADC、INC\n\n> * 普通加法ADD：ADD的执行对全部6个状态标志位都产生影响\n> * 带进位位的加法ADC：主要用于多字节加法运算，高16位（高八位）相加时，必须考虑低16位（低8位）产生的进位\n>   * ADC的执行对全部6个状态标志位都产生影响\n> * 加1指令INC:操作数可以是通用寄存器也可以是存储单元\n>   * 设置PF、AF、OF、ZF、SF，但不影响CF\n\n2）减法运算指令SUB、SBB、DEC、CMP（求补指令NEG不要求）\n\n> * 普通减法SUB：全部影响\n>\n> * 带借位的减法SBB：全部\n>\n> * 减1指令DEC：不影响CF\n>\n> * 求补NEG：全部影响\n>\n>   * 当操作数位0时，CF置0，其他均1\n>   * 字节操作数为-128或字操作数为-32768时，结果无变化，OF置1\n>\n> * **比较CMP**\n>\n>   * CMP OPRD1，OPRD2 ，对六个标志位全部产生影响，用于比较两个数的大小，可作为条件转移指令的转移条件\n>\n> * 简单条件转移指令\n>\n>   | 标志位 | 指令    | 转移条件 | 含义             |\n>   | ------ | ------- | -------- | ---------------- |\n>   | CF     | JC      | CF=1     | 有进位/借位转移  |\n>   | CF     | JNC     | CF=0     | 无进位/借位转移  |\n>   | ZF     | JZ/JE   | ZF=1     | 等于0/相等转移   |\n>   | ZF     | JNE/JNE | ZF=0     | 不等于0/不等转移 |\n>   | OF     | JO      | OF=1     | 溢出转移         |\n>   | OF     | JNO     | OF=0     | 非溢出转移       |\n>   | SF     | JS      | SF=1     | 负数转移         |\n>   | SF     | JNS     | SF=0     | 正数转移         |\n>   | PF     | JP/JPE  | PF=1     | 偶数转移         |\n>   | PF     | JNP/JPO | PF=0     | 奇数转移         |\n>\n> * CMP A B\n>\n>   * 无符号数条件转移指令\n>\n>     | 转移指令                   | 转移条件          | 含义       |\n>     | -------------------------- | ----------------- | ---------- |\n>     | JA/JNBE（A大/B不大且不等） | CF = 0 and ZF = 0 | A大        |\n>     | JAE/JNB(A大于等于B/B小于A) | CF = 0            | A大于等于B |\n>     | JB/JNAE                    | CF = 1            | B大于A     |\n>     | JBE/JNA                    | CF = 1 or ZF = 1  | B大于等于A |\n>\n>   * 有符号数条件转移指令\n>\n> | 转移指令                   | 转移条件             | 含义       |\n> | -------------------------- | -------------------- | ---------- |\n> | JG/JNLE （G代表A，L代表B） | SF = OF and ZF = 0   | A大        |\n> | JGE/JNL(A大于等于B/B小于A) | SF = OF              | A大于等于B |\n> | JL/JNGE                    | SF != OF  and ZF = 0 | B大于A     |\n> | JLE/JNG                    | SF != OF or ZF = 1   | B大于等于A |\n>\n> \n\n3）乘法指令（不要求）\n\n4）除法指令（不要求）\n\n3.逻辑运算和移位指令：AND、OR、NOT、XOR\n\n> and：CF = OF = 0\n>\n> OR ： CF = OF = 0\n>\n> NOT：取反，对符号位无影响\n>\n> XOR：CF = 0 = OF\n>\n> Test：两操作数相与但结果不送回目的操作数，只改变状态标志位CF=OF=0\n\nTEST、\n\nSHL、SHR、SAL、SAR、ROL、ROR、RCR、RCL\n\n> * 移位指令\n>   * **源操作数为移位次数（1或CL）**\n>   * **目的操作数为通用寄存器或存储单元**\n>   * 非循环移位\n>     * 算术左移：SAL ： SAL OPDR ，1 / SAL OPDR CL\n>     * 逻辑左移：SHL：\n>       * 若一次移位后操作数的最高位与CF不相同，则OF = 1。OF = 1对SAL表示溢出，对SHL不表示溢出\n>     * 算术右移：SAR：右移最低位给CF，最高位不变\n>     * 逻辑右移：SHR：最高位补0\n>     * **指令SAL和SAR当移位次数为n时，在不产生溢出的情况下，等于×2^n^和÷2^n^**\n>   * 循环移位\n>     * 不带CF循环左移：ROL\n>       * 首位给末尾和CF\n>     * 不带CF循环右移：ROR\n>       * 末位给首位和CF\n>     * 带CF循环左移：RCL\n>       * 首位给CF，CF给末尾\n>     * 带CF循环右移：RCR\n>       * 末尾给CF，CF给首位\n\n4.串操作指令：MOVS、CMPS、SCAS、LODS、STOS\n\n> **存储器中地址连续的若干单元的字符或数据称为字符串或数据串**\n>\n> 串操作指令就是对串中的每个字符或数据做相同操作的指令。每执行一次操作后能够自动修改指针，再执行下一次操作。\n>\n> * **特点**\n>   * 源串默认为数据段，允许段重设，偏移地址用SI寄存器指定即DS：SI\n>   * 目的串默认为附加段，**不允许段重设**，ES：DI\n>   * 串长度值放在CX寄存器中\n>   * 在对每个字节或字操作后，SI和DI寄存器的内容自动修改，修改方向和标志位DF有关，若DF=0，SIDI按照地址增量方向修改，（对字节操作加1对字操作加2），否则按地址减量方向修改\n>   * 可以在串操作指令前使用重复前缀，在每次串操作后CX的内容自动减1，直至CX=0，或不满足指定的条件\n> * **重复前缀**\n>   * REP：无条件重复前缀，重复执行规定的操作，直至CX = 0\n>   * REPE / PEPZ ： 重复条件：ZF = 1 且 CX ！=0\n>   * REPNE/REPNZ：重复条件：ZX = 0 且 CX ！= 0\n>   * **重复前缀操作不影响标志位**\n>   * 先执行串操作指令，串操作指令可能会影响标志位。然后CX - 1，并判断条件\n> * **串操作指令时8086指令系统中唯一能直接处理源和目标操作数都在存储单元的指令**\n> * 串传送指令：MOVS OPRD1 OPRD2\n>   * MOVSB：一次完成一个字节的传送\n>   * MOVSW：一次完成一个字的传送\n>     * 实现的操作：DS:[SI] -> ES :[DI] , SI + n -> SI DI + n -> DI\n>     * 常与无条件重复前缀联合使用，不影响标志位\n> * 串比较指令\n>   * CPMS OPRD1 OPRD2\n>     * CMPSB：按字节比较\n>     * CMPSW：按字比较\n>   * 常和重复前缀REPZ/REPE或RPENZ/REPNE联合使用，检查两个字符串是否相等\n>   * 串比较指令影响标志位，CX是否为0不影响标志位\n> * 串扫描指令：SCAS：\n>   * SCASB:按照AL内容对目的串进行扫描\n>   * SCASW：按照AX内容对目的串进行扫描\n>   * 不会改变操作数及SI，自动改变DI以及影响标志位\n> * 串装入指令：LOAD\n>   * LOADS：将源串按字节装入AL\n>   * LOADW：将源串按字装入AX\n>   * 自动改变SI寄存器的内容，不影响标志位，同时一般不带重复前缀指令\n>   * LOADSB = MOV AL[SI] INC SI\n>   * LOADSW = MOV AX [SI] INC SI INC SI\n> * 串存储指令：STOS \n>   * STOSB:将AL装入目的串\n>   * STOSW：将AX装入目的穿\n>   * 自动改变DI寄存器的内容，不影响标志位，利用重复前缀REP可对连续存储单元存入相同的值\n>   * STOSB：MOV ES:[DI] AL INC DI\n>   * STOSW: MOV ES:[DI] AX INC DI INC DI\n\n5.程序控制指令：\n\n1）转移指令：JMP、条件转移指令\n\n> JMP：无条件的使程序转移到指定的目标地址，并从该地址执行新的程序段\n>\n> 段内转移：CS不变，仅改变IP\n>\n> 段间转移：CS和IP都改变\n>\n> **条件转移指令**\n>\n> 简单条件转移指令\n>\n> | 标志位 | 指令    | 转移条件 | 含义             |\n> | ------ | ------- | -------- | ---------------- |\n> | CF     | JC      | CF=1     | 有进位/借位转移  |\n> | CF     | JNC     | CF=0     | 无进位/借位转移  |\n> | ZF     | JZ/JE   | ZF=1     | 等于0/相等转移   |\n> | ZF     | JNE/JNE | ZF=0     | 不等于0/不等转移 |\n> | OF     | JO      | OF=1     | 溢出转移         |\n> | OF     | JNO     | OF=0     | 非溢出转移       |\n> | SF     | JS      | SF=1     | 负数转移         |\n> | SF     | JNS     | SF=0     | 正数转移         |\n> | PF     | JP/JPE  | PF=1     | 偶数转移         |\n> | PF     | JNP/JPO | PF=0     | 奇数转移         |\n\n2）循环控制指令：LOOP、LOOPZ/LOOPE、LOOPNZ/LOOPNE\n\n> 循环次数必须先送入CX\n>\n> 循环控制指令不影响状态标志位，标志位主要由之前指令改变\n\n3）过程调用指令：CALL\n\n> 程序执行过程中，主程序可以根据需要随时调用子程序，子程序执行完后再回到主程序继续\n>\n> CALL：\n>\n> * 保存主程序断点地址（返回地址）\n> * 子程序入口地址-> IP (CS IP)\n>\n> RET：\n>\n> * 主程序返回地址->IP\n\n4）中断控制指令：INT \n\n> 产生软中断\n>\n> INT n\n>\n> n ； 中断类型码，中断向量地址 = n * 4\n\n6.处理器控制指令：常用的CLD 、STD、CLI、STI、HLT、CLC、STC\n\n> CLC：CF置0\n>\n> STC：CF置1\n>\n> CLD：DF置0\n>\n> STD：DF置1\n>\n> CLI：IF置0，关中断\n>\n> STI：IF置1\n>\n> HLT：CPU暂停\n>\n> \n\n \n\n## 第三章 汇编语言程序设计\n\n一、基本概念\n\n1.指令与伪指令区别？\n\n> 指令汇编后生成可被CPU执行的代码\n>\n> 伪指令不生产目标代码，只是用于告诉汇编程序如何对源程序进行汇编\n>\n> **伪指令在汇编过程中由汇编程序执行，如定义数据、分配存储区、定义段以及定义过程等**\n\n2.伪指令：段定义伪指令、数据定义伪指令：常数(字符串的使用DB、DW、DD)、变量和标号,当前位置计数器$（$!作变量使用，是16位偏移量）与定位伪指令ORG等伪指令。\n\n3.汇编语言语句类型及格式\n\n> 分为指令性语句和指示性语句\n>\n> **指令性语句:**由指令系统中助记符组成的语句，汇编后生成可被CPU执行的目标代码\n>\n> **指示性语句:**用于告诉汇编程序如何对源程序进行汇编，不生成可执行的目标代码，又称为伪操作语句或伪指令\n\n二、汇编语言程序设计\n\n1.汇编语言源程序结构\n\n> 一个完整的汇编语言源程序通常由若干个逻辑段组成，包括数据段、附加段、堆栈段、代码段\n>\n> 每个逻辑段由SEGMENT语言开始，由ENDS语言结束\n>\n> 整个源程序以END结尾\n\n2.汇编语言程序设计四种类型：顺序程序设计、分支程序设计、循环程序设计、子程序设计\n\n \n\n## 第四章  输入输出和中断技术\n\n一、基本概念\n\n1.输人/输出系统主要由哪几个部分组成？主要有哪些特点？\n\n>解:输入输出系统主要由三个部分组成,即输入输出接口、输入输出设备、输入输出软件。\n>\n>输入输出系统主要有4个特点:复杂性、异步性、实时性、与设备无关性\n\n2.I/0接口的主要功能有哪些？有哪两种编址方式？在8088/8086系统中采用哪一种编址方式？\n\n> 一般来说,I/O接口应具有以下功能:\n>\n> * 寻址\n> * 数据缓冲\n> * 数据格式变换\n> * 控制逻辑\n>\n> 有统一和独立编址\n>\n> 8086中采用独立编址方式\n\n3.试比较 4种基本输人/输出方法的特点。\n\n>在微型计算机系统中，主机与外设之间的数据传送有4种基本的输入输出方式：\n>无条件传送方式、查询工作方式、中断工作方式、直接存储器存取（DMA.方式。它们各自具有以下特点：\n>（1）无条件传送方式适合于简单的、慢速的、随时处于“准备好”接收或发送数据的外部设备，数据交换与指令的执行同步，控制方式简单。\n>（2）查询工作方式针对并不随时“准备好”、且满足一定状态才能实现数据的输入/输出的简单外部设备，其控制方式也比较简单，但CPU的效率比较低。\n>（3）中断工作方式是由外部设备作为主动的一方，在需要时向CPU提出工作请求，CPU在满足响应条件时响应该请求并执行相应的中断处理程序。这种工作方式使CPU的效率提高，但控制方式相对较复杂。\n>（4）DMA方式适合于高速外设，是4种基本输入/输出方式中速度最高的一种。\n\n4.主机与外部设备进行数据传送时,采用哪一种传送方式CPU的效率最高？\n\n> DMA\n\n二、逻辑电路及程序设计\n\n1.根据状态端口地址查询相关状态位的值，符合条件通过数据端口传送一次数据。\n\n2.中断向量表中中断向量设置。\n\n","categories":["校内课程","计算机组成原理"]}]