---
title: 基础知识总结
categories:
  - Linux学习
  - 牛客Linux
  - 第2章 Linux多进程开发
abbrlink: 4546cf5c
date: 2023-09-21 02:00:00
updated: 2023-09-21 02:00:00
---

<meta name="referrer" content="no-referrer"/>

`牛客Linux`的`第2章 Linux多进程开发`的`基础知识总结`部分。

<!-- more -->

`CSDN`：[https://blog.csdn.net/m0_61588837/article/details/132548326](https://blog.csdn.net/m0_61588837/article/details/132548326)

`markdown`文档在：[https://github.com/DavidingPlus/Md_Files/blob/master/Cpp/C%2B%2B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Linux/%E7%89%9B%E5%AE%A2%20Linux.md](https://github.com/DavidingPlus/Md_Files/blob/master/Cpp/C%2B%2B%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0/Linux/%E7%89%9B%E5%AE%A2%20Linux.md)

代码在：[https://github.com/DavidingPlus/Linux_Learning/tree/Newcoder_Linux](https://github.com/DavidingPlus/Linux_Learning/tree/Newcoder_Linux)

# 第二章 Linux多进程开发

## 一些概念

### 程序和进程

![image-20230716113520531](https://img-blog.csdnimg.cn/8c066e253e664b8dbbae425c6cbc8495.png)

![image-20230716113908652](https://img-blog.csdnimg.cn/87dae5a63f714639825c0af3f655a13a.png)

### 单道，多道程序设计

![image-20230716114055627](https://img-blog.csdnimg.cn/f54a9eb14ba34142b26ae51249f8a52b.png)

### 时间片

![image-20230716114135444](https://img-blog.csdnimg.cn/0d62d3a6ba2a4ad7897a3c072f416f2e.png)



### 并行和并发

![image-20230716114205304](https://img-blog.csdnimg.cn/07a4ca3a5b2a4cffa1660c292e8e8dee.png)

### 进程控制块PCB

**在Linux内核的进程控制块是 task_struct 结构体**

![image-20230716120419774](https://img-blog.csdnimg.cn/9f8ec96ec55c4f63b7d88793a161d004.png)

<img src="https://img-blog.csdnimg.cn/f6d27217a7f947c8928170e64f1f9e4d.png" alt="image-20230716121448756" style="zoom:80%;" />

## 进程状态

### 状态转化图

![image-20230718093121456](https://img-blog.csdnimg.cn/d3bc8a04198348c189aa395edc27ad62.png)

**加入新建和终止的状态**

![image-20230718093806701](https://img-blog.csdnimg.cn/81675cad6df6469b935a8b9d42d5cfef.png)

### 进程相关命令

~~~shell
ps aux / ajx
#注意aux和ajx的区别
~~~

![image-20230718094028703](https://img-blog.csdnimg.cn/7c6e6637ee1347f4bd0703747a917a25.png)

#### ps aux

![image-20230718094423758](https://img-blog.csdnimg.cn/0a14c4080bcb46928559584830f9337a.png)

stat参数的意义：

![image-20230718095104233](https://img-blog.csdnimg.cn/698614e12584488592fe8230c5e58f6d.png)

#### ps ajx

![image-20230718095230919](https://img-blog.csdnimg.cn/ee8464effa5c45fab889c27bd4057ea1.png)

#### top

**实时显示进程动态**

![image-20230718095445176](https://img-blog.csdnimg.cn/6c3abdd3ae9543b581491bead1006e8c.png)

#### kill

**杀死进程**

<img src="https://img-blog.csdnimg.cn/cf9073b5d0234181a1b4d5fdafffb1f5.png" alt="image-20230718095843259" style="zoom: 80%;" />

里面有一个 9 号信号(SIGKILL)，比如：

~~~bash
kill -9 <pid>
~~~

**这个命令可以强制杀掉某个进程**

![image-20230718100643298](https://img-blog.csdnimg.cn/09d94842dff847a89af558ad60c8096a.png)

#### ./a.out & 后台运行程序

**这个时候，这个进程会被挂在后台进行运行，然后他的打印信息仍然会打印在屏幕上，这里使用ps aux查看命令可以看出是可以正常执行命令的，不冲突，然后可以用 kill 998 将其杀掉**

![image-20230718101259447](https://img-blog.csdnimg.cn/a562b991c8e14231b161e51bf344e347.png)

## 创建进程

### 进程号和相关函数

**进程组是一个或者多个进程的集合，他们相关联，并且可以接受同一终端的各种信号，具有一个进程组号(pgid)**

![image-20230718101452289](https://img-blog.csdnimg.cn/b4d9c9cf59e24a59b0bd7b06ce20ea10.png)

### 进程创建

![image-20230718101951634](https://img-blog.csdnimg.cn/bb0d676a8e4e4ff49673312b9bb9bbb3.png)

#### fork()

~~~cpp
#include <unistd.h>

pid_t fork(void);
//作用：用于创建子进程
//返回值：
    //fork()的返回值会返回两次，一次是在父进程中，一次是在子进程中
    //为什么会走两次呢？因为这个cpp文件编译出来是一个可执行文件 a.out，这个文件执行后是进程 ./a.out，自然创建出来的也是 ./a.out进程，也就是走的是这个cpp程序
    //但是注意一点：子进程是不会执行fork()函数的，因为fork()函数是父进程执行的，但是他会持有返回值，在子进程当中就是0
    //成功 父进程中返回子进程的pid，子进程中返回0
    //失败 父进程中返回-1，没有子进程被创建，然后修改errno
~~~

~~~cpp
#include <iostream>
using namespace std;
#include <unistd.h>

int main() {
    int pid = fork();
    if (pid == -1) {
        perror("fork");
        return -1;
    }

    // 判断是父进程还是子进程
    if (pid > 0) {  // 父进程走，返回的是创建的子进程编号
        cout << pid << endl;
        printf("I am parent process, pid : %d , ppid : %d\n", getpid(), getppid());
    } else if (pid == 0)  // 子进程走
        printf("I am child process, pid : %d , ppid : %d\n", getpid(), getppid());

    // for
    for (int i = 0; i < 3; ++i) {
        sleep(1);
        cout << i << endl;
    }

    return 0;
}
~~~

**父进程和子进程是并发执行的，在如上的程序当中先打印那个是不确定的，取决于谁先拿到处理机!!!**

**当然如果程序的运行时间太短了，导致在一个时间片当中可以完成，那么看起来就像是两个东西是按照顺序进行的，但是实际上是并发的!!!**

例如这是两次的执行结果：

![image-20230718104207327](https://img-blog.csdnimg.cn/a1283af4784c410baf2221a8906d39cf.png)

当给多点的时候，到后面并发执行的时候就可能是交替执行

<img src="https://img-blog.csdnimg.cn/85cf918904d54db281d097b77777cb0b.png" alt="image-20230718105046657" style="zoom:67%;" />

### 父子进程虚拟地址空间

**执行到fork()函数的时候，克隆一份空间(不完全正确，后面会讲)，子进程这边不执行fork()函数，fork()函数只给父进程执行，但是子进程会得到返回值为0用来和父进程进行区别，然后两个进程根据逻辑并发执行!!**

**但其实这两个空间大部分的东西都是一样的!!!**

![image-20230718142613257](https://img-blog.csdnimg.cn/84822f6a580a4e9696f020862dfadc97.png)

#### 读时拷贝，写时共享

**子进程在被创建出来的时候，如果没有对变量进行修改，进行写的操作，那么父子进程共享一块空间；当父子进程需要进行写，就是修改变量的值的时候就拷贝一块空间，这样就节省了物理内粗拿到空间!!!**

![image-20230718143403658](https://img-blog.csdnimg.cn/90d61fd388c94bd3ae1f46ffd5cf6588.png)

### 总结：父子进程关系

区别：

- fork()函数返回值不同：父进程 > 0 ，返回子进程的pid；子进程 = 0
- pcb中的一些数据：当前进程的id pid，当前进程的父进程的id ppid，**信号集**

共同点：

- 在某些状态下，子进程刚被创建出来，还没执行任何写的操作

  用户区的数据，文件描述符表是共享的!!!

- 父子进程对变量是不是共享的？

  刚开始的时候是一样的，共享的；但是修改了数据就不共享了

  读时共享(两个进程没有做任何写的操作)，写时拷贝

## GDB多进程调试

**默认情况下gdb调试的都是父进程，加了断点的话默认只对父进程生效，可以设置**

![image-20230718145227613](https://img-blog.csdnimg.cn/1b30c958fd9e4a71b65ad4ded2c5e8c1.png)

### 设置调试子进程

![image-20230718145632605](https://img-blog.csdnimg.cn/7e023458740f4d5696327288f7dcf2c3.png)

### 设置调试模式

**这里我把 detac-on-fork 模式关闭了，父进程在被调试的时候，子进程会被挂起，所以屏幕上没显示j的信息**

![image-20230718151209448](https://img-blog.csdnimg.cn/93e2f24a56fd4a629d4f50c4b3c42967.png)

![image-20230718151224879](https://img-blog.csdnimg.cn/904d8708e6ec4868a3bc9c959e1c8142.png)

## exec函数族

### 函数族介绍

**exec函数族的作用是根据指定的文件名找到可执行文件，然后用它替换当前我们调用的进程的内容然后去执行**

**为了保护当前的进程的内容，一般创建一个子进程然后让exec函数族去替换子进程的内容去执行，这样就好了**

**执行成功了不会返回，因为新的已经取代了旧的，旧的再接受返回值并做操作没有任何意义；只有调用失败了才会返回-1，这个时候新的不会进来，还是旧的**

![image-20230718152959795](https://img-blog.csdnimg.cn/765dbf5bbec34206b5d2b0ba84b7f8f6.png)

图解

![image-20230718154755731](https://img-blog.csdnimg.cn/72938bd9ed2b4abfa8965691a9dc9eb8.png)

### 函数族(附图)

**前面6个函数是C标准库当中的函数，最后一个(execve)是Linux下的系统函数**

![image-20230718154816547](https://img-blog.csdnimg.cn/41b24a104c994e10970781c4cbbff38f.png)

#### execl()

~~~cpp
#include <unistd.h>
int execl(const char *pathname, const char *arg, ... , (char *) NULL );
//参数：
    //path：指定的执行的可执行文件的路径，例如：a.out 推荐写绝对路径
    //arg：字符串，是可执行文件所需要的参数列表
        //第一个参数(arg当中的第一个参数!!)一般没有作用，为了方便，一般写的是可执行的程序的名称
        //从第二参数开始往后，就是程序执行所需要的参数列表
        //参数最后需要以NULL结束(哨兵)

//返回值：
    //只有调用错误，才会有返回值，为-1，且设置errno
    //调用成功不会有返回值，
~~~

~~~cpp
#include <iostream>
using namespace std;
#include <unistd.h>

int main() {
    // 创建一个子进程，在子进程中执行exec函数族当中的函数
    pid_t child_pid = fork();
    if (child_pid == -1) {
        perror("fork");
        return -1;
    }

    if (child_pid > 0) {
        // 父进程
        printf("I am parent process , pid : %d\n", getpid());
        sleep(1);
    } else if (child_pid == 0) {
        // 子进程
        execl("hello", "hello", nullptr);
        printf("I am child process , pid : %d\n", getpid());
    }

    for (int i = 0; i < 3; ++i)
        printf("i = %d , pid = %d\n", i, getpid());

    return 0;
}
~~~

执行结果：

可以看出 child process 这句话没有打印出来，他被可执行文件hello替换掉了，最后的打印i是父进程打印出来的

![image-20230718170703719](https://cdnjson.com/images/2023/09/04/image-20230718170703719.png)

**还可以让其执行linux的shell命令**

比如 ps aux 命令，ps就是一个命令，对应可执行文件 /usr/bin/ps

~~~cpp
#include <iostream>
using namespace std;
#include <unistd.h>

int main() {
    // 创建一个子进程，在子进程中执行exec函数族当中的函数
    pid_t child_pid = fork();
    if (child_pid == -1) {
        perror("fork");
        return -1;
    }

    if (child_pid > 0) {
        // 父进程
        printf("I am parent process , pid : %d\n", getpid());
        sleep(1);
    } else if (child_pid == 0) {
        // 子进程
        // execl("hello", "hello", nullptr);

        // 可以执行linux系统自己的可执行程序，比如ps命令(/usr/bin/ps)
        execl("/usr/bin/ps", "ps", "aux", nullptr);

        printf("I am child process , pid : %d\n", getpid());
    }

    for (int i = 0; i < 3; ++i)
        printf("i = %d , pid = %d\n", i, getpid());

    return 0;
}
~~~

执行结果：

![image-20230718171319019](https://img-blog.csdnimg.cn/4cbd92ebe080486394ce600977223393.png)

#### execlp()

**与execl()函数的区别是execlp()函数里面传入的是可执行文件名，不是路径；会自动到环境变量中去查找这些可执行文件名，适合用作系统的命令，而execl()传路径，适合自己的可执行文件(不用配置环境变量)**

~~~cpp
#include <unistd.h>
int execlp(const char *file, const char *arg, ... , (char *) NULL );
//参数：
    //会到环境变量中查找可执行文件，找到了就执行，找不到就不成功!!!
    //file：需要执行的可执行文件的文件名，不包含路径!!!


    //arg：字符串，是可执行文件所需要的参数列表
        //第一个参数(arg当中的第一个参数!!)一般没有作用，为了方便，一般写的是可执行的程序的名称
        //从第二参数开始往后，就是程序执行所需要的参数列表
        //参数最后需要以NULL结束(哨兵)

//返回值：
    //只有调用错误，才会有返回值，为-1，且设置errno
    //调用成功不会有返回值
~~~

~~~cpp
#include <iostream>
using namespace std;
#include <unistd.h>

int main() {
    // 创建一个子进程，在子进程中执行exec函数族当中的函数
    pid_t child_pid = fork();
    if (child_pid == -1) {
        perror("fork");
        return -1;
    }

    if (child_pid > 0) {
        // 父进程
        printf("I am parent process , pid : %d\n", getpid());
        sleep(1);
    } else if (child_pid == 0) {
        // 子进程
        // execl("hello", "hello", nullptr);

        // 可以执行linux系统自己的可执行程序，比如ps命令(/usr/bin/ps)
        execlp("ps", "ps", "aux", nullptr);

        printf("I am child process , pid : %d\n", getpid());
    }

    for (int i = 0; i < 3; ++i)
        printf("i = %d , pid = %d\n", i, getpid());

    return 0;
}
~~~

依然能执行ps aux 命令

