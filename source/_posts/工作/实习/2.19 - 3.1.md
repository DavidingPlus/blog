---
title: 2.19 - 3.1
categories:
  - 工作
  - 实习
abbrlink: 5318c342
date: 2024-02-22 16:10:00
updated: 2024-02-25 17:20:00
---

<meta name="referrer" content="no-referrer"/>

自己`2.19 - 3.1`的实习工作记录。

<!-- more -->

# 迭代任务

1. 走查线程与同步相关内容，包括线程管理、线程数据、互斥锁、读写锁

# 代码走查问题

## 线程管理和数据

### lthreadinterface

1. 禁用了拷贝构造和赋值函数，按理同样应该禁用移动构造和赋值函数

   - 当然在本类中这是单例将构造函数私有，这倒无所谓，但是其他类也有类似的问题，因此还是罗列出来

   ~~~cpp
   /**
    * @brief 禁止进行拷贝构造。
    */
   LPlatformThreadInterface(const LPlatformThreadInterface &) = delete;
   
   /**
    * @brief 禁止进行赋值构造。
    */
   LPlatformThreadInterface &operator=(const LPlatformThreadInterface &) = delete;
   ~~~

### lposixthreadinterface

1. `joinThread()`有两行代码可以写为一行

   ~~~cpp
   void LPosixThreadInterface::joinThread(unsigned long threadId)
   {
       pthread_t tid = (pthread_t)threadId;
       int res = pthread_join(tid, nullptr);  // 暂不处理返回值
   	
       ...
   };
   ~~~

### lthread

1. 按理同样禁用移动构造和赋值函数，同`lthreadinterface`

### lthreaddata

1. 按理同样禁用移动构造和赋值函数，同`lthreadinterface`

## 互斥锁

### lmutex

1. 析构函数注释少写了句号（`。`）

   ~~~cpp
   /**
    * @brief 析构函数
    */
   ~LMutex();
   ~~~

2. 拷贝赋值函数少写了`const`

   ~~~cpp
   /**
    * @brief 禁止赋值构造。
    */
   LMutex &operator=(LMutex &) = delete;
   ~~~

   - 引申：在代码里面未禁用移动构造和赋值，针对互斥锁当前的情况，应当禁用移动构造和赋值函数

### lmutexcontext

1. 析构函数注释问题，同`lmutex`

### lposixmutexcontext

1. 析构函数注释问题，同`lmutex`

2. 析构函数和`trylock()`部分错误处理使用了`std::cerr`

   - `trylock()`这里可以理解，因为是试探能否加锁成功，不成功返回`false`，通过标准错误输出信息也可以
     - 另外，`std::cerr`对应的标准错流是无缓冲的，没必要使用`std::endl`再冲洗一次缓冲区，输出`'\n'`即可
   - 析构函数这里失败的话，建议使用异常处理

   ~~~cpp
   LPosixMutexContext::~LPosixMutexContext()
   {
       int res = pthread_mutex_destroy(&m_mutex);
       if (res != 0)
       {
           // Handle error properly
           std::cout << "pthread_mutex_destroy() gave error code: " << res << std::endl;
       }
   }
   
   bool LPosixMutexContext::tryLock()
   {
   	...
           
       else if (res == EBUSY)
       {
           std::cerr << "LMutex::tryLock(): Target mutex is busy." << std::endl;
           return false;
       }
   
       ...
   }
   ~~~

3. 在锁的构造函数当中，使用检错锁，但是在`lock()`当中未作重复加锁的针对性判断，具体见`./snippet/MutexLockTest`

   ~~~cpp
   void LPosixMutexContext::lock()
   {
       int res = pthread_mutex_lock(&m_mutex);
       if (res != 0)
       {
           throw LException(LString("互斥锁加锁失败，错误代码：").append(LString(res)));
       }
   }
   ~~~

   - `trylock()`的判断并无问题，经过验证普通锁和检错锁在`trylock()`下加锁失败返回的都是`EBUSY（16）`

### lwin32mutexcontext

1. 析构函数注释问题，同`lmutex`
2. `std::cerr`问题，同`lposixmutexcontext`

## 读写锁

### lreadwritelock

1. 拷贝赋值函数问题，同`lmutex`

### lposixreadwritelockcontext

1. 构造函数使用了静态初始化，经研究动态和静态的区别之后认为使用动态初始化可能好一点

   ~~~cpp
   LPosixReadWriteLockContext::LPosixReadWriteLockContext()
   {
       m_rwlock = PTHREAD_RWLOCK_INITIALIZER;
   }
   ~~~

   - 静态初始化出来的锁不需要手动释放了，在析构函数中调用了`destroy`，可能会出现不可预测的运行时问题
   - 互斥锁那边使用的是动态初始化，当然是因为需要设置检错锁必须这么做，但是个人认为为了保持代码风格的统一，建议使用动态初始化

2. `std::cerr`问题，同`lposixmutexcontext`

### lwin32readwritelockcontext

1. `std::cerr`问题，同`lposixmutexcontext`

# 学习的点

## 线程管理和数据

### lthreadinterface

`lthreadinterface`又是一个提供平台接口的单例加多态的例子，具体不再赘述

### lposixthreadinterface

1. 多线程私有数据`TSD（Thread Specific Data）`

   - 在多线程当中，所有线程共享程序段中的变量，例如一个全局变量，所有线程都可以使用，因此会出现线程同步的相关问题，也就有互斥锁、读写锁、条件变量、信号量等手段；但是现在我们需要一些数据，线程可以单独进行使用，其他线程无法访问，需要引入**线程存储**
   - `pthread_key_t`，对应一个`key`的变量，这个键在每个线程中可以对应存储对应的值，所以`key`是共享的，但是在各自线程中存储的数据是不一样的，这就是实现的大致思路；**表面上看起来这是一个全局变量，所有线程都可以使用它，而它的值在每一个线程中又是单独存储的。这就是线程存储的意义**
     - 接口具体的参数以及作用搜索`man`文档即可，这里只论述总体思路而不具体展开
   - 演示程序见`./snippet/PthreadKeyTest`

2. `pthread_once`：在多线程中让某些操作**只执行一次**

   ~~~cpp
   int pthread_once(pthread_once_t *once_control, void (*init_routine) (void))；
   
   // 功能：本函数使用初值为PTHREAD_ONCE_INIT的once_control变量保证init_routine()函数在本进程执行序列中仅执行一次。
   ~~~

   - 多线程中，尽管`pthread_once`会出现在多个线程中，但是能保证`init_routine`的函数只执行一次，`once_control`作执行一次的标志作用，并且`Linux`要求`once_control`的初始值必须为`PTHREAD_ONCE_INIT`，否则函数行为不正常

3. 有以上二者就能够理解代码中获取线程数据的设计了，代码中注释理解

   ~~~cpp
   pthread_once_t LPosixThreadInterface::sm_onceFlag = PTHREAD_ONCE_INIT;
   
   // 函数用作获取线程存储数据的指针
   LThreadData *LPosixThreadInterface::currentThreadData()
   {
       // 用pthread_once保证，initThreadLocalStorage只执行一次
       // initThreadLocalStorage函数用作初始化pthread_key_t，也就是存储键，可以让key共享，但是不同线程各自存储各自的数据
       pthread_once(&sm_onceFlag, LPosixThreadInterface::initThreadLocalStorage);
       // pthread_getspecific()，获取key对应的数据，这里就是线程数据；这样我的线程数据被更改之后就能通过这个接口通过key进行访问获得
       LThreadData *pThreadData = reinterpret_cast<LThreadData *>(pthread_getspecific(sm_tlsKeyThreadData));
       // 有则获得，无则创建返回
       if (!pThreadData)
       {
           pThreadData = new LThreadData();
           int res = pthread_setspecific(sm_tlsKeyThreadData, pThreadData);
           if (res != 0)
           {
               throw LException("无法在线程本地存储中设置线程数据。");
           }
       }
       return pThreadData;
   }
   ~~~

## 互斥锁

### lmutex

1. 为了做到平台适配，定义了统一基类`LPlatformMutexContext`指针，针对不同平台派生，使用多态进行处理，在后续的`lock()，trylock()，unlock()`中就很方便的使用`LPlatfromMutex`的接口即可

   - 在`LMutex`构造函数中，使用`#ifdef、#elif、#else、#endif`宏初始化指针

   ~~~cpp
   LMutex::LMutex()
   {
   #ifdef __unix__
       m_pMutexContext = new LPosixMutexContext();
   
   #elif _WIN32
       m_pMutexContext = new LWin32MutexContext();
   
   #else
       throw LException("无法创建互斥锁上下文：无法检测当前操作系统平台。");
   #endif
   }
   ~~~

### lmutexcontext

1. 是一个抽象基类，延申出`unix`和`win32`的各自派生，在类当中的函数都是纯虚函数，等待子类的覆写，由于无法实例化，因此需要在上层在做一层包装，也就是在`lmutex`中使用该类指针进行多态的管理，做到了平台无关

### lposixmutexcontext

1. 关于互斥锁属性中的普通锁和检错锁

   - 互斥锁属性通过`pthread_mutex_init()`进行设置，第一个参数是互斥锁指针，第二个参数是属性指针

- 普通锁属性：`PTHREAD_MUTEX_TIMED_NP`，默认值，线程加锁之后，实际上在锁这里形成了等待队列

- 检错锁属性：`PTHREAD_MUTEX_ERRORCHECK_NP`，和普通锁的区别是检测到自身重复加锁之后不会阻塞，而是返回`EDEADLK（35）`，这样可以一定程度上作加锁的安全检测

### lwin32mutexcontext

`win`平台下的互斥锁，官方文档：[Synchapi.h 标头 - Win32 apps | Microsoft Learn](https://learn.microsoft.com/zh-cn/windows/win32/api/synchapi/)

1. 代码中使用`CRITICAL_SECTION`关键节对象代表互斥锁，值得注意的是`win`平台自身也具有互斥锁，二者的区别在于关键节对象只能单个进程的线程使用，不支持跨进程共享
2. 一些接口
   - `InitializeCriticalSection`、`DeleteCriticalSection`、`EnterCriticalSection`、`TryEnterCriticalSection`、`LeaveCriticalSection`，`CriticalSection`意为临界区，分别对应初始化、销毁、加锁、尝试加锁、解锁，其中只有尝试解锁`trylock()`有返回值，其他的函数均没有返回值，因此没有错误异常处理是正常的

## 读写锁

### lreadwritelock

整体设计和互斥锁一样，这里不再赘述

### lposixreadwritelockcontext

1. 锁的静态初始化和动态初始化（以读写锁为例）

   - 静态初始化

   ~~~cpp
   pthread_rwlock_t m_rwlock = PTHREAD_RWLOCK_INITIALIZER;
   ~~~

   - 动态初始化

   ~~~cpp
   pthread_rwlock_t m_rwlock;
   pthread_rwlock_init(&m_rwlock, nullptr);
   ~~~

   二者的区别：

   - 静态初始化在编译期就初始化完毕；动态初始化在运行期
   - 静态初始化不能设置锁的相关属性，只能使用默认的；动态初始化可以
   - 静态初始化的锁存储在静态存储区；动态初始化在堆区
   - 静态初始化使用完毕之后不需要手动`destroy`；动态初始化需要

2. 读写锁的特别之处

   - 为什么有读写锁？为了增加效率，不同线程可以通过读锁同时读取，共享数据，但是不能修改；需要修改的时候使用排他的写锁
   - 在系统提供的`API`中，加锁有加读锁和加写锁两个，但是解锁只有一个，为什么？
     - 是因为同一个线程不可能同时持有读锁和写锁，否则会导致死锁，程序阻塞，具体见`./snippet/RwlockTest`
     - 读写锁明确了读锁就只能读，写锁就只能写，如果既要读又要写那还不如使用互斥锁
     - 因此只有一个解锁接口`unlock()`

### lwin32readwritelockcontext

1. 代码中使用`SRWLock`代表读写锁
2. 一些接口
   - `InitializeSRWLock`、`AcquireSRWLockShared`、`TryAcquireSRWLockShared`、`AcquireSRWLockExclusive`、`TryAcquireSRWLockExclusive`、`ReleaseSRWLockShared`、`ReleaseSRWLockExclusive`，其中只有`trylock()`有返回值，其他函数均没有返回值，不用做异常处理
3. `win32`下面，释放读写锁是分开的，没有统一的释放接口，只有各自释放的接口，共享读锁`ReleaseSRWLockShared`和排他写锁`ReleaseSRWLockExclusive`

